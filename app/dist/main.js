/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/classnames/index.js":
/*!********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/classnames/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/classnames/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/crel/crel.js":
/*!*************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/crel/crel.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//Copyright (C) 2012 Kory Nunn\r\n\r\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n/*\r\n\r\n    This code is not formatted for readability, but rather run-speed and to assist compilers.\r\n\r\n    However, the code's intention should be transparent.\r\n\r\n    *** IE SUPPORT ***\r\n\r\n    If you require this library to work in IE7, add the following after declaring crel.\r\n\r\n    var testDiv = document.createElement('div'),\r\n        testLabel = document.createElement('label');\r\n\r\n    testDiv.setAttribute('class', 'a');\r\n    testDiv['className'] !== 'a' ? crel.attrMap['class'] = 'className':undefined;\r\n    testDiv.setAttribute('name','a');\r\n    testDiv['name'] !== 'a' ? crel.attrMap['name'] = function(element, value){\r\n        element.id = value;\r\n    }:undefined;\r\n\r\n\r\n    testLabel.setAttribute('for', 'a');\r\n    testLabel['htmlFor'] !== 'a' ? crel.attrMap['for'] = 'htmlFor':undefined;\r\n\r\n\r\n\r\n*/\r\n\r\n(function (root, factory) {\r\n    if (true) {\r\n        module.exports = factory();\r\n    } else {}\r\n}(this, function () {\r\n    var fn = 'function',\r\n        obj = 'object',\r\n        nodeType = 'nodeType',\r\n        textContent = 'textContent',\r\n        setAttribute = 'setAttribute',\r\n        attrMapString = 'attrMap',\r\n        isNodeString = 'isNode',\r\n        isElementString = 'isElement',\r\n        d = typeof document === obj ? document : {},\r\n        isType = function(a, type){\r\n            return typeof a === type;\r\n        },\r\n        isNode = typeof Node === fn ? function (object) {\r\n            return object instanceof Node;\r\n        } :\r\n        // in IE <= 8 Node is an object, obviously..\r\n        function(object){\r\n            return object &&\r\n                isType(object, obj) &&\r\n                (nodeType in object) &&\r\n                isType(object.ownerDocument,obj);\r\n        },\r\n        isElement = function (object) {\r\n            return crel[isNodeString](object) && object[nodeType] === 1;\r\n        },\r\n        isArray = function(a){\r\n            return a instanceof Array;\r\n        },\r\n        appendChild = function(element, child) {\r\n            if (isArray(child)) {\r\n                child.map(function(subChild){\r\n                    appendChild(element, subChild);\r\n                });\r\n                return;\r\n            }\r\n            if(!crel[isNodeString](child)){\r\n                child = d.createTextNode(child);\r\n            }\r\n            element.appendChild(child);\r\n        };\r\n\r\n\r\n    function crel(){\r\n        var args = arguments, //Note: assigned to a variable to assist compilers. Saves about 40 bytes in closure compiler. Has negligable effect on performance.\r\n            element = args[0],\r\n            child,\r\n            settings = args[1],\r\n            childIndex = 2,\r\n            argumentsLength = args.length,\r\n            attributeMap = crel[attrMapString];\r\n\r\n        element = crel[isElementString](element) ? element : d.createElement(element);\r\n        // shortcut\r\n        if(argumentsLength === 1){\r\n            return element;\r\n        }\r\n\r\n        if(!isType(settings,obj) || crel[isNodeString](settings) || isArray(settings)) {\r\n            --childIndex;\r\n            settings = null;\r\n        }\r\n\r\n        // shortcut if there is only one child that is a string\r\n        if((argumentsLength - childIndex) === 1 && isType(args[childIndex], 'string') && element[textContent] !== undefined){\r\n            element[textContent] = args[childIndex];\r\n        }else{\r\n            for(; childIndex < argumentsLength; ++childIndex){\r\n                child = args[childIndex];\r\n\r\n                if(child == null){\r\n                    continue;\r\n                }\r\n\r\n                if (isArray(child)) {\r\n                  for (var i=0; i < child.length; ++i) {\r\n                    appendChild(element, child[i]);\r\n                  }\r\n                } else {\r\n                  appendChild(element, child);\r\n                }\r\n            }\r\n        }\r\n\r\n        for(var key in settings){\r\n            if(!attributeMap[key]){\r\n                if(isType(settings[key],fn)){\r\n                    element[key] = settings[key];\r\n                }else{\r\n                    element[setAttribute](key, settings[key]);\r\n                }\r\n            }else{\r\n                var attr = attributeMap[key];\r\n                if(typeof attr === fn){\r\n                    attr(element, settings[key]);\r\n                }else{\r\n                    element[setAttribute](attr, settings[key]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return element;\r\n    }\r\n\r\n    // Used for mapping one kind of attribute to the supported version of that in bad browsers.\r\n    crel[attrMapString] = {};\r\n\r\n    crel[isElementString] = isElement;\r\n\r\n    crel[isNodeString] = isNode;\r\n\r\n    if(typeof Proxy !== 'undefined'){\r\n        crel.proxy = new Proxy(crel, {\r\n            get: function(target, key){\r\n                !(key in crel) && (crel[key] = crel.bind(null, key));\r\n                return crel[key];\r\n            }\r\n        });\r\n    }\r\n\r\n    return crel;\r\n}));\r\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/crel/crel.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/element-class/index.js":
/*!***********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/element-class/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(opts) {\n  return new ElementClass(opts)\n}\n\nfunction indexOf(arr, prop) {\n  if (arr.indexOf) return arr.indexOf(prop)\n  for (var i = 0, len = arr.length; i < len; i++)\n    if (arr[i] === prop) return i\n  return -1\n}\n\nfunction ElementClass(opts) {\n  if (!(this instanceof ElementClass)) return new ElementClass(opts)\n  var self = this\n  if (!opts) opts = {}\n\n  // similar doing instanceof HTMLElement but works in IE8\n  if (opts.nodeType) opts = {el: opts}\n\n  this.opts = opts\n  this.el = opts.el || document.body\n  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)\n}\n\nElementClass.prototype.add = function(className) {\n  var el = this.el\n  if (!el) return\n  if (el.className === \"\") return el.className = className\n  var classes = el.className.split(' ')\n  if (indexOf(classes, className) > -1) return classes\n  classes.push(className)\n  el.className = classes.join(' ')\n  return classes\n}\n\nElementClass.prototype.remove = function(className) {\n  var el = this.el\n  if (!el) return\n  if (el.className === \"\") return\n  var classes = el.className.split(' ')\n  var idx = indexOf(classes, className)\n  if (idx > -1) classes.splice(idx, 1)\n  el.className = classes.join(' ')\n  return classes\n}\n\nElementClass.prototype.has = function(className) {\n  var el = this.el\n  if (!el) return\n  var classes = el.className.split(' ')\n  return indexOf(classes, className) > -1\n}\n\nElementClass.prototype.toggle = function(className) {\n  var el = this.el\n  if (!el) return\n  if (this.has(className)) this.remove(className)\n  else this.add(className)\n}\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/element-class/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/entities/maps/entities.json":
/*!****************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/entities/maps/entities.json ***!
  \****************************************************************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

eval("module.exports = {\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"};\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/entities/maps/entities.json?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/filepond/dist/filepond.js":
/*!**************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/filepond/dist/filepond.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * FilePond 4.8.0\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\n(function(global, factory) {\n   true\n    ? factory(exports)\n    : undefined;\n})(this, function(exports) {\n  'use strict';\n\n  var isNode = function isNode(value) {\n    return value instanceof HTMLElement;\n  };\n\n  var createStore = function createStore(initialState) {\n    var queries =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var actions =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // internal state\n    var state = Object.assign({}, initialState);\n\n    // contains all actions for next frame, is clear when actions are requested\n    var actionQueue = [];\n    var dispatchQueue = [];\n\n    // returns a duplicate of the current state\n    var getState = function getState() {\n      return Object.assign({}, state);\n    };\n\n    // returns a duplicate of the actions array and clears the actions array\n    var processActionQueue = function processActionQueue() {\n      // create copy of actions queue\n      var queue = [].concat(actionQueue);\n\n      // clear actions queue (we don't want no double actions)\n      actionQueue.length = 0;\n\n      return queue;\n    };\n\n    // processes actions that might block the main UI thread\n    var processDispatchQueue = function processDispatchQueue() {\n      // create copy of actions queue\n      var queue = [].concat(dispatchQueue);\n\n      // clear actions queue (we don't want no double actions)\n      dispatchQueue.length = 0;\n\n      // now dispatch these actions\n      queue.forEach(function(_ref) {\n        var type = _ref.type,\n          data = _ref.data;\n        dispatch(type, data);\n      });\n    };\n\n    // adds a new action, calls its handler and\n    var dispatch = function dispatch(type, data, isBlocking) {\n      // is blocking action\n      if (isBlocking) {\n        dispatchQueue.push({\n          type: type,\n          data: data\n        });\n\n        return;\n      }\n\n      // if this action has a handler, handle the action\n      if (actionHandlers[type]) {\n        actionHandlers[type](data);\n      }\n\n      // now add action\n      actionQueue.push({\n        type: type,\n        data: data\n      });\n    };\n\n    var query = function query(str) {\n      var _queryHandles;\n      for (\n        var _len = arguments.length,\n          args = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        args[_key - 1] = arguments[_key];\n      }\n      return queryHandles[str]\n        ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args)\n        : null;\n    };\n\n    var api = {\n      getState: getState,\n      processActionQueue: processActionQueue,\n      processDispatchQueue: processDispatchQueue,\n      dispatch: dispatch,\n      query: query\n    };\n\n    var queryHandles = {};\n    queries.forEach(function(query) {\n      queryHandles = Object.assign({}, query(state), {}, queryHandles);\n    });\n\n    var actionHandlers = {};\n    actions.forEach(function(action) {\n      actionHandlers = Object.assign(\n        {},\n        action(dispatch, query, state),\n        {},\n        actionHandlers\n      );\n    });\n\n    return api;\n  };\n\n  var defineProperty = function defineProperty(obj, property, definition) {\n    if (typeof definition === 'function') {\n      obj[property] = definition;\n      return;\n    }\n    Object.defineProperty(obj, property, Object.assign({}, definition));\n  };\n\n  var forin = function forin(obj, cb) {\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      cb(key, obj[key]);\n    }\n  };\n\n  var createObject = function createObject(definition) {\n    var obj = {};\n    forin(definition, function(property) {\n      defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n  };\n\n  var attr = function attr(node, name) {\n    var value =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (value === null) {\n      return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n  };\n\n  var ns = 'http://www.w3.org/2000/svg';\n  var svgElements = ['svg', 'path']; // only svg elements used\n\n  var isSVGElement = function isSVGElement(tag) {\n    return svgElements.includes(tag);\n  };\n\n  var createElement = function createElement(tag, className) {\n    var attributes =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof className === 'object') {\n      attributes = className;\n      className = null;\n    }\n    var element = isSVGElement(tag)\n      ? document.createElementNS(ns, tag)\n      : document.createElement(tag);\n    if (className) {\n      if (isSVGElement(tag)) {\n        attr(element, 'class', className);\n      } else {\n        element.className = className;\n      }\n    }\n    forin(attributes, function(name, value) {\n      attr(element, name, value);\n    });\n    return element;\n  };\n\n  var appendChild = function appendChild(parent) {\n    return function(child, index) {\n      if (typeof index !== 'undefined' && parent.children[index]) {\n        parent.insertBefore(child, parent.children[index]);\n      } else {\n        parent.appendChild(child);\n      }\n    };\n  };\n\n  var appendChildView = function appendChildView(parent, childViews) {\n    return function(view, index) {\n      if (typeof index !== 'undefined') {\n        childViews.splice(index, 0, view);\n      } else {\n        childViews.push(view);\n      }\n\n      return view;\n    };\n  };\n\n  var removeChildView = function removeChildView(parent, childViews) {\n    return function(view) {\n      // remove from child views\n      childViews.splice(childViews.indexOf(view), 1);\n\n      // remove the element\n      if (view.element.parentNode) {\n        parent.removeChild(view.element);\n      }\n\n      return view;\n    };\n  };\n\n  var getViewRect = function getViewRect(\n    elementRect,\n    childViews,\n    offset,\n    scale\n  ) {\n    var left = offset[0] || elementRect.left;\n    var top = offset[1] || elementRect.top;\n    var right = left + elementRect.width;\n    var bottom = top + elementRect.height * (scale[1] || 1);\n\n    var rect = {\n      // the rectangle of the element itself\n      element: Object.assign({}, elementRect),\n\n      // the rectangle of the element expanded to contain its children, does not include any margins\n      inner: {\n        left: elementRect.left,\n        top: elementRect.top,\n        right: elementRect.right,\n        bottom: elementRect.bottom\n      },\n\n      // the rectangle of the element expanded to contain its children including own margin and child margins\n      // margins will be added after we've recalculated the size\n      outer: {\n        left: left,\n        top: top,\n        right: right,\n        bottom: bottom\n      }\n    };\n\n    // expand rect to fit all child rectangles\n    childViews\n      .filter(function(childView) {\n        return !childView.isRectIgnored();\n      })\n      .map(function(childView) {\n        return childView.rect;\n      })\n      .forEach(function(childViewRect) {\n        expandRect(rect.inner, Object.assign({}, childViewRect.inner));\n        expandRect(rect.outer, Object.assign({}, childViewRect.outer));\n      });\n\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n\n    return rect;\n  };\n\n  var expandRect = function expandRect(parent, child) {\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n\n    if (child.bottom > parent.bottom) {\n      parent.bottom = child.bottom;\n    }\n\n    if (child.right > parent.right) {\n      parent.right = child.right;\n    }\n  };\n\n  var calculateRectSize = function calculateRectSize(rect) {\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n  };\n\n  var isNumber = function isNumber(value) {\n    return typeof value === 'number';\n  };\n\n  /**\n   * Determines if position is at destination\n   * @param position\n   * @param destination\n   * @param velocity\n   * @param errorMargin\n   * @returns {boolean}\n   */\n  var thereYet = function thereYet(position, destination, velocity) {\n    var errorMargin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;\n    return (\n      Math.abs(position - destination) < errorMargin &&\n      Math.abs(velocity) < errorMargin\n    );\n  };\n\n  /**\n   * Spring animation\n   */\n  var spring =\n    // default options\n    function spring() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$stiffness = _ref.stiffness,\n        stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness,\n        _ref$damping = _ref.damping,\n        damping = _ref$damping === void 0 ? 0.75 : _ref$damping,\n        _ref$mass = _ref.mass,\n        mass = _ref$mass === void 0 ? 10 : _ref$mass;\n      var target = null;\n      var position = null;\n      var velocity = 0;\n      var resting = false;\n\n      // updates spring state\n      var interpolate = function interpolate() {\n        // in rest, don't animate\n        if (resting) {\n          return;\n        }\n\n        // need at least a target or position to do springy things\n        if (!(isNumber(target) && isNumber(position))) {\n          resting = true;\n          velocity = 0;\n          return;\n        }\n\n        // calculate spring force\n        var f = -(position - target) * stiffness;\n\n        // update velocity by adding force based on mass\n        velocity += f / mass;\n\n        // update position by adding velocity\n        position += velocity;\n\n        // slow down based on amount of damping\n        velocity *= damping;\n\n        // we've arrived if we're near target and our velocity is near zero\n        if (thereYet(position, target, velocity)) {\n          position = target;\n          velocity = 0;\n          resting = true;\n\n          // we done\n          api.onupdate(position);\n          api.oncomplete(position);\n        } else {\n          // progress update\n          api.onupdate(position);\n        }\n      };\n\n      /**\n       * Set new target value\n       * @param value\n       */\n      var setTarget = function setTarget(value) {\n        // if currently has no position, set target and position to this value\n        if (isNumber(value) && !isNumber(position)) {\n          position = value;\n        }\n\n        // next target value will not be animated to\n        if (target === null) {\n          target = value;\n          position = value;\n        }\n\n        // let start moving to target\n        target = value;\n\n        // already at target\n        if (position === target || typeof target === 'undefined') {\n          // now resting as target is current position, stop moving\n          resting = true;\n          velocity = 0;\n\n          // done!\n          api.onupdate(position);\n          api.oncomplete(position);\n\n          return;\n        }\n\n        resting = false;\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          set: setTarget,\n          get: function get() {\n            return target;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var easeLinear = function easeLinear(t) {\n    return t;\n  };\n  var easeInOutQuad = function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  };\n\n  var tween =\n    // default values\n    function tween() // method definition\n    {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 500 : _ref$duration,\n        _ref$easing = _ref.easing,\n        easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay;\n      var start = null;\n      var t;\n      var p;\n      var resting = true;\n      var reverse = false;\n      var target = null;\n\n      var interpolate = function interpolate(ts) {\n        if (resting || target === null) {\n          return;\n        }\n\n        if (start === null) {\n          start = ts;\n        }\n\n        if (ts - start < delay) {\n          return;\n        }\n\n        t = ts - start - delay;\n\n        if (t < duration) {\n          p = t / duration;\n          api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n        } else {\n          t = 1;\n          p = reverse ? 0 : 1;\n          api.onupdate(p * target);\n          api.oncomplete(p * target);\n          resting = true;\n        }\n      };\n\n      // need 'api' to call onupdate callback\n      var api = createObject({\n        interpolate: interpolate,\n        target: {\n          get: function get() {\n            return reverse ? 0 : target;\n          },\n          set: function set(value) {\n            // is initial value\n            if (target === null) {\n              target = value;\n              api.onupdate(value);\n              api.oncomplete(value);\n              return;\n            }\n\n            // want to tween to a smaller value and have a current value\n            if (value < target) {\n              target = 1;\n              reverse = true;\n            } else {\n              // not tweening to a smaller value\n              reverse = false;\n              target = value;\n            }\n\n            // let's go!\n            resting = false;\n            start = null;\n          }\n        },\n\n        resting: {\n          get: function get() {\n            return resting;\n          }\n        },\n\n        onupdate: function onupdate(value) {},\n        oncomplete: function oncomplete(value) {}\n      });\n\n      return api;\n    };\n\n  var animator = {\n    spring: spring,\n    tween: tween\n  };\n\n  /*\n                       { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n                       { translation: { type: 'spring', ... }, ... }\n                       { translation: { x: { type: 'spring', ... } } }\n                      */\n  var createAnimator = function createAnimator(definition, category, property) {\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    var def =\n      definition[category] && typeof definition[category][property] === 'object'\n        ? definition[category][property]\n        : definition[category] || definition;\n\n    var type = typeof def === 'string' ? def : def.type;\n    var props = typeof def === 'object' ? Object.assign({}, def) : {};\n\n    return animator[type] ? animator[type](props) : null;\n  };\n\n  var addGetSet = function addGetSet(keys, obj, props) {\n    var overwrite =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    obj = Array.isArray(obj) ? obj : [obj];\n    obj.forEach(function(o) {\n      keys.forEach(function(key) {\n        var name = key;\n        var getter = function getter() {\n          return props[key];\n        };\n        var setter = function setter(value) {\n          return (props[key] = value);\n        };\n\n        if (typeof key === 'object') {\n          name = key.key;\n          getter = key.getter || getter;\n          setter = key.setter || setter;\n        }\n\n        if (o[name] && !overwrite) {\n          return;\n        }\n\n        o[name] = {\n          get: getter,\n          set: setter\n        };\n      });\n    });\n  };\n\n  var isDefined = function isDefined(value) {\n    return value != null;\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // setup animators\n\n  var animations = function animations(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      viewState = _ref.viewState;\n    // initial properties\n    var initialProps = Object.assign({}, viewProps);\n\n    // list of all active animations\n    var animations = [];\n\n    // setup animators\n    forin(mixinConfig, function(property, animation) {\n      var animator = createAnimator(animation);\n      if (!animator) {\n        return;\n      }\n\n      // when the animator updates, update the view state value\n      animator.onupdate = function(value) {\n        viewProps[property] = value;\n      };\n\n      // set animator target\n      animator.target = initialProps[property];\n\n      // when value is set, set the animator target value\n      var prop = {\n        key: property,\n        setter: function setter(value) {\n          // if already at target, we done!\n          if (animator.target === value) {\n            return;\n          }\n\n          animator.target = value;\n        },\n        getter: function getter() {\n          return viewProps[property];\n        }\n      };\n\n      // add getters and setters\n      addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n      // add it to the list for easy updating from the _write method\n      animations.push(animator);\n    });\n\n    // expose internal write api\n    return {\n      write: function write(ts) {\n        var resting = true;\n        animations.forEach(function(animation) {\n          if (!animation.resting) {\n            resting = false;\n          }\n          animation.interpolate(ts);\n        });\n        return resting;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var addEvent = function addEvent(element) {\n    return function(type, fn) {\n      element.addEventListener(type, fn);\n    };\n  };\n\n  var removeEvent = function removeEvent(element) {\n    return function(type, fn) {\n      element.removeEventListener(type, fn);\n    };\n  };\n\n  // mixin\n  var listeners = function listeners(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      viewState = _ref.viewState,\n      view = _ref.view;\n    var events = [];\n\n    var add = addEvent(view.element);\n    var remove = removeEvent(view.element);\n\n    viewExternalAPI.on = function(type, fn) {\n      events.push({\n        type: type,\n        fn: fn\n      });\n\n      add(type, fn);\n    };\n\n    viewExternalAPI.off = function(type, fn) {\n      events.splice(\n        events.findIndex(function(event) {\n          return event.type === type && event.fn === fn;\n        }),\n        1\n      );\n\n      remove(type, fn);\n    };\n\n    return {\n      write: function write() {\n        // not busy\n        return true;\n      },\n      destroy: function destroy() {\n        events.forEach(function(event) {\n          remove(event.type, event.fn);\n        });\n      }\n    };\n  };\n\n  // add to external api and link to props\n\n  var apis = function apis(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewExternalAPI = _ref.viewExternalAPI;\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n  };\n\n  // add to state,\n  // add getters and setters to internal and external api (if not set)\n  // set initial state based on props in viewProps\n  // apply as transforms each frame\n\n  var defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0\n  };\n\n  var styles = function styles(_ref) {\n    var mixinConfig = _ref.mixinConfig,\n      viewProps = _ref.viewProps,\n      viewInternalAPI = _ref.viewInternalAPI,\n      viewExternalAPI = _ref.viewExternalAPI,\n      view = _ref.view;\n    // initial props\n    var initialProps = Object.assign({}, viewProps);\n\n    // current props\n    var currentProps = {};\n\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n    // override rect on internal and external rect getter so it takes in account transforms\n    var getOffset = function getOffset() {\n      return [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n    };\n\n    var getScale = function getScale() {\n      return [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n    };\n    var getRect = function getRect() {\n      return view.rect\n        ? getViewRect(view.rect, view.childViews, getOffset(), getScale())\n        : null;\n    };\n    viewInternalAPI.rect = { get: getRect };\n    viewExternalAPI.rect = { get: getRect };\n\n    // apply view props\n    mixinConfig.forEach(function(key) {\n      viewProps[key] =\n        typeof initialProps[key] === 'undefined'\n          ? defaults[key]\n          : initialProps[key];\n    });\n\n    // expose api\n    return {\n      write: function write() {\n        // see if props have changed\n        if (!propsHaveChanged(currentProps, viewProps)) {\n          return;\n        }\n\n        // moves element to correct position on screen\n        applyStyles(view.element, viewProps);\n\n        // store new transforms\n        Object.assign(currentProps, Object.assign({}, viewProps));\n\n        // no longer busy\n        return true;\n      },\n      destroy: function destroy() {}\n    };\n  };\n\n  var propsHaveChanged = function propsHaveChanged(currentProps, newProps) {\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n      return true;\n    }\n\n    // lets analyze the individual props\n    for (var prop in newProps) {\n      if (newProps[prop] !== currentProps[prop]) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var applyStyles = function applyStyles(element, _ref2) {\n    var opacity = _ref2.opacity,\n      perspective = _ref2.perspective,\n      translateX = _ref2.translateX,\n      translateY = _ref2.translateY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      rotateX = _ref2.rotateX,\n      rotateY = _ref2.rotateY,\n      rotateZ = _ref2.rotateZ,\n      originX = _ref2.originX,\n      originY = _ref2.originY,\n      width = _ref2.width,\n      height = _ref2.height;\n\n    var transforms = '';\n    var styles = '';\n\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n      styles +=\n        'transform-origin: ' + (originX || 0) + 'px ' + (originY || 0) + 'px;';\n    }\n\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n      transforms += 'perspective(' + perspective + 'px) ';\n    }\n\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n      transforms +=\n        'translate3d(' +\n        (translateX || 0) +\n        'px, ' +\n        (translateY || 0) +\n        'px, 0) ';\n    }\n\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n      transforms +=\n        'scale3d(' +\n        (isDefined(scaleX) ? scaleX : 1) +\n        ', ' +\n        (isDefined(scaleY) ? scaleY : 1) +\n        ', 1) ';\n    }\n\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n      transforms += 'rotateZ(' + rotateZ + 'rad) ';\n    }\n\n    if (isDefined(rotateX)) {\n      transforms += 'rotateX(' + rotateX + 'rad) ';\n    }\n\n    if (isDefined(rotateY)) {\n      transforms += 'rotateY(' + rotateY + 'rad) ';\n    }\n\n    // add transforms\n    if (transforms.length) {\n      styles += 'transform:' + transforms + ';';\n    }\n\n    // add opacity\n    if (isDefined(opacity)) {\n      styles += 'opacity:' + opacity + ';';\n\n      // if we reach zero, we make the element inaccessible\n      if (opacity === 0) {\n        styles += 'visibility:hidden;';\n      }\n\n      // if we're below 100% opacity this element can't be clicked\n      if (opacity < 1) {\n        styles += 'pointer-events:none;';\n      }\n    }\n\n    // add height\n    if (isDefined(height)) {\n      styles += 'height:' + height + 'px;';\n    }\n\n    // add width\n    if (isDefined(width)) {\n      styles += 'width:' + width + 'px;';\n    }\n\n    // apply styles\n    var elementCurrentStyle = element.elementCurrentStyle || '';\n\n    // if new styles does not match current styles, lets update!\n    if (\n      styles.length !== elementCurrentStyle.length ||\n      styles !== elementCurrentStyle\n    ) {\n      element.style.cssText = styles;\n      // store current styles so we can compare them to new styles later on\n      // _not_ getting the style value is faster\n      element.elementCurrentStyle = styles;\n    }\n  };\n\n  var Mixins = {\n    styles: styles,\n    listeners: listeners,\n    animations: animations,\n    apis: apis\n  };\n\n  var updateRect = function updateRect() {\n    var rect =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var element =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var style =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!element.layoutCalculated) {\n      rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n      rect.marginTop = parseInt(style.marginTop, 10) || 0;\n      rect.marginRight = parseInt(style.marginRight, 10) || 0;\n      rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n      rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n      element.layoutCalculated = true;\n    }\n\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n\n    rect.scrollTop = element.scrollTop;\n\n    rect.hidden = element.offsetParent === null;\n\n    return rect;\n  };\n\n  var createView =\n    // default view definition\n    function createView() {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        _ref$tag = _ref.tag,\n        tag = _ref$tag === void 0 ? 'div' : _ref$tag,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? null : _ref$name,\n        _ref$attributes = _ref.attributes,\n        attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n        _ref$read = _ref.read,\n        read = _ref$read === void 0 ? function() {} : _ref$read,\n        _ref$write = _ref.write,\n        write = _ref$write === void 0 ? function() {} : _ref$write,\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function() {} : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function() {} : _ref$destroy,\n        _ref$filterFrameActio = _ref.filterFrameActionsForChild,\n        filterFrameActionsForChild =\n          _ref$filterFrameActio === void 0\n            ? function(child, actions) {\n                return actions;\n              }\n            : _ref$filterFrameActio,\n        _ref$didCreateView = _ref.didCreateView,\n        didCreateView =\n          _ref$didCreateView === void 0 ? function() {} : _ref$didCreateView,\n        _ref$didWriteView = _ref.didWriteView,\n        didWriteView =\n          _ref$didWriteView === void 0 ? function() {} : _ref$didWriteView,\n        _ref$ignoreRect = _ref.ignoreRect,\n        ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect,\n        _ref$ignoreRectUpdate = _ref.ignoreRectUpdate,\n        ignoreRectUpdate =\n          _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate,\n        _ref$mixins = _ref.mixins,\n        mixins = _ref$mixins === void 0 ? [] : _ref$mixins;\n      return function(\n        // each view requires reference to store\n        store\n      ) {\n        var props =\n          arguments.length > 1 && arguments[1] !== undefined\n            ? arguments[1]\n            : {};\n        // root element should not be changed\n        var element = createElement(tag, 'filepond--' + name, attributes);\n\n        // style reference should also not be changed\n        var style = window.getComputedStyle(element, null);\n\n        // element rectangle\n        var rect = updateRect();\n        var frameRect = null;\n\n        // rest state\n        var isResting = false;\n\n        // pretty self explanatory\n        var childViews = [];\n\n        // loaded mixins\n        var activeMixins = [];\n\n        // references to created children\n        var ref = {};\n\n        // state used for each instance\n        var state = {};\n\n        // list of writers that will be called to update this view\n        var writers = [\n          write // default writer\n        ];\n\n        var readers = [\n          read // default reader\n        ];\n\n        var destroyers = [\n          destroy // default destroy\n        ];\n\n        // core view methods\n        var getElement = function getElement() {\n          return element;\n        };\n        var getChildViews = function getChildViews() {\n          return childViews.concat();\n        };\n        var getReference = function getReference() {\n          return ref;\n        };\n        var createChildView = function createChildView(store) {\n          return function(view, props) {\n            return view(store, props);\n          };\n        };\n        var getRect = function getRect() {\n          if (frameRect) {\n            return frameRect;\n          }\n          frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n          return frameRect;\n        };\n        var getStyle = function getStyle() {\n          return style;\n        };\n\n        /**\n         * Read data from DOM\n         * @private\n         */\n        var _read = function _read() {\n          frameRect = null;\n\n          // read child views\n          childViews.forEach(function(child) {\n            return child._read();\n          });\n\n          var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n          if (shouldUpdate) {\n            updateRect(rect, element, style);\n          }\n\n          // readers\n          var api = { root: internalAPI, props: props, rect: rect };\n          readers.forEach(function(reader) {\n            return reader(api);\n          });\n        };\n\n        /**\n         * Write data to DOM\n         * @private\n         */\n        var _write = function _write(ts, frameActions, shouldOptimize) {\n          // if no actions, we assume that the view is resting\n          var resting = frameActions.length === 0;\n\n          // writers\n          writers.forEach(function(writer) {\n            var writerResting = writer({\n              props: props,\n              root: internalAPI,\n              actions: frameActions,\n              timestamp: ts,\n              shouldOptimize: shouldOptimize\n            });\n\n            if (writerResting === false) {\n              resting = false;\n            }\n          });\n\n          // run mixins\n          activeMixins.forEach(function(mixin) {\n            // if one of the mixins is still busy after write operation, we are not resting\n            var mixinResting = mixin.write(ts);\n            if (mixinResting === false) {\n              resting = false;\n            }\n          });\n\n          // updates child views that are currently attached to the DOM\n          childViews\n            .filter(function(child) {\n              return !!child.element.parentNode;\n            })\n            .forEach(function(child) {\n              // if a child view is not resting, we are not resting\n              var childResting = child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              if (!childResting) {\n                resting = false;\n              }\n            });\n\n          // append new elements to DOM and update those\n          childViews\n            //.filter(child => !child.element.parentNode)\n            .forEach(function(child, index) {\n              // skip\n              if (child.element.parentNode) {\n                return;\n              }\n\n              // append to DOM\n              internalAPI.appendChild(child.element, index);\n\n              // call read (need to know the size of these elements)\n              child._read();\n\n              // re-call write\n              child._write(\n                ts,\n                filterFrameActionsForChild(child, frameActions),\n                shouldOptimize\n              );\n\n              // we just added somthing to the dom, no rest\n              resting = false;\n            });\n\n          // update resting state\n          isResting = resting;\n\n          didWriteView({\n            props: props,\n            root: internalAPI,\n            actions: frameActions,\n            timestamp: ts\n          });\n\n          // let parent know if we are resting\n          return resting;\n        };\n\n        var _destroy = function _destroy() {\n          activeMixins.forEach(function(mixin) {\n            return mixin.destroy();\n          });\n          destroyers.forEach(function(destroyer) {\n            destroyer({ root: internalAPI, props: props });\n          });\n          childViews.forEach(function(child) {\n            return child._destroy();\n          });\n        };\n\n        // sharedAPI\n        var sharedAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          style: {\n            get: getStyle\n          },\n\n          childViews: {\n            get: getChildViews\n          }\n        };\n\n        // private API definition\n        var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: getRect\n          },\n\n          // access to custom children references\n          ref: {\n            get: getReference\n          },\n\n          // dom modifiers\n          is: function is(needle) {\n            return name === needle;\n          },\n          appendChild: appendChild(element),\n          createChildView: createChildView(store),\n          linkView: function linkView(view) {\n            childViews.push(view);\n            return view;\n          },\n          unlinkView: function unlinkView(view) {\n            childViews.splice(childViews.indexOf(view), 1);\n          },\n          appendChildView: appendChildView(element, childViews),\n          removeChildView: removeChildView(element, childViews),\n          registerWriter: function registerWriter(writer) {\n            return writers.push(writer);\n          },\n          registerReader: function registerReader(reader) {\n            return readers.push(reader);\n          },\n          registerDestroyer: function registerDestroyer(destroyer) {\n            return destroyers.push(destroyer);\n          },\n          invalidateLayout: function invalidateLayout() {\n            return (element.layoutCalculated = false);\n          },\n\n          // access to data store\n          dispatch: store.dispatch,\n          query: store.query\n        });\n\n        // public view API methods\n        var externalAPIDefinition = {\n          element: {\n            get: getElement\n          },\n\n          childViews: {\n            get: getChildViews\n          },\n\n          rect: {\n            get: getRect\n          },\n\n          resting: {\n            get: function get() {\n              return isResting;\n            }\n          },\n\n          isRectIgnored: function isRectIgnored() {\n            return ignoreRect;\n          },\n          _read: _read,\n          _write: _write,\n          _destroy: _destroy\n        };\n\n        // mixin API methods\n        var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {\n          rect: {\n            get: function get() {\n              return rect;\n            }\n          }\n        });\n\n        // add mixin functionality\n        Object.keys(mixins)\n          .sort(function(a, b) {\n            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n            if (a === 'styles') {\n              return 1;\n            } else if (b === 'styles') {\n              return -1;\n            }\n            return 0;\n          })\n          .forEach(function(key) {\n            var mixinAPI = Mixins[key]({\n              mixinConfig: mixins[key],\n              viewProps: props,\n              viewState: state,\n              viewInternalAPI: internalAPIDefinition,\n              viewExternalAPI: externalAPIDefinition,\n              view: createObject(mixinAPIDefinition)\n            });\n\n            if (mixinAPI) {\n              activeMixins.push(mixinAPI);\n            }\n          });\n\n        // construct private api\n        var internalAPI = createObject(internalAPIDefinition);\n\n        // create the view\n        create({\n          root: internalAPI,\n          props: props\n        });\n\n        // append created child views to root node\n        var childCount = element.children.length; // need to know the current child count so appending happens in correct order\n        childViews.forEach(function(child, index) {\n          internalAPI.appendChild(child.element, childCount + index);\n        });\n\n        // call did create\n        didCreateView(internalAPI);\n\n        // expose public api\n        return createObject(externalAPIDefinition);\n      };\n    };\n\n  var createPainter = function createPainter(read, write) {\n    var fps =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n    var name = '__framePainter';\n\n    // set global painter\n    if (window[name]) {\n      window[name].readers.push(read);\n      window[name].writers.push(write);\n      return;\n    }\n\n    window[name] = {\n      readers: [read],\n      writers: [write]\n    };\n\n    var painter = window[name];\n\n    var interval = 1000 / fps;\n    var last = null;\n    var id = null;\n    var requestTick = null;\n    var cancelTick = null;\n\n    var setTimerType = function setTimerType() {\n      if (document.hidden) {\n        requestTick = function requestTick() {\n          return window.setTimeout(function() {\n            return tick(performance.now());\n          }, interval);\n        };\n        cancelTick = function cancelTick() {\n          return window.clearTimeout(id);\n        };\n      } else {\n        requestTick = function requestTick() {\n          return window.requestAnimationFrame(tick);\n        };\n        cancelTick = function cancelTick() {\n          return window.cancelAnimationFrame(id);\n        };\n      }\n    };\n\n    document.addEventListener('visibilitychange', function() {\n      if (cancelTick) cancelTick();\n      setTimerType();\n      tick(performance.now());\n    });\n\n    var tick = function tick(ts) {\n      // queue next tick\n      id = requestTick(tick);\n\n      // limit fps\n      if (!last) {\n        last = ts;\n      }\n\n      var delta = ts - last;\n\n      if (delta <= interval) {\n        // skip frame\n        return;\n      }\n\n      // align next frame\n      last = ts - (delta % interval);\n\n      // update view\n      painter.readers.forEach(function(read) {\n        return read();\n      });\n      painter.writers.forEach(function(write) {\n        return write(ts);\n      });\n    };\n\n    setTimerType();\n    tick(performance.now());\n\n    return {\n      pause: function pause() {\n        cancelTick(id);\n      }\n    };\n  };\n\n  var createRoute = function createRoute(routes, fn) {\n    return function(_ref) {\n      var root = _ref.root,\n        props = _ref.props,\n        _ref$actions = _ref.actions,\n        actions = _ref$actions === void 0 ? [] : _ref$actions,\n        timestamp = _ref.timestamp,\n        shouldOptimize = _ref.shouldOptimize;\n      actions\n        .filter(function(action) {\n          return routes[action.type];\n        })\n        .forEach(function(action) {\n          return routes[action.type]({\n            root: root,\n            props: props,\n            action: action.data,\n            timestamp: timestamp,\n            shouldOptimize: shouldOptimize\n          });\n        });\n\n      if (fn) {\n        fn({\n          root: root,\n          props: props,\n          actions: actions,\n          timestamp: timestamp,\n          shouldOptimize: shouldOptimize\n        });\n      }\n    };\n  };\n\n  var insertBefore = function insertBefore(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode);\n  };\n\n  var insertAfter = function insertAfter(newNode, referenceNode) {\n    return referenceNode.parentNode.insertBefore(\n      newNode,\n      referenceNode.nextSibling\n    );\n  };\n\n  var isArray = function isArray(value) {\n    return Array.isArray(value);\n  };\n\n  var isEmpty = function isEmpty(value) {\n    return value == null;\n  };\n\n  var trim = function trim(str) {\n    return str.trim();\n  };\n\n  var toString = function toString(value) {\n    return '' + value;\n  };\n\n  var toArray = function toArray(value) {\n    var splitter =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\n    if (isEmpty(value)) {\n      return [];\n    }\n    if (isArray(value)) {\n      return value;\n    }\n    return toString(value)\n      .split(splitter)\n      .map(trim)\n      .filter(function(str) {\n        return str.length;\n      });\n  };\n\n  var isBoolean = function isBoolean(value) {\n    return typeof value === 'boolean';\n  };\n\n  var toBoolean = function toBoolean(value) {\n    return isBoolean(value) ? value : value === 'true';\n  };\n\n  var isString = function isString(value) {\n    return typeof value === 'string';\n  };\n\n  var toNumber = function toNumber(value) {\n    return isNumber(value)\n      ? value\n      : isString(value)\n      ? toString(value).replace(/[a-z]+/gi, '')\n      : 0;\n  };\n\n  var toInt = function toInt(value) {\n    return parseInt(toNumber(value), 10);\n  };\n\n  var toFloat = function toFloat(value) {\n    return parseFloat(toNumber(value));\n  };\n\n  var isInt = function isInt(value) {\n    return isNumber(value) && isFinite(value) && Math.floor(value) === value;\n  };\n\n  var toBytes = function toBytes(value) {\n    // is in bytes\n    if (isInt(value)) {\n      return value;\n    }\n\n    // is natural file size\n    var naturalFileSize = toString(value).trim();\n\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n      return toInt(naturalFileSize) * 1000 * 1000;\n    }\n\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n      naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n      return toInt(naturalFileSize) * 1000;\n    }\n\n    return toInt(naturalFileSize);\n  };\n\n  var isFunction = function isFunction(value) {\n    return typeof value === 'function';\n  };\n\n  var toFunctionReference = function toFunctionReference(string) {\n    var ref = self;\n    var levels = string.split('.');\n    var level = null;\n    while ((level = levels.shift())) {\n      ref = ref[level];\n      if (!ref) {\n        return null;\n      }\n    }\n    return ref;\n  };\n\n  var methods = {\n    process: 'POST',\n    patch: 'PATCH',\n    revert: 'DELETE',\n    fetch: 'GET',\n    restore: 'GET',\n    load: 'GET'\n  };\n\n  var createServerAPI = function createServerAPI(outline) {\n    var api = {};\n\n    api.url = isString(outline) ? outline : outline.url || '';\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n\n    forin(methods, function(key) {\n      api[key] = createAction(\n        key,\n        outline[key],\n        methods[key],\n        api.timeout,\n        api.headers\n      );\n    });\n\n    // special treatment for remove\n    api.remove = outline.remove || null;\n\n    // remove generic headers from api object\n    delete api.headers;\n\n    return api;\n  };\n\n  var createAction = function createAction(\n    name,\n    outline,\n    method,\n    timeout,\n    headers\n  ) {\n    // is explicitely set to null so disable\n    if (outline === null) {\n      return null;\n    }\n\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === 'function') {\n      return outline;\n    }\n\n    // build action object\n    var action = {\n      url: method === 'GET' || method === 'PATCH' ? '?' + name + '=' : '',\n      method: method,\n      headers: headers,\n      withCredentials: false,\n      timeout: timeout,\n      onload: null,\n      ondata: null,\n      onerror: null\n    };\n\n    // is a single url\n    if (isString(outline)) {\n      action.url = outline;\n      return action;\n    }\n\n    // overwrite\n    Object.assign(action, outline);\n\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n      var parts = action.headers.split(/:(.+)/);\n      action.headers = {\n        header: parts[0],\n        value: parts[1]\n      };\n    }\n\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n\n    return action;\n  };\n\n  var toServerAPI = function toServerAPI(value) {\n    return createServerAPI(value);\n  };\n\n  var isNull = function isNull(value) {\n    return value === null;\n  };\n\n  var isObject = function isObject(value) {\n    return typeof value === 'object' && value !== null;\n  };\n\n  var isAPI = function isAPI(value) {\n    return (\n      isObject(value) &&\n      isString(value.url) &&\n      isObject(value.process) &&\n      isObject(value.revert) &&\n      isObject(value.restore) &&\n      isObject(value.fetch)\n    );\n  };\n\n  var getType = function getType(value) {\n    if (isArray(value)) {\n      return 'array';\n    }\n\n    if (isNull(value)) {\n      return 'null';\n    }\n\n    if (isInt(value)) {\n      return 'int';\n    }\n\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n      return 'bytes';\n    }\n\n    if (isAPI(value)) {\n      return 'api';\n    }\n\n    return typeof value;\n  };\n\n  var replaceSingleQuotes = function replaceSingleQuotes(str) {\n    return str\n      .replace(/{\\s*'/g, '{\"')\n      .replace(/'\\s*}/g, '\"}')\n      .replace(/'\\s*:/g, '\":')\n      .replace(/:\\s*'/g, ':\"')\n      .replace(/,\\s*'/g, ',\"')\n      .replace(/'\\s*,/g, '\",');\n  };\n\n  var conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: function int(value) {\n      return getType(value) === 'bytes' ? toBytes(value) : toInt(value);\n    },\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: function string(value) {\n      return isFunction(value) ? value : toString(value);\n    },\n    function: function _function(value) {\n      return toFunctionReference(value);\n    },\n    serverapi: toServerAPI,\n    object: function object(value) {\n      try {\n        return JSON.parse(replaceSingleQuotes(value));\n      } catch (e) {\n        return null;\n      }\n    }\n  };\n\n  var convertTo = function convertTo(value, type) {\n    return conversionTable[type](value);\n  };\n\n  var getValueByType = function getValueByType(\n    newValue,\n    defaultValue,\n    valueType\n  ) {\n    // can always assign default value\n    if (newValue === defaultValue) {\n      return newValue;\n    }\n\n    // get the type of the new value\n    var newValueType = getType(newValue);\n\n    // is valid type?\n    if (newValueType !== valueType) {\n      // is string input, let's attempt to convert\n      var convertedValue = convertTo(newValue, valueType);\n\n      // what is the type now\n      newValueType = getType(convertedValue);\n\n      // no valid conversions found\n      if (convertedValue === null) {\n        throw 'Trying to assign value with incorrect type to \"' +\n          option +\n          '\", allowed type: \"' +\n          valueType +\n          '\"';\n      } else {\n        newValue = convertedValue;\n      }\n    }\n\n    // assign new value\n    return newValue;\n  };\n\n  var createOption = function createOption(defaultValue, valueType) {\n    var currentValue = defaultValue;\n    return {\n      enumerable: true,\n      get: function get() {\n        return currentValue;\n      },\n      set: function set(newValue) {\n        currentValue = getValueByType(newValue, defaultValue, valueType);\n      }\n    };\n  };\n\n  var createOptions = function createOptions(options) {\n    var obj = {};\n    forin(options, function(prop) {\n      var optionDefinition = options[prop];\n      obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n  };\n\n  var createInitialState = function createInitialState(options) {\n    return {\n      // model\n      items: [],\n\n      // timeout used for calling update items\n      listUpdateTimeout: null,\n\n      // timeout used for stacking metadata updates\n      itemUpdateTimeout: null,\n\n      // queue of items waiting to be processed\n      processingQueue: [],\n\n      // options\n      options: createOptions(options)\n    };\n  };\n\n  var fromCamels = function fromCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string\n      .split(/(?=[A-Z])/)\n      .map(function(part) {\n        return part.toLowerCase();\n      })\n      .join(separator);\n  };\n\n  var createOptionAPI = function createOptionAPI(store, options) {\n    var obj = {};\n    forin(options, function(key) {\n      obj[key] = {\n        get: function get() {\n          return store.getState().options[key];\n        },\n        set: function set(value) {\n          store.dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        }\n      };\n    });\n    return obj;\n  };\n\n  var createOptionActions = function createOptionActions(options) {\n    return function(dispatch, query, state) {\n      var obj = {};\n      forin(options, function(key) {\n        var name = fromCamels(key, '_').toUpperCase();\n\n        obj['SET_' + name] = function(action) {\n          try {\n            state.options[key] = action.value;\n          } catch (e) {} // nope, failed\n\n          // we successfully set the value of this option\n          dispatch('DID_SET_' + name, { value: state.options[key] });\n        };\n      });\n      return obj;\n    };\n  };\n\n  var createOptionQueries = function createOptionQueries(options) {\n    return function(state) {\n      var obj = {};\n      forin(options, function(key) {\n        obj['GET_' + fromCamels(key, '_').toUpperCase()] = function(action) {\n          return state.options[key];\n        };\n      });\n      return obj;\n    };\n  };\n\n  var InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5\n  };\n\n  var getUniqueId = function getUniqueId() {\n    return Math.random()\n      .toString(36)\n      .substr(2, 9);\n  };\n\n  var arrayRemove = function arrayRemove(arr, index) {\n    return arr.splice(index, 1);\n  };\n\n  var on = function on() {\n    var listeners = [];\n    var off = function off(event, cb) {\n      arrayRemove(\n        listeners,\n        listeners.findIndex(function(listener) {\n          return listener.event === event && (listener.cb === cb || !cb);\n        })\n      );\n    };\n    return {\n      fire: function fire(event) {\n        for (\n          var _len = arguments.length,\n            args = new Array(_len > 1 ? _len - 1 : 0),\n            _key = 1;\n          _key < _len;\n          _key++\n        ) {\n          args[_key - 1] = arguments[_key];\n        }\n        listeners\n          .filter(function(listener) {\n            return listener.event === event;\n          })\n          .map(function(listener) {\n            return listener.cb;\n          })\n          .forEach(function(cb) {\n            setTimeout(function() {\n              cb.apply(void 0, args);\n            }, 0);\n          });\n      },\n      on: function on(event, cb) {\n        listeners.push({ event: event, cb: cb });\n      },\n      onOnce: function onOnce(event, _cb) {\n        listeners.push({\n          event: event,\n          cb: function cb() {\n            off(event, _cb);\n            _cb.apply(void 0, arguments);\n          }\n        });\n      },\n      off: off\n    };\n  };\n\n  var copyObjectPropertiesToObject = function copyObjectPropertiesToObject(\n    src,\n    target,\n    excluded\n  ) {\n    Object.getOwnPropertyNames(src)\n      .filter(function(property) {\n        return !excluded.includes(property);\n      })\n      .forEach(function(key) {\n        return Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(src, key)\n        );\n      });\n  };\n\n  var PRIVATE = [\n    'fire',\n    'process',\n    'revert',\n    'load',\n    'on',\n    'off',\n    'onOnce',\n    'retryLoad',\n    'extend',\n    'archive',\n    'archived',\n    'release',\n    'released',\n    'requestProcessing',\n    'freeze'\n  ];\n\n  var createItemAPI = function createItemAPI(item) {\n    var api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n  };\n\n  var removeReleasedItems = function removeReleasedItems(items) {\n    items.forEach(function(item, index) {\n      if (item.released) {\n        arrayRemove(items, index);\n      }\n    });\n  };\n\n  var ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8\n  };\n\n  var FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3\n  };\n\n  var getNonNumeric = function getNonNumeric(str) {\n    return /[^0-9]+/.exec(str);\n  };\n\n  var getDecimalSeparator = function getDecimalSeparator() {\n    return getNonNumeric((1.1).toLocaleString())[0];\n  };\n\n  var getThousandsSeparator = function getThousandsSeparator() {\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    var decimalSeparator = getDecimalSeparator();\n    var thousandsStringWithSeparator = (1000.0).toLocaleString();\n    var thousandsStringWithoutSeparator = (1000.0).toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n      return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === '.' ? ',' : '.';\n  };\n\n  var Type = {\n    BOOLEAN: 'boolean',\n    INT: 'int',\n    NUMBER: 'number',\n    STRING: 'string',\n    ARRAY: 'array',\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    ACTION: 'action',\n    SERVER_API: 'serverapi',\n    REGEX: 'regex'\n  };\n\n  // all registered filters\n  var filters = [];\n\n  // loops over matching filters and passes options to each filter, returning the mapped results\n  var applyFilterChain = function applyFilterChain(key, value, utils) {\n    return new Promise(function(resolve, reject) {\n      // find matching filters for this key\n      var matchingFilters = filters\n        .filter(function(f) {\n          return f.key === key;\n        })\n        .map(function(f) {\n          return f.cb;\n        });\n\n      // resolve now\n      if (matchingFilters.length === 0) {\n        resolve(value);\n        return;\n      }\n\n      // first filter to kick things of\n      var initialFilter = matchingFilters.shift();\n\n      // chain filters\n      matchingFilters\n        .reduce(\n          // loop over promises passing value to next promise\n          function(current, next) {\n            return current.then(function(value) {\n              return next(value, utils);\n            });\n          },\n\n          // call initial filter, will return a promise\n          initialFilter(value, utils)\n\n          // all executed\n        )\n        .then(function(value) {\n          return resolve(value);\n        })\n        .catch(function(error) {\n          return reject(error);\n        });\n    });\n  };\n\n  var applyFilters = function applyFilters(key, value, utils) {\n    return filters\n      .filter(function(f) {\n        return f.key === key;\n      })\n      .map(function(f) {\n        return f.cb(value, utils);\n      });\n  };\n\n  // adds a new filter to the list\n  var addFilter = function addFilter(key, cb) {\n    return filters.push({ key: key, cb: cb });\n  };\n\n  var extendDefaultOptions = function extendDefaultOptions(additionalOptions) {\n    return Object.assign(defaultOptions, additionalOptions);\n  };\n\n  var getOptions = function getOptions() {\n    return Object.assign({}, defaultOptions);\n  };\n\n  var setOptions = function setOptions(opts) {\n    forin(opts, function(key, value) {\n      // key does not exist, so this option cannot be set\n      if (!defaultOptions[key]) {\n        return;\n      }\n      defaultOptions[key][0] = getValueByType(\n        value,\n        defaultOptions[key][0],\n        defaultOptions[key][1]\n      );\n    });\n  };\n\n  // default options on app\n  var defaultOptions = {\n    // the id to add to the root element\n    id: [null, Type.STRING],\n\n    // input field name to use\n    name: ['filepond', Type.STRING],\n\n    // disable the field\n    disabled: [false, Type.BOOLEAN],\n\n    // classname to put on wrapper\n    className: [null, Type.STRING],\n\n    // is the field required\n    required: [false, Type.BOOLEAN],\n\n    // Allow media capture when value is set\n    captureMethod: [null, Type.STRING],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n    // Feature toggles\n    allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n    allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n    allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n    allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n    allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n    allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n\n    // Revert mode\n    forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n    // Input requirements\n    maxFiles: [null, Type.INT], // Max number of files\n    checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n    // Where to put file\n    itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n    itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n    itemInsertInterval: [75, Type.INT],\n\n    // Drag 'n Drop related\n    dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n    dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n    dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n    ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n    // Upload related\n    instantUpload: [true, Type.BOOLEAN], // Should upload files immidiately on drop\n    maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n\n    // Chunks\n    chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n    chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n    chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n    chunkRetryDelays: [[500, 1000, 3000], Type.Array], // Amount of times to retry upload of a chunk when it fails\n\n    // The server api end points to use for uploading (see docs)\n    server: [null, Type.SERVER_API],\n\n    // Labels and status messages\n    labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n    labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n    labelIdle: [\n      'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n      Type.STRING\n    ],\n    labelInvalidField: ['Field contains invalid files', Type.STRING],\n    labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n    labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n    labelFileCountSingular: ['file in list', Type.STRING],\n    labelFileCountPlural: ['files in list', Type.STRING],\n    labelFileLoading: ['Loading', Type.STRING],\n    labelFileAdded: ['Added', Type.STRING], // assistive only\n    labelFileLoadError: ['Error during load', Type.STRING],\n    labelFileRemoved: ['Removed', Type.STRING], // assistive only\n    labelFileRemoveError: ['Error during remove', Type.STRING],\n    labelFileProcessing: ['Uploading', Type.STRING],\n    labelFileProcessingComplete: ['Upload complete', Type.STRING],\n    labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n    labelFileProcessingError: ['Error during upload', Type.STRING],\n    labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n    labelTapToCancel: ['tap to cancel', Type.STRING],\n    labelTapToRetry: ['tap to retry', Type.STRING],\n    labelTapToUndo: ['tap to undo', Type.STRING],\n\n    labelButtonRemoveItem: ['Remove', Type.STRING],\n    labelButtonAbortItemLoad: ['Abort', Type.STRING],\n    labelButtonRetryItemLoad: ['Retry', Type.STRING],\n    labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n    labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n    labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n    labelButtonProcessItem: ['Upload', Type.STRING],\n\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconProcess: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n      Type.STRING\n    ],\n\n    iconRetry: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconUndo: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    iconDone: [\n      '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n      Type.STRING\n    ],\n\n    // event handlers\n    oninit: [null, Type.FUNCTION],\n    onwarning: [null, Type.FUNCTION],\n    onerror: [null, Type.FUNCTION],\n    onactivatefile: [null, Type.FUNCTION],\n    onaddfilestart: [null, Type.FUNCTION],\n    onaddfileprogress: [null, Type.FUNCTION],\n    onaddfile: [null, Type.FUNCTION],\n    onprocessfilestart: [null, Type.FUNCTION],\n    onprocessfileprogress: [null, Type.FUNCTION],\n    onprocessfileabort: [null, Type.FUNCTION],\n    onprocessfilerevert: [null, Type.FUNCTION],\n    onprocessfile: [null, Type.FUNCTION],\n    onprocessfiles: [null, Type.FUNCTION],\n    onremovefile: [null, Type.FUNCTION],\n    onpreparefile: [null, Type.FUNCTION],\n    onupdatefiles: [null, Type.FUNCTION],\n\n    // hooks\n    beforeDropFile: [null, Type.FUNCTION],\n    beforeAddFile: [null, Type.FUNCTION],\n    beforeRemoveFile: [null, Type.FUNCTION],\n\n    // styles\n    stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n    stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n    styleItemPanelAspectRatio: [null, Type.STRING],\n    styleButtonRemoveItemPosition: ['left', Type.STRING],\n    styleButtonProcessItemPosition: ['right', Type.STRING],\n    styleLoadIndicatorPosition: ['right', Type.STRING],\n    styleProgressIndicatorPosition: ['right', Type.STRING],\n\n    // custom initial files array\n    files: [[], Type.ARRAY]\n  };\n\n  var getItemByQuery = function getItemByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return items[0] || null;\n    }\n\n    // query is index\n    if (isInt(query)) {\n      return items[query] || null;\n    }\n\n    // if query is item, get the id\n    if (typeof query === 'object') {\n      query = query.id;\n    }\n\n    // assume query is a string and return item by id\n    return (\n      items.find(function(item) {\n        return item.id === query;\n      }) || null\n    );\n  };\n\n  var getNumericAspectRatioFromString = function getNumericAspectRatioFromString(\n    aspectRatio\n  ) {\n    if (isEmpty(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n      var parts = aspectRatio.split(':');\n      return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n  };\n\n  var getActiveItems = function getActiveItems(items) {\n    return items.filter(function(item) {\n      return !item.archived;\n    });\n  };\n\n  var Status = {\n    EMPTY: 0,\n    IDLE: 1, // waiting\n    ERROR: 2, // a file is in error state\n    BUSY: 3, // busy processing or loading\n    READY: 4 // all files uploaded\n  };\n\n  var ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR\n  ];\n  var ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT\n  ];\n  var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\n  var isItemInErrorState = function isItemInErrorState(item) {\n    return ITEM_ERROR.includes(item.status);\n  };\n  var isItemInBusyState = function isItemInBusyState(item) {\n    return ITEM_BUSY.includes(item.status);\n  };\n  var isItemInReadyState = function isItemInReadyState(item) {\n    return ITEM_READY.includes(item.status);\n  };\n\n  var queries = function queries(state) {\n    return {\n      GET_STATUS: function GET_STATUS() {\n        var items = getActiveItems(state.items);\n        var EMPTY = Status.EMPTY,\n          ERROR = Status.ERROR,\n          BUSY = Status.BUSY,\n          IDLE = Status.IDLE,\n          READY = Status.READY;\n\n        if (items.length === 0) return EMPTY;\n\n        if (items.some(isItemInErrorState)) return ERROR;\n\n        if (items.some(isItemInBusyState)) return BUSY;\n\n        if (items.some(isItemInReadyState)) return READY;\n\n        return IDLE;\n      },\n\n      GET_ITEM: function GET_ITEM(query) {\n        return getItemByQuery(state.items, query);\n      },\n\n      GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {\n        return getItemByQuery(getActiveItems(state.items), query);\n      },\n\n      GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {\n        return getActiveItems(state.items);\n      },\n\n      GET_ITEMS: function GET_ITEMS() {\n        return state.items;\n      },\n\n      GET_ITEM_NAME: function GET_ITEM_NAME(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.filename : null;\n      },\n\n      GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {\n        var item = getItemByQuery(state.items, query);\n        return item ? item.fileSize : null;\n      },\n\n      GET_STYLES: function GET_STYLES() {\n        return Object.keys(state.options)\n          .filter(function(key) {\n            return /^style/.test(key);\n          })\n          .map(function(option) {\n            return {\n              name: option,\n              value: state.options[option]\n            };\n          });\n      },\n\n      GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {\n        var isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n        var aspectRatio = isShapeCircle\n          ? 1\n          : getNumericAspectRatioFromString(\n              state.options.stylePanelAspectRatio\n            );\n        return aspectRatio;\n      },\n\n      GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {\n        return state.options.styleItemPanelAspectRatio;\n      },\n\n      GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {\n        return getActiveItems(state.items).filter(function(item) {\n          return item.status === status;\n        });\n      },\n\n      GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {\n        return getActiveItems(state.items).length;\n      },\n\n      IS_ASYNC: function IS_ASYNC() {\n        return (\n          isObject(state.options.server) &&\n          (isObject(state.options.server.process) ||\n            isFunction(state.options.server.process))\n        );\n      }\n    };\n  };\n\n  var hasRoomForItem = function hasRoomForItem(state) {\n    var count = getActiveItems(state.items).length;\n\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n      return count === 0;\n    }\n\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    var maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n      return true;\n    }\n\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n      return true;\n    }\n\n    // no more room for another file\n    return false;\n  };\n\n  var limit = function limit(value, min, max) {\n    return Math.max(Math.min(max, value), min);\n  };\n\n  var arrayInsert = function arrayInsert(arr, index, item) {\n    return arr.splice(index, 0, item);\n  };\n\n  var insertItem = function insertItem(items, item, index) {\n    if (isEmpty(item)) {\n      return null;\n    }\n\n    // if index is undefined, append\n    if (typeof index === 'undefined') {\n      items.push(item);\n      return item;\n    }\n\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n\n    // add item to array\n    arrayInsert(items, index, item);\n\n    // expose\n    return item;\n  };\n\n  var isBase64DataURI = function isBase64DataURI(str) {\n    return /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n      str\n    );\n  };\n\n  var getFilenameFromURL = function getFilenameFromURL(url) {\n    return url\n      .split('/')\n      .pop()\n      .split('?')\n      .shift();\n  };\n\n  var getExtensionFromFilename = function getExtensionFromFilename(name) {\n    return name.split('.').pop();\n  };\n\n  var guesstimateExtension = function guesstimateExtension(type) {\n    // if no extension supplied, exit here\n    if (typeof type !== 'string') {\n      return '';\n    }\n\n    // get subtype\n    var subtype = type.split('/').pop();\n\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n      return 'svg';\n    }\n\n    if (/zip|compressed/.test(subtype)) {\n      return 'zip';\n    }\n\n    if (/plain/.test(subtype)) {\n      return 'txt';\n    }\n\n    if (/msword/.test(subtype)) {\n      return 'doc';\n    }\n\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n      // always use jpg extension\n      if (subtype === 'jpeg') {\n        return 'jpg';\n      }\n\n      // return subtype\n      return subtype;\n    }\n\n    return '';\n  };\n\n  var leftPad = function leftPad(value) {\n    var padding =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return (padding + value).slice(-padding.length);\n  };\n\n  var getDateString = function getDateString() {\n    var date =\n      arguments.length > 0 && arguments[0] !== undefined\n        ? arguments[0]\n        : new Date();\n    return (\n      date.getFullYear() +\n      '-' +\n      leftPad(date.getMonth() + 1, '00') +\n      '-' +\n      leftPad(date.getDate(), '00') +\n      '_' +\n      leftPad(date.getHours(), '00') +\n      '-' +\n      leftPad(date.getMinutes(), '00') +\n      '-' +\n      leftPad(date.getSeconds(), '00')\n    );\n  };\n\n  var getFileFromBlob = function getFileFromBlob(blob, filename) {\n    var type =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var extension =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var file =\n      typeof type === 'string'\n        ? blob.slice(0, blob.size, type)\n        : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n      filename = getDateString();\n    }\n\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n      file.name = filename;\n    } else {\n      extension = extension || guesstimateExtension(file.type);\n      file.name = filename + (extension ? '.' + extension : '');\n    }\n\n    return file;\n  };\n\n  var getBlobBuilder = function getBlobBuilder() {\n    return (window.BlobBuilder =\n      window.BlobBuilder ||\n      window.WebKitBlobBuilder ||\n      window.MozBlobBuilder ||\n      window.MSBlobBuilder);\n  };\n\n  var createBlob = function createBlob(arrayBuffer, mimeType) {\n    var BB = getBlobBuilder();\n\n    if (BB) {\n      var bb = new BB();\n      bb.append(arrayBuffer);\n      return bb.getBlob(mimeType);\n    }\n\n    return new Blob([arrayBuffer], {\n      type: mimeType\n    });\n  };\n\n  var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType(\n    byteString,\n    mimeType\n  ) {\n    var ab = new ArrayBuffer(byteString.length);\n    var ia = new Uint8Array(ab);\n\n    for (var i = 0; i < byteString.length; i++) {\n      ia[i] = byteString.charCodeAt(i);\n    }\n\n    return createBlob(ab, mimeType);\n  };\n\n  var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI(\n    dataURI\n  ) {\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n  };\n\n  var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI(\n    dataURI\n  ) {\n    // get data part of string (remove data:image/jpeg...,)\n    var data = dataURI.split(',')[1];\n\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, '');\n  };\n\n  var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI(\n    dataURI\n  ) {\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n  };\n\n  var getBlobFromBase64DataURI = function getBlobFromBase64DataURI(dataURI) {\n    var mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    var byteString = getByteStringFromBase64DataURI(dataURI);\n\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n  };\n\n  var getFileFromBase64DataURI = function getFileFromBase64DataURI(\n    dataURI,\n    filename,\n    extension\n  ) {\n    return getFileFromBlob(\n      getBlobFromBase64DataURI(dataURI),\n      filename,\n      null,\n      extension\n    );\n  };\n\n  var getFileNameFromHeader = function getFileNameFromHeader(header) {\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n\n    // get filename parts\n    var matches = header\n      .split(/filename=|filename\\*=.+''/)\n      .splice(1)\n      .map(function(name) {\n        return name.trim().replace(/^[\"']|[;\"']{0,2}$/g, '');\n      })\n      .filter(function(name) {\n        return name.length;\n      });\n\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n  };\n\n  var getFileSizeFromHeader = function getFileSizeFromHeader(header) {\n    if (/content-length:/i.test(header)) {\n      var size = header.match(/[0-9]+/)[0];\n      return size ? parseInt(size, 10) : null;\n    }\n    return null;\n  };\n\n  var getTranfserIdFromHeader = function getTranfserIdFromHeader(header) {\n    if (/x-content-transfer-id:/i.test(header)) {\n      var id = (header.split(':')[1] || '').trim();\n      return id || null;\n    }\n    return null;\n  };\n\n  var getFileInfoFromHeaders = function getFileInfoFromHeaders(headers) {\n    var info = {\n      source: null,\n      name: null,\n      size: null\n    };\n\n    var rows = headers.split('\\n');\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (\n        var _iterator = rows[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n      ) {\n        var header = _step.value;\n\n        var name = getFileNameFromHeader(header);\n        if (name) {\n          info.name = name;\n          continue;\n        }\n\n        var size = getFileSizeFromHeader(header);\n        if (size) {\n          info.size = size;\n          continue;\n        }\n\n        var source = getTranfserIdFromHeader(header);\n        if (source) {\n          info.source = source;\n          continue;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return info;\n  };\n\n  var createFileLoader = function createFileLoader(fetchFn) {\n    var state = {\n      source: null,\n      complete: false,\n      progress: 0,\n      size: null,\n      timestamp: null,\n      duration: 0,\n      request: null\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress;\n    };\n    var abort = function abort() {\n      if (state.request && state.request.abort) {\n        state.request.abort();\n      }\n    };\n\n    // load source\n    var load = function load() {\n      // get quick reference\n      var source = state.source;\n\n      api.fire('init', source);\n\n      // Load Files\n      if (source instanceof File) {\n        api.fire('load', source);\n      } else if (source instanceof Blob) {\n        // Load blobs, set default name to current date\n        api.fire('load', getFileFromBlob(source, source.name));\n      } else if (isBase64DataURI(source)) {\n        // Load base 64, set default name to current date\n        api.fire('load', getFileFromBase64DataURI(source));\n      } else {\n        // Deal as if is external URL, let's load it!\n        loadURL(source);\n      }\n    };\n\n    // loads a url\n    var loadURL = function loadURL(url) {\n      // is remote url and no fetch method supplied\n      if (!fetchFn) {\n        api.fire('error', {\n          type: 'error',\n          body: \"Can't load URL\",\n          code: 400\n        });\n\n        return;\n      }\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // load file\n      state.request = fetchFn(\n        url,\n        function(response) {\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // done!\n          state.complete = true;\n\n          // turn blob response into a file\n          if (response instanceof Blob) {\n            response = getFileFromBlob(\n              response,\n              response.name || getFilenameFromURL(url)\n            );\n          }\n\n          api.fire('load', response instanceof Blob ? response : response.body);\n        },\n        function(error) {\n          api.fire(\n            'error',\n            typeof error === 'string'\n              ? {\n                  type: 'error',\n                  code: 0,\n                  body: error\n                }\n              : error\n          );\n        },\n        function(computable, current, total) {\n          // collected some meta data already\n          if (total) {\n            state.size = total;\n          }\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // if we can't compute progress, we're not going to fire progress events\n          if (!computable) {\n            state.progress = null;\n            return;\n          }\n\n          // update progress percentage\n          state.progress = current / total;\n\n          // expose\n          api.fire('progress', state.progress);\n        },\n        function() {\n          api.fire('abort');\n        },\n        function(response) {\n          var fileinfo = getFileInfoFromHeaders(\n            typeof response === 'string' ? response : response.headers\n          );\n          api.fire('meta', {\n            size: state.size || fileinfo.size,\n            filename: fileinfo.name,\n            source: fileinfo.source\n          });\n        }\n      );\n    };\n\n    var api = Object.assign({}, on(), {\n      setSource: function setSource(source) {\n        return (state.source = source);\n      },\n      getProgress: getProgress, // file load progress\n      abort: abort, // abort file load\n      load: load // start load\n    });\n\n    return api;\n  };\n\n  var isGet = function isGet(method) {\n    return /GET|HEAD/.test(method);\n  };\n\n  var sendRequest = function sendRequest(data, url, options) {\n    var api = {\n      onheaders: function onheaders() {},\n      onprogress: function onprogress() {},\n      onload: function onload() {},\n      ontimeout: function ontimeout() {},\n      onerror: function onerror() {},\n      onabort: function onabort() {},\n      abort: function abort() {\n        aborted = true;\n        xhr.abort();\n      }\n    };\n\n    // timeout identifier, only used when timeout is defined\n    var aborted = false;\n    var headersReceived = false;\n\n    // set default options\n    options = Object.assign(\n      {\n        method: 'POST',\n        headers: {},\n        withCredentials: false\n      },\n      options\n    );\n\n    // encode url\n    url = encodeURI(url);\n\n    // if method is GET, add any received data to url\n\n    if (isGet(options.method) && data) {\n      url =\n        '' +\n        url +\n        encodeURIComponent(\n          typeof data === 'string' ? data : JSON.stringify(data)\n        );\n    }\n\n    // create request\n    var xhr = new XMLHttpRequest();\n\n    // progress of load\n    var process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = function(e) {\n      // no progress event when aborted ( onprogress is called once after abort() )\n      if (aborted) {\n        return;\n      }\n\n      api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = function() {\n      // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n      if (xhr.readyState < 2) {\n        return;\n      }\n\n      // no server response\n      if (xhr.readyState === 4 && xhr.status === 0) {\n        return;\n      }\n\n      if (headersReceived) {\n        return;\n      }\n\n      headersReceived = true;\n\n      // we've probably received some useful data in response headers\n      api.onheaders(xhr);\n    };\n\n    // load successful\n    xhr.onload = function() {\n      // is classified as valid response\n      if (xhr.status >= 200 && xhr.status < 300) {\n        api.onload(xhr);\n      } else {\n        api.onerror(xhr);\n      }\n    };\n\n    // error during load\n    xhr.onerror = function() {\n      return api.onerror(xhr);\n    };\n\n    // request aborted\n    xhr.onabort = function() {\n      aborted = true;\n      api.onabort();\n    };\n\n    // request timeout\n    xhr.ontimeout = function() {\n      return api.ontimeout(xhr);\n    };\n\n    // open up open up!\n    xhr.open(options.method, url, true);\n\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n      xhr.timeout = options.timeout;\n    }\n\n    // add headers\n    Object.keys(options.headers).forEach(function(key) {\n      var value = unescape(encodeURIComponent(options.headers[key]));\n      xhr.setRequestHeader(key, value);\n    });\n\n    // set type of response\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    // set credentials\n    if (options.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    // let's send our data\n    xhr.send(data);\n\n    return api;\n  };\n\n  var createResponse = function createResponse(type, code, body, headers) {\n    return {\n      type: type,\n      code: code,\n      body: body,\n      headers: headers\n    };\n  };\n\n  var createTimeoutResponse = function createTimeoutResponse(cb) {\n    return function(xhr) {\n      cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n    };\n  };\n\n  var createFetchFunction = function createFetchFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied\n    if (!action || !isString(action.url)) {\n      return null;\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal handler\n    return function(url, load, error, progress, abort, headers) {\n      // do local or remote request based on if the url is external\n      var request = sendRequest(\n        url,\n        apiUrl + action.url,\n        Object.assign({}, action, {\n          responseType: 'blob'\n        })\n      );\n\n      request.onload = function(xhr) {\n        // get headers\n        var headers = xhr.getAllResponseHeaders();\n\n        // get filename\n        var filename =\n          getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n        // create response\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            getFileFromBlob(onload(xhr.response), filename),\n            headers\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onheaders = function(xhr) {\n        headers(\n          createResponse(\n            'headers',\n            xhr.status,\n            null,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  function _typeof(obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function(obj) {\n        return obj &&\n          typeof Symbol === 'function' &&\n          obj.constructor === Symbol &&\n          obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  var REACT_ELEMENT_TYPE;\n\n  function _jsx(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE =\n        (typeof Symbol === 'function' &&\n          Symbol['for'] &&\n          Symbol['for']('react.element')) ||\n        0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {\n        children: void 0\n      };\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  }\n\n  function _asyncIterator(iterable) {\n    var method;\n\n    if (typeof Symbol !== 'undefined') {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator];\n        if (method != null) return method.call(iterable);\n      }\n\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator];\n        if (method != null) return method.call(iterable);\n      }\n    }\n\n    throw new TypeError('Object is not async iterable');\n  }\n\n  function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n\n  function _AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function(resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n        var wrappedAwait = value instanceof _AwaitValue;\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function(arg) {\n            if (wrappedAwait) {\n              resume('next', arg);\n              return;\n            }\n\n            settle(result.done ? 'return' : 'normal', arg);\n          },\n          function(err) {\n            resume('throw', err);\n          }\n        );\n      } catch (err) {\n        settle('throw', err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case 'return':\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case 'throw':\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== 'function') {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === 'function' && Symbol.asyncIterator) {\n    _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {\n      return this;\n    };\n  }\n\n  _AsyncGenerator.prototype.next = function(arg) {\n    return this._invoke('next', arg);\n  };\n\n  _AsyncGenerator.prototype.throw = function(arg) {\n    return this._invoke('throw', arg);\n  };\n\n  _AsyncGenerator.prototype.return = function(arg) {\n    return this._invoke('return', arg);\n  };\n\n  function _wrapAsyncGenerator(fn) {\n    return function() {\n      return new _AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n\n  function _awaitAsyncGenerator(value) {\n    return new _AwaitValue(value);\n  }\n\n  function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {},\n      waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function(resolve) {\n        resolve(inner[key](value));\n      });\n      return {\n        done: false,\n        value: awaitWrap(value)\n      };\n    }\n\n    if (typeof Symbol === 'function' && Symbol.iterator) {\n      iter[Symbol.iterator] = function() {\n        return this;\n      };\n    }\n\n    iter.next = function(value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump('next', value);\n    };\n\n    if (typeof inner.throw === 'function') {\n      iter.throw = function(value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n\n        return pump('throw', value);\n      };\n    }\n\n    if (typeof inner.return === 'function') {\n      iter.return = function(value) {\n        return pump('return', value);\n      };\n    }\n\n    return iter;\n  }\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function() {\n      var self = this,\n        args = arguments;\n      return new Promise(function(resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(\n            gen,\n            resolve,\n            reject,\n            _next,\n            _throw,\n            'next',\n            value\n          );\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if ('value' in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if ('value' in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends =\n      Object.assign ||\n      function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(\n          Object.getOwnPropertySymbols(source).filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          })\n        );\n      }\n\n      ownKeys.forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly)\n        symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source)\n        );\n      } else {\n        ownKeys(source).forEach(function(key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== 'function' && superClass !== null) {\n      throw new TypeError('Super expression must either be null or a function');\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf =\n      Object.setPrototypeOf ||\n      function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === 'function') return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf('[native code]') !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === 'function' ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== 'function') {\n        throw new TypeError(\n          'Super expression must either be null or a function'\n        );\n      }\n\n      if (typeof _cache !== 'undefined') {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _instanceof(left, right) {\n    if (\n      right != null &&\n      typeof Symbol !== 'undefined' &&\n      right[Symbol.hasInstance]\n    ) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule\n      ? obj\n      : {\n          default: obj\n        };\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc =\n              Object.defineProperty && Object.getOwnPropertyDescriptor\n                ? Object.getOwnPropertyDescriptor(obj, key)\n                : {};\n\n            if (desc.get || desc.set) {\n              Object.defineProperty(newObj, key, desc);\n            } else {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError('Cannot instantiate an arrow function');\n    }\n  }\n\n  function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError('Cannot destructure undefined');\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\n        \"this hasn't been initialised - super() hasn't been called\"\n      );\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === 'object' || typeof call === 'function')) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== 'undefined' && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(\n      Object.defineProperties(strings, {\n        raw: {\n          value: Object.freeze(raw)\n        }\n      })\n    );\n  }\n\n  function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    strings.raw = raw;\n    return strings;\n  }\n\n  function _temporalRef(val, name) {\n    if (val === _temporalUndefined) {\n      throw new ReferenceError(name + ' is not defined - temporal dead zone');\n    } else {\n      return val;\n    }\n  }\n\n  function _readOnlyError(name) {\n    throw new Error('\"' + name + '\" is read-only');\n  }\n\n  function _classNameTDZError(name) {\n    throw new Error(\n      'Class \"' + name + '\" cannot be referenced in computed property keys.'\n    );\n  }\n\n  var _temporalUndefined = {};\n\n  function _slicedToArray(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimit(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _slicedToArrayLoose(arr, i) {\n    return (\n      _arrayWithHoles(arr) ||\n      _iterableToArrayLimitLoose(arr, i) ||\n      _nonIterableRest()\n    );\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return (\n      _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\n    );\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)\n        arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (\n      Symbol.iterator in Object(iter) ||\n      Object.prototype.toString.call(iter) === '[object Arguments]'\n    )\n      return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (\n        var _i = arr[Symbol.iterator](), _s;\n        !(_n = (_s = _i.next()).done);\n        _n = true\n      ) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return'] != null) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _iterableToArrayLimitLoose(arr, i) {\n    var _arr = [];\n\n    for (\n      var _iterator = arr[Symbol.iterator](), _step;\n      !(_step = _iterator.next()).done;\n\n    ) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError('Invalid attempt to spread non-iterable instance');\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError('Invalid attempt to destructure non-iterable instance');\n  }\n\n  function _skipFirstGeneratorNext(fn) {\n    return function() {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    };\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== 'object' || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || 'default');\n      if (typeof res !== 'object') return res;\n      throw new TypeError('@@toPrimitive must return a primitive value.');\n    }\n\n    return (hint === 'string' ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, 'string');\n\n    return typeof key === 'symbol' ? key : String(key);\n  }\n\n  function _initializerWarningHelper(descriptor, context) {\n    throw new Error(\n      'Decorating class property failed. Please ensure that ' +\n        'proposal-class-properties is enabled and set to use loose mode. ' +\n        'To use proposal-class-properties in spec mode with decorators, wait for ' +\n        'the next major version of decorators in stage 2.'\n    );\n  }\n\n  function _initializerDefineProperty(target, property, descriptor, context) {\n    if (!descriptor) return;\n    Object.defineProperty(target, property, {\n      enumerable: descriptor.enumerable,\n      configurable: descriptor.configurable,\n      writable: descriptor.writable,\n      value: descriptor.initializer\n        ? descriptor.initializer.call(context)\n        : void 0\n    });\n  }\n\n  function _applyDecoratedDescriptor(\n    target,\n    property,\n    decorators,\n    descriptor,\n    context\n  ) {\n    var desc = {};\n    Object.keys(descriptor).forEach(function(key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators\n      .slice()\n      .reverse()\n      .reduce(function(desc, decorator) {\n        return decorator(target, property, desc) || desc;\n      }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object.defineProperty(target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var id = 0;\n\n  function _classPrivateFieldLooseKey(name) {\n    return '__private_' + id++ + '_' + name;\n  }\n\n  function _classPrivateFieldLooseBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError('attempted to use private field on non-instance');\n    }\n\n    return receiver;\n  }\n\n  function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n\n    return descriptor.value;\n  }\n\n  function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n\n    if (!descriptor) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n\n  function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError('attempted to set private field on non-instance');\n    }\n\n    var descriptor = privateMap.get(receiver);\n\n    if (descriptor.set) {\n      if (!('__destrObj' in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v);\n          }\n        };\n      }\n\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        throw new TypeError('attempted to set read only private field');\n      }\n\n      return descriptor;\n    }\n  }\n\n  function _classStaticPrivateFieldSpecGet(\n    receiver,\n    classConstructor,\n    descriptor\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return descriptor.value;\n  }\n\n  function _classStaticPrivateFieldSpecSet(\n    receiver,\n    classConstructor,\n    descriptor,\n    value\n  ) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    if (!descriptor.writable) {\n      throw new TypeError('attempted to set read only private field');\n    }\n\n    descriptor.value = value;\n    return value;\n  }\n\n  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError('Private static access of wrong provenance');\n    }\n\n    return method;\n  }\n\n  function _classStaticPrivateMethodSet() {\n    throw new TypeError('attempted to set read only static private field');\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators\n    );\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [['method'], ['field']],\n      initializeInstanceElements: function(O, elements) {\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === 'own') {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function(F, elements) {\n        var proto = F.prototype;\n        ['method', 'field'].forEach(function(kind) {\n          elements.forEach(function(element) {\n            var placement = element.placement;\n\n            if (\n              element.kind === kind &&\n              (placement === 'static' || placement === 'prototype')\n            ) {\n              var receiver = placement === 'static' ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function(receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === 'field') {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function(elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function(element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function(element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(\n            element,\n            placements\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function(element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError('Duplicated element (' + element.key + ')');\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function(element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) || elementObject\n          );\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function(elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor(\n            (0, decorators[i])(obj) || obj\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    'Duplicated element (' + elements[j].key + ')'\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function(element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === 'field') obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function(elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(\n            elementObject,\n            'finisher',\n            'An element descriptor'\n          );\n          this.disallowProperty(\n            elementObject,\n            'extras',\n            'An element descriptor'\n          );\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function(elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== 'method' && kind !== 'field') {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (\n          placement !== 'static' &&\n          placement !== 'prototype' &&\n          placement !== 'own'\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"'\n          );\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(\n          elementObject,\n          'elements',\n          'An element descriptor'\n        );\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== 'field') {\n          this.disallowProperty(\n            elementObject,\n            'initializer',\n            'A method descriptor'\n          );\n        } else {\n          this.disallowProperty(\n            descriptor,\n            'get',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'set',\n            'The property descriptor of a field descriptor'\n          );\n          this.disallowProperty(\n            descriptor,\n            'value',\n            'The property descriptor of a field descriptor'\n          );\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function(elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, 'finisher');\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function(elements) {\n        var obj = {\n          kind: 'class',\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: 'Descriptor',\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function(obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== 'class') {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"'\n          );\n        }\n\n        this.disallowProperty(obj, 'key', 'A class descriptor');\n        this.disallowProperty(obj, 'placement', 'A class descriptor');\n        this.disallowProperty(obj, 'descriptor', 'A class descriptor');\n        this.disallowProperty(obj, 'initializer', 'A class descriptor');\n        this.disallowProperty(obj, 'extras', 'A class descriptor');\n\n        var finisher = _optionalCallableProperty(obj, 'finisher');\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function(constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== 'function') {\n              throw new TypeError('Finishers must return a constructor.');\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(\n            objectType + \" can't have a .\" + name + ' property.'\n          );\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === 'method') {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'get') {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'set') {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === 'field') {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === 'field' ? 'field' : 'method',\n      key: key,\n      placement: def.static\n        ? 'static'\n        : def.kind === 'field'\n        ? 'own'\n        : 'prototype',\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === 'field') element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function(other) {\n      return (\n        other.kind === 'method' &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (\n        element.kind === 'method' &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              'Duplicated methods (' + element.key + \") can't be decorated.\"\n            );\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  'the same property (' +\n                  element.key +\n                  ').'\n              );\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== 'function') {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError('attempted to get private field on non-instance');\n    }\n\n    return fn;\n  }\n\n  function _classPrivateMethodSet() {\n    throw new TypeError('attempted to reassign private method');\n  }\n\n  function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, groups);\n    };\n\n    var _RegExp = _wrapNativeSuper(RegExp);\n\n    var _super = RegExp.prototype;\n\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, groups) {\n      var _this = _RegExp.call(this, re);\n\n      _groups.set(_this, groups);\n\n      return _this;\n    }\n\n    _inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === 'string') {\n        var groups = _groups.get(this);\n\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return '$' + groups[name];\n          })\n        );\n      } else if (typeof substitution === 'function') {\n        var _this = this;\n\n        return _super[Symbol.replace].call(this, str, function() {\n          var args = [];\n          args.push.apply(args, arguments);\n\n          if (typeof args[args.length - 1] !== 'object') {\n            args.push(buildGroups(args, _this));\n          }\n\n          return substitution.apply(this, args);\n        });\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    };\n\n    function buildGroups(result, re) {\n      var g = _groups.get(re);\n\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n\n  var ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4\n  };\n\n  /*\n                                                       function signature:\n                                                         (file, metadata, load, error, progress, abort, transfer, options) => {\n                                                           return {\n                                                           abort:() => {}\n                                                         }\n                                                       }\n                                                       */\n\n  // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\n  var processFileChunked = function processFileChunked(\n    apiUrl,\n    action,\n    name,\n    file,\n    metadata,\n    load,\n    error,\n    progress,\n    abort,\n    transfer,\n    options\n  ) {\n    // all chunks\n    var chunks = [];\n    var chunkTransferId = options.chunkTransferId,\n      chunkServer = options.chunkServer,\n      chunkSize = options.chunkSize,\n      chunkRetryDelays = options.chunkRetryDelays;\n\n    // default state\n    var state = {\n      serverId: chunkTransferId,\n      aborted: false\n    };\n\n    // set onload handlers\n    var ondata =\n      action.ondata ||\n      function(fd) {\n        return fd;\n      };\n    var onload =\n      action.onload ||\n      function(xhr, method) {\n        return method === 'HEAD'\n          ? xhr.getResponseHeader('Upload-Offset')\n          : xhr.response;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // create server hook\n    var requestTransferId = function requestTransferId(cb) {\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(file, metadata)\n          : Object.assign({}, action.headers, {\n              'Upload-Length': file.size\n            });\n\n      var requestParams = Object.assign({}, action, {\n        headers: headers\n      });\n\n      // send request object\n      var request = sendRequest(\n        ondata(formData),\n        apiUrl + action.url,\n        requestParams\n      );\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    var requestTransferOffset = function requestTransferOffset(cb) {\n      var requestUrl = apiUrl + chunkServer.url + state.serverId;\n\n      var headers =\n        typeof action.headers === 'function'\n          ? action.headers(state.serverId)\n          : Object.assign({}, action.headers);\n\n      var requestParams = {\n        headers: headers,\n        method: 'HEAD'\n      };\n\n      var request = sendRequest(null, requestUrl, requestParams);\n\n      request.onload = function(xhr) {\n        return cb(onload(xhr, requestParams.method));\n      };\n\n      request.onerror = function(xhr) {\n        return error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n    };\n\n    // create chunks\n    var lastChunkIndex = Math.floor(file.size / chunkSize);\n    for (var i = 0; i <= lastChunkIndex; i++) {\n      var offset = i * chunkSize;\n      var data = file.slice(\n        offset,\n        offset + chunkSize,\n        'application/offset+octet-stream'\n      );\n      chunks[i] = {\n        index: i,\n        size: data.size,\n        offset: offset,\n        data: data,\n        file: file,\n        progress: 0,\n        retries: _toConsumableArray(chunkRetryDelays),\n        status: ChunkStatus.QUEUED,\n        error: null,\n        request: null,\n        timeout: null\n      };\n    }\n\n    var completeProcessingChunks = function completeProcessingChunks() {\n      return load(state.serverId);\n    };\n\n    var canProcessChunk = function canProcessChunk(chunk) {\n      return (\n        chunk.status === ChunkStatus.QUEUED ||\n        chunk.status === ChunkStatus.ERROR\n      );\n    };\n\n    var processChunk = function processChunk(chunk) {\n      // processing is paused, wait here\n      if (state.aborted) return;\n\n      // get next chunk to process\n      chunk = chunk || chunks.find(canProcessChunk);\n\n      // no more chunks to process\n      if (!chunk) {\n        // all done?\n        if (\n          chunks.every(function(chunk) {\n            return chunk.status === ChunkStatus.COMPLETE;\n          })\n        ) {\n          completeProcessingChunks();\n        }\n\n        // no chunk to handle\n        return;\n      }\n\n      // now processing this chunk\n      chunk.status = ChunkStatus.PROCESSING;\n      chunk.progress = null;\n\n      // allow parsing of formdata\n      var ondata =\n        chunkServer.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onerror =\n        chunkServer.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // send request object\n      var requestUrl = apiUrl + chunkServer.url + state.serverId;\n\n      var headers =\n        typeof chunkServer.headers === 'function'\n          ? chunkServer.headers(chunk)\n          : Object.assign({}, chunkServer.headers, {\n              'Content-Type': 'application/offset+octet-stream',\n              'Upload-Offset': chunk.offset,\n              'Upload-Length': file.size,\n              'Upload-Name': file.name\n            });\n\n      var request = (chunk.request = sendRequest(\n        ondata(chunk.data),\n        requestUrl,\n        Object.assign({}, chunkServer, {\n          headers: headers\n        })\n      ));\n\n      request.onload = function() {\n        // done!\n        chunk.status = ChunkStatus.COMPLETE;\n\n        // remove request reference\n        chunk.request = null;\n\n        // start processing more chunks\n        processChunks();\n      };\n\n      request.onprogress = function(lengthComputable, loaded, total) {\n        chunk.progress = lengthComputable ? loaded : null;\n        updateTotalProgress();\n      };\n\n      request.onerror = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        chunk.error = onerror(xhr.response) || xhr.statusText;\n        if (!retryProcessChunk(chunk)) {\n          error(\n            createResponse(\n              'error',\n              xhr.status,\n              onerror(xhr.response) || xhr.statusText,\n              xhr.getAllResponseHeaders()\n            )\n          );\n        }\n      };\n\n      request.ontimeout = function(xhr) {\n        chunk.status = ChunkStatus.ERROR;\n        chunk.request = null;\n        if (!retryProcessChunk(chunk)) {\n          createTimeoutResponse(error)(xhr);\n        }\n      };\n\n      request.onabort = function() {\n        chunk.status = ChunkStatus.QUEUED;\n        chunk.request = null;\n        abort();\n      };\n    };\n\n    var retryProcessChunk = function retryProcessChunk(chunk) {\n      // no more retries left\n      if (chunk.retries.length === 0) return false;\n\n      // new retry\n      chunk.status = ChunkStatus.WAITING;\n      clearTimeout(chunk.timeout);\n      chunk.timeout = setTimeout(function() {\n        processChunk(chunk);\n      }, chunk.retries.shift());\n\n      // we're going to retry\n      return true;\n    };\n\n    var updateTotalProgress = function updateTotalProgress() {\n      // calculate total progress fraction\n      var totalBytesTransfered = chunks.reduce(function(p, chunk) {\n        if (p === null || chunk.progress === null) return null;\n        return p + chunk.progress;\n      }, 0);\n\n      // can't compute progress\n      if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n      // calculate progress values\n      var totalSize = chunks.reduce(function(total, chunk) {\n        return total + chunk.size;\n      }, 0);\n\n      // can update progress indicator\n      progress(true, totalBytesTransfered, totalSize);\n    };\n\n    // process new chunks\n    var processChunks = function processChunks() {\n      var totalProcessing = chunks.filter(function(chunk) {\n        return chunk.status === ChunkStatus.PROCESSING;\n      }).length;\n      if (totalProcessing >= 1) return;\n      processChunk();\n    };\n\n    var abortChunks = function abortChunks() {\n      chunks.forEach(function(chunk) {\n        clearTimeout(chunk.timeout);\n        if (chunk.request) {\n          chunk.request.abort();\n        }\n      });\n    };\n\n    // let's go!\n    if (!state.serverId) {\n      requestTransferId(function(serverId) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // pass back to item so we can use it if something goes wrong\n        transfer(serverId);\n\n        // store internally\n        state.serverId = serverId;\n        processChunks();\n      });\n    } else {\n      requestTransferOffset(function(offset) {\n        // stop here if aborted, might have happened in between request and callback\n        if (state.aborted) return;\n\n        // mark chunks with lower offset as complete\n        chunks\n          .filter(function(chunk) {\n            return chunk.offset < offset;\n          })\n          .forEach(function(chunk) {\n            chunk.status = ChunkStatus.COMPLETE;\n            chunk.progress = chunk.size;\n          });\n\n        // continue processing\n        processChunks();\n      });\n    }\n\n    return {\n      abort: function abort() {\n        state.aborted = true;\n        abortChunks();\n      }\n    };\n  };\n\n  /*\n                                                               function signature:\n                                                                 (file, metadata, load, error, progress, abort) => {\n                                                                   return {\n                                                                   abort:() => {}\n                                                                 }\n                                                               }\n                                                               */\n  var createFileProcessorFunction = function createFileProcessorFunction(\n    apiUrl,\n    action,\n    name,\n    options\n  ) {\n    return function(file, metadata, load, error, progress, abort, transfer) {\n      // no file received\n      if (!file) return;\n\n      // if was passed a file, and we can chunk it, exit here\n      var canChunkUpload = options.chunkUploads;\n      var shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n      var willChunkUpload =\n        canChunkUpload && (shouldChunkUpload || options.chunkForce);\n      if (file instanceof Blob && willChunkUpload)\n        return processFileChunked(\n          apiUrl,\n          action,\n          name,\n          file,\n          metadata,\n          load,\n          error,\n          progress,\n          abort,\n          transfer,\n          options\n        );\n\n      // set handlers\n      var ondata =\n        action.ondata ||\n        function(fd) {\n          return fd;\n        };\n      var onload =\n        action.onload ||\n        function(res) {\n          return res;\n        };\n      var onerror =\n        action.onerror ||\n        function(res) {\n          return null;\n        };\n\n      // create formdata object\n      var formData = new FormData();\n\n      // add metadata under same name\n      if (isObject(metadata)) {\n        formData.append(name, JSON.stringify(metadata));\n      }\n\n      // Turn into an array of objects so no matter what the input, we can handle it the same way\n      (file instanceof Blob ? [{ name: null, file: file }] : file).forEach(\n        function(item) {\n          formData.append(\n            name,\n            item.file,\n            item.name === null\n              ? item.file.name\n              : '' + item.name + item.file.name\n          );\n        }\n      );\n\n      // send request object\n      var request = sendRequest(ondata(formData), apiUrl + action.url, action);\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n      request.onprogress = progress;\n      request.onabort = abort;\n\n      // should return request\n      return request;\n    };\n  };\n\n  var createProcessorFunction = function createProcessorFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var name = arguments.length > 2 ? arguments[2] : undefined;\n    var options = arguments.length > 3 ? arguments[3] : undefined;\n\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function')\n      return function() {\n        for (\n          var _len = arguments.length, params = new Array(_len), _key = 0;\n          _key < _len;\n          _key++\n        ) {\n          params[_key] = arguments[_key];\n        }\n        return action.apply(void 0, [name].concat(params, [options]));\n      };\n\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n  };\n\n  /*\n                                                      function signature:\n                                                      (uniqueFileId, load, error) => { }\n                                                      */\n  var createRevertFunction = function createRevertFunction() {\n    var apiUrl =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    // is custom implementation\n    if (typeof action === 'function') {\n      return action;\n    }\n\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n      return function(uniqueFileId, load) {\n        return load();\n      };\n    }\n\n    // set onload hanlder\n    var onload =\n      action.onload ||\n      function(res) {\n        return res;\n      };\n    var onerror =\n      action.onerror ||\n      function(res) {\n        return null;\n      };\n\n    // internal implementation\n    return function(uniqueFileId, load, error) {\n      var request = sendRequest(\n        uniqueFileId,\n        apiUrl + action.url,\n        action // contains method, headers and withCredentials properties\n      );\n      request.onload = function(xhr) {\n        load(\n          createResponse(\n            'load',\n            xhr.status,\n            onload(xhr.response),\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.onerror = function(xhr) {\n        error(\n          createResponse(\n            'error',\n            xhr.status,\n            onerror(xhr.response) || xhr.statusText,\n            xhr.getAllResponseHeaders()\n          )\n        );\n      };\n\n      request.ontimeout = createTimeoutResponse(error);\n\n      return request;\n    };\n  };\n\n  var getRandomNumber = function getRandomNumber() {\n    var min =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var max =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return min + Math.random() * (max - min);\n  };\n\n  var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater(\n    cb\n  ) {\n    var duration =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    var offset =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var tickMin =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n    var tickMax =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;\n    var timeout = null;\n    var start = Date.now();\n\n    var tick = function tick() {\n      var runtime = Date.now() - start;\n      var delay = getRandomNumber(tickMin, tickMax);\n\n      if (runtime + delay > duration) {\n        delay = runtime + delay - duration;\n      }\n\n      var progress = runtime / duration;\n      if (progress >= 1) {\n        cb(1);\n        return;\n      }\n\n      cb(progress);\n\n      timeout = setTimeout(tick, delay);\n    };\n\n    tick();\n\n    return {\n      clear: function clear() {\n        clearTimeout(timeout);\n      }\n    };\n  };\n\n  var createFileProcessor = function createFileProcessor(processFn) {\n    var state = {\n      complete: false,\n      perceivedProgress: 0,\n      perceivedPerformanceUpdater: null,\n      progress: null,\n      timestamp: null,\n      perceivedDuration: 0,\n      duration: 0,\n      request: null,\n      response: null\n    };\n\n    var process = function process(file, metadata) {\n      var progressFn = function progressFn() {\n        // we've not yet started the real download, stop here\n        // the request might not go through, for instance, there might be some server trouble\n        // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n        if (state.duration === 0 || state.progress === null) {\n          return;\n        }\n\n        // as we're now processing, fire the progress event\n        api.fire('progress', api.getProgress());\n      };\n\n      var completeFn = function completeFn() {\n        state.complete = true;\n        api.fire('load-perceived', state.response.body);\n      };\n\n      // let's start processing\n      api.fire('start');\n\n      // set request start\n      state.timestamp = Date.now();\n\n      // create perceived performance progress indicator\n      state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n        function(progress) {\n          state.perceivedProgress = progress;\n          state.perceivedDuration = Date.now() - state.timestamp;\n\n          progressFn();\n\n          // if fake progress is done, and a response has been received,\n          // and we've not yet called the complete method\n          if (\n            state.response &&\n            state.perceivedProgress === 1 &&\n            !state.complete\n          ) {\n            // we done!\n            completeFn();\n          }\n        },\n        // random delay as in a list of files you start noticing\n        // files uploading at the exact same speed\n        getRandomNumber(750, 1500)\n      );\n\n      // remember request so we can abort it later\n      state.request = processFn(\n        // the file to process\n        file,\n\n        // the metadata to send along\n        metadata,\n\n        // callbacks (load, error, progress, abort, transfer)\n        // load expects the body to be a server id if\n        // you want to make use of revert\n        function(response) {\n          // we put the response in state so we can access\n          // it outside of this method\n          state.response = isObject(response)\n            ? response\n            : {\n                type: 'load',\n                code: 200,\n                body: '' + response,\n                headers: {}\n              };\n\n          // update duration\n          state.duration = Date.now() - state.timestamp;\n\n          // force progress to 1 as we're now done\n          state.progress = 1;\n\n          // actual load is done let's share results\n          api.fire('load', state.response.body);\n\n          // we are really done\n          // if perceived progress is 1 ( wait for perceived progress to complete )\n          // or if server does not support progress ( null )\n          if (state.perceivedProgress === 1) {\n            completeFn();\n          }\n        },\n\n        // error is expected to be an object with type, code, body\n        function(error) {\n          // cancel updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // update others about this error\n          api.fire(\n            'error',\n            isObject(error)\n              ? error\n              : {\n                  type: 'error',\n                  code: 0,\n                  body: '' + error\n                }\n          );\n        },\n\n        // actual processing progress\n        function(computable, current, total) {\n          // update actual duration\n          state.duration = Date.now() - state.timestamp;\n\n          // update actual progress\n          state.progress = computable ? current / total : null;\n\n          progressFn();\n        },\n\n        // abort does not expect a value\n        function() {\n          // stop updater\n          state.perceivedPerformanceUpdater.clear();\n\n          // fire the abort event so we can switch visuals\n          api.fire('abort', state.response ? state.response.body : null);\n        },\n\n        // register the id for this transfer\n        function(transferId) {\n          api.fire('transfer', transferId);\n        }\n      );\n    };\n\n    var abort = function abort() {\n      // no request running, can't abort\n      if (!state.request) return;\n\n      // stop updater\n      state.perceivedPerformanceUpdater.clear();\n\n      // abort actual request\n      state.request.abort();\n\n      // if has response object, we've completed the request\n      state.complete = true;\n    };\n\n    var reset = function reset() {\n      abort();\n      state.complete = false;\n      state.perceivedProgress = 0;\n      state.progress = 0;\n      state.timestamp = null;\n      state.perceivedDuration = 0;\n      state.duration = 0;\n      state.request = null;\n      state.response = null;\n    };\n\n    var getProgress = function getProgress() {\n      return state.progress\n        ? Math.min(state.progress, state.perceivedProgress)\n        : null;\n    };\n    var getDuration = function getDuration() {\n      return Math.min(state.duration, state.perceivedDuration);\n    };\n\n    var api = Object.assign({}, on(), {\n      process: process, // start processing file\n      abort: abort, // abort active process request\n      getProgress: getProgress,\n      getDuration: getDuration,\n      reset: reset\n    });\n\n    return api;\n  };\n\n  var getFilenameWithoutExtension = function getFilenameWithoutExtension(name) {\n    return name.substr(0, name.lastIndexOf('.')) || name;\n  };\n\n  var createFileStub = function createFileStub(source) {\n    var data = [source.name, source.size, source.type];\n\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n      data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n      // if is base64 data uri we need to determine the average size and type\n      data[1] = source.length;\n      data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n      // url\n      data[0] = getFilenameFromURL(source);\n      data[1] = 0;\n      data[2] = 'application/octet-stream';\n    }\n\n    return {\n      name: data[0],\n      size: data[1],\n      type: data[2]\n    };\n  };\n\n  var isFile = function isFile(value) {\n    return !!(value instanceof File || (value instanceof Blob && value.name));\n  };\n\n  var deepCloneObject = function deepCloneObject(src) {\n    if (!isObject(src)) return src;\n    var target = isArray(src) ? [] : {};\n    for (var key in src) {\n      if (!src.hasOwnProperty(key)) continue;\n      var v = src[key];\n      target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n  };\n\n  var createItem = function createItem() {\n    var origin =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var serverFileReference =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var file =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // unique id for this item, is used to identify the item across views\n    var id = getUniqueId();\n\n    /**\n     * Internal item state\n     */\n    var state = {\n      // is archived\n      archived: false,\n\n      // if is frozen, no longer fires events\n      frozen: false,\n\n      // removed from view\n      released: false,\n\n      // original source\n      source: null,\n\n      // file model reference\n      file: file,\n\n      // id of file on server\n      serverFileReference: serverFileReference,\n\n      // id of file transfer on server\n      transferId: null,\n\n      // is aborted\n      processingAborted: false,\n\n      // current item status\n      status: serverFileReference\n        ? ItemStatus.PROCESSING_COMPLETE\n        : ItemStatus.INIT,\n\n      // active processes\n      activeLoader: null,\n      activeProcessor: null\n    };\n\n    // callback used when abort processing is called to link back to the resolve method\n    var abortProcessingRequestComplete = null;\n\n    /**\n     * Externally added item metadata\n     */\n    var metadata = {};\n\n    // item data\n    var setStatus = function setStatus(status) {\n      return (state.status = status);\n    };\n\n    // fire event unless the item has been archived\n    var fire = function fire(event) {\n      if (state.released || state.frozen) return;\n      for (\n        var _len = arguments.length,\n          params = new Array(_len > 1 ? _len - 1 : 0),\n          _key = 1;\n        _key < _len;\n        _key++\n      ) {\n        params[_key - 1] = arguments[_key];\n      }\n      api.fire.apply(api, [event].concat(params));\n    };\n\n    // file data\n    var getFileExtension = function getFileExtension() {\n      return getExtensionFromFilename(state.file.name);\n    };\n    var getFileType = function getFileType() {\n      return state.file.type;\n    };\n    var getFileSize = function getFileSize() {\n      return state.file.size;\n    };\n    var getFile = function getFile() {\n      return state.file;\n    };\n\n    //\n    // logic to load a file\n    //\n    var load = function load(source, loader, onload) {\n      // remember the original item source\n      state.source = source;\n\n      // file stub is already there\n      if (state.file) {\n        fire('load-skip');\n        return;\n      }\n\n      // set a stub file object while loading the actual data\n      state.file = createFileStub(source);\n\n      // starts loading\n      loader.on('init', function() {\n        fire('load-init');\n      });\n\n      // we'eve received a size indication, let's update the stub\n      loader.on('meta', function(meta) {\n        // set size of file stub\n        state.file.size = meta.size;\n\n        // set name of file stub\n        state.file.filename = meta.filename;\n\n        // if has received source, we done\n        if (meta.source) {\n          origin = FileOrigin.LIMBO;\n          state.serverFileReference = meta.source;\n          state.status = ItemStatus.PROCESSING_COMPLETE;\n        }\n\n        // size has been updated\n        fire('load-meta');\n      });\n\n      // the file is now loading we need to update the progress indicators\n      loader.on('progress', function(progress) {\n        setStatus(ItemStatus.LOADING);\n\n        fire('load-progress', progress);\n      });\n\n      // an error was thrown while loading the file, we need to switch to error state\n      loader.on('error', function(error) {\n        setStatus(ItemStatus.LOAD_ERROR);\n\n        fire('load-request-error', error);\n      });\n\n      // user or another process aborted the file load (cannot retry)\n      loader.on('abort', function() {\n        setStatus(ItemStatus.INIT);\n        fire('load-abort');\n      });\n\n      // done loading\n      loader.on('load', function(file) {\n        // as we've now loaded the file the loader is no longer required\n        state.activeLoader = null;\n\n        // called when file has loaded succesfully\n        var success = function success(result) {\n          // set (possibly) transformed file\n          state.file = isFile(result) ? result : state.file;\n\n          // file received\n          if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n          } else {\n            setStatus(ItemStatus.IDLE);\n          }\n\n          fire('load');\n        };\n\n        var error = function error(result) {\n          // set original file\n          state.file = file;\n          fire('load-meta');\n\n          setStatus(ItemStatus.LOAD_ERROR);\n          fire('load-file-error', result);\n        };\n\n        // if we already have a server file reference, we don't need to call the onload method\n        if (state.serverFileReference) {\n          success(file);\n          return;\n        }\n\n        // no server id, let's give this file the full treatment\n        onload(file, success, error);\n      });\n\n      // set loader source data\n      loader.setSource(source);\n\n      // set as active loader\n      state.activeLoader = loader;\n\n      // load the source data\n      loader.load();\n    };\n\n    var retryLoad = function retryLoad() {\n      if (!state.activeLoader) {\n        return;\n      }\n      state.activeLoader.load();\n    };\n\n    var abortLoad = function abortLoad() {\n      if (state.activeLoader) {\n        state.activeLoader.abort();\n        return;\n      }\n      setStatus(ItemStatus.INIT);\n      fire('load-abort');\n    };\n\n    //\n    // logic to process a file\n    //\n    var process = function process(processor, onprocess) {\n      // processing was aborted\n      if (state.processingAborted) {\n        state.processingAborted = false;\n        return;\n      }\n\n      // now processing\n      setStatus(ItemStatus.PROCESSING);\n\n      // reset abort callback\n      abortProcessingRequestComplete = null;\n\n      // if no file loaded we'll wait for the load event\n      if (!(state.file instanceof Blob)) {\n        api.on('load', function() {\n          process(processor, onprocess);\n        });\n        return;\n      }\n\n      // setup processor\n      processor.on('load', function(serverFileReference) {\n        // need this id to be able to revert the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n      });\n\n      // register transfer id\n      processor.on('transfer', function(transferId) {\n        // need this id to be able to revert the upload\n        state.transferId = transferId;\n      });\n\n      processor.on('load-perceived', function(serverFileReference) {\n        // no longer required\n        state.activeProcessor = null;\n\n        // need this id to be able to rever the upload\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.PROCESSING_COMPLETE);\n        fire('process-complete', serverFileReference);\n      });\n\n      processor.on('start', function() {\n        fire('process-start');\n      });\n\n      processor.on('error', function(error) {\n        state.activeProcessor = null;\n        setStatus(ItemStatus.PROCESSING_ERROR);\n        fire('process-error', error);\n      });\n\n      processor.on('abort', function(serverFileReference) {\n        state.activeProcessor = null;\n\n        // if file was uploaded but processing was cancelled during perceived processor time store file reference\n        state.transferId = null;\n        state.serverFileReference = serverFileReference;\n\n        setStatus(ItemStatus.IDLE);\n        fire('process-abort');\n\n        // has timeout so doesn't interfere with remove action\n        if (abortProcessingRequestComplete) {\n          abortProcessingRequestComplete();\n        }\n      });\n\n      processor.on('progress', function(progress) {\n        fire('process-progress', progress);\n      });\n\n      // when successfully transformed\n      var success = function success(file) {\n        // if was archived in the mean time, don't process\n        if (state.archived) return;\n\n        // process file!\n        processor.process(file, Object.assign({}, metadata));\n      };\n\n      // something went wrong during transform phase\n      var error = console.error;\n\n      // start processing the file\n      onprocess(state.file, success, error);\n\n      // set as active processor\n      state.activeProcessor = processor;\n    };\n\n    var requestProcessing = function requestProcessing() {\n      state.processingAborted = false;\n      setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n\n    var abortProcessing = function abortProcessing() {\n      return new Promise(function(resolve) {\n        if (!state.activeProcessor) {\n          state.processingAborted = true;\n\n          setStatus(ItemStatus.IDLE);\n          fire('process-abort');\n\n          resolve();\n          return;\n        }\n\n        abortProcessingRequestComplete = function abortProcessingRequestComplete() {\n          resolve();\n        };\n\n        state.activeProcessor.abort();\n      });\n    };\n\n    //\n    // logic to revert a processed file\n    //\n    var revert = function revert(revertFileUpload, forceRevert) {\n      return new Promise(function(resolve, reject) {\n        // cannot revert without a server id for this process\n        if (state.serverFileReference === null) {\n          resolve();\n          return;\n        }\n\n        // revert the upload (fire and forget)\n        revertFileUpload(\n          state.serverFileReference,\n          function() {\n            // reset file server id as now it's no available on the server\n            state.serverFileReference = null;\n            resolve();\n          },\n          function(error) {\n            // don't set error state when reverting is optional, it will always resolve\n            if (!forceRevert) {\n              resolve();\n              return;\n            }\n\n            // oh no errors\n            setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n            fire('process-revert-error');\n            reject(error);\n          }\n        );\n\n        // fire event\n        setStatus(ItemStatus.IDLE);\n        fire('process-revert');\n      });\n    };\n\n    // exposed methods\n    var _setMetadata = function setMetadata(key, value, silent) {\n      var keys = key.split('.');\n      var root = keys[0];\n      var last = keys.pop();\n      var data = metadata;\n      keys.forEach(function(key) {\n        return (data = data[key]);\n      });\n\n      // compare old value against new value, if they're the same, we're not updating\n      if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n      // update value\n      data[last] = value;\n\n      // don't fire update\n      if (silent) return;\n\n      // fire update\n      fire('metadata-update', {\n        key: root,\n        value: metadata[root]\n      });\n    };\n\n    var getMetadata = function getMetadata(key) {\n      return deepCloneObject(key ? metadata[key] : metadata);\n    };\n\n    var api = Object.assign(\n      {\n        id: {\n          get: function get() {\n            return id;\n          }\n        },\n        origin: {\n          get: function get() {\n            return origin;\n          }\n        },\n        serverId: {\n          get: function get() {\n            return state.serverFileReference;\n          }\n        },\n        transferId: {\n          get: function get() {\n            return state.transferId;\n          }\n        },\n        status: {\n          get: function get() {\n            return state.status;\n          }\n        },\n        filename: {\n          get: function get() {\n            return state.file.name;\n          }\n        },\n        filenameWithoutExtension: {\n          get: function get() {\n            return getFilenameWithoutExtension(state.file.name);\n          }\n        },\n        fileExtension: { get: getFileExtension },\n        fileType: { get: getFileType },\n        fileSize: { get: getFileSize },\n        file: { get: getFile },\n\n        source: {\n          get: function get() {\n            return state.source;\n          }\n        },\n\n        getMetadata: getMetadata,\n        setMetadata: function setMetadata(key, value, silent) {\n          if (isObject(key)) {\n            var data = key;\n            Object.keys(data).forEach(function(key) {\n              _setMetadata(key, data[key], value);\n            });\n            return key;\n          }\n          _setMetadata(key, value, silent);\n          return value;\n        },\n\n        extend: function extend(name, handler) {\n          return (itemAPI[name] = handler);\n        },\n\n        abortLoad: abortLoad,\n        retryLoad: retryLoad,\n        requestProcessing: requestProcessing,\n        abortProcessing: abortProcessing,\n\n        load: load,\n        process: process,\n        revert: revert\n      },\n\n      on(),\n      {\n        freeze: function freeze() {\n          return (state.frozen = true);\n        },\n\n        release: function release() {\n          return (state.released = true);\n        },\n        released: {\n          get: function get() {\n            return state.released;\n          }\n        },\n\n        archive: function archive() {\n          return (state.archived = true);\n        },\n        archived: {\n          get: function get() {\n            return state.archived;\n          }\n        }\n      }\n    );\n\n    // create it here instead of returning it instantly so we can extend it later\n    var itemAPI = createObject(api);\n\n    return itemAPI;\n  };\n\n  var getItemIndexByQuery = function getItemIndexByQuery(items, query) {\n    // just return first index\n    if (isEmpty(query)) {\n      return 0;\n    }\n\n    // invalid queries\n    if (!isString(query)) {\n      return -1;\n    }\n\n    // return item by id (or -1 if not found)\n    return items.findIndex(function(item) {\n      return item.id === query;\n    });\n  };\n\n  var getItemById = function getItemById(items, itemId) {\n    var index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n      return;\n    }\n    return items[index] || null;\n  };\n\n  var fetchLocal = function fetchLocal(\n    url,\n    load,\n    error,\n    progress,\n    abort,\n    headers\n  ) {\n    var request = sendRequest(null, url, {\n      method: 'GET',\n      responseType: 'blob'\n    });\n\n    request.onload = function(xhr) {\n      // get headers\n      var headers = xhr.getAllResponseHeaders();\n\n      // get filename\n      var filename =\n        getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n      // create response\n      load(\n        createResponse(\n          'load',\n          xhr.status,\n          getFileFromBlob(xhr.response, filename),\n          headers\n        )\n      );\n    };\n\n    request.onerror = function(xhr) {\n      error(\n        createResponse(\n          'error',\n          xhr.status,\n          xhr.statusText,\n          xhr.getAllResponseHeaders()\n        )\n      );\n    };\n\n    request.onheaders = function(xhr) {\n      headers(\n        createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders())\n      );\n    };\n\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n\n    // should return request\n    return request;\n  };\n\n  var getDomainFromURL = function getDomainFromURL(url) {\n    if (url.indexOf('//') === 0) {\n      url = location.protocol + url;\n    }\n    return url\n      .toLowerCase()\n      .replace('blob:', '')\n      .replace(/([a-z])?:\\/\\//, '$1')\n      .split('/')[0];\n  };\n\n  var isExternalURL = function isExternalURL(url) {\n    return (\n      (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n      getDomainFromURL(location.href) !== getDomainFromURL(url)\n    );\n  };\n\n  var dynamicLabel = function dynamicLabel(label) {\n    return function() {\n      return isFunction(label) ? label.apply(void 0, arguments) : label;\n    };\n  };\n\n  var isMockItem = function isMockItem(item) {\n    return !isFile(item.file);\n  };\n\n  var listUpdated = function listUpdated(dispatch, state) {\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(function() {\n      dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n    }, 0);\n  };\n\n  var optionalPromise = function optionalPromise(fn) {\n    for (\n      var _len = arguments.length,\n        params = new Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      params[_key - 1] = arguments[_key];\n    }\n    return new Promise(function(resolve) {\n      if (!fn) {\n        return resolve(true);\n      }\n\n      var result = fn.apply(void 0, params);\n\n      if (result == null) {\n        return resolve(true);\n      }\n\n      if (typeof result === 'boolean') {\n        return resolve(result);\n      }\n\n      if (typeof result.then === 'function') {\n        result.then(resolve);\n      }\n    });\n  };\n\n  var sortItems = function sortItems(state, compare) {\n    state.items.sort(function(a, b) {\n      return compare(createItemAPI(a), createItemAPI(b));\n    });\n  };\n\n  // returns item based on state\n  var getItemByQueryFromState = function getItemByQueryFromState(\n    state,\n    itemHandler\n  ) {\n    return function() {\n      var _ref =\n          arguments.length > 0 && arguments[0] !== undefined\n            ? arguments[0]\n            : {},\n        query = _ref.query,\n        _ref$success = _ref.success,\n        success = _ref$success === void 0 ? function() {} : _ref$success,\n        _ref$failure = _ref.failure,\n        failure = _ref$failure === void 0 ? function() {} : _ref$failure;\n      var item = getItemByQuery(state.items, query);\n      if (!item) {\n        failure({\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        });\n\n        return;\n      }\n      itemHandler(item, success, failure);\n    };\n  };\n\n  var actions = function actions(dispatch, query, state) {\n    return {\n      /**\n       * Aborts all ongoing processes\n       */\n      ABORT_ALL: function ABORT_ALL() {\n        getActiveItems(state.items).forEach(function(item) {\n          item.freeze();\n          item.abortLoad();\n          item.abortProcessing();\n        });\n      },\n\n      /**\n       * Sets initial files\n       */\n      DID_SET_FILES: function DID_SET_FILES(_ref2) {\n        var _ref2$value = _ref2.value,\n          value = _ref2$value === void 0 ? [] : _ref2$value;\n\n        // map values to file objects\n        var files = value.map(function(file) {\n          return {\n            source: file.source ? file.source : file,\n            options: file.options\n          };\n        });\n\n        // loop over files, if file is in list, leave it be, if not, remove\n        // test if items should be moved\n        var activeItems = getActiveItems(state.items);\n\n        activeItems.forEach(function(item) {\n          // if item not is in new value, remove\n          if (\n            !files.find(function(file) {\n              return file.source === item.source || file.source === item.file;\n            })\n          ) {\n            dispatch('REMOVE_ITEM', { query: item });\n          }\n        });\n\n        // add new files\n        activeItems = getActiveItems(state.items);\n        files.forEach(function(file, index) {\n          // if file is already in list\n          if (\n            activeItems.find(function(item) {\n              return item.source === file.source || item.file === file.source;\n            })\n          )\n            return;\n\n          // not in list, add\n          dispatch(\n            'ADD_ITEM',\n            Object.assign({}, file, {\n              interactionMethod: InteractionMethod.NONE,\n              index: index\n            })\n          );\n        });\n      },\n\n      DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {\n        var id = _ref3.id;\n\n        // if is called multiple times in close succession we combined all calls together to save resources\n        clearTimeout(state.itemUpdateTimeout);\n        state.itemUpdateTimeout = setTimeout(function() {\n          var item = getItemById(state.items, id);\n\n          // only revert and attempt to upload when we're uploading to a server\n          if (!query('IS_ASYNC')) {\n            // should we update the output data\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              if (!shouldPrepareOutput) {\n                return;\n              }\n              dispatch(\n                'REQUEST_PREPARE_OUTPUT',\n                {\n                  query: id,\n                  item: item,\n                  success: function success(file) {\n                    dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                  }\n                },\n                true\n              );\n            });\n\n            return;\n          }\n\n          // for async scenarios\n          var upload = function upload() {\n            // we push this forward a bit so the interface is updated correctly\n            setTimeout(function() {\n              dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n            }, 32);\n          };\n\n          var revert = function revert(doUpload) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(doUpload ? upload : function() {})\n              .catch(function() {});\n          };\n\n          var abort = function abort(doUpload) {\n            item.abortProcessing().then(doUpload ? upload : function() {});\n          };\n\n          // if we should re-upload the file immidiately\n          if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n            return revert(state.options.instantUpload);\n          }\n\n          // if currently uploading, cancel upload\n          if (item.status === ItemStatus.PROCESSING) {\n            return abort(state.options.instantUpload);\n          }\n\n          if (state.options.instantUpload) {\n            upload();\n          }\n        }, 0);\n      },\n\n      SORT: function SORT(_ref4) {\n        var compare = _ref4.compare;\n        sortItems(state, compare);\n      },\n\n      ADD_ITEMS: function ADD_ITEMS(_ref5) {\n        var items = _ref5.items,\n          index = _ref5.index,\n          interactionMethod = _ref5.interactionMethod,\n          _ref5$success = _ref5.success,\n          success = _ref5$success === void 0 ? function() {} : _ref5$success,\n          _ref5$failure = _ref5.failure,\n          failure = _ref5$failure === void 0 ? function() {} : _ref5$failure;\n\n        var currentIndex = index;\n\n        if (index === -1 || typeof index === 'undefined') {\n          var insertLocation = query('GET_ITEM_INSERT_LOCATION');\n          var totalItems = query('GET_TOTAL_ITEMS');\n          currentIndex = insertLocation === 'before' ? 0 : totalItems;\n        }\n\n        var ignoredFiles = query('GET_IGNORED_FILES');\n        var isValidFile = function isValidFile(source) {\n          return isFile(source)\n            ? !ignoredFiles.includes(source.name.toLowerCase())\n            : !isEmpty(source);\n        };\n        var validItems = items.filter(isValidFile);\n\n        var promises = validItems.map(function(source) {\n          return new Promise(function(resolve, reject) {\n            dispatch('ADD_ITEM', {\n              interactionMethod: interactionMethod,\n              source: source.source || source,\n              success: resolve,\n              failure: reject,\n              index: currentIndex++,\n              options: source.options || {}\n            });\n          });\n        });\n\n        Promise.all(promises)\n          .then(success)\n          .catch(failure);\n      },\n\n      /**\n       * @param source\n       * @param index\n       * @param interactionMethod\n       */\n      ADD_ITEM: function ADD_ITEM(_ref6) {\n        var source = _ref6.source,\n          _ref6$index = _ref6.index,\n          index = _ref6$index === void 0 ? -1 : _ref6$index,\n          interactionMethod = _ref6.interactionMethod,\n          _ref6$success = _ref6.success,\n          success = _ref6$success === void 0 ? function() {} : _ref6$success,\n          _ref6$failure = _ref6.failure,\n          failure = _ref6$failure === void 0 ? function() {} : _ref6$failure,\n          _ref6$options = _ref6.options,\n          options = _ref6$options === void 0 ? {} : _ref6$options;\n\n        // if no source supplied\n        if (isEmpty(source)) {\n          failure({\n            error: createResponse('error', 0, 'No source'),\n\n            file: null\n          });\n\n          return;\n        }\n\n        // filter out invalid file items, used to filter dropped directory contents\n        if (\n          isFile(source) &&\n          state.options.ignoredFiles.includes(source.name.toLowerCase())\n        ) {\n          // fail silently\n          return;\n        }\n\n        // test if there's still room in the list of files\n        if (!hasRoomForItem(state)) {\n          // if multiple allowed, we can't replace\n          // or if only a single item is allowed but we're not allowed to replace it we exit\n          if (\n            state.options.allowMultiple ||\n            (!state.options.allowMultiple && !state.options.allowReplace)\n          ) {\n            var error = createResponse('warning', 0, 'Max files');\n\n            dispatch('DID_THROW_MAX_FILES', {\n              source: source,\n              error: error\n            });\n\n            failure({ error: error, file: null });\n\n            return;\n          }\n\n          // let's replace the item\n          // id of first item we're about to remove\n          var _item = getActiveItems(state.items)[0];\n\n          // if has been processed remove it from the server as well\n          if (\n            _item.status === ItemStatus.PROCESSING_COMPLETE ||\n            _item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            var forceRevert = query('GET_FORCE_REVERT');\n            _item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                forceRevert\n              )\n              .then(function() {\n                if (!forceRevert) return;\n\n                // try to add now\n                dispatch('ADD_ITEM', {\n                  source: source,\n                  index: index,\n                  interactionMethod: interactionMethod,\n                  success: success,\n                  failure: failure,\n                  options: options\n                });\n              })\n              .catch(function() {}); // no need to handle this catch state for now\n\n            if (forceRevert) return;\n          }\n\n          // remove first item as it will be replaced by this item\n          dispatch('REMOVE_ITEM', { query: _item.id });\n        }\n\n        // where did the file originate\n        var origin =\n          options.type === 'local'\n            ? FileOrigin.LOCAL\n            : options.type === 'limbo'\n            ? FileOrigin.LIMBO\n            : FileOrigin.INPUT;\n\n        // create a new blank item\n        var item = createItem(\n          // where did this file come from\n          origin,\n\n          // an input file never has a server file reference\n          origin === FileOrigin.INPUT ? null : source,\n\n          // file mock data, if defined\n          options.file\n        );\n\n        // set initial meta data\n        Object.keys(options.metadata || {}).forEach(function(key) {\n          item.setMetadata(key, options.metadata[key]);\n        });\n\n        // created the item, let plugins add methods\n        applyFilters('DID_CREATE_ITEM', item, {\n          query: query,\n          dispatch: dispatch\n        });\n\n        // where to insert new items\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n        // adjust index if is not allowed to pick location\n        if (!state.options.itemInsertLocationFreedom) {\n          index = itemInsertLocation === 'before' ? -1 : state.items.length;\n        }\n\n        // add item to list\n        insertItem(state.items, item, index);\n\n        // sort items in list\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // get a quick reference to the item id\n        var id = item.id;\n\n        // observe item events\n        item.on('load-init', function() {\n          dispatch('DID_START_ITEM_LOAD', { id: id });\n        });\n\n        item.on('load-meta', function() {\n          dispatch('DID_UPDATE_ITEM_META', { id: id });\n        });\n\n        item.on('load-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('load-request-error', function(error) {\n          var mainStatus = dynamicLabel(state.options.labelFileLoadError)(\n            error\n          );\n\n          // is client error, no way to recover\n          if (error.code >= 400 && error.code < 500) {\n            dispatch('DID_THROW_ITEM_INVALID', {\n              id: id,\n              error: error,\n              status: {\n                main: mainStatus,\n                sub: error.code + ' (' + error.body + ')'\n              }\n            });\n\n            // reject the file so can be dealt with through API\n            failure({ error: error, file: createItemAPI(item) });\n            return;\n          }\n\n          // is possible server error, so might be possible to retry\n          dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: mainStatus,\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('load-file-error', function(error) {\n          dispatch('DID_THROW_ITEM_INVALID', {\n            id: id,\n            error: error.status,\n            status: error.status\n          });\n\n          failure({ error: error.status, file: createItemAPI(item) });\n        });\n\n        item.on('load-abort', function() {\n          dispatch('REMOVE_ITEM', { query: id });\n        });\n\n        item.on('load-skip', function() {\n          dispatch('COMPLETE_LOAD_ITEM', {\n            query: id,\n            item: item,\n            data: {\n              source: source,\n              success: success\n            }\n          });\n        });\n\n        item.on('load', function() {\n          var handleAdd = function handleAdd(shouldAdd) {\n            // no should not add this file\n            if (!shouldAdd) {\n              dispatch('REMOVE_ITEM', {\n                query: id\n              });\n\n              return;\n            }\n\n            // now interested in metadata updates\n            item.on('metadata-update', function(change) {\n              dispatch('DID_UPDATE_ITEM_METADATA', { id: id, change: change });\n            });\n\n            // let plugins decide if the output data should be prepared at this point\n            // means we'll do this and wait for idle state\n            applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n              item: item,\n              query: query\n            }).then(function(shouldPrepareOutput) {\n              var loadComplete = function loadComplete() {\n                dispatch('COMPLETE_LOAD_ITEM', {\n                  query: id,\n                  item: item,\n                  data: {\n                    source: source,\n                    success: success\n                  }\n                });\n\n                listUpdated(dispatch, state);\n              };\n\n              // exit\n              if (shouldPrepareOutput) {\n                // wait for idle state and then run PREPARE_OUTPUT\n                dispatch(\n                  'REQUEST_PREPARE_OUTPUT',\n                  {\n                    query: id,\n                    item: item,\n                    success: function success(file) {\n                      dispatch('DID_PREPARE_OUTPUT', { id: id, file: file });\n                      loadComplete();\n                    }\n                  },\n                  true\n                );\n\n                return;\n              }\n\n              loadComplete();\n            });\n          };\n\n          // item loaded, allow plugins to\n          // - read data (quickly)\n          // - add metadata\n          applyFilterChain('DID_LOAD_ITEM', item, {\n            query: query,\n            dispatch: dispatch\n          })\n            .then(function() {\n              optionalPromise(\n                query('GET_BEFORE_ADD_FILE'),\n                createItemAPI(item)\n              ).then(handleAdd);\n            })\n            .catch(function() {\n              handleAdd(false);\n            });\n        });\n\n        item.on('process-start', function() {\n          dispatch('DID_START_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-progress', function(progress) {\n          dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', {\n            id: id,\n            progress: progress\n          });\n        });\n\n        item.on('process-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingError)(error),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-revert-error', function(error) {\n          dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n            id: id,\n            error: error,\n            status: {\n              main: dynamicLabel(state.options.labelFileProcessingRevertError)(\n                error\n              ),\n              sub: state.options.labelTapToRetry\n            }\n          });\n        });\n\n        item.on('process-complete', function(serverFileReference) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: id,\n            error: null,\n            serverFileReference: serverFileReference\n          });\n        });\n\n        item.on('process-abort', function() {\n          dispatch('DID_ABORT_ITEM_PROCESSING', { id: id });\n        });\n\n        item.on('process-revert', function() {\n          dispatch('DID_REVERT_ITEM_PROCESSING', { id: id });\n        });\n\n        // let view know the item has been inserted\n        dispatch('DID_ADD_ITEM', {\n          id: id,\n          index: index,\n          interactionMethod: interactionMethod\n        });\n\n        listUpdated(dispatch, state);\n\n        // start loading the source\n        var _ref7 = state.options.server || {},\n          url = _ref7.url,\n          load = _ref7.load,\n          restore = _ref7.restore,\n          fetch = _ref7.fetch;\n\n        item.load(\n          source,\n\n          // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n          createFileLoader(\n            origin === FileOrigin.INPUT\n              ? // input\n                isString(source) && isExternalURL(source)\n                ? createFetchFunction(url, fetch) // remote url\n                : fetchLocal // local url\n              : // limbo or local\n              origin === FileOrigin.LIMBO\n              ? createFetchFunction(url, restore) // limbo\n              : createFetchFunction(url, load) // local\n          ),\n\n          // called when the file is loaded so it can be piped through the filters\n          function(file, success, error) {\n            // let's process the file\n            applyFilterChain('LOAD_FILE', file, { query: query })\n              .then(success)\n              .catch(error);\n          }\n        );\n      },\n\n      REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref8) {\n        var item = _ref8.item,\n          success = _ref8.success,\n          _ref8$failure = _ref8.failure,\n          failure = _ref8$failure === void 0 ? function() {} : _ref8$failure;\n\n        // error response if item archived\n        var err = {\n          error: createResponse('error', 0, 'Item not found'),\n\n          file: null\n        };\n\n        // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n        if (item.archived) return failure(err);\n\n        // allow plugins to alter the file data\n        applyFilterChain('PREPARE_OUTPUT', item.file, {\n          query: query,\n          item: item\n        }).then(function(result) {\n          applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, {\n            query: query,\n            item: item\n          }).then(function(result) {\n            // don't handle archived items, an item could have been archived (load aborted) while being prepared\n            if (item.archived) return failure(err);\n\n            // we done!\n            success(result);\n          });\n        });\n      },\n\n      COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref9) {\n        var item = _ref9.item,\n          data = _ref9.data;\n        var success = data.success,\n          source = data.source;\n\n        // sort items in list\n        var itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n        if (isFunction(itemInsertLocation) && source) {\n          sortItems(state, itemInsertLocation);\n        }\n\n        // let interface know the item has loaded\n        dispatch('DID_LOAD_ITEM', {\n          id: item.id,\n          error: null,\n          serverFileReference: item.origin === FileOrigin.INPUT ? null : source\n        });\n\n        // item has been successfully loaded and added to the\n        // list of items so can now be safely returned for use\n        success(createItemAPI(item));\n\n        // if this is a local server file we need to show a different state\n        if (item.origin === FileOrigin.LOCAL) {\n          dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n          return;\n        }\n\n        // if is a temp server file we prevent async upload call here (as the file is already on the server)\n        if (item.origin === FileOrigin.LIMBO) {\n          dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n            id: item.id,\n            error: null,\n            serverFileReference: source\n          });\n\n          return;\n        }\n\n        // id we are allowed to upload the file immidiately, lets do it\n        if (query('IS_ASYNC') && state.options.instantUpload) {\n          dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n        }\n      },\n\n      RETRY_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        // try loading the source one more time\n        item.retryLoad();\n      }),\n\n      REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, function(\n        item,\n        _success,\n        failure\n      ) {\n        dispatch(\n          'REQUEST_PREPARE_OUTPUT',\n          {\n            query: item.id,\n            item: item,\n            success: function success(file) {\n              dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n              _success({\n                file: item,\n                output: file\n              });\n            },\n            failure: failure\n          },\n          true\n        );\n      }),\n\n      REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        // cannot be queued (or is already queued)\n        var itemCanBeQueuedForProcessing =\n          // waiting for something\n          item.status === ItemStatus.IDLE ||\n          // processing went wrong earlier\n          item.status === ItemStatus.PROCESSING_ERROR;\n\n        // not ready to be processed\n        if (!itemCanBeQueuedForProcessing) {\n          var process = function process() {\n            setTimeout(function() {\n              dispatch('REQUEST_ITEM_PROCESSING', {\n                query: item,\n                success: success,\n                failure: failure\n              });\n            }, 32);\n          };\n\n          // if already done processing or tried to revert but didn't work, try again\n          if (\n            item.status === ItemStatus.PROCESSING_COMPLETE ||\n            item.status === ItemStatus.PROCESSING_REVERT_ERROR\n          ) {\n            item\n              .revert(\n                createRevertFunction(\n                  state.options.server.url,\n                  state.options.server.revert\n                ),\n                query('GET_FORCE_REVERT')\n              )\n              .then(process)\n              .catch(function() {}); // don't continue with processing if something went wrong\n          } else if (item.status === ItemStatus.PROCESSING) {\n            item.abortProcessing().then(process);\n          }\n\n          return;\n        }\n\n        // already queued for processing\n        if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n        item.requestProcessing();\n\n        dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n        dispatch(\n          'PROCESS_ITEM',\n          { query: item, success: success, failure: failure },\n          true\n        );\n      }),\n\n      PROCESS_ITEM: getItemByQueryFromState(state, function(\n        item,\n        success,\n        failure\n      ) {\n        var maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n        var totalCurrentUploads = query(\n          'GET_ITEMS_BY_STATUS',\n          ItemStatus.PROCESSING\n        ).length;\n\n        // queue and wait till queue is freed up\n        if (totalCurrentUploads === maxParallelUploads) {\n          // queue for later processing\n          state.processingQueue.push({\n            id: item.id,\n            success: success,\n            failure: failure\n          });\n\n          // stop it!\n          return;\n        }\n\n        // if was not queued or is already processing exit here\n        if (item.status === ItemStatus.PROCESSING) return;\n\n        var processNext = function processNext() {\n          // process queueud items\n          var queueEntry = state.processingQueue.shift();\n\n          // no items left\n          if (!queueEntry) return;\n\n          // get item reference\n          var id = queueEntry.id,\n            success = queueEntry.success,\n            failure = queueEntry.failure;\n          var itemReference = getItemByQuery(state.items, id);\n\n          // if item was archived while in queue, jump to next\n          if (!itemReference || itemReference.archived) {\n            processNext();\n            return;\n          }\n\n          // process queued item\n          dispatch(\n            'PROCESS_ITEM',\n            { query: id, success: success, failure: failure },\n            true\n          );\n        };\n\n        // we done function\n        item.onOnce('process-complete', function() {\n          success(createItemAPI(item));\n          processNext();\n\n          // All items processed? No errors?\n          var allItemsProcessed =\n            query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE)\n              .length === state.items.length;\n          if (allItemsProcessed) {\n            dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n          }\n        });\n\n        // we error function\n        item.onOnce('process-error', function(error) {\n          failure({ error: error, file: createItemAPI(item) });\n          processNext();\n        });\n\n        // start file processing\n        var options = state.options;\n        item.process(\n          createFileProcessor(\n            createProcessorFunction(\n              options.server.url,\n              options.server.process,\n              options.name,\n              {\n                chunkTransferId: item.transferId,\n                chunkServer: options.server.patch,\n                chunkUploads: options.chunkUploads,\n                chunkForce: options.chunkForce,\n                chunkSize: options.chunkSize,\n                chunkRetryDelays: options.chunkRetryDelays\n              }\n            )\n          ),\n\n          // called when the file is about to be processed so it can be piped through the transform filters\n          function(file, success, error) {\n            // allow plugins to alter the file data\n            applyFilterChain('PREPARE_OUTPUT', file, {\n              query: query,\n              item: item\n            })\n              .then(function(file) {\n                dispatch('DID_PREPARE_OUTPUT', { id: item.id, file: file });\n\n                success(file);\n              })\n              .catch(error);\n          }\n        );\n      }),\n\n      RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n      }),\n\n      REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, function(item) {\n        optionalPromise(\n          query('GET_BEFORE_REMOVE_FILE'),\n          createItemAPI(item)\n        ).then(function(shouldRemove) {\n          if (!shouldRemove) {\n            return;\n          }\n          dispatch('REMOVE_ITEM', { query: item });\n        });\n      }),\n\n      RELEASE_ITEM: getItemByQueryFromState(state, function(item) {\n        item.release();\n      }),\n\n      REMOVE_ITEM: getItemByQueryFromState(state, function(item, success) {\n        var removeFromView = function removeFromView() {\n          // get id reference\n          var id = item.id;\n\n          // archive the item, this does not remove it from the list\n          getItemById(state.items, id).archive();\n\n          // tell the view the item has been removed\n          dispatch('DID_REMOVE_ITEM', { error: null, id: id, item: item });\n\n          // now the list has been modified\n          listUpdated(dispatch, state);\n\n          // correctly removed\n          success(createItemAPI(item));\n        };\n\n        // if this is a local file and the server.remove function has been configured, send source there so dev can remove file from server\n        var server = state.options.server;\n        if (\n          item.origin === FileOrigin.LOCAL &&\n          server &&\n          isFunction(server.remove)\n        ) {\n          dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n          server.remove(\n            item.source,\n            function() {\n              return removeFromView();\n            },\n            function(status) {\n              dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                id: item.id,\n                error: createResponse('error', 0, status, null),\n                status: {\n                  main: dynamicLabel(state.options.labelFileRemoveError)(\n                    status\n                  ),\n                  sub: state.options.labelTapToRetry\n                }\n              });\n            }\n          );\n        } else {\n          removeFromView();\n        }\n      }),\n\n      ABORT_ITEM_LOAD: getItemByQueryFromState(state, function(item) {\n        item.abortLoad();\n      }),\n\n      ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        // test if is already processed\n        if (item.serverId) {\n          dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n          return;\n        }\n\n        // abort\n        item.abortProcessing().then(function() {\n          var shouldRemove = state.options.instantUpload;\n          if (shouldRemove) {\n            dispatch('REMOVE_ITEM', { query: item.id });\n          }\n        });\n      }),\n\n      REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(\n        item\n      ) {\n        // not instant uploading, revert immidiately\n        if (!state.options.instantUpload) {\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n          return;\n        }\n\n        // if we're instant uploading the file will also be removed if we revert,\n        // so if a before remove file hook is defined we need to run it now\n        var handleRevert = function handleRevert(shouldRevert) {\n          if (!shouldRevert) return;\n          dispatch('REVERT_ITEM_PROCESSING', { query: item });\n        };\n\n        var fn = query('GET_BEFORE_REMOVE_FILE');\n        if (!fn) {\n          return handleRevert(true);\n        }\n\n        var requestRemoveResult = fn(createItemAPI(item));\n        if (requestRemoveResult == null) {\n          // undefined or null\n          return handleRevert(true);\n        }\n\n        if (typeof requestRemoveResult === 'boolean') {\n          return handleRevert(requestRemoveResult);\n        }\n\n        if (typeof requestRemoveResult.then === 'function') {\n          requestRemoveResult.then(handleRevert);\n        }\n      }),\n\n      REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, function(item) {\n        item\n          .revert(\n            createRevertFunction(\n              state.options.server.url,\n              state.options.server.revert\n            ),\n            query('GET_FORCE_REVERT')\n          )\n          .then(function() {\n            var shouldRemove = state.options.instantUpload || isMockItem(item);\n            if (shouldRemove) {\n              dispatch('REMOVE_ITEM', { query: item.id });\n            }\n          })\n          .catch(function() {});\n      }),\n\n      SET_OPTIONS: function SET_OPTIONS(_ref10) {\n        var options = _ref10.options;\n        forin(options, function(key, value) {\n          dispatch('SET_' + fromCamels(key, '_').toUpperCase(), {\n            value: value\n          });\n        });\n      }\n    };\n  };\n\n  var formatFilename = function formatFilename(name) {\n    return name;\n  };\n\n  var createElement$1 = function createElement(tagName) {\n    return document.createElement(tagName);\n  };\n\n  var text = function text(node, value) {\n    var textNode = node.childNodes[0];\n    if (!textNode) {\n      textNode = document.createTextNode(value);\n      node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n      textNode.nodeValue = value;\n    }\n  };\n\n  var polarToCartesian = function polarToCartesian(\n    centerX,\n    centerY,\n    radius,\n    angleInDegrees\n  ) {\n    var angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    };\n  };\n\n  var describeArc = function describeArc(\n    x,\n    y,\n    radius,\n    startAngle,\n    endAngle,\n    arcSweep\n  ) {\n    var start = polarToCartesian(x, y, radius, endAngle);\n    var end = polarToCartesian(x, y, radius, startAngle);\n    return [\n      'M',\n      start.x,\n      start.y,\n      'A',\n      radius,\n      radius,\n      0,\n      arcSweep,\n      0,\n      end.x,\n      end.y\n    ].join(' ');\n  };\n\n  var percentageArc = function percentageArc(x, y, radius, from, to) {\n    var arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n      arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n      arcSweep = 0;\n    }\n    return describeArc(\n      x,\n      y,\n      radius,\n      Math.min(0.9999, from) * 360,\n      Math.min(0.9999, to) * 360,\n      arcSweep\n    );\n  };\n\n  var create = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n\n    // svg\n    var svg = createElement('svg');\n    root.ref.path = createElement('path', {\n      'stroke-width': 2,\n      'stroke-linecap': 'round'\n    });\n\n    svg.appendChild(root.ref.path);\n\n    root.ref.svg = svg;\n\n    root.appendChild(svg);\n  };\n\n  var write = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    if (props.opacity === 0) {\n      return;\n    }\n\n    if (props.align) {\n      root.element.dataset.align = props.align;\n    }\n\n    // get width of stroke\n    var ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n    // calculate size of ring\n    var size = root.rect.element.width * 0.5;\n\n    // ring state\n    var ringFrom = 0;\n    var ringTo = 0;\n\n    // now in busy mode\n    if (props.spin) {\n      ringFrom = 0;\n      ringTo = 0.5;\n    } else {\n      ringFrom = 0;\n      ringTo = props.progress;\n    }\n\n    // get arc path\n    var coordinates = percentageArc(\n      size,\n      size,\n      size - ringStrokeWidth,\n      ringFrom,\n      ringTo\n    );\n\n    // update progress bar\n    attr(root.ref.path, 'd', coordinates);\n\n    // hide while contains 0 value\n    attr(\n      root.ref.path,\n      'stroke-opacity',\n      props.spin || props.progress > 0 ? 1 : 0\n    );\n  };\n\n  var progressIndicator = createView({\n    tag: 'div',\n    name: 'progress-indicator',\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create: create,\n    write: write,\n    mixins: {\n      apis: ['progress', 'spin', 'align'],\n      styles: ['opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 500 },\n        progress: {\n          type: 'spring',\n          stiffness: 0.95,\n          damping: 0.65,\n          mass: 10\n        }\n      }\n    }\n  });\n\n  var create$1 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.innerHTML =\n      (props.icon || '') + ('<span>' + props.label + '</span>');\n\n    props.isDisabled = false;\n  };\n\n  var write$1 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var isDisabled = props.isDisabled;\n    var shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n    if (shouldDisable && !isDisabled) {\n      props.isDisabled = true;\n      attr(root.element, 'disabled', 'disabled');\n    } else if (!shouldDisable && isDisabled) {\n      props.isDisabled = false;\n      root.element.removeAttribute('disabled');\n    }\n  };\n\n  var fileActionButton = createView({\n    tag: 'button',\n    attributes: {\n      type: 'button'\n    },\n\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'file-action-button',\n    mixins: {\n      apis: ['label'],\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      },\n\n      listeners: true\n    },\n\n    create: create$1,\n    write: write$1\n  });\n\n  var toNaturalFileSize = function toNaturalFileSize(bytes) {\n    var decimalSeparator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';\n    // nope, no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n\n    // just bytes\n    if (bytes < 1000) {\n      return bytes + ' bytes';\n    }\n\n    // kilobytes\n    if (bytes < MB) {\n      return Math.floor(bytes / KB) + ' KB';\n    }\n\n    // megabytes\n    if (bytes < GB) {\n      return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + ' MB';\n    }\n\n    // gigabytes\n    return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + ' GB';\n  };\n\n  var KB = 1000;\n  var MB = 1000000;\n  var GB = 1000000000;\n\n  var removeDecimalsWhenZero = function removeDecimalsWhenZero(\n    value,\n    decimalCount,\n    separator\n  ) {\n    return value\n      .toFixed(decimalCount)\n      .split('.')\n      .filter(function(part) {\n        return part !== '0';\n      })\n      .join(separator);\n  };\n\n  var create$2 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // filename\n    var fileName = createElement$1('span');\n    fileName.className = 'filepond--file-info-main';\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, 'aria-hidden', 'true');\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n\n    // filesize\n    var fileSize = createElement$1('span');\n    fileSize.className = 'filepond--file-info-sub';\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n\n    // set initial values\n    text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n    text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n  };\n\n  var updateFile = function updateFile(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    text(\n      root.ref.fileSize,\n      toNaturalFileSize(root.query('GET_ITEM_SIZE', props.id))\n    );\n\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var updateFileSizeOnError = function updateFileSizeOnError(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props;\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n      return;\n    }\n\n    text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n  };\n\n  var fileInfo = createView({\n    name: 'file-info',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: updateFile,\n      DID_UPDATE_ITEM_META: updateFile,\n      DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n      DID_THROW_ITEM_INVALID: updateFileSizeOnError\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$2,\n    mixins: {\n      styles: ['translateX', 'translateY'],\n      animations: {\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var toPercentage = function toPercentage(value) {\n    return Math.round(value * 100);\n  };\n\n  var create$3 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    // main status\n    var main = createElement$1('span');\n    main.className = 'filepond--file-status-main';\n    root.appendChild(main);\n    root.ref.main = main;\n\n    // sub status\n    var sub = createElement$1('span');\n    sub.className = 'filepond--file-status-sub';\n    root.appendChild(sub);\n    root.ref.sub = sub;\n\n    didSetItemLoadProgress({ root: root, action: { progress: null } });\n  };\n\n  var didSetItemLoadProgress = function didSetItemLoadProgress(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_LOADING')\n        : root.query('GET_LABEL_FILE_LOADING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didSetItemProcessProgress = function didSetItemProcessProgress(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var title =\n      action.progress === null\n        ? root.query('GET_LABEL_FILE_PROCESSING')\n        : root.query('GET_LABEL_FILE_PROCESSING') +\n          ' ' +\n          toPercentage(action.progress) +\n          '%';\n\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didRequestItemProcessing = function didRequestItemProcessing(_ref4) {\n    var root = _ref4.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n  };\n\n  var didAbortItemProcessing = function didAbortItemProcessing(_ref5) {\n    var root = _ref5.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n  };\n\n  var didCompleteItemProcessing = function didCompleteItemProcessing(_ref6) {\n    var root = _ref6.root;\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n  };\n\n  var clear = function clear(_ref7) {\n    var root = _ref7.root;\n    text(root.ref.main, '');\n    text(root.ref.sub, '');\n  };\n\n  var error = function error(_ref8) {\n    var root = _ref8.root,\n      action = _ref8.action;\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n  };\n\n  var fileStatus = createView({\n    name: 'file-status',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: clear,\n      DID_REVERT_ITEM_PROCESSING: clear,\n      DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n      DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n      DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n      DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n      DID_THROW_ITEM_LOAD_ERROR: error,\n      DID_THROW_ITEM_INVALID: error,\n      DID_THROW_ITEM_PROCESSING_ERROR: error,\n      DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n      DID_THROW_ITEM_REMOVE_ERROR: error\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    create: create$3,\n    mixins: {\n      styles: ['translateX', 'translateY', 'opacity'],\n      animations: {\n        opacity: { type: 'tween', duration: 250 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  /**\n   * Button definitions for the file view\n   */\n\n  var Buttons = {\n    AbortItemLoad: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n      action: 'ABORT_ITEM_LOAD',\n      className: 'filepond--action-abort-item-load',\n      align: 'LOAD_INDICATOR_POSITION' // right\n    },\n    RetryItemLoad: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n      action: 'RETRY_ITEM_LOAD',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-load',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RemoveItem: {\n      label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n      action: 'REQUEST_REMOVE_ITEM',\n      icon: 'GET_ICON_REMOVE',\n      className: 'filepond--action-remove-item',\n      align: 'BUTTON_REMOVE_ITEM_POSITION' // left\n    },\n    ProcessItem: {\n      label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n      action: 'REQUEST_ITEM_PROCESSING',\n      icon: 'GET_ICON_PROCESS',\n      className: 'filepond--action-process-item',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    AbortItemProcessing: {\n      label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n      action: 'ABORT_ITEM_PROCESSING',\n      className: 'filepond--action-abort-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RetryItemProcessing: {\n      label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n      action: 'RETRY_ITEM_PROCESSING',\n      icon: 'GET_ICON_RETRY',\n      className: 'filepond--action-retry-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    },\n    RevertItemProcessing: {\n      label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n      action: 'REQUEST_REVERT_ITEM_PROCESSING',\n      icon: 'GET_ICON_UNDO',\n      className: 'filepond--action-revert-item-processing',\n      align: 'BUTTON_PROCESS_ITEM_POSITION' // right\n    }\n  };\n\n  // make a list of buttons, we can then remove buttons from this list if they're disabled\n  var ButtonKeys = [];\n  forin(Buttons, function(key) {\n    ButtonKeys.push(key);\n  });\n\n  var calculateFileInfoOffset = function calculateFileInfoOffset(root) {\n    var buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n  };\n\n  // Force on full pixels so text stays crips\n  var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\n  };\n  var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset(\n    root\n  ) {\n    return Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n  };\n\n  var getLoadIndicatorAlignment = function getLoadIndicatorAlignment(root) {\n    return root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\n  };\n  var getProcessIndicatorAlignment = function getProcessIndicatorAlignment(\n    root\n  ) {\n    return root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\n  };\n  var getRemoveIndicatorAligment = function getRemoveIndicatorAligment(root) {\n    return root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n  };\n\n  var DefaultStyle = {\n    buttonAbortItemLoad: { opacity: 0 },\n    buttonRetryItemLoad: { opacity: 0 },\n    buttonRemoveItem: { opacity: 0 },\n    buttonProcessItem: { opacity: 0 },\n    buttonAbortItemProcessing: { opacity: 0 },\n    buttonRetryItemProcessing: { opacity: 0 },\n    buttonRevertItemProcessing: { opacity: 0 },\n    loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n    processProgressIndicator: {\n      opacity: 0,\n      align: getProcessIndicatorAlignment\n    },\n    processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n    info: { translateX: 0, translateY: 0, opacity: 0 },\n    status: { translateX: 0, translateY: 0, opacity: 0 }\n  };\n\n  var IdleStyle = {\n    buttonRemoveItem: { opacity: 1 },\n    buttonProcessItem: { opacity: 1 },\n    info: { translateX: calculateFileInfoOffset },\n    status: { translateX: calculateFileInfoOffset }\n  };\n\n  var ProcessingStyle = {\n    buttonAbortItemProcessing: { opacity: 1 },\n    processProgressIndicator: { opacity: 1 },\n    status: { opacity: 1 }\n  };\n\n  var StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset, opacity: 1 }\n    },\n\n    DID_START_ITEM_LOAD: {\n      buttonAbortItemLoad: { opacity: 1 },\n      loadProgressIndicator: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_LOAD_ERROR: {\n      buttonRetryItemLoad: { opacity: 1 },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_START_ITEM_REMOVE: {\n      processProgressIndicator: {\n        opacity: 1,\n        align: getRemoveIndicatorAligment\n      },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 0 }\n    },\n\n    DID_THROW_ITEM_REMOVE_ERROR: {\n      processProgressIndicator: {\n        opacity: 0,\n        align: getRemoveIndicatorAligment\n      },\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1, translateX: calculateFileInfoOffset }\n    },\n\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n      buttonRemoveItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      info: { opacity: 1 },\n      status: { opacity: 1 }\n    },\n\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonRetryItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset }\n    },\n\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n      buttonRevertItemProcessing: { opacity: 1 },\n      status: { opacity: 1 },\n      info: { opacity: 1 }\n    },\n\n    DID_ABORT_ITEM_PROCESSING: {\n      buttonRemoveItem: { opacity: 1 },\n      buttonProcessItem: { opacity: 1 },\n      info: { translateX: calculateFileInfoOffset },\n      status: { opacity: 1 }\n    },\n\n    DID_REVERT_ITEM_PROCESSING: IdleStyle\n  };\n\n  // complete indicator view\n  var processingCompleteIndicatorView = createView({\n    create: function create(_ref) {\n      var root = _ref.root;\n      root.element.innerHTML = root.query('GET_ICON_DONE');\n    },\n    name: 'processing-complete-indicator',\n    ignoreRect: true,\n    mixins: {\n      styles: ['scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$4 = function create(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n    var id = props.id;\n\n    // allow reverting upload\n    var allowRevert = root.query('GET_ALLOW_REVERT');\n\n    // is instant uploading, need this to determine the icon of the undo button\n    var instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n    // is async set up\n    var isAsync = root.query('IS_ASYNC');\n\n    // enabled buttons array\n    var enabledButtons = isAsync\n      ? ButtonKeys.concat()\n      : ButtonKeys.filter(function(key) {\n          return !/Process/.test(key);\n        });\n\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n      enabledButtons.splice(-1, 1);\n      var map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n      map.info.translateX = calculateFileHorizontalCenterOffset;\n      map.info.translateY = calculateFileVerticalCenterOffset;\n      map.status.translateY = calculateFileVerticalCenterOffset;\n      map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n      Buttons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n      Buttons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n    }\n\n    // create the button views\n    forin(Buttons, function(key, definition) {\n      // create button\n      var buttonView = root.createChildView(fileActionButton, {\n        label: root.query(definition.label),\n        icon: root.query(definition.icon),\n        opacity: 0\n      });\n\n      // should be appended?\n      if (enabledButtons.includes(key)) {\n        root.appendChildView(buttonView);\n      }\n\n      // add position attribute\n      buttonView.element.dataset.align = root.query(\n        'GET_STYLE_' + definition.align\n      );\n\n      // add class\n      buttonView.element.classList.add(definition.className);\n\n      // handle interactions\n      buttonView.on('click', function(e) {\n        e.stopPropagation();\n        root.dispatch(definition.action, { query: id });\n      });\n\n      // set reference\n      root.ref['button' + key] = buttonView;\n    });\n\n    // create file info view\n    root.ref.info = root.appendChildView(\n      root.createChildView(fileInfo, { id: id })\n    );\n\n    // create file status view\n    root.ref.status = root.appendChildView(\n      root.createChildView(fileStatus, { id: id })\n    );\n\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(\n      root.createChildView(processingCompleteIndicatorView)\n    );\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n      'GET_STYLE_BUTTON_PROCESS_ITEM_POSITION'\n    );\n\n    // add progress indicators\n    var loadIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_LOAD_INDICATOR_POSITION')\n      })\n    );\n\n    loadIndicatorView.element.classList.add('filepond--load-indicator');\n    root.ref.loadProgressIndicator = loadIndicatorView;\n\n    var progressIndicatorView = root.appendChildView(\n      root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION')\n      })\n    );\n\n    progressIndicatorView.element.classList.add('filepond--process-indicator');\n    root.ref.processProgressIndicator = progressIndicatorView;\n\n    // current active styles\n    root.ref.activeStyles = [];\n  };\n\n  var write$2 = function write(_ref3) {\n    var root = _ref3.root,\n      actions = _ref3.actions,\n      props = _ref3.props;\n\n    // route actions\n    route({ root: root, actions: actions, props: props });\n\n    // select last state change action\n    var action = actions\n      .concat()\n      .filter(function(action) {\n        return /^DID_/.test(action.type);\n      })\n      .reverse()\n      .find(function(action) {\n        return StyleMap[action.type];\n      });\n\n    // a new action happened, let's get the matching styles\n    if (action) {\n      // define new active styles\n      root.ref.activeStyles = [];\n\n      var stylesToApply = StyleMap[action.type];\n      forin(DefaultStyle, function(name, defaultStyles) {\n        // get reference to control\n        var control = root.ref[name];\n\n        // loop over all styles for this control\n        forin(defaultStyles, function(key, defaultValue) {\n          var value =\n            stylesToApply[name] &&\n            typeof stylesToApply[name][key] !== 'undefined'\n              ? stylesToApply[name][key]\n              : defaultValue;\n          root.ref.activeStyles.push({\n            control: control,\n            key: key,\n            value: value\n          });\n        });\n      });\n    }\n\n    // apply active styles to element\n    root.ref.activeStyles.forEach(function(_ref4) {\n      var control = _ref4.control,\n        key = _ref4.key,\n        value = _ref4.value;\n\n      control[key] = typeof value === 'function' ? value(root) : value;\n    });\n  };\n\n  var route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(\n      _ref5\n    ) {\n      var root = _ref5.root,\n        action = _ref5.action;\n      root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(\n      _ref6\n    ) {\n      var root = _ref6.root,\n        action = _ref6.action;\n      root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(\n      _ref7\n    ) {\n      var root = _ref7.root,\n        action = _ref7.action;\n      root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {\n      var root = _ref8.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {\n      var root = _ref9.root;\n      root.ref.loadProgressIndicator.spin = true;\n      root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {\n      var root = _ref10.root;\n      root.ref.processProgressIndicator.spin = true;\n      root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(\n      _ref11\n    ) {\n      var root = _ref11.root,\n        action = _ref11.action;\n      root.ref.loadProgressIndicator.spin = false;\n      root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(\n      _ref12\n    ) {\n      var root = _ref12.root,\n        action = _ref12.action;\n      root.ref.processProgressIndicator.spin = false;\n      root.ref.processProgressIndicator.progress = action.progress;\n    }\n  });\n\n  var file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    name: 'file'\n  });\n\n  /**\n   * Creates the file view\n   */\n  var create$5 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // filename\n    root.ref.fileName = createElement$1('legend');\n    root.appendChild(root.ref.fileName);\n\n    // file appended\n    root.ref.file = root.appendChildView(\n      root.createChildView(file, { id: props.id })\n    );\n\n    // create data container\n    var dataContainer = createElement$1('input');\n    dataContainer.type = 'hidden';\n    dataContainer.name = root.query('GET_NAME');\n    dataContainer.disabled = root.query('GET_DISABLED');\n    root.ref.data = dataContainer;\n    root.appendChild(dataContainer);\n  };\n\n  var didSetDisabled = function didSetDisabled(_ref2) {\n    var root = _ref2.root;\n    root.ref.data.disabled = root.query('GET_DISABLED');\n  };\n\n  /**\n   * Data storage\n   */\n  var didLoadItem = function didLoadItem(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action,\n      props = _ref3.props;\n    root.ref.data.value = action.serverFileReference;\n\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(\n      root.ref.fileName,\n      formatFilename(root.query('GET_ITEM_NAME', props.id))\n    );\n  };\n\n  var didRemoveItem = function didRemoveItem(_ref4) {\n    var root = _ref4.root;\n    root.ref.data.removeAttribute('value');\n  };\n\n  var didCompleteItemProcessing$1 = function didCompleteItemProcessing(_ref5) {\n    var root = _ref5.root,\n      action = _ref5.action;\n    root.ref.data.value = action.serverFileReference;\n  };\n\n  var didRevertItemProcessing = function didRevertItemProcessing(_ref6) {\n    var root = _ref6.root;\n    root.ref.data.removeAttribute('value');\n  };\n\n  var fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n      DID_SET_DISABLED: didSetDisabled,\n      DID_LOAD_ITEM: didLoadItem,\n      DID_REMOVE_ITEM: didRemoveItem,\n      DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing$1,\n      DID_REVERT_ITEM_PROCESSING: didRevertItemProcessing\n    }),\n\n    didCreateView: function didCreateView(root) {\n      applyFilters('CREATE_VIEW', Object.assign({}, root, { view: root }));\n    },\n    tag: 'fieldset',\n    name: 'file-wrapper'\n  });\n\n  var PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\n  var create$6 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    [\n      {\n        name: 'top'\n      },\n\n      {\n        name: 'center',\n        props: {\n          translateY: null,\n          scaleY: null\n        },\n\n        mixins: {\n          animations: {\n            scaleY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY', 'scaleY']\n        }\n      },\n\n      {\n        name: 'bottom',\n        props: {\n          translateY: null\n        },\n\n        mixins: {\n          animations: {\n            translateY: PANEL_SPRING_PROPS\n          },\n\n          styles: ['translateY']\n        }\n      }\n    ].forEach(function(section) {\n      createSection(root, section, props.name);\n    });\n\n    root.element.classList.add('filepond--' + props.name);\n\n    root.ref.scalable = null;\n  };\n\n  var createSection = function createSection(root, section, className) {\n    var viewConstructor = createView({\n      name: 'panel-' + section.name + ' filepond--' + className,\n      mixins: section.mixins,\n      ignoreRectUpdate: true\n    });\n\n    var view = root.createChildView(viewConstructor, section.props);\n\n    root.ref[section.name] = root.appendChildView(view);\n  };\n\n  var write$3 = function write(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props;\n\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n      root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n      root.element.dataset.scalable = root.ref.scalable;\n    }\n\n    // no height, can't set\n    if (!props.height) return;\n\n    // get child rects\n    var topRect = root.ref.top.rect.element;\n    var bottomRect = root.ref.bottom.rect.element;\n\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    var height = Math.max(topRect.height + bottomRect.height, props.height);\n\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY =\n      (height - topRect.height - bottomRect.height) / 100;\n\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n  };\n\n  var panel = createView({\n    name: 'panel',\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n      apis: ['height', 'scalable']\n    }\n  });\n\n  var ITEM_TRANSLATE_SPRING = {\n    type: 'spring',\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10\n  };\n\n  var ITEM_SCALE_SPRING = 'spring';\n\n  /**\n   * Creates the file view\n   */\n  var create$7 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // select\n    root.ref.handleClick = function() {\n      return root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n    };\n\n    // set id\n    root.element.id = 'filepond--item-' + props.id;\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // file view\n    root.ref.container = root.appendChildView(\n      root.createChildView(fileWrapper, { id: props.id })\n    );\n\n    // file panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'item-panel' })\n    );\n\n    // default start height\n    root.ref.panel.height = null;\n\n    // by default not marked for removal\n    props.markedForRemoval = false;\n  };\n\n  var StateMap = {\n    DID_START_ITEM_LOAD: 'busy',\n    DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n    DID_THROW_ITEM_INVALID: 'load-invalid',\n    DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n    DID_LOAD_ITEM: 'idle',\n    DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n    DID_START_ITEM_REMOVE: 'busy',\n    DID_START_ITEM_PROCESSING: 'busy',\n    DID_REQUEST_ITEM_PROCESSING: 'busy',\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n    DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n    DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n    DID_ABORT_ITEM_PROCESSING: 'cancelled',\n    DID_REVERT_ITEM_PROCESSING: 'idle'\n  };\n\n  var route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {\n      var root = _ref2.root,\n        action = _ref2.action;\n      var height = action.height;\n      root.height = height;\n    }\n  });\n\n  var write$4 = function write(_ref3) {\n    var root = _ref3.root,\n      actions = _ref3.actions,\n      props = _ref3.props,\n      shouldOptimize = _ref3.shouldOptimize;\n\n    // select last state change action\n    var action = actions\n      .concat()\n      .filter(function(action) {\n        return /^DID_/.test(action.type);\n      })\n      .reverse()\n      .find(function(action) {\n        return StateMap[action.type];\n      });\n\n    // no need to set same state twice\n    if (action && action.type !== props.currentState) {\n      // set current state\n      props.currentState = action.type;\n\n      // set state\n      root.element.dataset.filepondItemState =\n        StateMap[props.currentState] || '';\n    }\n\n    // route actions\n    var aspectRatio =\n      root.query('GET_ITEM_PANEL_ASPECT_RATIO') ||\n      root.query('GET_PANEL_ASPECT_RATIO');\n    if (!aspectRatio) {\n      route$1({ root: root, actions: actions, props: props });\n      if (!root.height && root.ref.container.rect.element.height > 0) {\n        root.height = root.ref.container.rect.element.height;\n      }\n    } else if (!shouldOptimize) {\n      root.height = root.rect.element.width * aspectRatio;\n    }\n\n    // sync panel height with item height\n    if (shouldOptimize) {\n      root.ref.panel.height = null;\n    }\n\n    root.ref.panel.height = root.height;\n  };\n\n  var item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: function destroy(_ref4) {\n      var root = _ref4.root,\n        props = _ref4.props;\n      root.element.removeEventListener('click', root.ref.handleClick);\n      root.dispatch('RELEASE_ITEM', { query: props.id });\n    },\n    tag: 'li',\n    name: 'item',\n    mixins: {\n      apis: ['id', 'interactionMethod', 'markedForRemoval', 'spawnDate'],\n      styles: [\n        'translateX',\n        'translateY',\n        'scaleX',\n        'scaleY',\n        'opacity',\n        'height'\n      ],\n\n      animations: {\n        scaleX: ITEM_SCALE_SPRING,\n        scaleY: ITEM_SCALE_SPRING,\n        translateX: ITEM_TRANSLATE_SPRING,\n        translateY: ITEM_TRANSLATE_SPRING,\n        opacity: { type: 'tween', duration: 150 }\n      }\n    }\n  });\n\n  var getItemIndexByPosition = function getItemIndexByPosition(\n    view,\n    positionInView\n  ) {\n    if (!positionInView) return;\n\n    var horizontalSpace = view.rect.element.width;\n    var children = view.childViews;\n    var l = children.length;\n    var last = null;\n\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n    // let's get the item width\n    var item = children[0];\n    var itemRect = item.rect.element;\n    var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    var itemWidth = itemRect.width + itemHorizontalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      for (var index = 0; index < l; index++) {\n        var child = children[index];\n        var childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n        if (positionInView.top < childMid) {\n          return index;\n        }\n      }\n      return l;\n    }\n\n    // grid\n    var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    var itemHeight = itemRect.height + itemVerticalMargin;\n    for (var _index = 0; _index < l; _index++) {\n      var indexX = _index % itemsPerRow;\n      var indexY = Math.floor(_index / itemsPerRow);\n\n      var offsetX = indexX * itemWidth;\n      var offsetY = indexY * itemHeight;\n\n      var itemTop = offsetY - itemRect.marginTop;\n      var itemRight = offsetX + itemWidth;\n      var itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n      if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n        if (positionInView.left < itemRight) {\n          return _index;\n        } else if (_index !== l - 1) {\n          last = _index;\n        } else {\n          last = null;\n        }\n      }\n    }\n\n    if (last !== null) {\n      return last;\n    }\n\n    return l;\n  };\n\n  var create$8 = function create(_ref) {\n    var root = _ref.root;\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, 'role', 'list');\n\n    root.ref.lastItemSpanwDate = Date.now();\n  };\n\n  /**\n   * Inserts a new item\n   * @param root\n   * @param action\n   */\n  var addItemView = function addItemView(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    var id = action.id,\n      index = action.index,\n      interactionMethod = action.interactionMethod;\n\n    root.ref.addIndex = index;\n\n    var now = Date.now();\n    var spawnDate = now;\n    var opacity = 1;\n\n    if (interactionMethod !== InteractionMethod.NONE) {\n      opacity = 0;\n      var cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n      var dist = now - root.ref.lastItemSpanwDate;\n      spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n\n    root.ref.lastItemSpanwDate = spawnDate;\n\n    root.appendChildView(\n      root.createChildView(\n        // view type\n        item,\n\n        // props\n        {\n          spawnDate: spawnDate,\n          id: id,\n          opacity: opacity,\n          interactionMethod: interactionMethod\n        }\n      ),\n\n      index\n    );\n  };\n\n  var moveItem = function moveItem(item, x, y) {\n    var vx =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var vy =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n\n    item.translateX = x;\n    item.translateY = y;\n\n    if (Date.now() > item.spawnDate) {\n      // reveal element\n      if (item.opacity === 0) {\n        introItemView(item, x, y, vx, vy);\n      }\n\n      // make sure is default scale every frame\n      item.scaleX = 1;\n      item.scaleY = 1;\n      item.opacity = 1;\n    }\n  };\n\n  var introItemView = function introItemView(item, x, y, vx, vy) {\n    if (item.interactionMethod === InteractionMethod.NONE) {\n      item.translateX = null;\n      item.translateX = x;\n      item.translateY = null;\n      item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n      item.translateX = null;\n      item.translateX = x - vx * 20;\n\n      item.translateY = null;\n      item.translateY = y - vy * 10;\n\n      item.scaleX = 0.8;\n      item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n      item.translateY = null;\n      item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n      item.translateX = null;\n      item.translateX = x - 30;\n      item.translateY = null;\n    }\n  };\n\n  /**\n   * Removes an existing item\n   * @param root\n   * @param action\n   */\n  var removeItemView = function removeItemView(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    var id = action.id;\n\n    // get the view matching the given id\n    var view = root.childViews.find(function(child) {\n      return child.id === id;\n    });\n\n    // if no view found, exit\n    if (!view) {\n      return;\n    }\n\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n\n    // mark for removal\n    view.markedForRemoval = true;\n  };\n\n  /**\n   * Setup action routes\n   */\n  var route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView\n  });\n\n  /**\n   * Write to view\n   * @param root\n   * @param actions\n   * @param props\n   */\n  var write$5 = function write(_ref4) {\n    var root = _ref4.root,\n      props = _ref4.props,\n      actions = _ref4.actions,\n      shouldOptimize = _ref4.shouldOptimize;\n\n    // route actions\n    route$2({ root: root, props: props, actions: actions });\n    var dragCoordinates = props.dragCoordinates;\n\n    // get index\n    var dragIndex = dragCoordinates\n      ? getItemIndexByPosition(root, dragCoordinates)\n      : null;\n\n    // available space on horizontal axis\n    var horizontalSpace = root.rect.element.width;\n\n    // only draw children that have dimensions\n    var visibleChildren = root.childViews.filter(function(child) {\n      return child.rect.element.height;\n    });\n\n    // sort based on current active items\n    var children = root\n      .query('GET_ACTIVE_ITEMS')\n      .map(function(item) {\n        return visibleChildren.find(function(child) {\n          return child.id === item.id;\n        });\n      })\n      .filter(function(item) {\n        return item;\n      });\n\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    var addIndex = root.ref.addIndex || null;\n\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n\n    var dragIndexOffset = 0;\n    var removeIndexOffset = 0;\n    var addIndexOffset = 0;\n\n    if (children.length === 0) return;\n\n    var childRect = children[0].rect.element;\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      var offsetY = 0;\n      var dragOffset = 0;\n\n      children.forEach(function(child, index) {\n        if (dragIndex) {\n          var dist = index - dragIndex;\n          if (dist === -2) {\n            dragOffset = -itemVerticalMargin * 0.25;\n          } else if (dist === -1) {\n            dragOffset = -itemVerticalMargin * 0.75;\n          } else if (dist === 0) {\n            dragOffset = itemVerticalMargin * 0.75;\n          } else if (dist === 1) {\n            dragOffset = itemVerticalMargin * 0.25;\n          } else {\n            dragOffset = 0;\n          }\n        }\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        if (!child.markedForRemoval) {\n          moveItem(child, 0, offsetY + dragOffset);\n        }\n\n        var itemHeight = child.rect.element.height + itemVerticalMargin;\n\n        var visualHeight =\n          itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n        offsetY += visualHeight;\n      });\n    }\n    // grid\n    else {\n      var prevX = 0;\n      var prevY = 0;\n\n      children.forEach(function(child, index) {\n        if (index === dragIndex) {\n          dragIndexOffset = 1;\n        }\n\n        if (index === addIndex) {\n          addIndexOffset += 1;\n        }\n\n        if (child.markedForRemoval && child.opacity < 0.5) {\n          removeIndexOffset -= 1;\n        }\n\n        var visualIndex =\n          index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n        var indexX = visualIndex % itemsPerRow;\n        var indexY = Math.floor(visualIndex / itemsPerRow);\n\n        var offsetX = indexX * itemWidth;\n        var offsetY = indexY * itemHeight;\n\n        var vectorX = Math.sign(offsetX - prevX);\n        var vectorY = Math.sign(offsetY - prevY);\n\n        prevX = offsetX;\n        prevY = offsetY;\n\n        if (child.markedForRemoval) return;\n\n        if (shouldOptimize) {\n          child.translateX = null;\n          child.translateY = null;\n        }\n\n        moveItem(child, offsetX, offsetY, vectorX, vectorY);\n      });\n    }\n  };\n\n  /**\n   * Filters actions that are meant specifically for a certain child of the list\n   * @param child\n   * @param actions\n   */\n  var filterSetItemActions = function filterSetItemActions(child, actions) {\n    return actions.filter(function(action) {\n      // if action has an id, filter out actions that don't have this child id\n      if (action.data && action.data.id) {\n        return child.id === action.data.id;\n      }\n\n      // allow all other actions\n      return true;\n    });\n  };\n\n  var list = createView({\n    create: create$8,\n    write: write$5,\n    tag: 'ul',\n    name: 'list',\n    didWriteView: function didWriteView(_ref5) {\n      var root = _ref5.root;\n      root.childViews\n        .filter(function(view) {\n          return view.markedForRemoval && view.opacity === 0 && view.resting;\n        })\n        .forEach(function(view) {\n          view._destroy();\n          root.removeChildView(view);\n        });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n      apis: ['dragCoordinates']\n    }\n  });\n\n  var create$9 = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n  };\n\n  var storeDragCoordinates = function storeDragCoordinates(_ref2) {\n    var root = _ref2.root,\n      props = _ref2.props,\n      action = _ref2.action;\n    if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n    props.dragCoordinates = {\n      left: action.position.scopeLeft - root.ref.list.rect.element.left,\n      top:\n        action.position.scopeTop -\n        (root.rect.outer.top +\n          root.rect.element.marginTop +\n          root.rect.element.scrollTop)\n    };\n  };\n\n  var clearDragCoordinates = function clearDragCoordinates(_ref3) {\n    var props = _ref3.props;\n    props.dragCoordinates = null;\n  };\n\n  var route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates\n  });\n\n  var write$6 = function write(_ref4) {\n    var root = _ref4.root,\n      props = _ref4.props,\n      actions = _ref4.actions;\n\n    // route actions\n    route$3({ root: root, props: props, actions: actions });\n\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n      props.overflowing = false;\n\n      // reset overflow state\n      root.element.dataset.state = '';\n      root.height = null;\n    }\n\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n      var newHeight = Math.round(props.overflow);\n      if (newHeight !== root.height) {\n        props.overflowing = true;\n        root.element.dataset.state = 'overflow';\n        root.height = newHeight;\n      }\n    }\n  };\n\n  var listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: 'list-scroller',\n    mixins: {\n      apis: ['overflow', 'dragCoordinates'],\n      styles: ['height', 'translateY'],\n      animations: {\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var attrToggle = function attrToggle(element, name, state) {\n    var enabledValue =\n      arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    if (state) {\n      attr(element, name, enabledValue);\n    } else {\n      element.removeAttribute(name);\n    }\n  };\n\n  var resetFileInput = function resetFileInput(input) {\n    // no value, no need to reset\n    if (!input || input.value === '') {\n      return;\n    }\n\n    try {\n      // for modern browsers\n      input.value = '';\n    } catch (err) {}\n\n    // for IE10\n    if (input.value) {\n      // quickly append input to temp form and reset form\n      var form = createElement$1('form');\n      var parentNode = input.parentNode;\n      var ref = input.nextSibling;\n      form.appendChild(input);\n      form.reset();\n\n      // re-inject input where it originally was\n      if (ref) {\n        parentNode.insertBefore(input, ref);\n      } else {\n        parentNode.appendChild(input);\n      }\n    }\n  };\n\n  var create$a = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // set id so can be referenced from outside labels\n    root.element.id = 'filepond--browser-' + props.id;\n\n    // set name of element (is removed when a value is set)\n    attr(root.element, 'name', root.query('GET_NAME'));\n\n    // we have to link this element to the status element\n    attr(root.element, 'aria-controls', 'filepond--assistant-' + props.id);\n\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, 'aria-labelledby', 'filepond--drop-label-' + props.id);\n\n    // handle changes to the input field\n    root.ref.handleChange = function(e) {\n      if (!root.element.value) {\n        return;\n      }\n\n      // extract files\n      var files = Array.from(root.element.files);\n\n      // we add a little delay so the OS file select window can move out of the way before we add our file\n      setTimeout(function() {\n        // load files\n        props.onload(files);\n\n        // reset input, it's just for exposing a method to drop files, should not retain any state\n        resetFileInput(root.element);\n      }, 250);\n    };\n    root.element.addEventListener('change', root.ref.handleChange);\n  };\n\n  var setAcceptedFileTypes = function setAcceptedFileTypes(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    attrToggle(\n      root.element,\n      'accept',\n      !!action.value,\n      action.value ? action.value.join(',') : ''\n    );\n  };\n\n  var toggleAllowMultiple = function toggleAllowMultiple(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    attrToggle(root.element, 'multiple', action.value);\n  };\n\n  var toggleDisabled = function toggleDisabled(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    var isDisabled = root.query('GET_DISABLED');\n    var doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n    var disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, 'disabled', disableField);\n  };\n\n  var toggleRequired = function toggleRequired(_ref5) {\n    var root = _ref5.root,\n      action = _ref5.action;\n    // want to remove required, always possible\n    if (!action.value) {\n      attrToggle(root.element, 'required', false);\n    }\n    // if want to make required, only possible when zero items\n    else if (root.query('GET_TOTAL_ITEMS') === 0) {\n      attrToggle(root.element, 'required', true);\n    }\n  };\n\n  var setCaptureMethod = function setCaptureMethod(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    attrToggle(\n      root.element,\n      'capture',\n      !!action.value,\n      action.value === true ? '' : action.value\n    );\n  };\n\n  var updateRequiredStatus = function updateRequiredStatus(_ref7) {\n    var root = _ref7.root;\n    var element = root.element;\n    // always remove the required attribute when more than zero items\n    if (root.query('GET_TOTAL_ITEMS') > 0) {\n      attrToggle(element, 'required', false);\n      attrToggle(element, 'name', false);\n    } else {\n      // add name attribute\n      attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n      // remove any validation messages\n      var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n      if (shouldCheckValidity) {\n        element.setCustomValidity('');\n      }\n\n      // we only add required if the field has been deemed required\n      if (root.query('GET_REQUIRED')) {\n        attrToggle(element, 'required', true);\n      }\n    }\n  };\n\n  var updateFieldValidityStatus = function updateFieldValidityStatus(_ref8) {\n    var root = _ref8.root;\n    var shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n  };\n\n  var browser = createView({\n    tag: 'input',\n    name: 'browser',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n      type: 'file'\n    },\n\n    create: create$a,\n    destroy: function destroy(_ref9) {\n      var root = _ref9.root;\n      root.element.removeEventListener('change', root.ref.handleChange);\n    },\n    write: createRoute({\n      DID_LOAD_ITEM: updateRequiredStatus,\n      DID_REMOVE_ITEM: updateRequiredStatus,\n      DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n      DID_SET_DISABLED: toggleDisabled,\n      DID_SET_ALLOW_BROWSE: toggleDisabled,\n      DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n      DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n      DID_SET_CAPTURE_METHOD: setCaptureMethod,\n      DID_SET_REQUIRED: toggleRequired\n    })\n  });\n\n  var Key = {\n    ENTER: 13,\n    SPACE: 32\n  };\n\n  var create$b = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // create the label and link it to the file browser\n    var label = createElement$1('label');\n    attr(label, 'for', 'filepond--browser-' + props.id);\n\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, 'id', 'filepond--drop-label-' + props.id);\n\n    // hide the label for screenreaders, the input element will read the contents of the label when it's focussed. If we don't set aria-hidden the screenreader will also navigate the contents of the label separately from the input.\n    attr(label, 'aria-hidden', 'true');\n\n    // handle keys\n    root.ref.handleKeyDown = function(e) {\n      var isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n      if (!isActivationKey) return;\n      // stops from triggering the element a second time\n      e.preventDefault();\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    root.ref.handleClick = function(e) {\n      var isLabelClick = e.target === label || label.contains(e.target);\n\n      // don't want to click twice\n      if (isLabelClick) return;\n\n      // click link (will then in turn activate file input)\n      root.ref.label.click();\n    };\n\n    // attach events\n    label.addEventListener('keydown', root.ref.handleKeyDown);\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // update\n    updateLabelValue(label, props.caption);\n\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n  };\n\n  var updateLabelValue = function updateLabelValue(label, value) {\n    label.innerHTML = value;\n    var clickable = label.querySelector('.filepond--label-action');\n    if (clickable) {\n      attr(clickable, 'tabindex', '0');\n    }\n    return value;\n  };\n\n  var dropLabel = createView({\n    name: 'drop-label',\n    ignoreRect: true,\n    create: create$b,\n    destroy: function destroy(_ref2) {\n      var root = _ref2.root;\n      root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n      root.element.removeEventListener('click', root.ref.handleClick);\n    },\n    write: createRoute({\n      DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {\n        var root = _ref3.root,\n          action = _ref3.action;\n        updateLabelValue(root.ref.label, action.value);\n      }\n    }),\n\n    mixins: {\n      styles: ['opacity', 'translateX', 'translateY'],\n      animations: {\n        opacity: { type: 'tween', duration: 150 },\n        translateX: 'spring',\n        translateY: 'spring'\n      }\n    }\n  });\n\n  var blob = createView({\n    name: 'drip-blob',\n    ignoreRect: true,\n    mixins: {\n      styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n      animations: {\n        scaleX: 'spring',\n        scaleY: 'spring',\n        translateX: 'spring',\n        translateY: 'spring',\n        opacity: { type: 'tween', duration: 250 }\n      }\n    }\n  });\n\n  var addBlob = function addBlob(_ref) {\n    var root = _ref.root;\n    var centerX = root.rect.element.width * 0.5;\n    var centerY = root.rect.element.height * 0.5;\n\n    root.ref.blob = root.appendChildView(\n      root.createChildView(blob, {\n        opacity: 0,\n        scaleX: 2.5,\n        scaleY: 2.5,\n        translateX: centerX,\n        translateY: centerY\n      })\n    );\n  };\n\n  var moveBlob = function moveBlob(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!root.ref.blob) {\n      addBlob({ root: root });\n      return;\n    }\n\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n  };\n\n  var hideBlob = function hideBlob(_ref3) {\n    var root = _ref3.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.opacity = 0;\n  };\n\n  var explodeBlob = function explodeBlob(_ref4) {\n    var root = _ref4.root;\n    if (!root.ref.blob) {\n      return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n  };\n\n  var write$7 = function write(_ref5) {\n    var root = _ref5.root,\n      props = _ref5.props,\n      actions = _ref5.actions;\n    route$4({ root: root, props: props, actions: actions });\n    var blob = root.ref.blob;\n\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n      root.removeChildView(blob);\n      root.ref.blob = null;\n    }\n  };\n\n  var route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob\n  });\n\n  var drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'drip',\n    write: write$7\n  });\n\n  var getRootNode = function getRootNode(element) {\n    return 'getRootNode' in element ? element.getRootNode() : document;\n  };\n\n  var images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\n  var text$1 = ['css', 'csv', 'html', 'txt'];\n  var map = {\n    zip: 'zip|compressed',\n    epub: 'application/epub+zip'\n  };\n\n  var guesstimateMimeType = function guesstimateMimeType() {\n    var extension =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n      return (\n        'image/' +\n        (extension === 'jpg'\n          ? 'jpeg'\n          : extension === 'svg'\n          ? 'svg+xml'\n          : extension)\n      );\n    }\n    if (text$1.includes(extension)) {\n      return 'text/' + extension;\n    }\n    return map[extension] || null;\n  };\n\n  var requestDataTransferItems = function requestDataTransferItems(\n    dataTransfer\n  ) {\n    return new Promise(function(resolve, reject) {\n      // try to get links from transfer, if found we'll exit immidiately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n      var links = getLinks(dataTransfer);\n      if (links.length && !hasFiles(dataTransfer)) {\n        return resolve(links);\n      }\n      // try to get files from the transfer\n      getFiles(dataTransfer).then(resolve);\n    });\n  };\n\n  /**\n   * Test if datatransfer has files\n   */\n  var hasFiles = function hasFiles(dataTransfer) {\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n  };\n\n  /**\n   * Extracts files from a DataTransfer object\n   */\n  var getFiles = function getFiles(dataTransfer) {\n    return new Promise(function(resolve, reject) {\n      // get the transfer items as promises\n      var promisedFiles = (dataTransfer.items\n        ? Array.from(dataTransfer.items)\n        : []\n      )\n        // only keep file system items (files and directories)\n        .filter(function(item) {\n          return isFileSystemItem(item);\n        })\n\n        // map each item to promise\n        .map(function(item) {\n          return getFilesFromItem(item);\n        });\n\n      // if is empty, see if we can extract some info from the files property as a fallback\n      if (!promisedFiles.length) {\n        // TODO: test for directories (should not be allowed)\n        // Use FileReader, problem is that the files property gets lost in the process\n\n        resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n        return;\n      }\n\n      // done!\n      Promise.all(promisedFiles)\n        .then(function(returnedFileGroups) {\n          // flatten groups\n          var files = [];\n          returnedFileGroups.forEach(function(group) {\n            files.push.apply(files, group);\n          });\n\n          // done (filter out empty files)!\n          resolve(\n            files.filter(function(file) {\n              return file;\n            })\n          );\n        })\n        .catch(console.error);\n    });\n  };\n\n  var isFileSystemItem = function isFileSystemItem(item) {\n    if (isEntry(item)) {\n      var entry = getAsEntry(item);\n      if (entry) {\n        return entry.isFile || entry.isDirectory;\n      }\n    }\n    return item.kind === 'file';\n  };\n\n  var getFilesFromItem = function getFilesFromItem(item) {\n    return new Promise(function(resolve, reject) {\n      if (isDirectoryEntry(item)) {\n        getFilesInDirectory(getAsEntry(item))\n          .then(resolve)\n          .catch(reject);\n        return;\n      }\n\n      resolve([item.getAsFile()]);\n    });\n  };\n\n  var getFilesInDirectory = function getFilesInDirectory(entry) {\n    return new Promise(function(resolve, reject) {\n      var files = [];\n\n      // the total entries to read\n      var dirCounter = 0;\n      var fileCounter = 0;\n\n      var resolveIfDone = function resolveIfDone() {\n        if (fileCounter === 0 && dirCounter === 0) {\n          resolve(files);\n        }\n      };\n\n      // the recursive function\n      var readEntries = function readEntries(dirEntry) {\n        dirCounter++;\n\n        var directoryReader = dirEntry.createReader();\n\n        // directories are returned in batches, we need to process all batches before we're done\n        var readBatch = function readBatch() {\n          directoryReader.readEntries(function(entries) {\n            if (entries.length === 0) {\n              dirCounter--;\n              resolveIfDone();\n              return;\n            }\n\n            entries.forEach(function(entry) {\n              // recursively read more directories\n              if (entry.isDirectory) {\n                readEntries(entry);\n              } else {\n                // read as file\n                fileCounter++;\n\n                entry.file(function(file) {\n                  files.push(correctMissingFileType(file));\n                  fileCounter--;\n                  resolveIfDone();\n                });\n              }\n            });\n\n            // try to get next batch of files\n            readBatch();\n          }, reject);\n        };\n\n        // read first batch of files\n        readBatch();\n      };\n\n      // go!\n      readEntries(entry);\n    });\n  };\n\n  var correctMissingFileType = function correctMissingFileType(file) {\n    if (file.type.length) return file;\n    var date = file.lastModifiedDate;\n    var name = file.name;\n    file = file.slice(\n      0,\n      file.size,\n      guesstimateMimeType(getExtensionFromFilename(file.name))\n    );\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n  };\n\n  var isDirectoryEntry = function isDirectoryEntry(item) {\n    return isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n  };\n\n  var isEntry = function isEntry(item) {\n    return 'webkitGetAsEntry' in item;\n  };\n\n  var getAsEntry = function getAsEntry(item) {\n    return item.webkitGetAsEntry();\n  };\n\n  /**\n   * Extracts links from a DataTransfer object\n   */\n  var getLinks = function getLinks(dataTransfer) {\n    var links = [];\n    try {\n      // look in meta data property\n      links = getLinksFromTransferMetaData(dataTransfer);\n      if (links.length) {\n        return links;\n      }\n      links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n      // nope nope nope (probably IE trouble)\n    }\n    return links;\n  };\n\n  var getLinksFromTransferURLData = function getLinksFromTransferURLData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('url');\n    if (typeof data === 'string' && data.length) {\n      return [data];\n    }\n    return [];\n  };\n\n  var getLinksFromTransferMetaData = function getLinksFromTransferMetaData(\n    dataTransfer\n  ) {\n    var data = dataTransfer.getData('text/html');\n    if (typeof data === 'string' && data.length) {\n      var matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n      if (matches) {\n        return [matches[1]];\n      }\n    }\n    return [];\n  };\n\n  var dragNDropObservers = [];\n\n  var eventPosition = function eventPosition(e) {\n    return {\n      pageLeft: e.pageX,\n      pageTop: e.pageY,\n      scopeLeft: e.offsetX || e.layerX,\n      scopeTop: e.offsetY || e.layerY\n    };\n  };\n\n  var createDragNDropClient = function createDragNDropClient(\n    element,\n    scopeToObserve,\n    filterElement\n  ) {\n    var observer = getDragNDropObserver(scopeToObserve);\n\n    var client = {\n      element: element,\n      filterElement: filterElement,\n      state: null,\n      ondrop: function ondrop() {},\n      onenter: function onenter() {},\n      ondrag: function ondrag() {},\n      onexit: function onexit() {},\n      onload: function onload() {},\n      allowdrop: function allowdrop() {}\n    };\n\n    client.destroy = observer.addListener(client);\n\n    return client;\n  };\n\n  var getDragNDropObserver = function getDragNDropObserver(element) {\n    // see if already exists, if so, return\n    var observer = dragNDropObservers.find(function(item) {\n      return item.element === element;\n    });\n    if (observer) {\n      return observer;\n    }\n\n    // create new observer, does not yet exist for this element\n    var newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n  };\n\n  var createDragNDropObserver = function createDragNDropObserver(element) {\n    var clients = [];\n\n    var routes = {\n      dragenter: dragenter,\n      dragover: dragover,\n      dragleave: dragleave,\n      drop: drop\n    };\n\n    var handlers = {};\n\n    forin(routes, function(event, createHandler) {\n      handlers[event] = createHandler(element, clients);\n      element.addEventListener(event, handlers[event], false);\n    });\n\n    var observer = {\n      element: element,\n      addListener: function addListener(client) {\n        // add as client\n        clients.push(client);\n\n        // return removeListener function\n        return function() {\n          // remove client\n          clients.splice(clients.indexOf(client), 1);\n\n          // if no more clients, clean up observer\n          if (clients.length === 0) {\n            dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n            forin(routes, function(event) {\n              element.removeEventListener(event, handlers[event], false);\n            });\n          }\n        };\n      }\n    };\n\n    return observer;\n  };\n\n  var elementFromPoint = function elementFromPoint(root, point) {\n    if (!('elementFromPoint' in root)) {\n      root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n  };\n\n  var isEventTarget = function isEventTarget(e, target) {\n    // get root\n    var root = getRootNode(target);\n\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    var elementAtPosition = elementFromPoint(root, {\n      x: e.pageX - window.pageXOffset,\n      y: e.pageY - window.pageYOffset\n    });\n\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n  };\n\n  var initialTarget = null;\n\n  var setDropEffect = function setDropEffect(dataTransfer, effect) {\n    // is in try catch as IE11 will throw error if not\n    try {\n      dataTransfer.dropEffect = effect;\n    } catch (e) {}\n  };\n\n  var dragenter = function dragenter(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      initialTarget = e.target;\n\n      clients.forEach(function(client) {\n        var element = client.element,\n          onenter = client.onenter;\n\n        if (isEventTarget(e, element)) {\n          client.state = 'enter';\n\n          // fire enter event\n          onenter(eventPosition(e));\n        }\n      });\n    };\n  };\n\n  var dragover = function dragover(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        var overDropTarget = false;\n\n        clients.some(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            onenter = client.onenter,\n            onexit = client.onexit,\n            ondrag = client.ondrag,\n            allowdrop = client.allowdrop;\n\n          // by default we can drop\n          setDropEffect(dataTransfer, 'copy');\n\n          // allow transfer of these items\n          var allowsTransfer = allowdrop(items);\n\n          // only used when can be dropped on page\n          if (!allowsTransfer) {\n            setDropEffect(dataTransfer, 'none');\n            return;\n          }\n\n          // targetting this client\n          if (isEventTarget(e, element)) {\n            overDropTarget = true;\n\n            // had no previous state, means we are entering this client\n            if (client.state === null) {\n              client.state = 'enter';\n              onenter(eventPosition(e));\n              return;\n            }\n\n            // now over element (no matter if it allows the drop or not)\n            client.state = 'over';\n\n            // needs to allow transfer\n            if (filterElement && !allowsTransfer) {\n              setDropEffect(dataTransfer, 'none');\n              return;\n            }\n\n            // dragging\n            ondrag(eventPosition(e));\n          } else {\n            // should be over an element to drop\n            if (filterElement && !overDropTarget) {\n              setDropEffect(dataTransfer, 'none');\n            }\n\n            // might have just left this client?\n            if (client.state) {\n              client.state = null;\n              onexit(eventPosition(e));\n            }\n          }\n        });\n      });\n    };\n  };\n\n  var drop = function drop(root, clients) {\n    return function(e) {\n      e.preventDefault();\n\n      var dataTransfer = e.dataTransfer;\n\n      requestDataTransferItems(dataTransfer).then(function(items) {\n        clients.forEach(function(client) {\n          var filterElement = client.filterElement,\n            element = client.element,\n            ondrop = client.ondrop,\n            onexit = client.onexit,\n            allowdrop = client.allowdrop;\n\n          client.state = null;\n\n          // if we're filtering on element we need to be over the element to drop\n          if (filterElement && !isEventTarget(e, element)) return;\n\n          // no transfer for this client\n          if (!allowdrop(items)) return onexit(eventPosition(e));\n\n          // we can drop these items on this client\n          ondrop(eventPosition(e), items);\n        });\n      });\n    };\n  };\n\n  var dragleave = function dragleave(root, clients) {\n    return function(e) {\n      if (initialTarget !== e.target) {\n        return;\n      }\n\n      clients.forEach(function(client) {\n        var onexit = client.onexit;\n\n        client.state = null;\n\n        onexit(eventPosition(e));\n      });\n    };\n  };\n\n  var createHopper = function createHopper(scope, validateItems, options) {\n    // is now hopper scope\n    scope.classList.add('filepond--hopper');\n\n    // shortcuts\n    var catchesDropsOnPage = options.catchesDropsOnPage,\n      requiresDropOnElement = options.requiresDropOnElement,\n      _options$filterItems = options.filterItems,\n      filterItems =\n        _options$filterItems === void 0\n          ? function(items) {\n              return items;\n            }\n          : _options$filterItems;\n\n    // create a dnd client\n    var client = createDragNDropClient(\n      scope,\n      catchesDropsOnPage ? document.documentElement : scope,\n      requiresDropOnElement\n    );\n\n    // current client state\n    var lastState = '';\n    var currentState = '';\n\n    // determines if a file may be dropped\n    client.allowdrop = function(items) {\n      // TODO: if we can, throw error to indicate the items cannot by dropped\n\n      return validateItems(filterItems(items));\n    };\n\n    client.ondrop = function(position, items) {\n      var filteredItems = filterItems(items);\n\n      if (!validateItems(filteredItems)) {\n        api.ondragend(position);\n        return;\n      }\n\n      currentState = 'drag-drop';\n\n      api.onload(filteredItems, position);\n    };\n\n    client.ondrag = function(position) {\n      api.ondrag(position);\n    };\n\n    client.onenter = function(position) {\n      currentState = 'drag-over';\n\n      api.ondragstart(position);\n    };\n\n    client.onexit = function(position) {\n      currentState = 'drag-exit';\n\n      api.ondragend(position);\n    };\n\n    var api = {\n      updateHopperState: function updateHopperState() {\n        if (lastState !== currentState) {\n          scope.dataset.hopperState = currentState;\n          lastState = currentState;\n        }\n      },\n      onload: function onload() {},\n      ondragstart: function ondragstart() {},\n      ondrag: function ondrag() {},\n      ondragend: function ondragend() {},\n      destroy: function destroy() {\n        // destroy client\n        client.destroy();\n      }\n    };\n\n    return api;\n  };\n\n  var listening = false;\n  var listeners$1 = [];\n\n  var handlePaste = function handlePaste(e) {\n    requestDataTransferItems(e.clipboardData).then(function(files) {\n      // no files received\n      if (!files.length) {\n        return;\n      }\n\n      // notify listeners of received files\n      listeners$1.forEach(function(listener) {\n        return listener(files);\n      });\n    });\n  };\n\n  var listen = function listen(cb) {\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n      return;\n    }\n\n    // add initial listener\n    listeners$1.push(cb);\n\n    // setup paste listener for entire page\n    if (listening) {\n      return;\n    }\n\n    listening = true;\n    document.addEventListener('paste', handlePaste);\n  };\n\n  var unlisten = function unlisten(listener) {\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n    // clean up\n    if (listeners$1.length === 0) {\n      document.removeEventListener('paste', handlePaste);\n      listening = false;\n    }\n  };\n\n  var createPaster = function createPaster() {\n    var cb = function cb(files) {\n      api.onload(files);\n    };\n\n    var api = {\n      destroy: function destroy() {\n        unlisten(cb);\n      },\n      onload: function onload() {}\n    };\n\n    listen(cb);\n\n    return api;\n  };\n\n  /**\n   * Creates the file view\n   */\n  var create$c = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n    root.element.id = 'filepond--assistant-' + props.id;\n    attr(root.element, 'role', 'status');\n    attr(root.element, 'aria-live', 'polite');\n    attr(root.element, 'aria-relevant', 'additions');\n  };\n\n  var addFilesNotificationTimeout = null;\n  var notificationClearTimeout = null;\n\n  var filenames = [];\n\n  var assist = function assist(root, message) {\n    root.element.textContent = message;\n  };\n\n  var clear$1 = function clear(root) {\n    root.element.textContent = '';\n  };\n\n  var listModified = function listModified(root, filename, label) {\n    var total = root.query('GET_TOTAL_ITEMS');\n    assist(\n      root,\n      label +\n        ' ' +\n        filename +\n        ', ' +\n        total +\n        ' ' +\n        (total === 1\n          ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n          : root.query('GET_LABEL_FILE_COUNT_PLURAL'))\n    );\n\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(function() {\n      clear$1(root);\n    }, 1500);\n  };\n\n  var isUsingFilePond = function isUsingFilePond(root) {\n    return root.element.parentNode.contains(document.activeElement);\n  };\n\n  var itemAdded = function itemAdded(_ref2) {\n    var root = _ref2.root,\n      action = _ref2.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    root.element.textContent = '';\n    var item = root.query('GET_ITEM', action.id);\n    filenames.push(item.filename);\n\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(function() {\n      listModified(\n        root,\n        filenames.join(', '),\n        root.query('GET_LABEL_FILE_ADDED')\n      );\n\n      filenames.length = 0;\n    }, 750);\n  };\n\n  var itemRemoved = function itemRemoved(_ref3) {\n    var root = _ref3.root,\n      action = _ref3.action;\n    if (!isUsingFilePond(root)) {\n      return;\n    }\n\n    var item = action.item;\n    listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n  };\n\n  var itemProcessed = function itemProcessed(_ref4) {\n    var root = _ref4.root,\n      action = _ref4.action;\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemProcessedUndo = function itemProcessedUndo(_ref5) {\n    var root = _ref5.root,\n      action = _ref5.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n    var label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n    assist(root, filename + ' ' + label);\n  };\n\n  var itemError = function itemError(_ref6) {\n    var root = _ref6.root,\n      action = _ref6.action;\n    var item = root.query('GET_ITEM', action.id);\n    var filename = item.filename;\n\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    assist(root, action.status.main + ' ' + filename + ' ' + action.status.sub);\n  };\n\n  var assistant = createView({\n    create: create$c,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n      DID_LOAD_ITEM: itemAdded,\n      DID_REMOVE_ITEM: itemRemoved,\n      DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n      DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n      DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n      DID_THROW_ITEM_REMOVE_ERROR: itemError,\n      DID_THROW_ITEM_LOAD_ERROR: itemError,\n      DID_THROW_ITEM_INVALID: itemError,\n      DID_THROW_ITEM_PROCESSING_ERROR: itemError\n    }),\n\n    tag: 'span',\n    name: 'assistant'\n  });\n\n  var toCamels = function toCamels(string) {\n    var separator =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n    return string.replace(new RegExp(separator + '.', 'g'), function(sub) {\n      return sub.charAt(1).toUpperCase();\n    });\n  };\n\n  var debounce = function debounce(func) {\n    var interval =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    var immidiateOnly =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var last = Date.now();\n    var timeout = null;\n\n    return function() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      clearTimeout(timeout);\n\n      var dist = Date.now() - last;\n\n      var fn = function fn() {\n        last = Date.now();\n        func.apply(void 0, args);\n      };\n\n      if (dist < interval) {\n        // we need to delay by the difference between interval and dist\n        // for example: if distance is 10 ms and interval is 16 ms,\n        // we need to wait an additional 6ms before calling the function)\n        if (!immidiateOnly) {\n          timeout = setTimeout(fn, interval - dist);\n        }\n      } else {\n        // go!\n        fn();\n      }\n    };\n  };\n\n  var MAX_FILES_LIMIT = 1000000;\n\n  var create$d = function create(_ref) {\n    var root = _ref.root,\n      props = _ref.props;\n\n    // Add id\n    var id = root.query('GET_ID');\n    if (id) {\n      root.element.id = id;\n    }\n\n    // Add className\n    var className = root.query('GET_CLASS_NAME');\n    if (className) {\n      className.split(' ').forEach(function(name) {\n        root.element.classList.add(name);\n      });\n    }\n\n    // Field label\n    root.ref.label = root.appendChildView(\n      root.createChildView(\n        dropLabel,\n        Object.assign({}, props, {\n          translateY: null,\n          caption: root.query('GET_LABEL_IDLE')\n        })\n      )\n    );\n\n    // List of items\n    root.ref.list = root.appendChildView(\n      root.createChildView(listScroller, { translateY: null })\n    );\n\n    // Background panel\n    root.ref.panel = root.appendChildView(\n      root.createChildView(panel, { name: 'panel-root' })\n    );\n\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(\n      root.createChildView(assistant, Object.assign({}, props))\n    );\n\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1('div');\n    root.ref.measure.style.height = '100%';\n    root.element.appendChild(root.ref.measure);\n\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n\n    // apply initial style properties\n    root\n      .query('GET_STYLES')\n      .filter(function(style) {\n        return !isEmpty(style.value);\n      })\n      .map(function(_ref2) {\n        var name = _ref2.name,\n          value = _ref2.value;\n        root.element.dataset[name] = value;\n      });\n\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(function() {\n      root.ref.updateHistory = [];\n      root.dispatch('DID_RESIZE_ROOT');\n    }, 250);\n\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n  };\n\n  var write$8 = function write(_ref3) {\n    var root = _ref3.root,\n      props = _ref3.props,\n      actions = _ref3.actions;\n\n    // route actions\n    route$5({ root: root, props: props, actions: actions });\n\n    // apply style properties\n    actions\n      .filter(function(action) {\n        return /^DID_SET_STYLE_/.test(action.type);\n      })\n      .filter(function(action) {\n        return !isEmpty(action.data.value);\n      })\n      .map(function(_ref4) {\n        var type = _ref4.type,\n          data = _ref4.data;\n        var name = toCamels(type.substr(8).toLowerCase(), '_');\n        root.element.dataset[name] = data.value;\n        root.invalidateLayout();\n      });\n\n    if (root.rect.element.hidden) return;\n\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n      root.ref.widthPrevious = root.rect.element.width;\n      root.ref.widthUpdated();\n    }\n\n    // get box bounds, we do this only once\n    var bounds = root.ref.bounds;\n    if (!bounds) {\n      bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n      // destroy measure element\n      root.element.removeChild(root.ref.measure);\n      root.ref.measure = null;\n    }\n\n    // get quick references to various high level parts of the upload tool\n    var _root$ref = root.ref,\n      hopper = _root$ref.hopper,\n      label = _root$ref.label,\n      list = _root$ref.list,\n      panel = _root$ref.panel;\n\n    // sets correct state to hopper scope\n    if (hopper) {\n      hopper.updateHopperState();\n    }\n\n    // bool to indicate if we're full or not\n    var aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n    var isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = isMultiItem\n      ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT\n      : 1;\n    var atMaxCapacity = totalItems === maxItems;\n\n    // action used to add item\n    var addAction = actions.find(function(action) {\n      return action.type === 'DID_ADD_ITEM';\n    });\n\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n      // get interaction type\n      var interactionMethod = addAction.data.interactionMethod;\n\n      // hide label\n      label.opacity = 0;\n\n      if (isMultiItem) {\n        label.translateY = -40;\n      } else {\n        if (interactionMethod === InteractionMethod.API) {\n          label.translateX = 40;\n        } else if (interactionMethod === InteractionMethod.BROWSE) {\n          label.translateY = 40;\n        } else {\n          label.translateY = 30;\n        }\n      }\n    } else if (!atMaxCapacity) {\n      label.opacity = 1;\n      label.translateX = 0;\n      label.translateY = 0;\n    }\n\n    var listItemMargin = calculateListItemMargin(root);\n\n    var listHeight = calculateListHeight(root);\n\n    var labelHeight = label.rect.element.height;\n    var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n    var listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    var listMarginBottom =\n      totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n    var visualHeight =\n      currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    var boundsHeight =\n      currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n    // link list to label bottom position\n    list.translateY =\n      Math.max(0, currentLabelHeight - list.rect.element.marginTop) -\n      listItemMargin.top;\n\n    if (aspectRatio) {\n      // fixed aspect ratio\n\n      // calculate height based on width\n      var width = root.rect.element.width;\n      var height = width * aspectRatio;\n\n      // clear history if aspect ratio has changed\n      if (aspectRatio !== root.ref.previousAspectRatio) {\n        root.ref.previousAspectRatio = aspectRatio;\n        root.ref.updateHistory = [];\n      }\n\n      // remember this width\n      var history = root.ref.updateHistory;\n      history.push(width);\n\n      var MAX_BOUNCES = 2;\n      if (history.length > MAX_BOUNCES * 2) {\n        var l = history.length;\n        var bottom = l - 10;\n        var bounces = 0;\n        for (var i = l; i >= bottom; i--) {\n          if (history[i] === history[i - 2]) {\n            bounces++;\n          }\n\n          if (bounces >= MAX_BOUNCES) {\n            // dont adjust height\n            return;\n          }\n        }\n      }\n\n      // fix height of panel so it adheres to aspect ratio\n      panel.scalable = false;\n      panel.height = height;\n\n      // available height for list\n      var listAvailableHeight =\n        // the height of the panel minus the label height\n        height -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      if (listHeight.visual > listAvailableHeight) {\n        list.overflow = listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = height;\n    } else if (bounds.fixedHeight) {\n      // fixed height\n\n      // fix height of panel\n      panel.scalable = false;\n\n      // available height for list\n      var _listAvailableHeight =\n        // the height of the panel minus the label height\n        bounds.fixedHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height\n      if (listHeight.visual > _listAvailableHeight) {\n        list.overflow = _listAvailableHeight;\n      } else {\n        list.overflow = null;\n      }\n\n      // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n      // max-height\n\n      // not a fixed height panel\n      var isCappedHeight = visualHeight >= bounds.cappedHeight;\n      var panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n      panel.scalable = true;\n      panel.height = isCappedHeight\n        ? panelHeight\n        : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n      // available height for list\n      var _listAvailableHeight2 =\n        // the height of the panel minus the label height\n        panelHeight -\n        currentLabelHeight -\n        // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) -\n        // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n\n      // set list height (if is overflowing)\n      if (\n        visualHeight > bounds.cappedHeight &&\n        listHeight.visual > _listAvailableHeight2\n      ) {\n        list.overflow = _listAvailableHeight2;\n      } else {\n        list.overflow = null;\n      }\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.min(\n        bounds.cappedHeight,\n        boundsHeight - listItemMargin.top - listItemMargin.bottom\n      );\n    } else {\n      // flexible height\n\n      // not a fixed height panel\n      var itemMargin =\n        totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n      panel.scalable = true;\n      panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n      // set container bounds (so pushes siblings downwards)\n      root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n  };\n\n  var calculateListItemMargin = function calculateListItemMargin(root) {\n    var item = root.ref.list.childViews[0].childViews[0];\n    return item\n      ? {\n          top: item.rect.element.marginTop,\n          bottom: item.rect.element.marginBottom\n        }\n      : {\n          top: 0,\n          bottom: 0\n        };\n  };\n\n  var calculateListHeight = function calculateListHeight(root) {\n    var visual = 0;\n    var bounds = 0;\n\n    // get file list reference\n    var scrollList = root.ref.list;\n    var itemList = scrollList.childViews[0];\n    var children = itemList.childViews;\n\n    // no children, done!\n    if (children.length === 0) return { visual: visual, bounds: bounds };\n\n    var horizontalSpace = itemList.rect.element.width;\n    var dragIndex = getItemIndexByPosition(\n      itemList,\n      scrollList.dragCoordinates\n    );\n\n    var childRect = children[0].rect.element;\n\n    var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n    var itemWidth = childRect.width + itemHorizontalMargin;\n    var itemHeight = childRect.height + itemVerticalMargin;\n\n    var newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n    var removedItem = children.find(function(child) {\n      return child.markedForRemoval && child.opacity < 0.45;\n    })\n      ? -1\n      : 0;\n    var verticalItemCount = children.length + newItem + removedItem;\n    var itemsPerRow = Math.round(horizontalSpace / itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n      children.forEach(function(item) {\n        var height = item.rect.element.height + itemVerticalMargin;\n        bounds += height;\n        visual += height * item.opacity;\n      });\n    }\n    // grid\n    else {\n      bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n      visual = bounds;\n    }\n\n    return { visual: visual, bounds: bounds };\n  };\n\n  var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight(\n    root\n  ) {\n    var height = root.ref.measureHeight || null;\n    var cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    var fixedHeight = height === 0 ? null : height;\n\n    return {\n      cappedHeight: cappedHeight,\n      fixedHeight: fixedHeight\n    };\n  };\n\n  var exceedsMaxFiles = function exceedsMaxFiles(root, items) {\n    var allowReplace = root.query('GET_ALLOW_REPLACE');\n    var allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n    var totalItems = root.query('GET_TOTAL_ITEMS');\n    var maxItems = root.query('GET_MAX_FILES');\n\n    // total amount of items being dragged\n    var totalBrowseItems = items.length;\n\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n      return true;\n    }\n\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;\n\n    // no more room?\n    var hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n      root.dispatch('DID_THROW_MAX_FILES', {\n        source: items,\n        error: createResponse('warning', 0, 'Max files')\n      });\n\n      return true;\n    }\n\n    return false;\n  };\n\n  var getDragIndex = function getDragIndex(list, position) {\n    var itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, {\n      left: position.scopeLeft - itemList.rect.element.left,\n      top:\n        position.scopeTop -\n        (list.rect.outer.top +\n          list.rect.element.marginTop +\n          list.rect.element.scrollTop)\n    });\n  };\n\n  /**\n   * Enable or disable file drop functionality\n   */\n  var toggleDrop = function toggleDrop(root) {\n    var isAllowed = root.query('GET_ALLOW_DROP');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n      var hopper = createHopper(\n        root.element,\n        function(items) {\n          // these files don't fit so stop here\n          if (exceedsMaxFiles(root, items)) return false;\n\n          // allow quick validation of dropped items\n          var beforeDropFile =\n            root.query('GET_BEFORE_DROP_FILE') ||\n            function() {\n              return true;\n            };\n\n          // all items should be validated by all filters as valid\n          var dropValidation = root.query('GET_DROP_VALIDATION');\n          return dropValidation\n            ? items.every(function(item) {\n                return (\n                  applyFilters('ALLOW_HOPPER_ITEM', item, {\n                    query: root.query\n                  }).every(function(result) {\n                    return result === true;\n                  }) && beforeDropFile(item)\n                );\n              })\n            : true;\n        },\n        {\n          filterItems: function filterItems(items) {\n            var ignoredFiles = root.query('GET_IGNORED_FILES');\n            return items.filter(function(item) {\n              if (isFile(item)) {\n                return !ignoredFiles.includes(item.name.toLowerCase());\n              }\n              return true;\n            });\n          },\n          catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n          requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT')\n        }\n      );\n\n      hopper.onload = function(items, position) {\n        root.dispatch('ADD_ITEMS', {\n          items: items,\n          index: getDragIndex(root.ref.list, position),\n          interactionMethod: InteractionMethod.DROP\n        });\n\n        root.dispatch('DID_DROP', { position: position });\n\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      hopper.ondragstart = function(position) {\n        root.dispatch('DID_START_DRAG', { position: position });\n      };\n\n      hopper.ondrag = debounce(function(position) {\n        root.dispatch('DID_DRAG', { position: position });\n      });\n\n      hopper.ondragend = function(position) {\n        root.dispatch('DID_END_DRAG', { position: position });\n      };\n\n      root.ref.hopper = hopper;\n\n      root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n      root.ref.hopper.destroy();\n      root.ref.hopper = null;\n      root.removeChildView(root.ref.drip);\n    }\n  };\n\n  /**\n   * Enable or disable browse functionality\n   */\n  var toggleBrowse = function toggleBrowse(root, props) {\n    var isAllowed = root.query('GET_ALLOW_BROWSE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n      root.ref.browser = root.appendChildView(\n        root.createChildView(\n          browser,\n          Object.assign({}, props, {\n            onload: function onload(items) {\n              // these files don't fit so stop here\n              if (exceedsMaxFiles(root, items)) return false;\n\n              // add items!\n              root.dispatch('ADD_ITEMS', {\n                items: items,\n                index: -1,\n                interactionMethod: InteractionMethod.BROWSE\n              });\n            }\n          })\n        ),\n\n        0\n      );\n    } else if (!enabled && root.ref.browser) {\n      root.removeChildView(root.ref.browser);\n      root.ref.browser = null;\n    }\n  };\n\n  /**\n   * Enable or disable paste functionality\n   */\n  var togglePaste = function togglePaste(root) {\n    var isAllowed = root.query('GET_ALLOW_PASTE');\n    var isDisabled = root.query('GET_DISABLED');\n    var enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n      root.ref.paster = createPaster();\n      root.ref.paster.onload = function(items) {\n        root.dispatch('ADD_ITEMS', {\n          items: items,\n          index: -1,\n          interactionMethod: InteractionMethod.PASTE\n        });\n      };\n    } else if (!enabled && root.ref.paster) {\n      root.ref.paster.destroy();\n      root.ref.paster = null;\n    }\n  };\n\n  /**\n   * Route actions\n   */\n  var route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {\n      var root = _ref5.root,\n        props = _ref5.props;\n      toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {\n      var root = _ref6.root;\n      toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {\n      var root = _ref7.root;\n      togglePaste(root);\n    },\n    DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {\n      var root = _ref8.root,\n        props = _ref8.props;\n      toggleDrop(root);\n      togglePaste(root);\n      toggleBrowse(root, props);\n      var isDisabled = root.query('GET_DISABLED');\n      if (isDisabled) {\n        root.element.dataset.disabled = 'disabled';\n      } else {\n        // delete root.element.dataset.disabled; <= this does not work on iOS 10\n        root.element.removeAttribute('data-disabled');\n      }\n    }\n  });\n\n  var root = createView({\n    name: 'root',\n    read: function read(_ref9) {\n      var root = _ref9.root;\n      if (root.ref.measure) {\n        root.ref.measureHeight = root.ref.measure.offsetHeight;\n      }\n    },\n    create: create$d,\n    write: write$8,\n    destroy: function destroy(_ref10) {\n      var root = _ref10.root;\n      if (root.ref.paster) {\n        root.ref.paster.destroy();\n      }\n      if (root.ref.hopper) {\n        root.ref.hopper.destroy();\n      }\n    },\n    mixins: {\n      styles: ['height']\n    }\n  });\n\n  // creates the app\n  var createApp = function createApp() {\n    var initialOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // let element\n    var originalElement = null;\n\n    // get default options\n    var defaultOptions = getOptions();\n\n    // create the data store, this will contain all our app info\n    var store = createStore(\n      // initial state (should be serializable)\n      createInitialState(defaultOptions),\n\n      // queries\n      [queries, createOptionQueries(defaultOptions)],\n\n      // action handlers\n      [actions, createOptionActions(defaultOptions)]\n    );\n\n    // set initial options\n    store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n    // kick thread if visibility changes\n    var visibilityHandler = function visibilityHandler() {\n      if (document.hidden) return;\n      store.dispatch('KICK');\n    };\n    document.addEventListener('visibilitychange', visibilityHandler);\n\n    // re-render on window resize start and finish\n    var resizeDoneTimer = null;\n    var isResizing = false;\n    var isResizingHorizontally = false;\n    var initialWindowWidth = null;\n    var currentWindowWidth = null;\n    var resizeHandler = function resizeHandler() {\n      if (!isResizing) {\n        isResizing = true;\n      }\n      clearTimeout(resizeDoneTimer);\n      resizeDoneTimer = setTimeout(function() {\n        isResizing = false;\n        initialWindowWidth = null;\n        currentWindowWidth = null;\n        if (isResizingHorizontally) {\n          isResizingHorizontally = false;\n          store.dispatch('DID_STOP_RESIZE');\n        }\n      }, 500);\n    };\n    window.addEventListener('resize', resizeHandler);\n\n    // render initial view\n    var view = root(store, { id: getUniqueId() });\n\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    var isResting = false;\n    var isHidden = false;\n\n    var readWriteApi = {\n      // necessary for update loop\n\n      /**\n       * Reads from dom (never call manually)\n       * @private\n       */\n      _read: function _read() {\n        // test if we're resizing horizontally\n        // TODO: see if we can optimize this by measuring root rect\n        if (isResizing) {\n          currentWindowWidth = window.innerWidth;\n          if (!initialWindowWidth) {\n            initialWindowWidth = currentWindowWidth;\n          }\n\n          if (\n            !isResizingHorizontally &&\n            currentWindowWidth !== initialWindowWidth\n          ) {\n            store.dispatch('DID_START_RESIZE');\n            isResizingHorizontally = true;\n          }\n        }\n\n        if (isHidden && isResting) {\n          // test if is no longer hidden\n          isResting = view.element.offsetParent === null;\n        }\n\n        // if resting, no need to read as numbers will still all be correct\n        if (isResting) return;\n\n        // read view data\n        view._read();\n\n        // if is hidden we need to know so we exit rest mode when revealed\n        isHidden = view.rect.element.hidden;\n      },\n\n      /**\n       * Writes to dom (never call manually)\n       * @private\n       */\n      _write: function _write(ts) {\n        // get all actions from store\n        var actions = store\n          .processActionQueue()\n\n          // filter out set actions (these will automatically trigger DID_SET)\n          .filter(function(action) {\n            return !/^SET_/.test(action.type);\n          });\n\n        // if was idling and no actions stop here\n        if (isResting && !actions.length) return;\n\n        // some actions might trigger events\n        routeActionsToEvents(actions);\n\n        // update the view\n        isResting = view._write(ts, actions, isResizingHorizontally);\n\n        // will clean up all archived items\n        removeReleasedItems(store.query('GET_ITEMS'));\n\n        // now idling\n        if (isResting) {\n          store.processDispatchQueue();\n        }\n      }\n    };\n\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    var createEvent = function createEvent(name) {\n      return function(data) {\n        // create default event\n        var event = {\n          type: name\n        };\n\n        // no data to add\n        if (!data) {\n          return event;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('error')) {\n          event.error = data.error ? Object.assign({}, data.error) : null;\n        }\n\n        if (data.status) {\n          event.status = Object.assign({}, data.status);\n        }\n\n        if (data.file) {\n          event.output = data.file;\n        }\n\n        // only source is available, else add item if possible\n        if (data.source) {\n          event.file = data.source;\n        } else if (data.item || data.id) {\n          var item = data.item ? data.item : store.query('GET_ITEM', data.id);\n          event.file = item ? createItemAPI(item) : null;\n        }\n\n        // map all items in a possible items array\n        if (data.items) {\n          event.items = data.items.map(createItemAPI);\n        }\n\n        // if this is a progress event add the progress amount\n        if (/progress/.test(name)) {\n          event.progress = data.progress;\n        }\n\n        return event;\n      };\n    };\n\n    var eventRoutes = {\n      DID_DESTROY: createEvent('destroy'),\n\n      DID_INIT: createEvent('init'),\n\n      DID_THROW_MAX_FILES: createEvent('warning'),\n\n      DID_START_ITEM_LOAD: createEvent('addfilestart'),\n      DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n      DID_LOAD_ITEM: createEvent('addfile'),\n\n      DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n      DID_THROW_ITEM_REMOVE_ERROR: [\n        createEvent('error'),\n        createEvent('removefile')\n      ],\n\n      DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n      DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n      DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n      DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n      DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n      DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n      DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n      DID_THROW_ITEM_PROCESSING_ERROR: [\n        createEvent('error'),\n        createEvent('processfile')\n      ],\n\n      DID_REMOVE_ITEM: createEvent('removefile'),\n\n      DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n      DID_ACTIVATE_ITEM: createEvent('activatefile')\n    };\n\n    var exposeEvent = function exposeEvent(event) {\n      // create event object to be dispatched\n      var detail = Object.assign({ pond: exports }, event);\n      delete detail.type;\n      view.element.dispatchEvent(\n        new CustomEvent('FilePond:' + event.type, {\n          // event info\n          detail: detail,\n\n          // event behaviour\n          bubbles: true,\n          cancelable: true,\n          composed: true // triggers listeners outside of shadow root\n        })\n      );\n\n      // event object to params used for `on()` event handlers and callbacks `oninit()`\n      var params = [];\n\n      // if is possible error event, make it the first param\n      if (event.hasOwnProperty('error')) {\n        params.push(event.error);\n      }\n\n      // file is always section\n      if (event.hasOwnProperty('file')) {\n        params.push(event.file);\n      }\n\n      // append other props\n      var filtered = ['type', 'error', 'file'];\n      Object.keys(event)\n        .filter(function(key) {\n          return !filtered.includes(key);\n        })\n        .forEach(function(key) {\n          return params.push(event[key]);\n        });\n\n      // on(type, () => { })\n      exports.fire.apply(exports, [event.type].concat(params));\n\n      // oninit = () => {}\n      var handler = store.query('GET_ON' + event.type.toUpperCase());\n      if (handler) {\n        handler.apply(void 0, params);\n      }\n    };\n\n    var routeActionsToEvents = function routeActionsToEvents(actions) {\n      if (!actions.length) {\n        return;\n      }\n\n      actions.forEach(function(action) {\n        if (!eventRoutes[action.type]) {\n          return;\n        }\n        var routes = eventRoutes[action.type];\n        (Array.isArray(routes) ? routes : [routes]).forEach(function(route) {\n          setTimeout(function() {\n            exposeEvent(route(action.data));\n          }, 0);\n        });\n      });\n    };\n\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    var setOptions = function setOptions(options) {\n      return store.dispatch('SET_OPTIONS', { options: options });\n    };\n\n    var getFile = function getFile(query) {\n      return store.query('GET_ACTIVE_ITEM', query);\n    };\n\n    var prepareFile = function prepareFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PREPARE', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var addFile = function addFile(source) {\n      var options =\n        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function(resolve, reject) {\n        addFiles([{ source: source, options: options }], {\n          index: options.index\n        })\n          .then(function(items) {\n            return resolve(items && items[0]);\n          })\n          .catch(reject);\n      });\n    };\n\n    var removeFile = function removeFile(query) {\n      // request item removal\n      store.dispatch('REMOVE_ITEM', { query: query });\n\n      // see if item has been removed\n      return store.query('GET_ACTIVE_ITEM', query) === null;\n    };\n\n    var addFiles = function addFiles() {\n      for (\n        var _len = arguments.length, args = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        args[_key] = arguments[_key];\n      }\n      return new Promise(function(resolve, reject) {\n        var sources = [];\n        var options = {};\n\n        // user passed a sources array\n        if (isArray(args[0])) {\n          sources.push.apply(sources, args[0]);\n          Object.assign(options, args[1] || {});\n        } else {\n          // user passed sources as arguments, last one might be options object\n          var lastArgument = args[args.length - 1];\n          if (\n            typeof lastArgument === 'object' &&\n            !(lastArgument instanceof Blob)\n          ) {\n            Object.assign(options, args.pop());\n          }\n\n          // add rest to sources\n          sources.push.apply(sources, args);\n        }\n\n        store.dispatch('ADD_ITEMS', {\n          items: sources,\n          index: options.index,\n          interactionMethod: InteractionMethod.API,\n          success: resolve,\n          failure: reject\n        });\n      });\n    };\n\n    var getFiles = function getFiles() {\n      return store.query('GET_ACTIVE_ITEMS');\n    };\n\n    var processFile = function processFile(query) {\n      return new Promise(function(resolve, reject) {\n        store.dispatch('REQUEST_ITEM_PROCESSING', {\n          query: query,\n          success: function success(item) {\n            resolve(item);\n          },\n          failure: function failure(error) {\n            reject(error);\n          }\n        });\n      });\n    };\n\n    var prepareFiles = function prepareFiles() {\n      for (\n        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2] = arguments[_key2];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      var items = queries.length ? queries : getFiles();\n      return Promise.all(items.map(prepareFile));\n    };\n\n    var processFiles = function processFiles() {\n      for (\n        var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;\n        _key3 < _len3;\n        _key3++\n      ) {\n        args[_key3] = arguments[_key3];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      if (!queries.length) {\n        var files = getFiles().filter(function(item) {\n          return (\n            !(\n              item.status === ItemStatus.IDLE &&\n              item.origin === FileOrigin.LOCAL\n            ) &&\n            item.status !== ItemStatus.PROCESSING &&\n            item.status !== ItemStatus.PROCESSING_COMPLETE &&\n            item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n          );\n        });\n\n        return Promise.all(files.map(processFile));\n      }\n      return Promise.all(queries.map(processFile));\n    };\n\n    var removeFiles = function removeFiles() {\n      for (\n        var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;\n        _key4 < _len4;\n        _key4++\n      ) {\n        args[_key4] = arguments[_key4];\n      }\n      var queries = Array.isArray(args[0]) ? args[0] : args;\n      var files = getFiles();\n\n      if (!queries.length) {\n        return Promise.all(files.map(removeFile));\n      }\n\n      // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n      var mappedQueries = queries\n        .map(function(query) {\n          return isNumber(query)\n            ? files[query]\n              ? files[query].id\n              : null\n            : query;\n        })\n        .filter(function(query) {\n          return query;\n        });\n\n      return mappedQueries.map(removeFile);\n    };\n\n    var exports = Object.assign(\n      {},\n\n      on(),\n      {},\n\n      readWriteApi,\n      {},\n\n      createOptionAPI(store, defaultOptions),\n      {\n        /**\n         * Override options defined in options object\n         * @param options\n         */\n        setOptions: setOptions,\n\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */\n        addFile: addFile,\n\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */\n        addFiles: addFiles,\n\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */\n        getFile: getFile,\n\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */\n        processFile: processFile,\n\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */\n        prepareFile: prepareFile,\n\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */\n        removeFile: removeFile,\n\n        /**\n         * Returns all files (wrapped in public api)\n         */\n        getFiles: getFiles,\n\n        /**\n         * Starts uploading all files\n         */\n        processFiles: processFiles,\n\n        /**\n         * Clears all files from the files list\n         */\n        removeFiles: removeFiles,\n\n        /**\n         * Starts preparing output of all files\n         */\n        prepareFiles: prepareFiles,\n\n        /**\n         * Sort list of files\n         */\n        sort: function sort(compare) {\n          return store.dispatch('SORT', { compare: compare });\n        },\n\n        /**\n         * Browse the file system for a file\n         */\n        browse: function browse() {\n          // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n          var input = view.element.querySelector('input[type=file]');\n          if (input) {\n            input.click();\n          }\n        },\n\n        /**\n         * Destroys the app\n         */\n        destroy: function destroy() {\n          // request destruction\n          exports.fire('destroy', view.element);\n\n          // stop active processes (file uploads, fetches, stuff like that)\n          // loop over items and depending on states call abort for ongoing processes\n          store.dispatch('ABORT_ALL');\n\n          // destroy view\n          view._destroy();\n\n          // stop listening to resize\n          window.removeEventListener('resize', resizeHandler);\n\n          // stop listening to the visiblitychange event\n          document.removeEventListener('visibilitychange', visibilityHandler);\n\n          // dispatch destroy\n          store.dispatch('DID_DESTROY');\n        },\n\n        /**\n         * Inserts the plugin before the target element\n         */\n        insertBefore: function insertBefore$1(element) {\n          return insertBefore(view.element, element);\n        },\n\n        /**\n         * Inserts the plugin after the target element\n         */\n        insertAfter: function insertAfter$1(element) {\n          return insertAfter(view.element, element);\n        },\n\n        /**\n         * Appends the plugin to the target element\n         */\n        appendTo: function appendTo(element) {\n          return element.appendChild(view.element);\n        },\n\n        /**\n         * Replaces an element with the app\n         */\n        replaceElement: function replaceElement(element) {\n          // insert the app before the element\n          insertBefore(view.element, element);\n\n          // remove the original element\n          element.parentNode.removeChild(element);\n\n          // remember original element\n          originalElement = element;\n        },\n\n        /**\n         * Restores the original element\n         */\n        restoreElement: function restoreElement() {\n          if (!originalElement) {\n            return; // no element to restore\n          }\n\n          // restore original element\n          insertAfter(originalElement, view.element);\n\n          // remove our element\n          view.element.parentNode.removeChild(view.element);\n\n          // remove reference\n          originalElement = null;\n        },\n\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */\n        isAttachedTo: function isAttachedTo(element) {\n          return view.element === element || originalElement === element;\n        },\n\n        /**\n         * Returns the root element\n         */\n        element: {\n          get: function get() {\n            return view.element;\n          }\n        },\n\n        /**\n         * Returns the current pond status\n         */\n        status: {\n          get: function get() {\n            return store.query('GET_STATUS');\n          }\n        }\n      }\n    );\n\n    // Done!\n    store.dispatch('DID_INIT');\n\n    // create actual api object\n    return createObject(exports);\n  };\n\n  var createAppObject = function createAppObject() {\n    var customOptions =\n      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // default options\n    var defaultOptions = {};\n    forin(getOptions(), function(key, value) {\n      defaultOptions[key] = value[0];\n    });\n\n    // set app options\n    var app = createApp(\n      Object.assign(\n        {},\n\n        defaultOptions,\n        {},\n\n        customOptions\n      )\n    );\n\n    // return the plugin instance\n    return app;\n  };\n\n  var lowerCaseFirstLetter = function lowerCaseFirstLetter(string) {\n    return string.charAt(0).toLowerCase() + string.slice(1);\n  };\n\n  var attributeNameToPropertyName = function attributeNameToPropertyName(\n    attributeName\n  ) {\n    return toCamels(attributeName.replace(/^data-/, ''));\n  };\n\n  var mapObject = function mapObject(object, propertyMap) {\n    // remove unwanted\n    forin(propertyMap, function(selector, mapping) {\n      forin(object, function(property, value) {\n        // create regexp shortcut\n        var selectorRegExp = new RegExp(selector);\n\n        // tests if\n        var matches = selectorRegExp.test(property);\n\n        // no match, skip\n        if (!matches) {\n          return;\n        }\n\n        // if there's a mapping, the original property is always removed\n        delete object[property];\n\n        // should only remove, we done!\n        if (mapping === false) {\n          return;\n        }\n\n        // move value to new property\n        if (isString(mapping)) {\n          object[mapping] = value;\n          return;\n        }\n\n        // move to group\n        var group = mapping.group;\n        if (isObject(mapping) && !object[group]) {\n          object[group] = {};\n        }\n\n        object[group][\n          lowerCaseFirstLetter(property.replace(selectorRegExp, ''))\n        ] = value;\n      });\n\n      // do submapping\n      if (mapping.mapping) {\n        mapObject(object[mapping.group], mapping.mapping);\n      }\n    });\n  };\n\n  var getAttributesAsObject = function getAttributesAsObject(node) {\n    var attributeMapping =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // turn attributes into object\n    var attributes = [];\n    forin(node.attributes, function(index) {\n      attributes.push(node.attributes[index]);\n    });\n\n    var output = attributes\n      .filter(function(attribute) {\n        return attribute.name;\n      })\n      .reduce(function(obj, attribute) {\n        var value = attr(node, attribute.name);\n\n        obj[attributeNameToPropertyName(attribute.name)] =\n          value === attribute.name ? true : value;\n        return obj;\n      }, {});\n\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n\n    return output;\n  };\n\n  var createAppAtElement = function createAppAtElement(element) {\n    var options =\n      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // how attributes of the input element are mapped to the options for the plugin\n    var attributeMapping = {\n      // translate to other name\n      '^class$': 'className',\n      '^multiple$': 'allowMultiple',\n      '^capture$': 'captureMethod',\n\n      // group under single property\n      '^server': {\n        group: 'server',\n        mapping: {\n          '^process': {\n            group: 'process'\n          },\n\n          '^revert': {\n            group: 'revert'\n          },\n\n          '^fetch': {\n            group: 'fetch'\n          },\n\n          '^restore': {\n            group: 'restore'\n          },\n\n          '^load': {\n            group: 'load'\n          }\n        }\n      },\n\n      // don't include in object\n      '^type$': false,\n      '^files$': false\n    };\n\n    // add additional option translators\n    applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n    // create final options object by setting options object and then overriding options supplied on element\n    var mergedOptions = Object.assign({}, options);\n\n    var attributeOptions = getAttributesAsObject(\n      element.nodeName === 'FIELDSET'\n        ? element.querySelector('input[type=file]')\n        : element,\n      attributeMapping\n    );\n\n    // merge with options object\n    Object.keys(attributeOptions).forEach(function(key) {\n      if (isObject(attributeOptions[key])) {\n        if (!isObject(mergedOptions[key])) {\n          mergedOptions[key] = {};\n        }\n        Object.assign(mergedOptions[key], attributeOptions[key]);\n      } else {\n        mergedOptions[key] = attributeOptions[key];\n      }\n    });\n\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(\n      Array.from(element.querySelectorAll('input:not([type=file])')).map(\n        function(input) {\n          return {\n            source: input.value,\n            options: {\n              type: input.dataset.type\n            }\n          };\n        }\n      )\n    );\n\n    // build plugin\n    var app = createAppObject(mergedOptions);\n\n    // add already selected files\n    if (element.files) {\n      Array.from(element.files).forEach(function(file) {\n        app.addFile(file);\n      });\n    }\n\n    // replace the target element\n    app.replaceElement(element);\n\n    // expose\n    return app;\n  };\n\n  // if an element is passed, we create the instance at that element, if not, we just create an up object\n  var createApp$1 = function createApp() {\n    return isNode(arguments.length <= 0 ? undefined : arguments[0])\n      ? createAppAtElement.apply(void 0, arguments)\n      : createAppObject.apply(void 0, arguments);\n  };\n\n  var PRIVATE_METHODS = ['fire', '_read', '_write'];\n\n  var createAppAPI = function createAppAPI(app) {\n    var api = {};\n\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n    return api;\n  };\n\n  /**\n   * Replaces placeholders in given string with replacements\n   * @param string - \"Foo {bar}\"\"\n   * @param replacements - { \"bar\": 10 }\n   */\n  var replaceInString = function replaceInString(string, replacements) {\n    return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {\n      return replacements[group];\n    });\n  };\n\n  var createWorker = function createWorker(fn) {\n    var workerBlob = new Blob(['(', fn.toString(), ')()'], {\n      type: 'application/javascript'\n    });\n\n    var workerURL = URL.createObjectURL(workerBlob);\n    var worker = new Worker(workerURL);\n\n    return {\n      transfer: function transfer(message, cb) {},\n      post: function post(message, cb, transferList) {\n        var id = getUniqueId();\n\n        worker.onmessage = function(e) {\n          if (e.data.id === id) {\n            cb(e.data.message);\n          }\n        };\n\n        worker.postMessage(\n          {\n            id: id,\n            message: message\n          },\n\n          transferList\n        );\n      },\n      terminate: function terminate() {\n        worker.terminate();\n        URL.revokeObjectURL(workerURL);\n      }\n    };\n  };\n\n  var loadImage = function loadImage(url) {\n    return new Promise(function(resolve, reject) {\n      var img = new Image();\n      img.onload = function() {\n        resolve(img);\n      };\n      img.onerror = function(e) {\n        reject(e);\n      };\n      img.src = url;\n    });\n  };\n\n  var renameFile = function renameFile(file, name) {\n    var renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n  };\n\n  var copyFile = function copyFile(file) {\n    return renameFile(file, file.name);\n  };\n\n  // already registered plugins (can't register twice)\n  var registeredPlugins = [];\n\n  // pass utils to plugin\n  var createAppPlugin = function createAppPlugin(plugin) {\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n      return;\n    }\n\n    // remember this plugin\n    registeredPlugins.push(plugin);\n\n    // setup!\n    var pluginOutline = plugin({\n      addFilter: addFilter,\n      utils: {\n        Type: Type,\n        forin: forin,\n        isString: isString,\n        isFile: isFile,\n        toNaturalFileSize: toNaturalFileSize,\n        replaceInString: replaceInString,\n        getExtensionFromFilename: getExtensionFromFilename,\n        getFilenameWithoutExtension: getFilenameWithoutExtension,\n        guesstimateMimeType: guesstimateMimeType,\n        getFileFromBlob: getFileFromBlob,\n        getFilenameFromURL: getFilenameFromURL,\n        createRoute: createRoute,\n        createWorker: createWorker,\n        createView: createView,\n        createItemAPI: createItemAPI,\n        loadImage: loadImage,\n        copyFile: copyFile,\n        renameFile: renameFile,\n        createBlob: createBlob,\n        applyFilterChain: applyFilterChain,\n        text: text,\n        getNumericAspectRatioFromString: getNumericAspectRatioFromString\n      },\n\n      views: {\n        fileActionButton: fileActionButton\n      }\n    });\n\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n  };\n\n  // feature detection used by supported() method\n  var isOperaMini = function isOperaMini() {\n    return (\n      Object.prototype.toString.call(window.operamini) === '[object OperaMini]'\n    );\n  };\n  var hasPromises = function hasPromises() {\n    return 'Promise' in window;\n  };\n  var hasBlobSlice = function hasBlobSlice() {\n    return 'slice' in Blob.prototype;\n  };\n  var hasCreateObjectURL = function hasCreateObjectURL() {\n    return 'URL' in window && 'createObjectURL' in window.URL;\n  };\n  var hasVisibility = function hasVisibility() {\n    return 'visibilityState' in document;\n  };\n  var hasTiming = function hasTiming() {\n    return 'performance' in window;\n  }; // iOS 8.x\n  var isBrowser = function isBrowser() {\n    return (\n      typeof window !== 'undefined' && typeof window.document !== 'undefined'\n    );\n  };\n\n  var supported = (function() {\n    // Runs immidiately and then remembers result for subsequent calls\n    var isSupported =\n      // Has to be a browser\n      isBrowser() &&\n      // Can't run on Opera Mini due to lack of everything\n      !isOperaMini() &&\n      // Require these APIs to feature detect a modern browser\n      hasVisibility() &&\n      hasPromises() &&\n      hasBlobSlice() &&\n      hasCreateObjectURL() &&\n      hasTiming();\n\n    return function() {\n      return isSupported;\n    };\n  })();\n\n  /**\n   * Plugin internal state (over all instances)\n   */\n  var state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: []\n  };\n\n  // plugin name\n  var name = 'filepond';\n\n  /**\n   * Public Plugin methods\n   */\n  var fn = function fn() {};\n  exports.Status = {};\n  exports.FileStatus = {};\n  exports.FileOrigin = {};\n  exports.OptionTypes = {};\n  exports.create = fn;\n  exports.destroy = fn;\n  exports.parse = fn;\n  exports.find = fn;\n  exports.registerPlugin = fn;\n  exports.getOptions = fn;\n  exports.setOptions = fn;\n\n  // if not supported, no API\n  if (supported()) {\n    // start painter and fire load event\n    createPainter(\n      function() {\n        state.apps.forEach(function(app) {\n          return app._read();\n        });\n      },\n      function(ts) {\n        state.apps.forEach(function(app) {\n          return app._write(ts);\n        });\n      }\n    );\n\n    // fire loaded event so we know when FilePond is available\n    var dispatch = function dispatch() {\n      // let others know we have area ready\n      document.dispatchEvent(\n        new CustomEvent('FilePond:loaded', {\n          detail: {\n            supported: supported,\n            create: exports.create,\n            destroy: exports.destroy,\n            parse: exports.parse,\n            find: exports.find,\n            registerPlugin: exports.registerPlugin,\n            setOptions: exports.setOptions\n          }\n        })\n      );\n\n      // clean up event\n      document.removeEventListener('DOMContentLoaded', dispatch);\n    };\n\n    if (document.readyState !== 'loading') {\n      // move to back of execution queue, FilePond should have been exported by then\n      setTimeout(function() {\n        return dispatch();\n      }, 0);\n    } else {\n      document.addEventListener('DOMContentLoaded', dispatch);\n    }\n\n    // updates the OptionTypes object based on the current options\n    var updateOptionTypes = function updateOptionTypes() {\n      return forin(getOptions(), function(key, value) {\n        exports.OptionTypes[key] = value[1];\n      });\n    };\n\n    exports.Status = Object.assign({}, Status);\n    exports.FileOrigin = Object.assign({}, FileOrigin);\n    exports.FileStatus = Object.assign({}, ItemStatus);\n\n    exports.OptionTypes = {};\n    updateOptionTypes();\n\n    // create method, creates apps and adds them to the app array\n    exports.create = function create() {\n      var app = createApp$1.apply(void 0, arguments);\n      app.on('destroy', exports.destroy);\n      state.apps.push(app);\n      return createAppAPI(app);\n    };\n\n    // destroys apps and removes them from the app array\n    exports.destroy = function destroy(hook) {\n      // returns true if the app was destroyed successfully\n      var indexToRemove = state.apps.findIndex(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (indexToRemove >= 0) {\n        // remove from apps\n        var app = state.apps.splice(indexToRemove, 1)[0];\n\n        // restore original dom element\n        app.restoreElement();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    // parses the given context for plugins (does not include the context element itself)\n    exports.parse = function parse(context) {\n      // get all possible hooks\n      var matchedHooks = Array.from(context.querySelectorAll('.' + name));\n\n      // filter out already active hooks\n      var newHooks = matchedHooks.filter(function(newHook) {\n        return !state.apps.find(function(app) {\n          return app.isAttachedTo(newHook);\n        });\n      });\n\n      // create new instance for each hook\n      return newHooks.map(function(hook) {\n        return exports.create(hook);\n      });\n    };\n\n    // returns an app based on the given element hook\n    exports.find = function find(hook) {\n      var app = state.apps.find(function(app) {\n        return app.isAttachedTo(hook);\n      });\n      if (!app) {\n        return null;\n      }\n      return createAppAPI(app);\n    };\n\n    // adds a plugin extension\n    exports.registerPlugin = function registerPlugin() {\n      for (\n        var _len = arguments.length, plugins = new Array(_len), _key = 0;\n        _key < _len;\n        _key++\n      ) {\n        plugins[_key] = arguments[_key];\n      }\n\n      // register plugins\n      plugins.forEach(createAppPlugin);\n\n      // update OptionTypes, each plugin might have extended the default options\n      updateOptionTypes();\n    };\n\n    exports.getOptions = function getOptions$1() {\n      var opts = {};\n      forin(getOptions(), function(key, value) {\n        opts[key] = value[0];\n      });\n      return opts;\n    };\n\n    exports.setOptions = function setOptions$1(opts) {\n      if (isObject(opts)) {\n        // update existing plugins\n        state.apps.forEach(function(app) {\n          app.setOptions(opts);\n        });\n\n        // override defaults\n        setOptions(opts);\n      }\n\n      // return new options\n      return exports.getOptions();\n    };\n  }\n\n  exports.supported = supported;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/filepond/dist/filepond.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/extend.js":
/*!***********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/extend.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n/* eslint no-restricted-syntax: 0 */\nvar extend = function extend(target) {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 0; index < sources.length; index++) {\n        var source = sources[index];\n        if (source !== undefined && source !== null) {\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    output[key] = source[key];\n                }\n            }\n        }\n    }\n    return output;\n};\n\nexports['default'] = extend;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/extend.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/flatten.js":
/*!************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/flatten.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extend = __webpack_require__(/*! ./extend */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/extend.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _node = __webpack_require__(/*! ./node */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/node.js\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// @param {object|array} nodes The tree nodes\n// @param {object} [options] The options object\n// @param {boolean} [options.openAllNodes] True to open all nodes. Defaults to false.\n// @param {array} [options.openNodes] An array that contains the ids of open nodes\n// @return {array}\n/* eslint no-console: 0 */\nvar flatten = function flatten() {\n    var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    nodes = [].concat(nodes);\n\n    var flatten = [];\n    var stack = [];\n    var pool = {\n        lastChild: {}\n    };\n\n    options.openAllNodes = !!options.openAllNodes;\n    options.openNodes = options.openNodes || [];\n    options.throwOnError = !!options.throwOnError;\n\n    {\n        // root node\n        var firstNode = nodes.length > 0 ? nodes[0] : null;\n        var parentNode = firstNode ? firstNode.parent : null;\n        if (parentNode && !(parentNode instanceof _node2['default'])) {\n            parentNode = new _node2['default'](parentNode);\n        }\n        var rootNode = parentNode || new _node2['default']({ // defaults\n            parent: null,\n            children: nodes,\n            state: {\n                depth: -1,\n                open: true, // always open\n                path: '',\n                prefixMask: '',\n                total: 0\n            }\n        });\n\n        if (rootNode === parentNode) {\n            var subtotal = rootNode.state.total || 0;\n\n            // Traversing up through its ancestors\n            var p = rootNode;\n            while (p) {\n                var _p$state = p.state,\n                    path = _p$state.path,\n                    _p$state$total = _p$state.total,\n                    total = _p$state$total === undefined ? 0 : _p$state$total;\n\n                // Rebuild the lastChild pool\n\n                if (p.isLastChild() && path) {\n                    pool.lastChild[path] = true;\n                }\n\n                // Subtract the number 'subtotal' from the total of the root node and all its ancestors\n                p.state.total = total - subtotal;\n                if (p.state.total < 0) {\n                    if (options.throwOnError) {\n                        throw new Error('The node might have been corrupted: id=' + JSON.stringify(p.id) + ', state=' + JSON.stringify(p.state));\n                    } else {\n                        console && console.log('Error: The node might have been corrupted: id=%s, parent=%s, children=%s, state=%s', JSON.stringify(p.id), p.parent, p.children, JSON.stringify(p.state));\n                    }\n                }\n\n                p = p.parent;\n            }\n        }\n\n        stack.push([rootNode, rootNode.state.depth, 0]);\n    }\n\n    while (stack.length > 0) {\n        var _stack$pop = stack.pop(),\n            current = _stack$pop[0],\n            depth = _stack$pop[1],\n            index = _stack$pop[2];\n\n        var _loop = function _loop() {\n            var node = current.children[index];\n            if (!(node instanceof _node2['default'])) {\n                node = new _node2['default'](node);\n            }\n            node.parent = current;\n            node.children = node.children || [];\n\n            // Ensure parent.children[index] is equal to the current node\n            node.parent.children[index] = node;\n\n            var path = current.state.path + '.' + index;\n            var open = node.hasChildren() && function () {\n                var openAllNodes = options.openAllNodes,\n                    openNodes = options.openNodes;\n\n                if (openAllNodes) {\n                    return true;\n                }\n                // determine by node object\n                if (openNodes.indexOf(node) >= 0) {\n                    return true;\n                }\n                // determine by node id\n                if (openNodes.indexOf(node.id) >= 0) {\n                    return true;\n                }\n                return false;\n            }();\n            var prefixMask = function (prefix) {\n                var mask = '';\n                while (prefix.length > 0) {\n                    prefix = prefix.replace(/\\.\\d+$/, '');\n                    if (!prefix || pool.lastChild[prefix]) {\n                        mask = '0' + mask;\n                    } else {\n                        mask = '1' + mask;\n                    }\n                }\n                return mask;\n            }(path);\n\n            if (node.isLastChild()) {\n                pool.lastChild[path] = true;\n            }\n\n            // This allows you to put extra information to node.state\n            node.state = (0, _extend2['default'])({}, node.state, {\n                depth: depth + 1,\n                open: open,\n                path: path,\n                prefixMask: prefixMask,\n                total: 0\n            });\n\n            var parentDidOpen = true;\n\n            {\n                // Check the open state from its ancestors\n                var _p = node;\n                while (_p.parent !== null) {\n                    if (_p.parent.state.open === false) {\n                        parentDidOpen = false;\n                        break;\n                    }\n                    _p = _p.parent;\n                }\n            }\n\n            if (parentDidOpen) {\n                // Push the node to flatten list only if all of its parent nodes have the open state set to true\n                flatten.push(node);\n\n                // Update the total number of visible child nodes\n                var _p2 = node;\n                while (_p2.parent !== null) {\n                    _p2.parent.state.total++;\n                    _p2 = _p2.parent;\n                }\n            }\n\n            ++index;\n\n            if (node.hasChildren()) {\n                // Push back parent node to the stack that will be able to continue\n                // the next iteration once all the child nodes of the current node\n                // have been completely explored.\n                stack.push([current, depth, index]);\n\n                index = 0;\n                depth = depth + 1;\n                current = node;\n            }\n        };\n\n        while (index < current.children.length) {\n            _loop();\n        }\n    }\n\n    return flatten;\n};\n\nexports['default'] = flatten;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/flatten.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/index.js":
/*!**********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/index.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.Node = exports.flatten = undefined;\n\nvar _flatten = __webpack_require__(/*! ./flatten */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/flatten.js\");\n\nvar _flatten2 = _interopRequireDefault(_flatten);\n\nvar _node = __webpack_require__(/*! ./node */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/node.js\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// IE8 compatibility output\nexports.flatten = _flatten2['default'];\nexports.Node = _node2['default'];\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/node.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/node.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extend = __webpack_require__(/*! ./extend */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/extend.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function () {\n    function Node(node) {\n        _classCallCheck(this, Node);\n\n        this.id = null;\n        this.parent = null;\n        this.children = [];\n        this.state = {};\n\n        (0, _extend2['default'])(this, node);\n\n        this.children = this.children || [];\n    }\n    // Returns a boolean value indicating whether a node is a descendant of a given node or not.\n    // @param {object} node Specifies the node that may be contained by (a descendant of) a specified node.\n    // @return {boolean} Returns true if a node is a descendant of a specified node, otherwise false. A descendant can be a child, grandchild, great-grandchild, and so on.\n\n\n    Node.prototype.contains = function contains(node) {\n        while (node instanceof Node && node !== this) {\n            if (node.parent === this) {\n                return true;\n            }\n            node = node.parent;\n        }\n        return false;\n    };\n    // Gets a child node at the specified index.\n    // @param {number} The index of the child node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getChildAt = function getChildAt(index) {\n        var node = null;\n        if (this.children.length > 0 && index >= 0 && index < this.children.length) {\n            node = this.children[index];\n        }\n        return node;\n    };\n    // Gets the child nodes.\n    // @return {array} Returns an array of objects that define the nodes.\n\n\n    Node.prototype.getChildren = function getChildren() {\n        return this.children;\n    };\n    // Gets the first child node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getFirstChild = function getFirstChild() {\n        var node = null;\n        if (this.children.length > 0) {\n            node = this.children[0];\n        }\n        return node;\n    };\n    // Gets the last child node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getLastChild = function getLastChild() {\n        var node = null;\n        if (this.children.length > 0) {\n            node = this.children[this.children.length - 1];\n        }\n        return node;\n    };\n    // Gets the next sibling node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getNextSibling = function getNextSibling() {\n        var node = null;\n        if (this.parent) {\n            var index = this.parent.children.indexOf(this);\n            if (index >= 0 && index < this.parent.children.length - 1) {\n                node = this.parent.children[index + 1];\n            }\n        }\n        return node;\n    };\n    // Gets the parent node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getParent = function getParent() {\n        return this.parent;\n    };\n    // Gets the previous sibling node.\n    // @return {object} Returns an object that defines the node, null otherwise.\n\n\n    Node.prototype.getPreviousSibling = function getPreviousSibling() {\n        var node = null;\n        if (this.parent) {\n            var index = this.parent.children.indexOf(this);\n            if (index > 0 && index < this.parent.children.length) {\n                node = this.parent.children[index - 1];\n            }\n        }\n        return node;\n    };\n    // Checks whether this node has children.\n    // @return {boolean} Returns true if the node has children, false otherwise.\n\n\n    Node.prototype.hasChildren = function hasChildren() {\n        return this.children.length > 0;\n    };\n    // Checks whether this node is the last child of its parent.\n    // @return {boolean} Returns true if the node is the last child of its parent, false otherwise.\n\n\n    Node.prototype.isLastChild = function isLastChild() {\n        var hasNextSibling = this.getNextSibling();\n        return !hasNextSibling;\n    };\n\n    return Node;\n}();\n\nexports['default'] = Node;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/node.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/html5-tag/lib/index.js":
/*!***********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/html5-tag/lib/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _escapeHtml = __webpack_require__(/*! escape-html */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js\");\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// https://www.w3.org/TR/html5/syntax.html#void-elements\n// Void elements only have a start tag; end tags must not be specified for void elements.\nvar voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\n// @param {string} [tag] The tag name. Defaults to 'div'.\n// @param {object} attrs HTML attributes.\n// @param {string} [text] The content string.\nmodule.exports = function (tag, attrs, text) {\n    if ((typeof tag === 'undefined' ? 'undefined' : _typeof(tag)) === 'object') {\n        text = attrs;\n        attrs = tag;\n        tag = 'div';\n    }\n\n    var voidElement = voidElements.indexOf(('' + tag).toLowerCase()) >= 0;\n    var html = '<' + tag;\n\n    attrs = _extends({}, attrs);\n    Object.keys(attrs).forEach(function (name) {\n        var value = attrs[name];\n        if (typeof value === 'string') {\n            value = (0, _escapeHtml2.default)('' + value);\n            html += ' ' + name + '=\"' + value + '\"';\n        } else if (!!value) {\n            html += ' ' + name;\n        }\n    });\n\n    if (voidElement) {\n        html += '>';\n    } else if (text !== undefined) {\n        html += '>' + text + '</' + tag + '>';\n    } else {\n        html += '/>';\n    }\n\n    return html;\n};\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/html5-tag/lib/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/dist/infinite-tree.css":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/dist/infinite-tree.css ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/dist/infinite-tree.css?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/browser.js":
/*!*****************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/browser.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n// https://gist.github.com/padolsey/527683#comment-786682\nvar getIEVersion = exports.getIEVersion = function getIEVersion() {\n    var div = document.createElement('div');\n    var all = div.getElementsByTagName('i') || [];\n\n    var v = 3;\n    do {\n        ++v;\n        div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->';\n    } while (all[0]);\n\n    return v > 4 ? v : document.documentMode;\n};\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/browser.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/clusterize.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/clusterize.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _ensureArray = __webpack_require__(/*! ./ensure-array */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/ensure-array.js\");\n\nvar _ensureArray2 = _interopRequireDefault(_ensureArray);\n\nvar _browser = __webpack_require__(/*! ./browser */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/browser.js\");\n\nvar _dom = __webpack_require__(/*! ./dom */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/dom.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ie = (0, _browser.getIEVersion)();\n\nvar Clusterize = function (_EventEmitter) {\n    _inherits(Clusterize, _EventEmitter);\n\n    function Clusterize(options) {\n        _classCallCheck(this, Clusterize);\n\n        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n        _this.options = {\n            rowsInBlock: 50,\n            blocksInCluster: 4,\n            tag: null,\n            emptyClass: '',\n            emptyText: '',\n            keepParity: true\n        };\n        _this.state = {\n            lastClusterIndex: -1,\n            itemHeight: 0,\n            blockHeight: 0,\n            clusterHeight: 0\n        };\n        _this.scrollElement = null;\n        _this.contentElement = null;\n        _this.rows = [];\n        _this.cache = {};\n\n        _this.scrollEventListener = function () {\n            var debounce = null;\n\n            return function () {\n                var isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;\n                if (isMac) {\n                    if (_this.contentElement.style.pointerEvents !== 'none') {\n                        _this.contentElement.style.pointerEvents = 'none';\n                    }\n\n                    if (debounce) {\n                        clearTimeout(debounce);\n                        debounce = null;\n                    }\n\n                    debounce = setTimeout(function () {\n                        debounce = null;\n                        _this.contentElement.style.pointerEvents = 'auto';\n                    }, 50);\n                }\n\n                var clusterIndex = _this.getCurrentClusterIndex();\n                if (_this.state.lastClusterIndex !== clusterIndex) {\n                    _this.changeDOM();\n                }\n                _this.state.lastClusterIndex = clusterIndex;\n            };\n        }();\n\n        _this.resizeEventListener = function () {\n            var debounce = null;\n\n            return function () {\n                if (debounce) {\n                    clearTimeout(debounce);\n                    debounce = null;\n                }\n                debounce = setTimeout(function () {\n                    var prevItemHeight = _this.state.itemHeight;\n                    var current = _this.computeHeight();\n\n                    if (current.itemHeight > 0 && prevItemHeight !== current.itemHeight) {\n                        _this.state = _extends({}, _this.state, current);\n                        _this.update(_this.rows);\n                    }\n                }, 100);\n            };\n        }();\n\n        if (!(_this instanceof Clusterize)) {\n            var _ret;\n\n            return _ret = new Clusterize(options), _possibleConstructorReturn(_this, _ret);\n        }\n\n        _this.options = Object.keys(_this.options).reduce(function (acc, key) {\n            if (options[key] !== undefined) {\n                acc[key] = options[key];\n            } else {\n                acc[key] = _this.options[key];\n            }\n            return acc;\n        }, {});\n\n        _this.scrollElement = options.scrollElement;\n        _this.contentElement = options.contentElement;\n\n        // Keep focus on the scrolling content\n        if (!_this.contentElement.hasAttribute('tabindex')) {\n            _this.contentElement.setAttribute('tabindex', 0);\n        }\n\n        if (Array.isArray(options.rows)) {\n            _this.rows = options.rows;\n        } else {\n            _this.rows = [];\n\n            var nodes = _this.contentElement.children;\n            var length = nodes.length;\n            for (var i = 0; i < length; ++i) {\n                var node = nodes[i];\n                _this.rows.push(node.outerHTML || '');\n            }\n        }\n\n        // Remember scroll position\n        var scrollTop = _this.scrollElement.scrollTop;\n\n        _this.changeDOM();\n\n        // Restore scroll position\n        _this.scrollElement.scrollTop = scrollTop;\n\n        (0, _dom.addEventListener)(_this.scrollElement, 'scroll', _this.scrollEventListener);\n        (0, _dom.addEventListener)(window, 'resize', _this.resizeEventListener);\n        return _this;\n    }\n\n    Clusterize.prototype.destroy = function destroy(clean) {\n        (0, _dom.removeEventListener)(this.scrollElement, 'scroll', this.scrollEventListener);\n        (0, _dom.removeEventListener)(window, 'resize', this.resizeEventListener);\n\n        var rows = clean ? this.generateEmptyRow() : this.rows();\n        this.setContent(rows.join(''));\n    };\n\n    Clusterize.prototype.update = function update(rows) {\n        this.rows = (0, _ensureArray2['default'])(rows);\n\n        // Remember scroll position\n        var scrollTop = this.scrollElement.scrollTop;\n\n        if (this.rows.length * this.state.itemHeight < scrollTop) {\n            this.scrollElement.scrollTop = 0;\n            this.state.lastClusterIndex = 0;\n        }\n        this.changeDOM();\n\n        // Restore scroll position\n        this.scrollElement.scrollTop = scrollTop;\n    };\n\n    Clusterize.prototype.clear = function clear() {\n        this.rows = [];\n        this.update();\n    };\n\n    Clusterize.prototype.append = function append(rows) {\n        rows = (0, _ensureArray2['default'])(rows);\n        if (!rows.length) {\n            return;\n        }\n        this.rows = this.rows.concat(rows);\n        this.changeDOM();\n    };\n\n    Clusterize.prototype.prepend = function prepend(rows) {\n        rows = (0, _ensureArray2['default'])(rows);\n        if (!rows.length) {\n            return;\n        }\n        this.rows = rows.concat(this.rows);\n        this.changeDOM();\n    };\n\n    Clusterize.prototype.computeHeight = function computeHeight() {\n        if (!this.rows.length) {\n            return {\n                clusterHeight: 0,\n                blockHeight: this.state.blockHeight,\n                itemHeight: this.state.itemHeight\n            };\n        } else {\n            var nodes = this.contentElement.children;\n            var node = nodes[Math.floor(nodes.length / 2)];\n\n            var itemHeight = node.offsetHeight;\n\n            if (this.options.tag === 'tr' && (0, _dom.getElementStyle)(this.contentElement, 'borderCollapse') !== 'collapse') {\n                itemHeight += parseInt((0, _dom.getElementStyle)(this.contentElement, 'borderSpacing'), 10) || 0;\n            }\n\n            if (this.options.tag !== 'tr') {\n                var marginTop = parseInt((0, _dom.getElementStyle)(node, 'marginTop'), 10) || 0;\n                var marginBottom = parseInt((0, _dom.getElementStyle)(node, 'marginBottom'), 10) || 0;\n                itemHeight += Math.max(marginTop, marginBottom);\n            }\n\n            var blockHeight = itemHeight * this.options.rowsInBlock;\n            var clusterHeight = blockHeight * this.options.blocksInCluster;\n\n            return {\n                itemHeight: itemHeight,\n                blockHeight: blockHeight,\n                clusterHeight: clusterHeight\n            };\n        }\n    };\n\n    Clusterize.prototype.getCurrentClusterIndex = function getCurrentClusterIndex() {\n        var _state = this.state,\n            blockHeight = _state.blockHeight,\n            clusterHeight = _state.clusterHeight;\n\n        if (!blockHeight || !clusterHeight) {\n            return 0;\n        }\n        return Math.floor(this.scrollElement.scrollTop / (clusterHeight - blockHeight)) || 0;\n    };\n\n    Clusterize.prototype.generateEmptyRow = function generateEmptyRow() {\n        var _options = this.options,\n            tag = _options.tag,\n            emptyText = _options.emptyText,\n            emptyClass = _options.emptyClass;\n\n\n        if (!tag || !emptyText) {\n            return [];\n        }\n\n        var emptyRow = document.createElement(tag);\n        emptyRow.className = emptyClass;\n\n        if (tag === 'tr') {\n            var td = document.createElement('td');\n            td.colSpan = 100;\n            td.appendChild(document.createTextNode(emptyText));\n            emptyRow.appendChild(td);\n        } else {\n            emptyRow.appendChild(document.createTextNode(emptyText));\n        }\n\n        return [emptyRow.outerHTML];\n    };\n\n    Clusterize.prototype.renderExtraTag = function renderExtraTag(className, height) {\n        var tag = document.createElement(this.options.tag);\n        var prefix = 'infinite-tree-';\n\n        tag.className = [prefix + 'extra-row', prefix + className].join(' ');\n\n        if (height) {\n            tag.style.height = height + 'px';\n        }\n\n        return tag.outerHTML;\n    };\n\n    Clusterize.prototype.changeDOM = function changeDOM() {\n        if (!this.state.clusterHeight && this.rows.length > 0) {\n            if (ie && ie <= 9 && !this.options.tag) {\n                this.options.tag = this.rows[0].match(/<([^>\\s/]*)/)[1].toLowerCase();\n            }\n\n            if (this.contentElement.children.length <= 1) {\n                this.cache.content = this.setContent(this.rows[0] + this.rows[0] + this.rows[0]);\n            }\n\n            if (!this.options.tag) {\n                this.options.tag = this.contentElement.children[0].tagName.toLowerCase();\n            }\n\n            this.state = _extends({}, this.state, this.computeHeight());\n        }\n\n        var topOffset = 0;\n        var bottomOffset = 0;\n        var rows = [];\n\n        if (this.rows.length < this.options.rowsInBlock) {\n            rows = this.rows.length > 0 ? this.rows : this.generateEmptyRow();\n        } else {\n            var rowsInCluster = this.options.rowsInBlock * this.options.blocksInCluster;\n            var clusterIndex = this.getCurrentClusterIndex();\n            var visibleStart = Math.max((rowsInCluster - this.options.rowsInBlock) * clusterIndex, 0);\n            var visibleEnd = visibleStart + rowsInCluster;\n\n            topOffset = Math.max(visibleStart * this.state.itemHeight, 0);\n            bottomOffset = Math.max((this.rows.length - visibleEnd) * this.state.itemHeight, 0);\n\n            // Returns a shallow copy of the rows selected from `visibleStart` to `visibleEnd` (`visibleEnd` not included).\n            rows = this.rows.slice(visibleStart, visibleEnd);\n        }\n\n        var content = rows.join('');\n        var contentChanged = this.checkChanges('content', content);\n        var topOffsetChanged = this.checkChanges('top', topOffset);\n        var bottomOffsetChanged = this.checkChanges('bottom', bottomOffset);\n\n        if (contentChanged || topOffsetChanged) {\n            var layout = [];\n\n            if (topOffset > 0) {\n                if (this.options.keepParity) {\n                    layout.push(this.renderExtraTag('keep-parity'));\n                }\n                layout.push(this.renderExtraTag('top-space', topOffset));\n            }\n\n            layout.push(content);\n\n            if (bottomOffset > 0) {\n                layout.push(this.renderExtraTag('bottom-space', bottomOffset));\n            }\n\n            this.emit('clusterWillChange');\n\n            this.setContent(layout.join(''));\n\n            this.emit('clusterDidChange');\n        } else if (bottomOffsetChanged) {\n            this.contentElement.lastChild.style.height = bottomOffset + 'px';\n        }\n    };\n\n    Clusterize.prototype.setContent = function setContent(content) {\n        // For IE 9 and older versions\n        if (ie && ie <= 9 && this.options.tag === 'tr') {\n            var div = document.createElement('div');\n            div.innerHTML = '<table><tbody>' + content + '</tbody></table>';\n\n            var lastChild = this.contentElement.lastChild;\n            while (lastChild) {\n                this.contentElement.removeChild(lastChild);\n                lastChild = this.contentElement.lastChild;\n            }\n\n            var rowsNodes = this.getChildNodes(div.firstChild.firstChild);\n            while (rowsNodes.length) {\n                this.contentElement.appendChild(rowsNodes.shift());\n            }\n        } else {\n            this.contentElement.innerHTML = content;\n        }\n    };\n\n    Clusterize.prototype.getChildNodes = function getChildNodes(tag) {\n        var childNodes = tag.children;\n        var nodes = [];\n        var length = childNodes.length;\n\n        for (var i = 0; i < length; i++) {\n            nodes.push(childNodes[i]);\n        }\n\n        return nodes;\n    };\n\n    Clusterize.prototype.checkChanges = function checkChanges(type, value) {\n        var changed = value !== this.cache[type];\n        this.cache[type] = value;\n        return changed;\n    };\n\n    return Clusterize;\n}(_events.EventEmitter);\n\nexports['default'] = Clusterize;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/clusterize.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/dom.js":
/*!*************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/dom.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nvar getElementStyle = function getElementStyle(el, prop) {\n    return window.getComputedStyle ? window.getComputedStyle(el)[prop] : el.currentStyle[prop];\n};\n\nvar preventDefault = function preventDefault(e) {\n    if (typeof e.preventDefault !== 'undefined') {\n        e.preventDefault();\n    } else {\n        e.returnValue = false;\n    }\n};\n\nvar stopPropagation = function stopPropagation(e) {\n    if (typeof e.stopPropagation !== 'undefined') {\n        e.stopPropagation();\n    } else {\n        e.cancelBubble = true;\n    }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Compatibility\nvar addEventListener = function addEventListener(target, type, listener) {\n    if (target.addEventListener) {\n        // Standard\n        target.addEventListener(type, listener, false);\n    } else if (target.attachEvent) {\n        // IE8\n        // In Internet Explorer versions before IE 9, you have to use attachEvent rather than the standard addEventListener.\n        target.attachEvent('on' + type, listener);\n    }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\nvar removeEventListener = function removeEventListener(target, type, listener) {\n    if (target.removeEventListener) {\n        // Standard\n        target.removeEventListener(type, listener, false);\n    } else if (target.detachEvent) {\n        // IE8\n        // In Internet Explorer versions before IE 9, you have to use detachEvent rather than the standard removeEventListener.\n        target.detachEvent('on' + type, listener);\n    }\n};\n\nexports.getElementStyle = getElementStyle;\nexports.preventDefault = preventDefault;\nexports.stopPropagation = stopPropagation;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/dom.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/ensure-array.js":
/*!**********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/ensure-array.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nvar ensureArray = function ensureArray() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    if (args.length === 0 || args[0] === undefined || args[0] === null) {\n        return [];\n    }\n    if (args.length === 1) {\n        return [].concat(args[0]);\n    }\n    return [].concat(args);\n};\n\nexports[\"default\"] = ensureArray;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/ensure-array.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/extend.js":
/*!****************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/extend.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint no-restricted-syntax: 0 */\nvar extend = function extend(target) {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 0; index < sources.length; index++) {\n        var source = sources[index];\n        if (source !== undefined && source !== null) {\n            for (var key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    output[key] = source[key];\n                }\n            }\n        }\n    }\n    return output;\n};\n\nmodule.exports = extend;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/extend.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/index.js":
/*!***************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _infiniteTree = __webpack_require__(/*! ./infinite-tree */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/infinite-tree.js\");\n\nvar _infiniteTree2 = _interopRequireDefault(_infiniteTree);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nmodule.exports = _infiniteTree2['default'];\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/infinite-tree.js":
/*!***********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/infinite-tree.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _classnames = __webpack_require__(/*! classnames */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/classnames/index.js\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _elementClass = __webpack_require__(/*! element-class */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/element-class/index.js\");\n\nvar _elementClass2 = _interopRequireDefault(_elementClass);\n\nvar _isDom = __webpack_require__(/*! is-dom */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/is-dom/index.js\");\n\nvar _isDom2 = _interopRequireDefault(_isDom);\n\nvar _flattree = __webpack_require__(/*! flattree */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/flattree/lib/index.js\");\n\nvar _clusterize = __webpack_require__(/*! ./clusterize */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/clusterize.js\");\n\nvar _clusterize2 = _interopRequireDefault(_clusterize);\n\nvar _ensureArray = __webpack_require__(/*! ./ensure-array */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/ensure-array.js\");\n\nvar _ensureArray2 = _interopRequireDefault(_ensureArray);\n\nvar _extend = __webpack_require__(/*! ./extend */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/extend.js\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _utilities = __webpack_require__(/*! ./utilities */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/utilities.js\");\n\nvar _lookupTable = __webpack_require__(/*! ./lookup-table */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/lookup-table.js\");\n\nvar _lookupTable2 = _interopRequireDefault(_lookupTable);\n\nvar _renderer = __webpack_require__(/*! ./renderer */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/renderer.js\");\n\nvar _dom = __webpack_require__(/*! ./dom */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/dom.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-continue: 0 */\n/* eslint operator-assignment: 0 */\n\n\nvar noop = function noop() {};\n\nvar error = function error(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Error: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n    });\n\n    if (console && console.error) {\n        console.error(message);\n    }\n    try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this error to fire.\n        throw new Error(message);\n    } catch (e) {\n        // Ignore\n    }\n};\n\nvar ensureNodeInstance = function ensureNodeInstance(node) {\n    if (!node) {\n        // undefined or null\n        return false;\n    }\n    if (!(node instanceof _flattree.Node)) {\n        error('The node must be a Node object.');\n        return false;\n    }\n    return true;\n};\n\nvar createRootNode = function createRootNode(rootNode) {\n    return (0, _extend2['default'])(rootNode || new _flattree.Node(), {\n        parent: null,\n        children: [],\n        state: {\n            depth: -1,\n            open: true, // always open\n            path: '',\n            prefixMask: '',\n            total: 0\n        }\n    });\n};\n\nvar InfiniteTree = function (_events$EventEmitter) {\n    _inherits(InfiniteTree, _events$EventEmitter);\n\n    // Creates new InfiniteTree object.\n    function InfiniteTree(el, options) {\n        _classCallCheck(this, InfiniteTree);\n\n        var _this = _possibleConstructorReturn(this, _events$EventEmitter.call(this));\n\n        _this.options = {\n            autoOpen: false,\n            droppable: false,\n            shouldLoadNodes: null,\n            loadNodes: null,\n            rowRenderer: _renderer.defaultRowRenderer,\n            selectable: true,\n            shouldSelectNode: null,\n\n            // When el is not specified, the tree will run in the stealth mode\n            el: null,\n\n            // The following options will have no effect in the stealth mode\n            layout: 'div',\n            noDataClass: 'infinite-tree-no-data',\n            noDataText: 'No data',\n            nodeIdAttr: 'data-id',\n            togglerClass: 'infinite-tree-toggler'\n        };\n        _this.state = {\n            openNodes: [],\n            rootNode: createRootNode(),\n            selectedNode: null\n        };\n        _this.clusterize = null;\n        _this.nodeTable = new _lookupTable2['default']();\n        _this.nodes = [];\n        _this.rows = [];\n        _this.filtered = false;\n        _this.scrollElement = null;\n        _this.contentElement = null;\n        _this.draggableTarget = null;\n        _this.droppableTarget = null;\n        _this.contentListener = {\n            'click': function click(event) {\n                event = event || window.event;\n\n                // Wrap stopPropagation that allows click event handler to stop execution\n                // by setting the cancelBubble property\n                var stopPropagation = event.stopPropagation;\n                event.stopPropagation = function () {\n                    // Setting the cancelBubble property in browsers that don't support it doesn't hurt.\n                    // Of course it doesn't actually cancel the bubbling, but the assignment itself is safe.\n                    event.cancelBubble = true;\n\n                    if (stopPropagation) {\n                        stopPropagation.call(event);\n                    }\n                };\n\n                // Call setTimeout(fn, 0) to re-queues the execution of subsequent calls, it allows the\n                // click event to bubble up to higher level event handlers before handling tree events.\n                setTimeout(function () {\n                    // Stop execution if the cancelBubble property is set to true by higher level event handlers\n                    if (event.cancelBubble === true) {\n                        return;\n                    }\n\n                    // Emit a \"click\" event\n                    _this.emit('click', event);\n\n                    // Stop execution if the cancelBubble property is set to true after emitting the click event\n                    if (event.cancelBubble === true) {\n                        return;\n                    }\n\n                    var itemTarget = null;\n                    var clickToggler = false;\n\n                    if (event.target) {\n                        itemTarget = event.target !== event.currentTarget ? event.target : null;\n                    } else if (event.srcElement) {\n                        // IE8\n                        itemTarget = event.srcElement;\n                    }\n\n                    while (itemTarget && itemTarget.parentElement !== _this.contentElement) {\n                        if ((0, _elementClass2['default'])(itemTarget).has(_this.options.togglerClass)) {\n                            clickToggler = true;\n                        }\n                        itemTarget = itemTarget.parentElement;\n                    }\n\n                    if (!itemTarget || itemTarget.hasAttribute('disabled')) {\n                        return;\n                    }\n\n                    var id = itemTarget.getAttribute(_this.options.nodeIdAttr);\n                    var node = _this.getNodeById(id);\n                    if (!node) {\n                        return;\n                    }\n\n                    // Click on the toggler to open/close a tree node\n                    if (clickToggler) {\n                        _this.toggleNode(node, { async: true });\n                        return;\n                    }\n\n                    _this.selectNode(node); // selectNode will re-render the tree\n                }, 0);\n            },\n            'dblclick': function dblclick(event) {\n                // Emit a \"doubleClick\" event\n                _this.emit('doubleClick', event);\n            },\n            'keydown': function keydown(event) {\n                // Emit a \"keyDown\" event\n                _this.emit('keyDown', event);\n            },\n            'keyup': function keyup(event) {\n                // Emit a \"keyUp\" event\n                _this.emit('keyUp', event);\n            },\n            // https://developer.mozilla.org/en-US/docs/Web/Events/dragstart\n            // The dragstart event is fired when the user starts dragging an element or text selection.\n            'dragstart': function dragstart(event) {\n                event = event || window.event;\n\n                _this.draggableTarget = event.target || event.srcElement;\n            },\n            // https://developer.mozilla.org/en-US/docs/Web/Events/dragend\n            // The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key).\n            'dragend': function dragend(event) {\n                event = event || window.event;\n\n                var _this$options$droppab = _this.options.droppable.hoverClass,\n                    hoverClass = _this$options$droppab === undefined ? '' : _this$options$droppab;\n\n                // Draggable\n\n                _this.draggableTarget = null;\n\n                // Droppable\n                if (_this.droppableTarget) {\n                    (0, _elementClass2['default'])(_this.droppableTarget).remove(hoverClass);\n                    _this.droppableTarget = null;\n                }\n            },\n            // https://developer.mozilla.org/en-US/docs/Web/Events/dragenter\n            // The dragenter event is fired when a dragged element or text selection enters a valid drop target.\n            'dragenter': function dragenter(event) {\n                event = event || window.event;\n\n                var itemTarget = null;\n\n                if (event.target) {\n                    itemTarget = event.target !== event.currentTarget ? event.target : null;\n                } else if (event.srcElement) {\n                    // IE8\n                    itemTarget = event.srcElement;\n                }\n\n                while (itemTarget && itemTarget.parentElement !== _this.contentElement) {\n                    itemTarget = itemTarget.parentElement;\n                }\n\n                if (!itemTarget) {\n                    return;\n                }\n\n                if (_this.droppableTarget === itemTarget) {\n                    return;\n                }\n\n                var _this$options$droppab2 = _this.options.droppable,\n                    accept = _this$options$droppab2.accept,\n                    _this$options$droppab3 = _this$options$droppab2.hoverClass,\n                    hoverClass = _this$options$droppab3 === undefined ? '' : _this$options$droppab3;\n\n\n                (0, _elementClass2['default'])(_this.droppableTarget).remove(hoverClass);\n                _this.droppableTarget = null;\n\n                var canDrop = true; // Defaults to true\n\n                if (typeof accept === 'function') {\n                    var id = itemTarget.getAttribute(_this.options.nodeIdAttr);\n                    var node = _this.getNodeById(id);\n\n                    canDrop = !!accept.call(_this, event, {\n                        type: 'dragenter',\n                        draggableTarget: _this.draggableTarget,\n                        droppableTarget: itemTarget,\n                        node: node\n                    });\n                }\n\n                if (canDrop) {\n                    (0, _elementClass2['default'])(itemTarget).add(hoverClass);\n                    _this.droppableTarget = itemTarget;\n                }\n            },\n            // https://developer.mozilla.org/en-US/docs/Web/Events/dragover\n            // The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds).\n            'dragover': function dragover(event) {\n                event = event || window.event;\n\n                (0, _dom.preventDefault)(event);\n            },\n            // https://developer.mozilla.org/en-US/docs/Web/Events/drop\n            // The drop event is fired when an element or text selection is dropped on a valid drop target.\n            'drop': function drop(event) {\n                event = event || window.event;\n\n                // prevent default action (open as link for some elements)\n                (0, _dom.preventDefault)(event);\n\n                if (!(_this.draggableTarget && _this.droppableTarget)) {\n                    return;\n                }\n\n                var _this$options$droppab4 = _this.options.droppable,\n                    accept = _this$options$droppab4.accept,\n                    drop = _this$options$droppab4.drop,\n                    _this$options$droppab5 = _this$options$droppab4.hoverClass,\n                    hoverClass = _this$options$droppab5 === undefined ? '' : _this$options$droppab5;\n\n                var id = _this.droppableTarget.getAttribute(_this.options.nodeIdAttr);\n                var node = _this.getNodeById(id);\n\n                var canDrop = true; // Defaults to true\n\n                if (typeof accept === 'function') {\n                    canDrop = !!accept.call(_this, event, {\n                        type: 'drop',\n                        draggableTarget: _this.draggableTarget,\n                        droppableTarget: _this.droppableTarget,\n                        node: node\n                    });\n                }\n\n                if (canDrop && typeof drop === 'function') {\n                    drop.call(_this, event, {\n                        draggableTarget: _this.draggableTarget,\n                        droppableTarget: _this.droppableTarget,\n                        node: node\n                    });\n                }\n\n                (0, _elementClass2['default'])(_this.droppableTarget).remove(hoverClass);\n                _this.droppableTarget = null;\n            }\n        };\n\n\n        if ((0, _isDom2['default'])(el)) {\n            options = _extends({}, options, { el: el });\n        } else if (el && (typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object') {\n            options = el;\n        }\n\n        // Assign options\n        _this.options = _extends({}, _this.options, options);\n\n        _this.create();\n\n        // Load tree data if it's provided\n        if (_this.options.data) {\n            _this.loadData(_this.options.data);\n        }\n        return _this;\n    }\n\n    // The following elements will have no effect in the stealth mode\n\n\n    InfiniteTree.prototype.create = function create() {\n        var _this2 = this;\n\n        if (this.options.el) {\n            var tag = null;\n\n            this.scrollElement = document.createElement('div');\n\n            if (this.options.layout === 'table') {\n                var tableElement = document.createElement('table');\n                tableElement.className = (0, _classnames2['default'])('infinite-tree', 'infinite-tree-table');\n                var contentElement = document.createElement('tbody');\n                tableElement.appendChild(contentElement);\n                this.scrollElement.appendChild(tableElement);\n                this.contentElement = contentElement;\n\n                // The tag name for supporting elements\n                tag = 'tr';\n            } else {\n                var _contentElement = document.createElement('div');\n                this.scrollElement.appendChild(_contentElement);\n                this.contentElement = _contentElement;\n\n                // The tag name for supporting elements\n                tag = 'div';\n            }\n\n            this.scrollElement.className = (0, _classnames2['default'])('infinite-tree', 'infinite-tree-scroll');\n            this.contentElement.className = (0, _classnames2['default'])('infinite-tree', 'infinite-tree-content');\n\n            this.options.el.appendChild(this.scrollElement);\n\n            this.clusterize = new _clusterize2['default']({\n                tag: tag,\n                rows: [],\n                scrollElement: this.scrollElement,\n                contentElement: this.contentElement,\n                emptyText: this.options.noDataText,\n                emptyClass: this.options.noDataClass\n            });\n\n            this.clusterize.on('clusterWillChange', function () {\n                _this2.emit('clusterWillChange');\n            });\n            this.clusterize.on('clusterDidChange', function () {\n                _this2.emit('clusterDidChange');\n            });\n\n            (0, _dom.addEventListener)(this.contentElement, 'click', this.contentListener.click);\n            (0, _dom.addEventListener)(this.contentElement, 'dblclick', this.contentListener.dblclick);\n            (0, _dom.addEventListener)(this.contentElement, 'keydown', this.contentListener.keydown);\n            (0, _dom.addEventListener)(this.contentElement, 'keyup', this.contentListener.keyup);\n\n            if (this.options.droppable) {\n                (0, _dom.addEventListener)(document, 'dragstart', this.contentListener.dragstart);\n                (0, _dom.addEventListener)(document, 'dragend', this.contentListener.dragend);\n                (0, _dom.addEventListener)(this.contentElement, 'dragenter', this.contentListener.dragenter);\n                (0, _dom.addEventListener)(this.contentElement, 'dragleave', this.contentListener.dragleave);\n                (0, _dom.addEventListener)(this.contentElement, 'dragover', this.contentListener.dragover);\n                (0, _dom.addEventListener)(this.contentElement, 'drop', this.contentListener.drop);\n            }\n        }\n    };\n\n    InfiniteTree.prototype.destroy = function destroy() {\n        this.clear();\n\n        if (this.options.el) {\n            (0, _dom.removeEventListener)(this.contentElement, 'click', this.contentListener.click);\n            (0, _dom.removeEventListener)(this.contentElement, 'dblclick', this.contentListener.dblclick);\n            (0, _dom.removeEventListener)(this.contentElement, 'keydown', this.contentListener.keydown);\n            (0, _dom.removeEventListener)(this.contentElement, 'keyup', this.contentListener.keyup);\n\n            if (this.options.droppable) {\n                (0, _dom.removeEventListener)(document, 'dragstart', this.contentListener.dragstart);\n                (0, _dom.removeEventListener)(document, 'dragend', this.contentListener.dragend);\n                (0, _dom.removeEventListener)(this.contentElement, 'dragenter', this.contentListener.dragenter);\n                (0, _dom.removeEventListener)(this.contentElement, 'dragleave', this.contentListener.dragleave);\n                (0, _dom.removeEventListener)(this.contentElement, 'dragover', this.contentListener.dragover);\n                (0, _dom.removeEventListener)(this.contentElement, 'drop', this.contentListener.drop);\n            }\n\n            if (this.clusterize) {\n                this.clusterize.destroy(true); // True to remove all data from the list\n                this.clusterize = null;\n            }\n\n            // Remove all child nodes\n            while (this.contentElement.firstChild) {\n                this.contentElement.removeChild(this.contentElement.firstChild);\n            }\n            while (this.scrollElement.firstChild) {\n                this.scrollElement.removeChild(this.scrollElement.firstChild);\n            }\n\n            var containerElement = this.options.el;\n            while (containerElement.firstChild) {\n                containerElement.removeChild(containerElement.firstChild);\n            }\n\n            this.contentElement = null;\n            this.scrollElement = null;\n        }\n    };\n    // Adds an array of new child nodes to a parent node at the specified index.\n    // * If the parent is null or undefined, inserts new childs at the specified index in the top-level.\n    // * If the parent has children, the method adds the new child to it at the specified index.\n    // * If the parent does not have children, the method adds the new child to the parent.\n    // * If the index value is greater than or equal to the number of children in the parent, the method adds the child at the end of the children.\n    // @param {Array} newNodes An array of new child nodes.\n    // @param {number} [index] The 0-based index of where to insert the child node.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.addChildNodes = function addChildNodes(newNodes, index, parentNode) {\n        var _this3 = this;\n\n        newNodes = [].concat(newNodes || []); // Ensure array\n        if (newNodes.length === 0) {\n            return false;\n        }\n\n        if ((typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'object') {\n            // The 'object' type might be Node or null\n            parentNode = index || this.state.rootNode; // Defaults to rootNode if not specified\n            index = parentNode.children.length;\n        } else {\n            parentNode = parentNode || this.state.rootNode; // Defaults to rootNode if not specified\n        }\n\n        if (!ensureNodeInstance(parentNode)) {\n            return false;\n        }\n\n        if (typeof index !== 'number') {\n            index = parentNode.children.length;\n        }\n\n        // Assign parent\n        newNodes.forEach(function (newNode) {\n            newNode.parent = parentNode;\n        });\n\n        // Insert new child node at the specified index\n        parentNode.children.splice.apply(parentNode.children, [index, 0].concat(newNodes));\n\n        // Get the index of the first new node within the array of child nodes\n        index = parentNode.children.indexOf(newNodes[0]);\n\n        var deleteCount = parentNode.state.total;\n        var nodes = (0, _flattree.flatten)(parentNode.children, { openNodes: this.state.openNodes });\n        var rows = [];\n        // Update rows\n        rows.length = nodes.length;\n        for (var i = 0; i < nodes.length; ++i) {\n            var node = nodes[i];\n            rows[i] = this.options.rowRenderer(node, this.options);\n        }\n\n        if (parentNode === this.state.rootNode) {\n            this.nodes = nodes;\n            this.rows = rows;\n        } else {\n            var parentOffset = this.nodes.indexOf(parentNode);\n            if (parentOffset >= 0) {\n                if (parentNode.state.open === true) {\n                    // Update nodes & rows\n                    this.nodes.splice.apply(this.nodes, [parentOffset + 1, deleteCount].concat(nodes));\n                    this.rows.splice.apply(this.rows, [parentOffset + 1, deleteCount].concat(rows));\n                }\n\n                // Update the row corresponding to the parent node\n                this.rows[parentOffset] = this.options.rowRenderer(parentNode, this.options);\n            }\n        }\n\n        // Update the lookup table with newly added nodes\n        parentNode.children.slice(index).forEach(function (childNode) {\n            _this3.flattenNode(childNode).forEach(function (node) {\n                if (node.id !== undefined) {\n                    _this3.nodeTable.set(node.id, node);\n                }\n            });\n        });\n\n        // Update list\n        this.update();\n\n        return true;\n    };\n    // Adds a new child node to the end of the list of children of a specified parent node.\n    // * If the parent is null or undefined, inserts the child at the specified index in the top-level.\n    // * If the parent has children, the method adds the child as the last child.\n    // * If the parent does not have children, the method adds the child to the parent.\n    // @param {object} newNode The new child node.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.appendChildNode = function appendChildNode(newNode, parentNode) {\n        // Defaults to rootNode if the parentNode is not specified\n        parentNode = parentNode || this.state.rootNode;\n\n        if (!ensureNodeInstance(parentNode)) {\n            return false;\n        }\n\n        var index = parentNode.children.length;\n        var newNodes = [].concat(newNode || []); // Ensure array\n        return this.addChildNodes(newNodes, index, parentNode);\n    };\n    // Checks or unchecks a node.\n    // @param {Node} node The Node object.\n    // @param {boolean} [checked] Whether to check or uncheck the node. If not specified, it will toggle between checked and unchecked state.\n    // @return {boolean} Returns true on success, false otherwise.\n    // @example\n    //\n    // tree.checkNode(node); // toggle checked and unchecked state\n    // tree.checkNode(node, true); // checked=true, indeterminate=false\n    // tree.checkNode(node, false); // checked=false, indeterminate=false\n    //\n    // @doc\n    //\n    // state.checked | state.indeterminate | description\n    // ------------- | ------------------- | -----------\n    // false         | false               | The node and all of its children are unchecked.\n    // true          | false               | The node and all of its children are checked.\n    // true          | true                | The node will appear as indeterminate when the node is checked and some (but not all) of its children are checked.\n\n\n    InfiniteTree.prototype.checkNode = function checkNode(node, checked) {\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        this.emit('willCheckNode', node);\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n        if (nodeIndex < 0) {\n            error('Invalid node index');\n            return false;\n        }\n\n        if (checked === true) {\n            node.state.checked = true;\n            node.state.indeterminate = false;\n        } else if (checked === false) {\n            node.state.checked = false;\n            node.state.indeterminate = false;\n        } else {\n            node.state.checked = !!node.state.checked;\n            node.state.indeterminate = !!node.state.indeterminate;\n            node.state.checked = node.state.checked && node.state.indeterminate || !node.state.checked;\n            node.state.indeterminate = false;\n        }\n\n        var topmostNode = node;\n\n        var updateChildNodes = function updateChildNodes(parentNode) {\n            var childNode = parentNode.getFirstChild(); // Ignore parent node\n            while (childNode) {\n                // Update checked and indeterminate state\n                childNode.state.checked = parentNode.state.checked;\n                childNode.state.indeterminate = false;\n\n                if (childNode.hasChildren()) {\n                    childNode = childNode.getFirstChild();\n                } else {\n                    // Find the parent level\n                    while (childNode.getNextSibling() === null && childNode.parent !== parentNode) {\n                        // Use child-parent link to get to the parent level\n                        childNode = childNode.getParent();\n                    }\n\n                    // Get next sibling\n                    childNode = childNode.getNextSibling();\n                }\n            }\n        };\n\n        var updateParentNodes = function updateParentNodes(childNode) {\n            var parentNode = childNode.parent;\n\n            while (parentNode && parentNode.state.depth >= 0) {\n                topmostNode = parentNode;\n\n                var checkedCount = 0;\n                var indeterminate = false;\n\n                var len = parentNode.children ? parentNode.children.length : 0;\n                for (var i = 0; i < len; ++i) {\n                    var _childNode = parentNode.children[i];\n                    indeterminate = indeterminate || !!_childNode.state.indeterminate;\n                    if (_childNode.state.checked) {\n                        checkedCount++;\n                    }\n                }\n\n                if (checkedCount === 0) {\n                    parentNode.state.indeterminate = false;\n                    parentNode.state.checked = false;\n                } else if (checkedCount > 0 && checkedCount < len || indeterminate) {\n                    parentNode.state.indeterminate = true;\n                    parentNode.state.checked = true;\n                } else {\n                    parentNode.state.indeterminate = false;\n                    parentNode.state.checked = true;\n                }\n\n                parentNode = parentNode.parent;\n            }\n        };\n\n        updateChildNodes(node);\n        updateParentNodes(node);\n\n        this.updateNode(topmostNode);\n\n        // Emit a \"checkNode\" event\n        this.emit('checkNode', node);\n\n        return true;\n    };\n    // Clears the tree.\n\n\n    InfiniteTree.prototype.clear = function clear() {\n        if (this.clusterize) {\n            this.clusterize.clear();\n        }\n        this.nodeTable.clear();\n        this.nodes = [];\n        this.rows = [];\n        this.state.openNodes = [];\n        this.state.rootNode = createRootNode(this.state.rootNode);\n        this.state.selectedNode = null;\n    };\n    // Closes a node to hide its children.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"closeNode\" and \"selectNode\" events from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.closeNode = function closeNode(node, options) {\n        var _this4 = this;\n\n        var _options = _extends({}, options),\n            _options$async = _options.async,\n            async = _options$async === undefined ? false : _options$async,\n            _options$asyncCallbac = _options.asyncCallback,\n            asyncCallback = _options$asyncCallbac === undefined ? noop : _options$asyncCallbac,\n            _options$silent = _options.silent,\n            silent = _options$silent === undefined ? false : _options$silent;\n\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        this.emit('willCloseNode', node);\n\n        // Cannot close the root node\n        if (node === this.state.rootNode) {\n            error('Cannot close the root node');\n            return false;\n        }\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n        if (nodeIndex < 0) {\n            error('Invalid node index');\n            return false;\n        }\n\n        // Check if the closeNode action can be performed\n        if (this.state.openNodes.indexOf(node) < 0) {\n            return false;\n        }\n\n        // Toggle the collapsing state\n        node.state.collapsing = true;\n        // Update the row corresponding to the node\n        this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n        // Update list\n        this.update();\n\n        var fn = function fn() {\n            // Keep selected node unchanged if \"node\" is equal to \"this.state.selectedNode\"\n            if (_this4.state.selectedNode && _this4.state.selectedNode !== node) {\n                // row #0 - node.0         => parent node (total=4)\n                // row #1   - node.0.0     => close this node; next selected node (total=2)\n                // row #2       node.0.0.0 => selected node (total=0)\n                // row #3       node.0.0.1\n                // row #4     node.0.1\n                var selectedIndex = _this4.nodes.indexOf(_this4.state.selectedNode);\n                var _total = node.state.total;\n                var rangeFrom = nodeIndex + 1;\n                var rangeTo = nodeIndex + _total;\n\n                if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n                    _this4.selectNode(node, options);\n                }\n            }\n\n            node.state.open = false; // Set the open state to false\n            var openNodes = _this4.state.openNodes.filter(function (node) {\n                return node.state.open;\n            });\n            _this4.state.openNodes = openNodes;\n\n            // Subtract total from ancestor nodes\n            var total = node.state.total;\n            for (var p = node; p !== null; p = p.parent) {\n                p.state.total = p.state.total - total;\n            }\n\n            // Update nodes & rows\n            _this4.nodes.splice(nodeIndex + 1, total);\n            _this4.rows.splice(nodeIndex + 1, total);\n\n            // Toggle the collapsing state\n            node.state.collapsing = false;\n            // Update the row corresponding to the node\n            _this4.rows[nodeIndex] = _this4.options.rowRenderer(node, _this4.options);\n\n            // Update list\n            _this4.update();\n\n            if (!silent) {\n                // Emit a \"closeNode\" event\n                _this4.emit('closeNode', node);\n            }\n\n            if (typeof asyncCallback === 'function') {\n                asyncCallback();\n            }\n        };\n\n        if (async) {\n            setTimeout(fn, 0);\n        } else {\n            fn();\n        }\n\n        return true;\n    };\n    // Filters nodes. Use a string or a function to test each node of the tree. Otherwise, it will render nothing after filtering (e.g. tree.filter(), tree.filter(null), tree.flter(0), tree.filter({}), etc.).\n    // @param {string|function} predicate A keyword string, or a function to test each node of the tree. If the predicate is an empty string, all nodes will be filtered. If the predicate is a function, returns true to keep the node, false otherwise.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.caseSensitive] Case sensitive string comparison. Defaults to false. This option is only available for string comparison.\n    // @param {boolean} [options.exactMatch] Exact string matching. Defaults to false. This option is only available for string comparison.\n    // @param {string} [options.filterPath] Gets the value at path of Node object. Defaults to 'name'. This option is only available for string comparison.\n    // @param {boolean} [options.includeAncestors] Whether to include ancestor nodes. Defaults to true.\n    // @param {boolean} [options.includeDescendants] Whether to include descendant nodes. Defaults to true.\n    // @example\n    //\n    // const filterOptions = {\n    //     caseSensitive: false,\n    //     exactMatch: false,\n    //     filterPath: 'props.some.other.key',\n    //     includeAncestors: true,\n    //     includeDescendants: true\n    // };\n    // tree.filter('keyword', filterOptions);\n    //\n    // @example\n    //\n    // const filterOptions = {\n    //     includeAncestors: true,\n    //     includeDescendants: true\n    // };\n    // tree.filter(function(node) {\n    //     const keyword = 'keyword';\n    //     const filterText = node.name || '';\n    //     return filterText.toLowerCase().indexOf(keyword) >= 0;\n    // }, filterOptions);\n\n\n    InfiniteTree.prototype.filter = function filter(predicate, options) {\n        options = _extends({\n            caseSensitive: false,\n            exactMatch: false,\n            filterPath: 'name',\n            includeAncestors: true,\n            includeDescendants: true\n        }, options);\n\n        this.filtered = true;\n\n        var rootNode = this.state.rootNode;\n        var traverse = function traverse(node) {\n            var filterNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            if (!node || !node.children) {\n                return false;\n            }\n\n            if (node === rootNode) {\n                node.state.filtered = false;\n            } else if (filterNode) {\n                node.state.filtered = true;\n            } else if (typeof predicate === 'string') {\n                // string\n                var filterText = (0, _utilities.get)(node, options.filterPath, '');\n                if (Number.isFinite(filterText)) {\n                    filterText = String(filterText);\n                }\n                if (typeof filterText !== 'string') {\n                    filterText = '';\n                }\n                var keyword = predicate;\n                if (!options.caseSensitive) {\n                    filterText = filterText.toLowerCase();\n                    keyword = keyword.toLowerCase();\n                }\n                node.state.filtered = options.exactMatch ? filterText === keyword : filterText.indexOf(keyword) >= 0;\n            } else if (typeof predicate === 'function') {\n                // function\n                var callback = predicate;\n                node.state.filtered = !!callback(node);\n            } else {\n                node.state.filtered = false;\n            }\n\n            if (options.includeDescendants) {\n                filterNode = filterNode || node.state.filtered;\n            }\n\n            var filtered = false;\n            for (var i = 0; i < node.children.length; ++i) {\n                var childNode = node.children[i];\n                if (!childNode) {\n                    continue;\n                }\n                if (traverse(childNode, filterNode)) {\n                    filtered = true;\n                }\n            }\n            if (options.includeAncestors && filtered) {\n                node.state.filtered = true;\n            }\n\n            return node.state.filtered;\n        };\n\n        traverse(rootNode);\n\n        // Update rows\n        this.rows.length = this.nodes.length;\n        for (var i = 0; i < this.nodes.length; ++i) {\n            var node = this.nodes[i];\n            this.rows[i] = this.options.rowRenderer(node, this.options);\n        }\n\n        this.update();\n    };\n    // Flattens all child nodes of a parent node by performing full tree traversal using child-parent link.\n    // No recursion or stack is involved.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @return {array} Returns an array of Node objects containing all the child nodes of the parent node.\n\n\n    InfiniteTree.prototype.flattenChildNodes = function flattenChildNodes(parentNode) {\n        // Defaults to rootNode if the parentNode is not specified\n        parentNode = parentNode || this.state.rootNode;\n\n        if (!ensureNodeInstance(parentNode)) {\n            return [];\n        }\n\n        var list = [];\n        var node = parentNode.getFirstChild(); // Ignore parent node\n        while (node) {\n            list.push(node);\n            if (node.hasChildren()) {\n                node = node.getFirstChild();\n            } else {\n                // Find the parent level\n                while (node.getNextSibling() === null && node.parent !== parentNode) {\n                    // Use child-parent link to get to the parent level\n                    node = node.getParent();\n                }\n\n                // Get next sibling\n                node = node.getNextSibling();\n            }\n        }\n\n        return list;\n    };\n    // Flattens a node by performing full tree traversal using child-parent link.\n    // No recursion or stack is involved.\n    // @param {Node} node The Node object.\n    // @return {array} Returns a flattened list of Node objects.\n\n\n    InfiniteTree.prototype.flattenNode = function flattenNode(node) {\n        if (!ensureNodeInstance(node)) {\n            return [];\n        }\n\n        return [node].concat(this.flattenChildNodes(node));\n    };\n    // Gets a list of child nodes.\n    // @param {Node} [parentNode] The Node object that defines the parent node. If null or undefined, returns a list of top level nodes.\n    // @return {array} Returns an array of Node objects containing all the child nodes of the parent node.\n\n\n    InfiniteTree.prototype.getChildNodes = function getChildNodes(parentNode) {\n        // Defaults to rootNode if the parentNode is not specified\n        parentNode = parentNode || this.state.rootNode;\n\n        if (!ensureNodeInstance(parentNode)) {\n            return [];\n        }\n\n        return parentNode.children;\n    };\n    // Gets a node by its unique id. This assumes that you have given the nodes in the data a unique id.\n    // @param {string|number} id An unique node id. A null value will be returned if the id doesn't match.\n    // @return {Node} Returns a node the matches the id, null otherwise.\n\n\n    InfiniteTree.prototype.getNodeById = function getNodeById(id) {\n        var node = this.nodeTable.get(id);\n        if (!node) {\n            // Find the first node that matches the id\n            node = this.nodes.filter(function (node) {\n                return node.id === id;\n            })[0];\n            if (!node) {\n                return null;\n            }\n            this.nodeTable.set(node.id, node);\n        }\n        return node;\n    };\n    // Returns the node at the specified point. If the specified point is outside the visible bounds or either coordinate is negative, the result is null.\n    // @param {number} x A horizontal position within the current viewport.\n    // @param {number} y A vertical position within the current viewport.\n    // @return {Node} The Node object under the given point.\n\n\n    InfiniteTree.prototype.getNodeFromPoint = function getNodeFromPoint(x, y) {\n        var el = document.elementFromPoint(x, y);\n        while (el && el.parentElement !== this.contentElement) {\n            el = el.parentElement;\n        }\n        if (!el) {\n            return null;\n        }\n        var id = el.getAttribute(this.options.nodeIdAttr);\n        var node = this.getNodeById(id);\n\n        return node;\n    };\n    // Gets an array of open nodes.\n    // @return {array} Returns an array of Node objects containing open nodes.\n\n\n    InfiniteTree.prototype.getOpenNodes = function getOpenNodes() {\n        // returns a shallow copy of an array into a new array object.\n        return this.state.openNodes.slice();\n    };\n    // Gets the root node.\n    // @return {Node} Returns the root node, or null if empty.\n\n\n    InfiniteTree.prototype.getRootNode = function getRootNode() {\n        return this.state.rootNode;\n    };\n    // Gets the selected node.\n    // @return {Node} Returns the selected node, or null if not selected.\n\n\n    InfiniteTree.prototype.getSelectedNode = function getSelectedNode() {\n        return this.state.selectedNode;\n    };\n    // Gets the index of the selected node.\n    // @return {number} Returns the index of the selected node, or -1 if not selected.\n\n\n    InfiniteTree.prototype.getSelectedIndex = function getSelectedIndex() {\n        return this.nodes.indexOf(this.state.selectedNode);\n    };\n    // Inserts the specified node after the reference node.\n    // @param {object} newNode The new sibling node.\n    // @param {Node} referenceNode The Node object that defines the reference node.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.insertNodeAfter = function insertNodeAfter(newNode, referenceNode) {\n        if (!ensureNodeInstance(referenceNode)) {\n            return false;\n        }\n\n        var parentNode = referenceNode.getParent();\n        var index = parentNode.children.indexOf(referenceNode) + 1;\n        var newNodes = [].concat(newNode || []); // Ensure array\n\n        return this.addChildNodes(newNodes, index, parentNode);\n    };\n    // Inserts the specified node before the reference node.\n    // @param {object} newNode The new sibling node.\n    // @param {Node} referenceNode The Node object that defines the reference node.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.insertNodeBefore = function insertNodeBefore(newNode, referenceNode) {\n        if (!ensureNodeInstance(referenceNode)) {\n            return false;\n        }\n\n        var parentNode = referenceNode.getParent();\n        var index = parentNode.children.indexOf(referenceNode);\n        var newNodes = [].concat(newNode || []); // Ensure array\n\n        return this.addChildNodes(newNodes, index, parentNode);\n    };\n    // Loads data in the tree.\n    // @param {object|array} data The data is an object or array of objects that defines the node.\n\n\n    InfiniteTree.prototype.loadData = function loadData() {\n        var _this5 = this;\n\n        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        this.nodes = (0, _flattree.flatten)(data, { openAllNodes: this.options.autoOpen });\n\n        // Clear lookup table\n        this.nodeTable.clear();\n\n        this.state.openNodes = this.nodes.filter(function (node) {\n            return node.state.open;\n        });\n        this.state.selectedNode = null;\n\n        var rootNode = function () {\n            var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            // Finding the root node\n            while (node && node.parent !== null) {\n                node = node.parent;\n            }\n            return node;\n        }(this.nodes.length > 0 ? this.nodes[0] : null);\n\n        this.state.rootNode = rootNode || createRootNode(this.state.rootNode); // Create a new root node if rootNode is null\n\n        // Update the lookup table with newly added nodes\n        this.flattenChildNodes(this.state.rootNode).forEach(function (node) {\n            if (node.id !== undefined) {\n                _this5.nodeTable.set(node.id, node);\n            }\n        });\n\n        // Update rows\n        this.rows.length = this.nodes.length;\n        for (var i = 0; i < this.nodes.length; ++i) {\n            var node = this.nodes[i];\n            this.rows[i] = this.options.rowRenderer(node, this.options);\n        }\n\n        // Update list\n        this.update();\n    };\n    // Moves a node from its current position to the new position.\n    // @param {Node} node The Node object.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @param {number} [index] The 0-based index of where to insert the child node.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.moveNodeTo = function moveNodeTo(node, parentNode, index) {\n        if (!ensureNodeInstance(node) || !ensureNodeInstance(parentNode)) {\n            return false;\n        }\n\n        for (var p = parentNode; p !== null; p = p.parent) {\n            if (p === node) {\n                error('Cannot move an ancestor node (id=' + node.id + ') to the specified parent node (id=' + parentNode.id + ').');\n                return false;\n            }\n        }\n\n        return this.removeNode(node) && this.addChildNodes(node, index, parentNode);\n    };\n    // Opens a node to display its children.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"openNode\" event from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.openNode = function openNode(node, options) {\n        var _this6 = this;\n\n        var _options2 = _extends({}, options),\n            _options2$async = _options2.async,\n            async = _options2$async === undefined ? false : _options2$async,\n            _options2$asyncCallba = _options2.asyncCallback,\n            asyncCallback = _options2$asyncCallba === undefined ? noop : _options2$asyncCallba,\n            _options2$silent = _options2.silent,\n            silent = _options2$silent === undefined ? false : _options2$silent;\n\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        if (!this.nodeTable.has(node.id)) {\n            error('Cannot open node with the given node id:', node.id);\n            return false;\n        }\n\n        // Check if the openNode action can be performed\n        if (this.state.openNodes.indexOf(node) >= 0) {\n            return false;\n        }\n\n        this.emit('willOpenNode', node);\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n\n        var fn = function fn() {\n            node.state.open = true;\n\n            if (_this6.state.openNodes.indexOf(node) < 0) {\n                // the most recently used items first\n                _this6.state.openNodes = [node].concat(_this6.state.openNodes);\n            }\n\n            var nodes = (0, _flattree.flatten)(node.children, { openNodes: _this6.state.openNodes });\n\n            // Add all child nodes to the lookup table if the first child does not exist in the lookup table\n            if (nodes.length > 0 && !_this6.nodeTable.get(nodes[0])) {\n                nodes.forEach(function (node) {\n                    if (node.id !== undefined) {\n                        _this6.nodeTable.set(node.id, node);\n                    }\n                });\n            }\n\n            // Toggle the expanding state\n            node.state.expanding = false;\n\n            if (nodeIndex >= 0) {\n                var rows = [];\n                // Update rows\n                rows.length = nodes.length;\n                for (var i = 0; i < nodes.length; ++i) {\n                    var _node = nodes[i];\n                    rows[i] = _this6.options.rowRenderer(_node, _this6.options);\n                }\n\n                // Update nodes & rows\n                _this6.nodes.splice.apply(_this6.nodes, [nodeIndex + 1, 0].concat(nodes));\n                _this6.rows.splice.apply(_this6.rows, [nodeIndex + 1, 0].concat(rows));\n\n                // Update the row corresponding to the node\n                _this6.rows[nodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n\n                // Update list\n                _this6.update();\n            }\n\n            if (!silent) {\n                // Emit a \"openNode\" event\n                _this6.emit('openNode', node);\n            }\n\n            if (typeof asyncCallback === 'function') {\n                asyncCallback();\n            }\n        };\n\n        if (nodeIndex < 0) {\n            // Toggle the expanding state\n            node.state.expanding = true;\n\n            if (async) {\n                setTimeout(fn, 0);\n            } else {\n                fn();\n            }\n\n            return true;\n        }\n\n        var shouldLoadNodes = typeof this.options.shouldLoadNodes === 'function' ? !!this.options.shouldLoadNodes(node) : !node.hasChildren() && node.loadOnDemand;\n\n        if (shouldLoadNodes) {\n            if (typeof this.options.loadNodes !== 'function') {\n                return false;\n            }\n\n            // Reentrancy not allowed\n            if (node.state.loading === true) {\n                return false;\n            }\n\n            // Toggle the loading state\n            node.state.loading = true;\n            // Update the row corresponding to the node\n            this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n            // Update list\n            this.update();\n\n            // Do a setTimeout to prevent the CPU intensive task\n            setTimeout(function () {\n                _this6.options.loadNodes(node, function (err, nodes) {\n                    var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n                    nodes = (0, _ensureArray2['default'])(nodes);\n\n                    var currentNodeIndex = _this6.nodes.indexOf(node);\n\n                    if (nodes.length === 0 && currentNodeIndex >= 0) {\n                        node.state.open = true;\n\n                        if (_this6.state.openNodes.indexOf(node) < 0) {\n                            // the most recently used items first\n                            _this6.state.openNodes = [node].concat(_this6.state.openNodes);\n                        }\n                    }\n\n                    if (err || nodes.length === 0) {\n                        // Toggle the loading state\n                        node.state.loading = false;\n                        // Update the row corresponding to the node\n                        _this6.rows[currentNodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n                        // Update list\n                        _this6.update();\n\n                        if (typeof done === 'function') {\n                            done();\n                        }\n                        return;\n                    }\n\n                    _this6.addChildNodes(nodes, node);\n\n                    // Ensure the node has children to prevent infinite loop\n                    if (node.hasChildren()) {\n                        // Call openNode again\n                        _this6.openNode(node, _extends({}, options, {\n                            async: true,\n                            asyncCallback: function asyncCallback() {\n                                // Toggle the loading state\n                                node.state.loading = false;\n                                var openedNodeIndex = _this6.nodes.indexOf(node);\n                                // Update the row corresponding to the node\n                                _this6.rows[openedNodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n                                // Update list\n                                _this6.update();\n\n                                if (typeof done === 'function') {\n                                    done();\n                                }\n                            }\n                        }));\n                    } else {\n                        // Toggle the loading state\n                        node.state.loading = false;\n                        // Update the row corresponding to the node\n                        _this6.rows[currentNodeIndex] = _this6.options.rowRenderer(node, _this6.options);\n                        // Update list\n                        _this6.update();\n\n                        if (typeof done === 'function') {\n                            done();\n                        }\n                    }\n                });\n            }, 0);\n\n            return true;\n        }\n\n        // Toggle the expanding state\n        node.state.expanding = true;\n\n        // Update the row corresponding to the node\n        this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n        // Update list\n        this.update();\n\n        if (async) {\n            setTimeout(fn, 0);\n        } else {\n            fn();\n        }\n\n        return true;\n    };\n    // Removes all child nodes from a parent node.\n    // @param {Node} parentNode The Node object that defines the parent node.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"selectNode\" event from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.removeChildNodes = function removeChildNodes(parentNode, options) {\n        var _this7 = this;\n\n        if (!ensureNodeInstance(parentNode)) {\n            return false;\n        }\n\n        if (parentNode.children.length === 0) {\n            return false;\n        }\n        if (parentNode === this.state.rootNode) {\n            this.clear();\n            return true;\n        }\n\n        var parentNodeIndex = this.nodes.indexOf(parentNode);\n\n        // Update selected node\n        if (parentNodeIndex >= 0 && this.state.selectedNode) {\n            // row #0 - node.0         => parent node (total=4)\n            // row #1   - node.0.0\n            // row #2       node.0.0.0 => current selected node\n            // row #3       node.0.0.1\n            // row #4     node.0.1\n            var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n            var rangeFrom = parentNodeIndex + 1;\n            var rangeTo = parentNodeIndex + parentNode.state.total;\n\n            if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n                if (parentNode === this.state.rootNode) {\n                    this.selectNode(null, options);\n                } else {\n                    this.selectNode(parentNode, options);\n                }\n            }\n        }\n\n        // Get the nodes being removed\n        var removedNodes = this.flattenChildNodes(parentNode);\n\n        // Get the number of nodes to be removed\n        var deleteCount = parentNode.state.total;\n\n        // Subtract the deleteCount for all ancestors (parent, grandparent, etc.) of the current node\n        for (var p = parentNode; p !== null; p = p.parent) {\n            p.state.total = p.state.total - deleteCount;\n        }\n\n        // Update parent node\n        parentNode.children = [];\n        if (parentNode !== this.state.rootNode) {\n            parentNode.state.open = parentNode.state.open && parentNode.children.length > 0;\n        }\n\n        if (parentNodeIndex >= 0) {\n            // Update nodes & rows\n            this.nodes.splice(parentNodeIndex + 1, deleteCount);\n            this.rows.splice(parentNodeIndex + 1, deleteCount);\n\n            // Update the row corresponding to the parent node\n            this.rows[parentNodeIndex] = this.options.rowRenderer(parentNode, this.options);\n        }\n\n        {\n            // Update open nodes and lookup table\n            this.state.openNodes = this.state.openNodes.filter(function (node) {\n                return removedNodes.indexOf(node) < 0 && node.state.open;\n            });\n\n            removedNodes.forEach(function (node) {\n                _this7.nodeTable.unset(node.id);\n            });\n        }\n\n        // Update list\n        this.update();\n\n        return true;\n    };\n    // Removes a node and all of its child nodes.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"selectNode\" event from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.removeNode = function removeNode(node, options) {\n        var _this8 = this;\n\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        var parentNode = node.parent;\n        if (!parentNode) {\n            return false;\n        }\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n        var parentNodeIndex = this.nodes.indexOf(parentNode);\n\n        // Update selected node\n        if (nodeIndex >= 0 && this.state.selectedNode) {\n            // row #0 - node.0         => parent node (total=4)\n            // row #1   - node.0.0     => remove this node (total=2)\n            // row #2       node.0.0.0 => current selected node (total=0)\n            // row #3       node.0.0.1\n            // row #4     node.0.1     => next selected node (total=0)\n            var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n            var rangeFrom = nodeIndex;\n            var rangeTo = nodeIndex + node.state.total + 1;\n\n            if (rangeFrom <= selectedIndex && selectedIndex <= rangeTo) {\n                // Change the selected node in the following order:\n                // 1. next sibling node\n                // 2. previous sibling node\n                // 3. parent node\n                var selectedNode = node.getNextSibling() || node.getPreviousSibling() || node.getParent();\n\n                if (selectedNode === this.state.rootNode) {\n                    this.selectNode(null, options);\n                } else {\n                    this.selectNode(selectedNode, options);\n                }\n            }\n        }\n\n        // Get the nodes being removed\n        var removedNodes = this.flattenNode(node);\n\n        // Get the number of nodes to be removed\n        var deleteCount = node.state.total + 1;\n\n        // Subtract the deleteCount for all ancestors (parent, grandparent, etc.) of the current node\n        for (var p = parentNode; p !== null; p = p.parent) {\n            p.state.total = p.state.total - deleteCount;\n        }\n\n        // Update parent node\n        parentNode.children.splice(parentNode.children.indexOf(node), 1);\n        if (parentNode !== this.state.rootNode) {\n            parentNode.state.open = parentNode.state.open && parentNode.children.length > 0;\n        }\n\n        if (nodeIndex >= 0) {\n            // Update nodes & rows\n            this.nodes.splice(nodeIndex, deleteCount);\n            this.rows.splice(nodeIndex, deleteCount);\n        }\n\n        // Update the row corresponding to the parent node\n        if (parentNodeIndex >= 0) {\n            this.rows[parentNodeIndex] = this.options.rowRenderer(parentNode, this.options);\n        }\n\n        {\n            // Update open nodes and lookup table\n            this.state.openNodes = this.state.openNodes.filter(function (node) {\n                return removedNodes.indexOf(node) < 0 && node.state.open;\n            });\n\n            removedNodes.forEach(function (node) {\n                _this8.nodeTable.unset(node.id);\n            });\n        }\n\n        // Update list\n        this.update();\n\n        return true;\n    };\n    // Sets the current scroll position to this node.\n    // @param {Node} node The Node object.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.scrollToNode = function scrollToNode(node) {\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n        if (nodeIndex < 0) {\n            return false;\n        }\n        if (!this.contentElement) {\n            return false;\n        }\n\n        // Scroll to a desired position\n        var firstChild = this.contentElement.firstChild;\n        while (firstChild) {\n            var className = firstChild.className || '';\n            if (className.indexOf('clusterize-extra-row') < 0 && firstChild.offsetHeight > 0) {\n                break;\n            }\n            firstChild = firstChild.nextSibling;\n        }\n        // If all items in the list is the same height, it can be calculated by nodeIndex * height.\n        var offsetHeight = firstChild && firstChild.offsetHeight || 0;\n        if (offsetHeight > 0) {\n            this.scrollTop(nodeIndex * offsetHeight);\n        }\n\n        // Find the absolute position of the node\n        var nodeSelector = '[' + this.options.nodeIdAttr + '=\"' + node.id + '\"]';\n        var nodeEl = this.contentElement.querySelector(nodeSelector);\n        if (nodeEl) {\n            this.scrollTop(nodeEl.offsetTop);\n        }\n\n        return true;\n    };\n    // Gets (or sets) the current vertical position of the scroll bar.\n    // @param {number} [value] If the value is specified, indicates the new position to set the scroll bar to.\n    // @return {number} Returns the vertical scroll position.\n\n\n    InfiniteTree.prototype.scrollTop = function scrollTop(value) {\n        if (!this.scrollElement) {\n            return 0;\n        }\n        if (value !== undefined) {\n            this.scrollElement.scrollTop = Number(value);\n        }\n        return this.scrollElement.scrollTop;\n    };\n    // Selects a node.\n    // @param {Node} node The Node object. If null or undefined, deselects the current node.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.autoScroll] Pass true to automatically scroll to the selected node. Defaults to true.\n    // @param {boolean} [options.silent] Pass true to prevent \"selectNode\" event from being triggered. Defaults to false.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.selectNode = function selectNode() {\n        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var options = arguments[1];\n        var _options3 = this.options,\n            selectable = _options3.selectable,\n            shouldSelectNode = _options3.shouldSelectNode;\n\n        var _options4 = _extends({}, options),\n            _options4$autoScroll = _options4.autoScroll,\n            autoScroll = _options4$autoScroll === undefined ? true : _options4$autoScroll,\n            _options4$silent = _options4.silent,\n            silent = _options4$silent === undefined ? false : _options4$silent;\n\n        this.emit('willSelectNode', node);\n\n        if (!selectable) {\n            return false;\n        }\n        if (typeof shouldSelectNode === 'function' && !shouldSelectNode(node)) {\n            return false;\n        }\n        if (node === this.state.rootNode) {\n            return false;\n        }\n\n        if (node === null) {\n            // Deselect the current node\n            if (this.state.selectedNode) {\n                var selectedNode = this.state.selectedNode;\n                var selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n\n                selectedNode.state.selected = false;\n                this.rows[selectedIndex] = this.options.rowRenderer(selectedNode, this.options);\n                this.state.selectedNode = null;\n\n                // Update list\n                this.update();\n\n                if (!silent) {\n                    // Emit a \"selectNode\" event\n                    this.emit('selectNode', null);\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n        if (nodeIndex < 0) {\n            return false;\n        }\n\n        // Select this node\n        if (this.state.selectedNode !== node) {\n            node.state.selected = true;\n\n            // Update the row corresponding to the node\n            this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n        }\n\n        // Deselect the current node\n        if (this.state.selectedNode) {\n            var _selectedNode = this.state.selectedNode;\n            var _selectedIndex = this.nodes.indexOf(this.state.selectedNode);\n            _selectedNode.state.selected = false;\n            this.rows[_selectedIndex] = this.options.rowRenderer(_selectedNode, this.options);\n        }\n\n        if (this.state.selectedNode !== node) {\n            this.state.selectedNode = node;\n\n            if (!silent) {\n                // Emit a \"selectNode\" event\n                this.emit('selectNode', node);\n            }\n\n            if (autoScroll && this.scrollElement && this.contentElement) {\n                var nodeSelector = '[' + this.options.nodeIdAttr + '=\"' + node.id + '\"]';\n                var nodeEl = this.contentElement.querySelector(nodeSelector);\n                if (nodeEl) {\n                    var offsetTop = nodeEl.offsetTop || 0;\n                    var offsetHeight = nodeEl.offsetHeight || 0;\n\n                    // Scroll Up\n                    if (offsetTop < this.scrollElement.scrollTop) {\n                        this.scrollElement.scrollTop = offsetTop;\n                    }\n\n                    // Scroll Down\n                    if (offsetTop + offsetHeight >= this.scrollElement.scrollTop + this.scrollElement.clientHeight) {\n                        this.scrollElement.scrollTop += offsetHeight;\n                    }\n                }\n            }\n        } else {\n            this.state.selectedNode = null;\n\n            if (!silent) {\n                // Emit a \"selectNode\" event\n                this.emit('selectNode', null);\n            }\n        }\n\n        // Update list\n        this.update();\n\n        return true;\n    };\n    // Swaps two nodes.\n    // @param {Node} node1 The Node object.\n    // @param {Node} node2 The Node object.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.swapNodes = function swapNodes(node1, node2) {\n        if (!ensureNodeInstance(node1) || !ensureNodeInstance(node1.parent)) {\n            return false;\n        }\n        if (!ensureNodeInstance(node2) || !ensureNodeInstance(node2.parent)) {\n            return false;\n        }\n\n        var parentNode1 = node1.parent;\n        var parentNode2 = node2.parent;\n\n        for (var p = parentNode1; p !== null; p = p.parent) {\n            if (p === node2) {\n                error('Cannot swap two nodes with one being an ancestor of the other.');\n                return false;\n            }\n        }\n        for (var _p = parentNode2; _p !== null; _p = _p.parent) {\n            if (_p === node1) {\n                error('Cannot swap two nodes with one being an ancestor of the other.');\n                return false;\n            }\n        }\n\n        var nodeIndex1 = parentNode1.children.indexOf(node1);\n        var nodeIndex2 = parentNode2.children.indexOf(node2);\n\n        return this.moveNodeTo(node1, parentNode2, nodeIndex2) && this.moveNodeTo(node2, parentNode1, nodeIndex1);\n    };\n    // Toggles a node to display or hide its children.\n    // @param {Node} node The Node object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.silent] Pass true to prevent \"closeNode\", \"openNode\", and \"selectNode\" events from being triggered.\n    // @return {boolean} Returns true on success, false otherwise.\n\n\n    InfiniteTree.prototype.toggleNode = function toggleNode(node, options) {\n        if (!ensureNodeInstance(node)) {\n            return false;\n        }\n\n        if (this.state.openNodes.indexOf(node) >= 0) {\n            // Close node\n            return this.closeNode(node, options);\n        } else {\n            // Open node\n            return this.openNode(node, options);\n        }\n    };\n    // Serializes the current state of a node to a JSON string.\n    // @param {Node} node The Node object. If null, returns the whole tree.\n    // @return {string} Returns a JSON string represented the tree.\n\n\n    InfiniteTree.prototype.toString = function toString() {\n        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        var traverse = function traverse(node) {\n            var s = '[';\n            if (node && node.children) {\n                var _loop = function _loop(i) {\n                    var list = [];\n                    s = s + '{';\n                    Object.keys(node).forEach(function (key) {\n                        var value = node[key];\n                        if (key === 'parent') {\n                            // ignore parent\n                            return;\n                        }\n                        if (key === 'children') {\n                            // traverse child nodes\n                            list.push('\"' + key + '\":' + traverse(node.children[i]));\n                            return;\n                        }\n                        if (typeof value === 'string' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n                            list.push('\"' + key + '\":' + JSON.stringify(value));\n                        } else {\n                            // primitive types\n                            list.push('\"' + key + '\":' + value);\n                        }\n                    });\n                    s = s + list.join(',');\n                    s = s + '}' + (i === node.children.length - 1 ? '' : ',');\n                };\n\n                for (var i = 0; i < node.children.length; ++i) {\n                    _loop(i);\n                }\n            }\n            s = s + ']';\n            return s;\n        };\n\n        if (!node) {\n            node = this.state.rootNode;\n        }\n\n        return traverse(node);\n    };\n    // Unfilters nodes.\n\n\n    InfiniteTree.prototype.unfilter = function unfilter() {\n        this.filtered = false;\n\n        var rootNode = this.state.rootNode;\n        var traverse = function traverse(node) {\n            if (!node) {\n                return;\n            }\n            delete node.state.filtered;\n\n            if (!node.children) {\n                return;\n            }\n            for (var i = 0; i < node.children.length; ++i) {\n                var childNode = node.children[i];\n                if (!childNode) {\n                    continue;\n                }\n                traverse(childNode);\n            }\n        };\n\n        traverse(rootNode);\n\n        // Update rows\n        this.rows.length = this.nodes.length;\n        for (var i = 0; i < this.nodes.length; ++i) {\n            var node = this.nodes[i];\n            this.rows[i] = this.options.rowRenderer(node, this.options);\n        }\n\n        this.update();\n    };\n    // Updates the tree.\n\n\n    InfiniteTree.prototype.update = function update() {\n        // Emit a \"contentWillUpdate\" event\n        this.emit('contentWillUpdate');\n\n        if (this.clusterize) {\n            // Update list\n            var rows = this.rows.filter(function (row) {\n                return !!row;\n            });\n            this.clusterize.update(rows);\n        }\n\n        // Emit a \"contentWillUpdate\" event\n        this.emit('contentDidUpdate');\n    };\n    // Updates the data of a node.\n    // @param {Node} node The Node object.\n    // @param {object} data The data object.\n    // @param {object} [options] The options object.\n    // @param {boolean} [options.shallowRendering] True to render only the parent node, false to render the parent node and all expanded child nodes. Defaults to false.\n\n\n    InfiniteTree.prototype.updateNode = function updateNode(node, data, options) {\n        if (!ensureNodeInstance(node)) {\n            return;\n        }\n\n        // Clone a new one\n        data = _extends({}, data);\n\n        if (data.id !== undefined && data.id !== null) {\n            this.nodeTable.unset(node.id);\n            this.nodeTable.set(data.id, node);\n            node.id = data.id;\n        }\n\n        // Ignore keys: id, children, parent, and state\n        delete data.id;\n        delete data.children;\n        delete data.parent;\n        delete data.state;\n\n        node = (0, _extend2['default'])(node, data);\n\n        // Retrieve node index\n        var nodeIndex = this.nodes.indexOf(node);\n        if (nodeIndex >= 0) {\n            var _options5 = _extends({}, options),\n                _options5$shallowRend = _options5.shallowRendering,\n                shallowRendering = _options5$shallowRend === undefined ? false : _options5$shallowRend;\n\n            // Update the row corresponding to the node\n\n\n            this.rows[nodeIndex] = this.options.rowRenderer(node, this.options);\n\n            if (!shallowRendering) {\n                var total = node.state.total;\n                var rangeFrom = nodeIndex + 1;\n                var rangeTo = nodeIndex + total;\n                for (var index = rangeFrom; index <= rangeTo; ++index) {\n                    this.rows[index] = this.options.rowRenderer(this.nodes[index], this.options);\n                }\n            }\n\n            // Update list\n            this.update();\n        }\n    };\n\n    return InfiniteTree;\n}(_events2['default'].EventEmitter);\n\nexports['default'] = InfiniteTree;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/infinite-tree.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/lookup-table.js":
/*!**********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/lookup-table.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LookupTable = function () {\n    function LookupTable() {\n        _classCallCheck(this, LookupTable);\n\n        this.data = {};\n    }\n\n    LookupTable.prototype.clear = function clear() {\n        this.data = {};\n    };\n\n    LookupTable.prototype.get = function get(key) {\n        return this.data[key];\n    };\n\n    LookupTable.prototype.has = function has(key) {\n        return this.data[key] !== undefined;\n    };\n\n    LookupTable.prototype.set = function set(key, value) {\n        this.data[key] = value;\n        return value;\n    };\n\n    LookupTable.prototype.unset = function unset(key) {\n        if (this.data[key] !== undefined) {\n            delete this.data[key];\n        }\n    };\n\n    return LookupTable;\n}();\n\nexports[\"default\"] = LookupTable;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/lookup-table.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/renderer.js":
/*!******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/renderer.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.defaultRowRenderer = undefined;\n\nvar _classnames = __webpack_require__(/*! classnames */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/classnames/index.js\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _escapeHtml = __webpack_require__(/*! escape-html */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js\");\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _html5Tag = __webpack_require__(/*! html5-tag */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/html5-tag/lib/index.js\");\n\nvar _html5Tag2 = _interopRequireDefault(_html5Tag);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar defaultRowRenderer = function defaultRowRenderer(node, treeOptions) {\n    var id = node.id,\n        name = node.name,\n        _node$loadOnDemand = node.loadOnDemand,\n        loadOnDemand = _node$loadOnDemand === undefined ? false : _node$loadOnDemand,\n        children = node.children,\n        state = node.state;\n\n    var droppable = treeOptions.droppable;\n    var depth = state.depth,\n        open = state.open,\n        path = state.path,\n        total = state.total,\n        _state$selected = state.selected,\n        selected = _state$selected === undefined ? false : _state$selected,\n        filtered = state.filtered;\n\n    var childrenLength = Object.keys(children).length;\n    var more = node.hasChildren();\n\n    if (filtered === false) {\n        return '';\n    }\n\n    var togglerContent = '';\n    if (!more && loadOnDemand) {\n        togglerContent = '►';\n    }\n    if (more && open) {\n        togglerContent = '▼';\n    }\n    if (more && !open) {\n        togglerContent = '►';\n    }\n    var toggler = (0, _html5Tag2['default'])('a', {\n        'class': function () {\n            if (!more && loadOnDemand) {\n                return (0, _classnames2['default'])(treeOptions.togglerClass, 'infinite-tree-closed');\n            }\n            if (more && open) {\n                return (0, _classnames2['default'])(treeOptions.togglerClass);\n            }\n            if (more && !open) {\n                return (0, _classnames2['default'])(treeOptions.togglerClass, 'infinite-tree-closed');\n            }\n            return '';\n        }()\n    }, togglerContent);\n    var title = (0, _html5Tag2['default'])('span', {\n        'class': (0, _classnames2['default'])('infinite-tree-title')\n    }, (0, _escapeHtml2['default'])(name));\n    var treeNode = (0, _html5Tag2['default'])('div', {\n        'class': 'infinite-tree-node',\n        'style': 'margin-left: ' + depth * 18 + 'px'\n    }, toggler + title);\n\n    return (0, _html5Tag2['default'])('div', {\n        'data-id': id,\n        'data-expanded': more && open,\n        'data-depth': depth,\n        'data-path': path,\n        'data-selected': selected,\n        'data-children': childrenLength,\n        'data-total': total,\n        'class': (0, _classnames2['default'])('infinite-tree-item', { 'infinite-tree-selected': selected }),\n        'droppable': droppable\n    }, treeNode);\n}; /* eslint import/prefer-default-export: 0 */\nexports.defaultRowRenderer = defaultRowRenderer;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/renderer.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/utilities.js":
/*!*******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/utilities.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar trim = exports.trim = function trim(str) {\n    var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' \\f\\n\\r\\t\\v';\n\n    while (chars.indexOf(str[0]) >= 0) {\n        str = str.slice(1);\n    }\n    while (chars.indexOf(str[str.length - 1]) >= 0) {\n        str = str.slice(0, -1);\n    }\n    return str;\n};\n\nvar get = exports.get = function () {\n    var re = new RegExp(/[\\w\\-]+|\\[[^\\]]*\\]+/g);\n\n    return function (object, path, defaultValue) {\n        if (!object || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n            return defaultValue;\n        }\n\n        path = '' + path;\n\n        var keys = path.match(re);\n        if (!keys) {\n            return defaultValue;\n        }\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            key = trim(key, ' \\f\\n\\r\\t\\v');\n            if (key[0] === '[') {\n                key = trim(key.slice(1, -1), ' \\f\\n\\r\\t\\v');\n            }\n            key = trim(key, '\\'\"');\n\n            if (object === undefined || object === null || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n                break;\n            }\n\n            object = object[key];\n\n            if (object === undefined) {\n                break;\n            }\n        }\n\n        return object !== undefined ? object : defaultValue;\n    };\n}();\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/utilities.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/is-dom/index.js":
/*!****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/is-dom/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = isNode\n\nfunction isNode (val) {\n  return (!val || typeof val !== 'object')\n    ? false\n    : (typeof window === 'object' && typeof window.Node === 'object')\n      ? (val instanceof window.Node)\n      : (typeof val.nodeType === 'number') &&\n        (typeof val.nodeName === 'string')\n}\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/is-dom/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/index.js":
/*!********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Helpers\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\nfunction isString(obj) { return _class(obj) === '[object String]'; }\nfunction isObject(obj) { return _class(obj) === '[object Object]'; }\nfunction isRegExp(obj) { return _class(obj) === '[object RegExp]'; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\n\n\nfunction escapeRE(str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&'); }\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n};\n\n\nfunction isOptionsObj(obj) {\n  return Object.keys(obj || {}).reduce(function (acc, k) {\n    return acc || defaultOptions.hasOwnProperty(k);\n  }, false);\n}\n\n\nvar defaultSchemas = {\n  'http:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.http) {\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.http =  new RegExp(\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        );\n      }\n      if (self.re.http.test(tail)) {\n        return tail.match(self.re.http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'https:':  'http:',\n  'ftp:':    'http:',\n  '//':      {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.no_http) {\n      // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.no_http =  new RegExp(\n          '^' +\n          self.re.src_auth +\n          // Don't allow single-level domains, because of false positives like '//test'\n          // with code comments\n          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\\\.)+' + self.re.src_domain_root + ')' +\n          self.re.src_port +\n          self.re.src_host_terminator +\n          self.re.src_path,\n\n          'i'\n        );\n      }\n\n      if (self.re.no_http.test(tail)) {\n        // should not be `://` & `///`, that protects from errors in protocol name\n        if (pos >= 3 && text[pos - 3] === ':') { return 0; }\n        if (pos >= 3 && text[pos - 3] === '/') { return 0; }\n        return tail.match(self.re.no_http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'mailto:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.mailto) {\n        self.re.mailto =  new RegExp(\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\n        );\n      }\n      if (self.re.mailto.test(tail)) {\n        return tail.match(self.re.mailto)[0].length;\n      }\n      return 0;\n    }\n  }\n};\n\n/*eslint-disable max-len*/\n\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\nvar tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';\n\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');\n\n/*eslint-enable max-len*/\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction resetScanCache(self) {\n  self.__index__ = -1;\n  self.__text_cache__   = '';\n}\n\nfunction createValidator(re) {\n  return function (text, pos) {\n    var tail = text.slice(pos);\n\n    if (re.test(tail)) {\n      return tail.match(re)[0].length;\n    }\n    return 0;\n  };\n}\n\nfunction createNormalizer() {\n  return function (match, self) {\n    self.normalize(match);\n  };\n}\n\n// Schemas compiler. Build regexps.\n//\nfunction compile(self) {\n\n  // Load & clone RE patterns.\n  var re = self.re = __webpack_require__(/*! ./lib/re */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/lib/re.js\")(self.__opts__);\n\n  // Define dynamic patterns\n  var tlds = self.__tlds__.slice();\n\n  self.onCompile();\n\n  if (!self.__tlds_replaced__) {\n    tlds.push(tlds_2ch_src_re);\n  }\n  tlds.push(re.src_xn);\n\n  re.src_tlds = tlds.join('|');\n\n  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }\n\n  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');\n  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');\n  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');\n  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\n\n  //\n  // Compile each schema\n  //\n\n  var aliases = [];\n\n  self.__compiled__ = {}; // Reset compiled data\n\n  function schemaError(name, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n  }\n\n  Object.keys(self.__schemas__).forEach(function (name) {\n    var val = self.__schemas__[name];\n\n    // skip disabled methods\n    if (val === null) { return; }\n\n    var compiled = { validate: null, link: null };\n\n    self.__compiled__[name] = compiled;\n\n    if (isObject(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate);\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate;\n      } else {\n        schemaError(name, val);\n      }\n\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize;\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer();\n      } else {\n        schemaError(name, val);\n      }\n\n      return;\n    }\n\n    if (isString(val)) {\n      aliases.push(name);\n      return;\n    }\n\n    schemaError(name, val);\n  });\n\n  //\n  // Compile postponed aliases\n  //\n\n  aliases.forEach(function (alias) {\n    if (!self.__compiled__[self.__schemas__[alias]]) {\n      // Silently fail on missed schemas to avoid errons on disable.\n      // schemaError(alias, self.__schemas__[alias]);\n      return;\n    }\n\n    self.__compiled__[alias].validate =\n      self.__compiled__[self.__schemas__[alias]].validate;\n    self.__compiled__[alias].normalize =\n      self.__compiled__[self.__schemas__[alias]].normalize;\n  });\n\n  //\n  // Fake record for guessed links\n  //\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\n\n  //\n  // Build schema condition\n  //\n  var slist = Object.keys(self.__compiled__)\n                      .filter(function (name) {\n                        // Filter disabled & fake schemas\n                        return name.length > 0 && self.__compiled__[name];\n                      })\n                      .map(escapeRE)\n                      .join('|');\n  // (?!_) cause 1.5x slowdown\n  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');\n  self.re.schema_search = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\n\n  self.re.pretest = RegExp(\n    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',\n    'i'\n  );\n\n  //\n  // Cleanup\n  //\n\n  resetScanCache(self);\n}\n\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/\nfunction Match(self, shift) {\n  var start = self.__index__,\n      end   = self.__last_index__,\n      text  = self.__text_cache__.slice(start, end);\n\n  /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/\n  this.schema    = self.__schema__.toLowerCase();\n  /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/\n  this.index     = start + shift;\n  /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/\n  this.lastIndex = end + shift;\n  /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/\n  this.raw       = text;\n  /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/\n  this.text      = text;\n  /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/\n  this.url       = text;\n}\n\nfunction createMatch(self, shift) {\n  var match = new Match(self, shift);\n\n  self.__compiled__[match.schema].normalize(match, self);\n\n  return match;\n}\n\n\n/**\n * class LinkifyIt\n **/\n\n/**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/\nfunction LinkifyIt(schemas, options) {\n  if (!(this instanceof LinkifyIt)) {\n    return new LinkifyIt(schemas, options);\n  }\n\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas;\n      schemas = {};\n    }\n  }\n\n  this.__opts__           = assign({}, defaultOptions, options);\n\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\n  this.__index__          = -1;\n  this.__last_index__     = -1; // Next scan position\n  this.__schema__         = '';\n  this.__text_cache__     = '';\n\n  this.__schemas__        = assign({}, defaultSchemas, schemas);\n  this.__compiled__       = {};\n\n  this.__tlds__           = tlds_default;\n  this.__tlds_replaced__  = false;\n\n  this.re = {};\n\n  compile(this);\n}\n\n\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/\nLinkifyIt.prototype.add = function add(schema, definition) {\n  this.__schemas__[schema] = definition;\n  compile(this);\n  return this;\n};\n\n\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/\nLinkifyIt.prototype.set = function set(options) {\n  this.__opts__ = assign(this.__opts__, options);\n  return this;\n};\n\n\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/\nLinkifyIt.prototype.test = function test(text) {\n  // Reset scan cache\n  this.__text_cache__ = text;\n  this.__index__      = -1;\n\n  if (!text.length) { return false; }\n\n  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n\n  // try to scan for link with schema - that's the most simple rule\n  if (this.re.schema_test.test(text)) {\n    re = this.re.schema_search;\n    re.lastIndex = 0;\n    while ((m = re.exec(text)) !== null) {\n      len = this.testSchemaAt(text, m[2], re.lastIndex);\n      if (len) {\n        this.__schema__     = m[2];\n        this.__index__      = m.index + m[1].length;\n        this.__last_index__ = m.index + m[0].length + len;\n        break;\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n    // guess schemaless links\n    tld_pos = text.search(this.re.host_fuzzy_test);\n    if (tld_pos >= 0) {\n      // if tld is located after found link - no need to check fuzzy pattern\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n\n          shift = ml.index + ml[1].length;\n\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__     = '';\n            this.__index__      = shift;\n            this.__last_index__ = ml.index + ml[0].length;\n          }\n        }\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n    // guess schemaless emails\n    at_pos = text.indexOf('@');\n    if (at_pos >= 0) {\n      // We can't skip this check, because this cases are possible:\n      // 192.168.1.1@gmail.com, my.in@example.com\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n\n        shift = me.index + me[1].length;\n        next  = me.index + me[0].length;\n\n        if (this.__index__ < 0 || shift < this.__index__ ||\n            (shift === this.__index__ && next > this.__last_index__)) {\n          this.__schema__     = 'mailto:';\n          this.__index__      = shift;\n          this.__last_index__ = next;\n        }\n      }\n    }\n  }\n\n  return this.__index__ >= 0;\n};\n\n\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/\nLinkifyIt.prototype.pretest = function pretest(text) {\n  return this.re.pretest.test(text);\n};\n\n\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n  // If not supported schema check requested - terminate\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0;\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n};\n\n\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * recommend to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/\nLinkifyIt.prototype.match = function match(text) {\n  var shift = 0, result = [];\n\n  // Try to take previous element from cache, if .test() called before\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n    result.push(createMatch(this, shift));\n    shift = this.__last_index__;\n  }\n\n  // Cut head if cache was used\n  var tail = shift ? text.slice(shift) : text;\n\n  // Scan string until end reached\n  while (this.test(tail)) {\n    result.push(createMatch(this, shift));\n\n    tail = tail.slice(this.__last_index__);\n    shift += this.__last_index__;\n  }\n\n  if (result.length) {\n    return result;\n  }\n\n  return null;\n};\n\n\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/\nLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n  list = Array.isArray(list) ? list : [ list ];\n\n  if (!keepOld) {\n    this.__tlds__ = list.slice();\n    this.__tlds_replaced__ = true;\n    compile(this);\n    return this;\n  }\n\n  this.__tlds__ = this.__tlds__.concat(list)\n                                  .sort()\n                                  .filter(function (el, idx, arr) {\n                                    return el !== arr[idx - 1];\n                                  })\n                                  .reverse();\n\n  compile(this);\n  return this;\n};\n\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/\nLinkifyIt.prototype.normalize = function normalize(match) {\n\n  // Do minimal possible changes by default. Need to collect feedback prior\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\n  if (!match.schema) { match.url = 'http://' + match.url; }\n\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n    match.url = 'mailto:' + match.url;\n  }\n};\n\n\n/**\n * LinkifyIt#onCompile()\n *\n * Override to modify basic RegExp-s.\n **/\nLinkifyIt.prototype.onCompile = function onCompile() {\n};\n\n\nmodule.exports = LinkifyIt;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/lib/re.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/lib/re.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (opts) {\n  var re = {};\n\n  // Use direct extract instead of `regenerate` to reduse browserified size\n  re.src_Any = __webpack_require__(/*! uc.micro/properties/Any/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/properties/Any/regex.js\").source;\n  re.src_Cc  = __webpack_require__(/*! uc.micro/categories/Cc/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cc/regex.js\").source;\n  re.src_Z   = __webpack_require__(/*! uc.micro/categories/Z/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Z/regex.js\").source;\n  re.src_P   = __webpack_require__(/*! uc.micro/categories/P/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/P/regex.js\").source;\n\n  // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');\n\n  // \\p{\\Z\\Cc} (white spaces + control)\n  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');\n\n  // Experimental. List of chars, completely prohibited in links\n  // because can separate it from other part of text\n  var text_separators = '[><\\uff5c]';\n\n  // All possible word characters (everything without punctuation, spaces & controls)\n  // Defined via punctuation & spaces to save space\n  // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';\n  // The same as abothe but without [0-9]\n  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  re.src_ip4 =\n\n    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\n\n  // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\\\[\\\\]()]).)+@)?';\n\n  re.src_port =\n\n    '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\n\n  re.src_host_terminator =\n\n    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + re.src_ZPCc + '))';\n\n  re.src_path =\n\n    '(?:' +\n      '[/?#]' +\n        '(?:' +\n          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' +\n          '\\\\[(?:(?!' + re.src_ZCc + '|\\\\]).)*\\\\]|' +\n          '\\\\((?:(?!' + re.src_ZCc + '|[)]).)*\\\\)|' +\n          '\\\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\\\}|' +\n          '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' +\n          \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" +\n          \"\\\\'(?=\" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found\n          '\\\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to\n                                     // - english\n                                     // - percent-encoded\n                                     // - parts of file path\n                                     // until more examples found.\n          '\\\\.(?!' + re.src_ZCc + '|[.]).|' +\n          (opts && opts['---'] ?\n            '\\\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate\n            :\n            '\\\\-+|'\n          ) +\n          '\\\\,(?!' + re.src_ZCc + ').|' +      // allow `,,,` in paths\n          '\\\\!(?!' + re.src_ZCc + '|[!]).|' +\n          '\\\\?(?!' + re.src_ZCc + '|[?]).' +\n        ')+' +\n      '|\\\\/' +\n    ')?';\n\n  re.src_email_name =\n\n    '[\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]+';\n\n  re.src_xn =\n\n    'xn--[a-z0-9\\\\-]{1,59}';\n\n  // More to read about domain names\n  // http://serverfault.com/questions/638260/\n\n  re.src_domain_root =\n\n    // Allow letters & digits (http://test1)\n    '(?:' +\n      re.src_xn +\n      '|' +\n      re.src_pseudo_letter + '{1,63}' +\n    ')';\n\n  re.src_domain =\n\n    '(?:' +\n      re.src_xn +\n      '|' +\n      '(?:' + re.src_pseudo_letter + ')' +\n      '|' +\n      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +\n    ')';\n\n  re.src_host =\n\n    '(?:' +\n    // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)*' + re.src_domain/*_root*/ + ')' +\n    ')';\n\n  re.tpl_host_fuzzy =\n\n    '(?:' +\n      re.src_ip4 +\n    '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))' +\n    ')';\n\n  re.tpl_host_no_ip_fuzzy =\n\n    '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))';\n\n  re.src_host_strict =\n\n    re.src_host + re.src_host_terminator;\n\n  re.tpl_host_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_host_terminator;\n\n  re.src_host_port_strict =\n\n    re.src_host + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_no_ip_fuzzy_strict =\n\n    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Main rules\n\n  // Rude test fuzzy links by host, for quick deny\n  re.tpl_host_fuzzy_test =\n\n    'localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';\n\n  re.tpl_email_fuzzy =\n\n      '(^|' + text_separators + '|\\\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';\n\n  re.tpl_link_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';\n\n  re.tpl_link_no_ip_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';\n\n  return re;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/lib/re.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/index.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = __webpack_require__(/*! ./lib/ */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/index.js\");\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/entities.js":
/*!***********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/entities.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// HTML5 entities map: { name -> utf16string }\n//\n\n\n/*eslint quotes:0*/\nmodule.exports = __webpack_require__(/*! entities/maps/entities.json */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/entities/maps/entities.json\");\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/entities.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_blocks.js":
/*!**************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_blocks.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n\n\n\nmodule.exports = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'meta',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'source',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n];\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_blocks.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_re.js":
/*!**********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_re.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Regexps to match html elements\n\n\n\nvar attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\n\nvar unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar single_quoted = \"'[^']*'\";\nvar double_quoted = '\"[^\"]*\"';\n\nvar attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\n\nvar attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\n\nvar open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\n\nvar close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing  = '<[?].*?[?]>';\nvar declaration = '<![A-Z]+\\\\s+[^>]*>';\nvar cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\nvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\n                        '|' + processing + '|' + declaration + '|' + cdata + ')');\nvar HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');\n\nmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\nmodule.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_re.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Utilities\n//\n\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj) { return _class(obj) === '[object String]'; }\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return _hasOwnProperty.call(object, key);\n}\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt(src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\n\nvar UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\nvar ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;\nvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\n\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nvar entities = __webpack_require__(/*! ./entities */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/entities.js\");\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n\n  if (has(entities, name)) {\n    return entities[name];\n  }\n\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16)\n    :\n      parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\n/*function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n}*/\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\nfunction unescapeAll(str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str; }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped; }\n    return replaceEntityPattern(match, entity);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n\nfunction escapeRE(str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isSpace(code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true;\n  }\n  return false;\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace(code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true; }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*eslint-disable max-len*/\nvar UNICODE_PUNCT_RE = __webpack_require__(/*! uc.micro/categories/P/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/P/regex.js\");\n\n// Currently without astral characters support.\nfunction isPunctChar(ch) {\n  return UNICODE_PUNCT_RE.test(ch);\n}\n\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct(ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nexports.lib                 = {};\nexports.lib.mdurl           = __webpack_require__(/*! mdurl */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/index.js\");\nexports.lib.ucmicro         = __webpack_require__(/*! uc.micro */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/index.js\");\n\nexports.assign              = assign;\nexports.isString            = isString;\nexports.has                 = has;\nexports.unescapeMd          = unescapeMd;\nexports.unescapeAll         = unescapeAll;\nexports.isValidEntityCode   = isValidEntityCode;\nexports.fromCodePoint       = fromCodePoint;\n// exports.replaceEntities     = replaceEntities;\nexports.escapeHtml          = escapeHtml;\nexports.arrayReplaceAt      = arrayReplaceAt;\nexports.isSpace             = isSpace;\nexports.isWhiteSpace        = isWhiteSpace;\nexports.isMdAsciiPunct      = isMdAsciiPunct;\nexports.isPunctChar         = isPunctChar;\nexports.escapeRE            = escapeRE;\nexports.normalizeReference  = normalizeReference;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/index.js":
/*!*********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Just a shortcut for bulk export\n\n\n\nexports.parseLinkLabel       = __webpack_require__(/*! ./parse_link_label */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_label.js\");\nexports.parseLinkDestination = __webpack_require__(/*! ./parse_link_destination */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_destination.js\");\nexports.parseLinkTitle       = __webpack_require__(/*! ./parse_link_title */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_title.js\");\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_destination.js":
/*!**************************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_destination.js ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Parse link destination\n//\n\n\n\nvar isSpace     = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\nvar unescapeAll = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").unescapeAll;\n\n\nmodule.exports = function parseLinkDestination(str, pos, max) {\n  var code, level,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (str.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = str.charCodeAt(pos);\n      if (code === 0x0A /* \\n */ || isSpace(code)) { return result; }\n      if (code === 0x3E /* > */) {\n        result.pos = pos + 1;\n        result.str = unescapeAll(str.slice(start + 1, pos));\n        result.ok = true;\n        return result;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return result;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control characters\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n    }\n\n    if (code === 0x29 /* ) */) {\n      if (level === 0) { break; }\n      level--;\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return result; }\n  if (level !== 0) { return result; }\n\n  result.str = unescapeAll(str.slice(start, pos));\n  result.lines = lines;\n  result.pos = pos;\n  result.ok = true;\n  return result;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_destination.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_label.js":
/*!********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_label.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_label.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_title.js":
/*!********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_title.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Parse link title\n//\n\n\n\nvar unescapeAll = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").unescapeAll;\n\n\nmodule.exports = function parseLinkTitle(str, pos, max) {\n  var code,\n      marker,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (pos >= max) { return result; }\n\n  marker = str.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n    if (code === marker) {\n      result.pos = pos + 1;\n      result.lines = lines;\n      result.str = unescapeAll(str.slice(start + 1, pos));\n      result.ok = true;\n      return result;\n    } else if (code === 0x0A) {\n      lines++;\n    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos++;\n      if (str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n\n    pos++;\n  }\n\n  return result;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/parse_link_title.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/index.js":
/*!*************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/index.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Main parser class\n\n\n\n\nvar utils        = __webpack_require__(/*! ./common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\");\nvar helpers      = __webpack_require__(/*! ./helpers */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/helpers/index.js\");\nvar Renderer     = __webpack_require__(/*! ./renderer */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/renderer.js\");\nvar ParserCore   = __webpack_require__(/*! ./parser_core */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_core.js\");\nvar ParserBlock  = __webpack_require__(/*! ./parser_block */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_block.js\");\nvar ParserInline = __webpack_require__(/*! ./parser_inline */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_inline.js\");\nvar LinkifyIt    = __webpack_require__(/*! linkify-it */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/linkify-it/index.js\");\nvar mdurl        = __webpack_require__(/*! mdurl */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/index.js\");\nvar punycode     = __webpack_require__(/*! punycode */ \"./node_modules/punycode/punycode.js\");\n\n\nvar config = {\n  'default': __webpack_require__(/*! ./presets/default */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/default.js\"),\n  zero: __webpack_require__(/*! ./presets/zero */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/zero.js\"),\n  commonmark: __webpack_require__(/*! ./presets/commonmark */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/commonmark.js\")\n};\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n\nfunction validateLink(url) {\n  // url should be normalized at this point, and existing entities are decoded\n  var str = url.trim().toLowerCase();\n\n  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];\n\nfunction normalizeLink(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.encode(mdurl.format(parsed));\n}\n\nfunction normalizeLinkText(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toUnicode(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.decode(mdurl.format(parsed));\n}\n\n\n/**\n * class MarkdownIt\n *\n * Main parser/renderer class.\n *\n * ##### Usage\n *\n * ```javascript\n * // node.js, \"classic\" way:\n * var MarkdownIt = require('markdown-it'),\n *     md = new MarkdownIt();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // node.js, the same, but with sugar:\n * var md = require('markdown-it')();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // browser without AMD, added to \"window\" on script load\n * // Note, there are no dash.\n * var md = window.markdownit();\n * var result = md.render('# markdown-it rulezz!');\n * ```\n *\n * Single line rendering, without paragraph wrap:\n *\n * ```javascript\n * var md = require('markdown-it')();\n * var result = md.renderInline('__markdown-it__ rulezz!');\n * ```\n **/\n\n/**\n * new MarkdownIt([presetName, options])\n * - presetName (String): optional, `commonmark` / `zero`\n * - options (Object)\n *\n * Creates parser instanse with given config. Can be called without `new`.\n *\n * ##### presetName\n *\n * MarkdownIt provides named presets as a convenience to quickly\n * enable/disable active syntax rules and options for common use cases.\n *\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\n *   similar to GFM, used when no preset name given. Enables all available rules,\n *   but still without html, typographer & autolinker.\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n *   For example, when you need only `bold` and `italic` markup and nothing else.\n *\n * ##### options:\n *\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n *   That's not safe! You may need external sanitizer to protect output from XSS.\n *   It's better to extend features via plugins, instead of enabling HTML.\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n *   world you will need HTML output.\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n *   Can be useful for external highlighters.\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\n *   quotes beautification (smartquotes).\n * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement\n *   pairs, when typographer enabled and smartquotes on. For example, you can\n *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and\n *   `['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›']` for French (including nbsp).\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n *   return empty string if the source was not changed and should be escaped\n *   externaly. If result starts with <pre... internal wrapper is skipped.\n *\n * ##### Example\n *\n * ```javascript\n * // commonmark mode\n * var md = require('markdown-it')('commonmark');\n *\n * // default mode\n * var md = require('markdown-it')();\n *\n * // enable everything\n * var md = require('markdown-it')({\n *   html: true,\n *   linkify: true,\n *   typographer: true\n * });\n * ```\n *\n * ##### Syntax highlighting\n *\n * ```js\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return hljs.highlight(lang, str, true).value;\n *       } catch (__) {}\n *     }\n *\n *     return ''; // use external default escaping\n *   }\n * });\n * ```\n *\n * Or with full wrapper override (if you need assign class to `<pre>`):\n *\n * ```javascript\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * // Actual default values\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return '<pre class=\"hljs\"><code>' +\n *                hljs.highlight(lang, str, true).value +\n *                '</code></pre>';\n *       } catch (__) {}\n *     }\n *\n *     return '<pre class=\"hljs\"><code>' + md.utils.escapeHtml(str) + '</code></pre>';\n *   }\n * });\n * ```\n *\n **/\nfunction MarkdownIt(presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options);\n  }\n\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {};\n      presetName = 'default';\n    }\n  }\n\n  /**\n   * MarkdownIt#inline -> ParserInline\n   *\n   * Instance of [[ParserInline]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.inline = new ParserInline();\n\n  /**\n   * MarkdownIt#block -> ParserBlock\n   *\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.block = new ParserBlock();\n\n  /**\n   * MarkdownIt#core -> Core\n   *\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.core = new ParserCore();\n\n  /**\n   * MarkdownIt#renderer -> Renderer\n   *\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n   * rules for new token types, generated by plugins.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * function myToken(tokens, idx, options, env, self) {\n   *   //...\n   *   return result;\n   * };\n   *\n   * md.renderer.rules['my_token'] = myToken\n   * ```\n   *\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\n   **/\n  this.renderer = new Renderer();\n\n  /**\n   * MarkdownIt#linkify -> LinkifyIt\n   *\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\n   * rule.\n   **/\n  this.linkify = new LinkifyIt();\n\n  /**\n   * MarkdownIt#validateLink(url) -> Boolean\n   *\n   * Link validation function. CommonMark allows too much in links. By default\n   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n   * except some embedded image types.\n   *\n   * You can change this behaviour:\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   * // enable everything\n   * md.validateLink = function () { return true; }\n   * ```\n   **/\n  this.validateLink = validateLink;\n\n  /**\n   * MarkdownIt#normalizeLink(url) -> String\n   *\n   * Function used to encode link url to a machine-readable format,\n   * which includes url-encoding, punycode, etc.\n   **/\n  this.normalizeLink = normalizeLink;\n\n  /**\n   * MarkdownIt#normalizeLinkText(url) -> String\n   *\n   * Function used to decode link url to a human-readable format`\n   **/\n  this.normalizeLinkText = normalizeLinkText;\n\n\n  // Expose utils & helpers for easy acces from plugins\n\n  /**\n   * MarkdownIt#utils -> utils\n   *\n   * Assorted utility functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\n   **/\n  this.utils = utils;\n\n  /**\n   * MarkdownIt#helpers -> helpers\n   *\n   * Link components parser functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n   **/\n  this.helpers = utils.assign({}, helpers);\n\n\n  this.options = {};\n  this.configure(presetName);\n\n  if (options) { this.set(options); }\n}\n\n\n/** chainable\n * MarkdownIt.set(options)\n *\n * Set parser options (in the same format as in constructor). Probably, you\n * will never need it, but you can change options after constructor call.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .set({ html: true, breaks: true })\n *             .set({ typographer, true });\n * ```\n *\n * __Note:__ To achieve the best possible performance, don't modify a\n * `markdown-it` instance options on the fly. If you need multiple configurations\n * it's best to create multiple instances and initialize each with separate\n * config.\n **/\nMarkdownIt.prototype.set = function (options) {\n  utils.assign(this.options, options);\n  return this;\n};\n\n\n/** chainable, internal\n * MarkdownIt.configure(presets)\n *\n * Batch load of all options and compenent settings. This is internal method,\n * and you probably will not need it. But if you with - see available presets\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n *\n * We strongly recommend to use presets instead of direct config loads. That\n * will give better compatibility with next versions.\n **/\nMarkdownIt.prototype.configure = function (presets) {\n  var self = this, presetName;\n\n  if (utils.isString(presets)) {\n    presetName = presets;\n    presets = config[presetName];\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name'); }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty'); }\n\n  if (presets.options) { self.set(presets.options); }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules);\n      }\n      if (presets.components[name].rules2) {\n        self[name].ruler2.enableOnly(presets.components[name].rules2);\n      }\n    });\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.enable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to enable\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable list or rules. It will automatically find appropriate components,\n * containing rules with given names. If rule not found, and `ignoreInvalid`\n * not set - throws exception.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .enable(['sub', 'sup'])\n *             .disable('smartquotes');\n * ```\n **/\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.enable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.enable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);\n  }\n\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.disable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\n **/\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.disable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.disable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.use(plugin, params)\n *\n * Load specified plugin with given params into current parser instance.\n * It's just a sugar to call `plugin(md, params)` with curring.\n *\n * ##### Example\n *\n * ```javascript\n * var iterator = require('markdown-it-for-inline');\n * var md = require('markdown-it')()\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n *             });\n * ```\n **/\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\n  plugin.apply(plugin, args);\n  return this;\n};\n\n\n/** internal\n * MarkdownIt.parse(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Parse input string and returns list of block tokens (special token type\n * \"inline\" will contain list of inline tokens). You should not call this\n * method directly, until you write custom renderer (for example, to produce\n * AST).\n *\n * `env` is used to pass data between \"distributed\" rules and return additional\n * metadata like reference info, needed for the renderer. It also can be used to\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\n * and then pass updated object to renderer.\n **/\nMarkdownIt.prototype.parse = function (src, env) {\n  if (typeof src !== 'string') {\n    throw new Error('Input data should be a String');\n  }\n\n  var state = new this.core.State(src, this, env);\n\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.render(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Render markdown string into html. It does all magic for you :).\n *\n * `env` can be used to inject additional metadata (`{}` by default).\n * But you will not need it with high probability. See also comment\n * in [[MarkdownIt.parse]].\n **/\nMarkdownIt.prototype.render = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parse(src, env), this.options, env);\n};\n\n\n/** internal\n * MarkdownIt.parseInline(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n * block tokens list with the single `inline` element, containing parsed inline\n * tokens in `children` property. Also updates `env` object.\n **/\nMarkdownIt.prototype.parseInline = function (src, env) {\n  var state = new this.core.State(src, this, env);\n\n  state.inlineMode = true;\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.renderInline(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n * will NOT be wrapped into `<p>` tags.\n **/\nMarkdownIt.prototype.renderInline = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parseInline(src, env), this.options, env);\n};\n\n\nmodule.exports = MarkdownIt;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_block.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_block.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n\n\n\nvar Ruler           = __webpack_require__(/*! ./ruler */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/ruler.js\");\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      __webpack_require__(/*! ./rules_block/table */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/table.js\"),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       __webpack_require__(/*! ./rules_block/code */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/code.js\") ],\n  [ 'fence',      __webpack_require__(/*! ./rules_block/fence */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/fence.js\"),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', __webpack_require__(/*! ./rules_block/blockquote */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/blockquote.js\"), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         __webpack_require__(/*! ./rules_block/hr */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/hr.js\"),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       __webpack_require__(/*! ./rules_block/list */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/list.js\"),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  __webpack_require__(/*! ./rules_block/reference */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/reference.js\") ],\n  [ 'heading',    __webpack_require__(/*! ./rules_block/heading */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/heading.js\"),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   __webpack_require__(/*! ./rules_block/lheading */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/lheading.js\") ],\n  [ 'html_block', __webpack_require__(/*! ./rules_block/html_block */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/html_block.js\"), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'paragraph',  __webpack_require__(/*! ./rules_block/paragraph */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/paragraph.js\") ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = __webpack_require__(/*! ./rules_block/state_block */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/state_block.js\");\n\n\nmodule.exports = ParserBlock;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_block.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_core.js":
/*!*******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_core.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** internal\n * class Core\n *\n * Top-level rules executor. Glues block/inline parsers and does intermediate\n * transformations.\n **/\n\n\n\nvar Ruler  = __webpack_require__(/*! ./ruler */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/ruler.js\");\n\n\nvar _rules = [\n  [ 'normalize',      __webpack_require__(/*! ./rules_core/normalize */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/normalize.js\")      ],\n  [ 'block',          __webpack_require__(/*! ./rules_core/block */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/block.js\")          ],\n  [ 'inline',         __webpack_require__(/*! ./rules_core/inline */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/inline.js\")         ],\n  [ 'linkify',        __webpack_require__(/*! ./rules_core/linkify */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/linkify.js\")        ],\n  [ 'replacements',   __webpack_require__(/*! ./rules_core/replacements */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/replacements.js\")   ],\n  [ 'smartquotes',    __webpack_require__(/*! ./rules_core/smartquotes */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/smartquotes.js\")    ]\n];\n\n\n/**\n * new Core()\n **/\nfunction Core() {\n  /**\n   * Core#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of core rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n\n/**\n * Core.process(state)\n *\n * Executes core chain rules.\n **/\nCore.prototype.process = function (state) {\n  var i, l, rules;\n\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\nCore.prototype.State = __webpack_require__(/*! ./rules_core/state_core */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/state_core.js\");\n\n\nmodule.exports = Core;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_core.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_inline.js":
/*!*********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_inline.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n\n\n\nvar Ruler           = __webpack_require__(/*! ./ruler */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/ruler.js\");\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [\n  [ 'text',            __webpack_require__(/*! ./rules_inline/text */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text.js\") ],\n  [ 'newline',         __webpack_require__(/*! ./rules_inline/newline */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/newline.js\") ],\n  [ 'escape',          __webpack_require__(/*! ./rules_inline/escape */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/escape.js\") ],\n  [ 'backticks',       __webpack_require__(/*! ./rules_inline/backticks */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/backticks.js\") ],\n  [ 'strikethrough',   __webpack_require__(/*! ./rules_inline/strikethrough */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/strikethrough.js\").tokenize ],\n  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/emphasis.js\").tokenize ],\n  [ 'link',            __webpack_require__(/*! ./rules_inline/link */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/link.js\") ],\n  [ 'image',           __webpack_require__(/*! ./rules_inline/image */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/image.js\") ],\n  [ 'autolink',        __webpack_require__(/*! ./rules_inline/autolink */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/autolink.js\") ],\n  [ 'html_inline',     __webpack_require__(/*! ./rules_inline/html_inline */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/html_inline.js\") ],\n  [ 'entity',          __webpack_require__(/*! ./rules_inline/entity */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/entity.js\") ]\n];\n\nvar _rules2 = [\n  [ 'balance_pairs',   __webpack_require__(/*! ./rules_inline/balance_pairs */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/balance_pairs.js\") ],\n  [ 'strikethrough',   __webpack_require__(/*! ./rules_inline/strikethrough */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/strikethrough.js\").postProcess ],\n  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/emphasis.js\").postProcess ],\n  [ 'text_collapse',   __webpack_require__(/*! ./rules_inline/text_collapse */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text_collapse.js\") ]\n];\n\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler();\n\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok, i, pos = state.pos,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      maxNesting = state.md.options.maxNesting,\n      cache = state.cache;\n\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) { break; }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) { state.pos++; }\n  cache[pos] = state.pos;\n};\n\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      end = state.posMax,\n      maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) { break; }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n\n  this.tokenize(state);\n\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\n\nParserInline.prototype.State = __webpack_require__(/*! ./rules_inline/state_inline */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/state_inline.js\");\n\n\nmodule.exports = ParserInline;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/parser_inline.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/commonmark.js":
/*!**************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/commonmark.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Commonmark default options\n\n\n\n\nmodule.exports = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fence',\n        'heading',\n        'hr',\n        'html_block',\n        'lheading',\n        'list',\n        'reference',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'html_inline',\n        'image',\n        'link',\n        'newline',\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'emphasis',\n        'text_collapse'\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/commonmark.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/default.js":
/*!***********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/default.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// markdown-it default options\n\n\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   100            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/default.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/zero.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/zero.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n// modes. For example, to parse bold/italic only.\n\n\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'text_collapse'\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/presets/zero.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/renderer.js":
/*!****************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/renderer.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n\n\n\nvar assign          = __webpack_require__(/*! ./common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").assign;\nvar unescapeAll     = __webpack_require__(/*! ./common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").unescapeAll;\nvar escapeHtml      = __webpack_require__(/*! ./common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").escapeHtml;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          escapeHtml(tokens[idx].content) +\n          '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      highlighted, i, tmpAttrs, tmpToken;\n\n  if (info) {\n    langName = info.split(/\\s+/g)[0];\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .clone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    i        = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n    if (i < 0) {\n      tmpAttrs.push([ 'class', options.langPrefix + langName ]);\n    } else {\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n\n    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'\n          + highlighted\n          + '</code></pre>\\n';\n  }\n\n\n  return  '<pre><code' + slf.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env);\n\n  return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/renderer.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/ruler.js":
/*!*************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/ruler.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n\n\n\n/**\n * new Ruler()\n **/\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\n\n  this.enable(list, ignoreInvalid);\n};\n\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/ruler.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/blockquote.js":
/*!******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/blockquote.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Block quotes\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      wasOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip spaces after \">\" and re-calculate offset\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  wasOutdented = false;\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !wasOutdented) {\n      // This line is inside the blockquote.\n\n      // skip spaces after \">\" and re-calculate offset\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/blockquote.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/code.js":
/*!************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/code.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Code block (4 spaces padded)\n\n\n\n\nmodule.exports = function code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last, token;\n\n  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = last;\n\n  token         = state.push('code_block', 'code', 0);\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/code.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/fence.js":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/fence.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// fences (``` lang, ~~~ lang)\n\n\n\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem, token, markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (params.indexOf(String.fromCharCode(marker)) >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n  token         = state.push('fence', 'code', 0);\n  token.info    = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup  = markup;\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/fence.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/heading.js":
/*!***************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/heading.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// heading (#, ##, ...)\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function heading(state, startLine, endLine, silent) {\n  var ch, level, tmp, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipSpacesBack(max, pos);\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  token        = state.push('heading_open', 'h' + String(level), 1);\n  token.markup = '########'.slice(0, level);\n  token.map    = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = state.src.slice(pos, max).trim();\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token        = state.push('heading_close', 'h' + String(level), -1);\n  token.markup = '########'.slice(0, level);\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/heading.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/hr.js":
/*!**********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/hr.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Horizontal rule\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && !isSpace(ch)) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n\n  token        = state.push('hr', 'hr', 0);\n  token.map    = [ startLine, state.line ];\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/hr.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/html_block.js":
/*!******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/html_block.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// HTML block\n\n\n\n\nvar block_names = __webpack_require__(/*! ../common/html_blocks */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_blocks.js\");\nvar HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(/*! ../common/html_re */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_re.js\").HTML_OPEN_CLOSE_TAG_RE;\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/html_block.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/lheading.js":
/*!****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/lheading.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// lheading (---, ===)\n\n\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1, oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/lheading.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/list.js":
/*!************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/list.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Lists\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldIndent,\n      oldLIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldLIndent = state.sCount[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldLIndent;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/list.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/paragraph.js":
/*!*****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/paragraph.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Paragraph\n\n\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/paragraph.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/reference.js":
/*!*****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/reference.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar normalizeReference   = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").normalizeReference;\nvar isSpace              = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/reference.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/state_block.js":
/*!*******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/state_block.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Parser state class\n\n\n\nvar Token = __webpack_require__(/*! ../token */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/token.js\");\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/state_block.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/table.js":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/table.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// GFM table, non-standard\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction escapedSplit(str) {\n  var result = [],\n      pos = 0,\n      max = str.length,\n      ch,\n      escapes = 0,\n      lastPos = 0,\n      backTicked = false,\n      lastBackTick = 0;\n\n  ch  = str.charCodeAt(pos);\n\n  while (pos < max) {\n    if (ch === 0x60/* ` */) {\n      if (backTicked) {\n        // make \\` close code sequence, but not open it;\n        // the reason is: `\\` is correct code block\n        backTicked = false;\n        lastBackTick = pos;\n      } else if (escapes % 2 === 0) {\n        backTicked = true;\n        lastBackTick = pos;\n      }\n    } else if (ch === 0x7c/* | */ && (escapes % 2 === 0) && !backTicked) {\n      result.push(str.substring(lastPos, pos));\n      lastPos = pos + 1;\n    }\n\n    if (ch === 0x5c/* \\ */) {\n      escapes++;\n    } else {\n      escapes = 0;\n    }\n\n    pos++;\n\n    // If there was an un-closed backtick, go back to just after\n    // the last backtick, but as if it was a normal character\n    if (pos === max && backTicked) {\n      backTicked = false;\n      pos = lastBackTick + 1;\n    }\n\n    ch = str.charCodeAt(pos);\n  }\n\n  result.push(str.substring(lastPos));\n\n  return result;\n}\n\n\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, columns, columnCount, token,\n      aligns, t, tableLines, tbodyLines;\n\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false; }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos++);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  while (pos < state.eMarks[nextLine]) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }\n\n    pos++;\n  }\n\n  lineText = getLine(state, startLine + 1);\n\n  columns = lineText.split('|');\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n  columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n  // header row will define an amount of columns in the entire table,\n  // and align row shouldn't be smaller than that (the rest of the rows can)\n  columnCount = columns.length;\n  if (columnCount > aligns.length) { return false; }\n\n  if (silent) { return true; }\n\n  token     = state.push('table_open', 'table', 1);\n  token.map = tableLines = [ startLine, 0 ];\n\n  token     = state.push('thead_open', 'thead', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  token     = state.push('tr_open', 'tr', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  for (i = 0; i < columns.length; i++) {\n    token          = state.push('th_open', 'th', 1);\n    token.map      = [ startLine, startLine + 1 ];\n    if (aligns[i]) {\n      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n    }\n\n    token          = state.push('inline', '', 0);\n    token.content  = columns[i].trim();\n    token.map      = [ startLine, startLine + 1 ];\n    token.children = [];\n\n    token          = state.push('th_close', 'th', -1);\n  }\n\n  token     = state.push('tr_close', 'tr', -1);\n  token     = state.push('thead_close', 'thead', -1);\n\n  token     = state.push('tbody_open', 'tbody', 1);\n  token.map = tbodyLines = [ startLine + 2, 0 ];\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) { break; }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }\n    columns = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\n\n    token = state.push('tr_open', 'tr', 1);\n    for (i = 0; i < columnCount; i++) {\n      token          = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n      }\n\n      token          = state.push('inline', '', 0);\n      token.content  = columns[i] ? columns[i].trim() : '';\n      token.children = [];\n\n      token          = state.push('td_close', 'td', -1);\n    }\n    token = state.push('tr_close', 'tr', -1);\n  }\n  token = state.push('tbody_close', 'tbody', -1);\n  token = state.push('table_close', 'table', -1);\n\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_block/table.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/block.js":
/*!************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/block.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function block(state) {\n  var token;\n\n  if (state.inlineMode) {\n    token          = new state.Token('inline', '', 0);\n    token.content  = state.src;\n    token.map      = [ 0, 1 ];\n    token.children = [];\n    state.tokens.push(token);\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/block.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/inline.js":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/inline.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/inline.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/linkify.js":
/*!**************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/linkify.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n\n\n\nvar arrayReplaceAt = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").arrayReplaceAt;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/linkify.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/normalize.js":
/*!****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/normalize.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Normalize input string\n\n\n\n\nvar NEWLINES_RE  = /\\r[\\n\\u0085]?|[\\u2424\\u2028\\u0085]/g;\nvar NULL_RE      = /\\u0000/g;\n\n\nmodule.exports = function inline(state) {\n  var str;\n\n  // Normalize newlines\n  str = state.src.replace(NEWLINES_RE, '\\n');\n\n  // Replace NULL characters\n  str = str.replace(NULL_RE, '\\uFFFD');\n\n  state.src = str;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/normalize.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/replacements.js":
/*!*******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/replacements.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Simple typographyc replacements\n//\n// (c) (C) → ©\n// (tm) (TM) → ™\n// (r) (R) → ®\n// +- → ±\n// (p) (P) -> §\n// ... → … (also ?.... → ?.., !.... → !..)\n// ???????? → ???, !!!!! → !!!, `,,` → `,`\n// -- → &ndash;, --- → &mdash;\n//\n\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\n// Workaround for phantomjs - need regex without /g flag,\n// or root check will fail every second time\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  c: '©',\n  r: '®',\n  p: '§',\n  tm: '™'\n};\n\nfunction replaceFn(match, name) {\n  return SCOPED_ABBR[name.toLowerCase()];\n}\n\nfunction replace_scoped(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\nfunction replace_rare(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      if (RARE_RE.test(token.content)) {\n        token.content = token.content\n                    .replace(/\\+-/g, '±')\n                    // .., ..., ....... -> …\n                    // but ?..... & !..... -> ?.. & !..\n                    .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n                    .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n                    // em-dash\n                    .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n                    // en-dash\n                    .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n                    .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n      }\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\n\nmodule.exports = function replace(state) {\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children);\n    }\n\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children);\n    }\n\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/replacements.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/smartquotes.js":
/*!******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/smartquotes.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Convert straight quotation marks to typographic ones\n//\n\n\n\nvar isWhiteSpace   = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isWhiteSpace;\nvar isPunctChar    = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isPunctChar;\nvar isMdAsciiPunct = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* ’ */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (tokens[j].type !== 'text') continue;\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (tokens[j].type !== 'text') continue;\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // treat this as the middle of the word\n        canOpen = false;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/smartquotes.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/state_core.js":
/*!*****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/state_core.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Core state object\n//\n\n\nvar Token = __webpack_require__(/*! ../token */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/token.js\");\n\n\nfunction StateCore(src, md, env) {\n  this.src = src;\n  this.env = env;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.md = md; // link to parser instance\n}\n\n// re-export Token class to use in core rules\nStateCore.prototype.Token = Token;\n\n\nmodule.exports = StateCore;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_core/state_core.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/autolink.js":
/*!*****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/autolink.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process autolinks '<protocol:...>'\n\n\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)>/;\n\n\nmodule.exports = function autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, token,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  if (AUTOLINK_RE.test(tail)) {\n    linkMatch = tail.match(AUTOLINK_RE);\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  if (EMAIL_RE.test(tail)) {\n    emailMatch = tail.match(EMAIL_RE);\n\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink('mailto:' + url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/autolink.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/backticks.js":
/*!******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/backticks.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Parse backticks\n\n\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, matchStart, matchEnd, token,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        token         = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n                                 .replace(/[ \\n]+/g, ' ')\n                                 .trim();\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/backticks.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/balance_pairs.js":
/*!**********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/balance_pairs.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// For each opening emphasis-like marker find a matching closing one\n//\n\n\n\nmodule.exports = function link_pairs(state) {\n  var i, j, lastDelim, currDelim,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    lastDelim = delimiters[i];\n\n    if (!lastDelim.close) { continue; }\n\n    j = i - lastDelim.jump - 1;\n\n    while (j >= 0) {\n      currDelim = delimiters[j];\n\n      if (currDelim.open &&\n          currDelim.marker === lastDelim.marker &&\n          currDelim.end < 0 &&\n          currDelim.level === lastDelim.level) {\n\n        // typeofs are for backward compatibility with plugins\n        var odd_match = (currDelim.close || lastDelim.open) &&\n                        typeof currDelim.length !== 'undefined' &&\n                        typeof lastDelim.length !== 'undefined' &&\n                        (currDelim.length + lastDelim.length) % 3 === 0;\n\n        if (!odd_match) {\n          lastDelim.jump = i - j;\n          lastDelim.open = false;\n          currDelim.end  = i;\n          currDelim.jump = 0;\n          break;\n        }\n      }\n\n      j -= currDelim.jump + 1;\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/balance_pairs.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/emphasis.js":
/*!*****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/emphasis.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process *this* and _that_\n//\n\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // Token level.\n      //\n      level:  state.level,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&\n               delimiters[i - 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/emphasis.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/entity.js":
/*!***************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/entity.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\n\nvar entities          = __webpack_require__(/*! ../common/entities */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/entities.js\");\nvar has               = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").has;\nvar isValidEntityCode = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isValidEntityCode;\nvar fromCodePoint     = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").fromCodePoint;\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nmodule.exports = function entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        if (has(entities, match[1])) {\n          if (!silent) { state.pending += entities[match[1]]; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/entity.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/escape.js":
/*!***************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/escape.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process escaped chars and hardbreaks\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nmodule.exports = function escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push('hardbreak', 'br', 0);\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/escape.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/html_inline.js":
/*!********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/html_inline.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process html tags\n\n\n\n\nvar HTML_TAG_RE = __webpack_require__(/*! ../common/html_re */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/html_re.js\").HTML_TAG_RE;\n\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nmodule.exports = function html_inline(state, silent) {\n  var ch, match, max, token,\n      pos = state.pos;\n\n  if (!state.md.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    token         = state.push('html_inline', '', 0);\n    token.content = state.src.slice(pos, pos + match[0].length);\n  }\n  state.pos += match[0].length;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/html_inline.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/image.js":
/*!**************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/image.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process ![image](<src> \"title\")\n\n\n\nvar normalizeReference   = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").normalizeReference;\nvar isSpace              = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens = []\n    );\n\n    token          = state.push('image', 'img', 0);\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\n    token.children = tokens;\n    token.content  = content;\n\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/image.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/link.js":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/link.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Process [link](<to> \"stuff\")\n\n\n\nvar normalizeReference   = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").normalizeReference;\nvar isSpace              = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function link(state, silent) {\n  var attrs,\n      code,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      res,\n      ref,\n      title,\n      token,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      parseReference = true;\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 1;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false;\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true;\n    }\n    pos++;\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    token        = state.push('link_open', 'a', 1);\n    token.attrs  = attrs = [ [ 'href', href ] ];\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n\n    state.md.inline.tokenize(state);\n\n    token        = state.push('link_close', 'a', -1);\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/link.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/newline.js":
/*!****************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/newline.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Proceess '\\n'\n\n\n\nvar isSpace = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isSpace;\n\n\nmodule.exports = function newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        state.pending = state.pending.replace(/ +$/, '');\n        state.push('hardbreak', 'br', 0);\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push('softbreak', 'br', 0);\n      }\n\n    } else {\n      state.push('softbreak', 'br', 0);\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && isSpace(state.src.charCodeAt(pos))) { pos++; }\n\n  state.pos = pos;\n  return true;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/newline.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/state_inline.js":
/*!*********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/state_inline.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Inline parser state\n\n\n\n\nvar Token          = __webpack_require__(/*! ../token */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/token.js\");\nvar isWhiteSpace   = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isWhiteSpace;\nvar isPunctChar    = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isPunctChar;\nvar isMdAsciiPunct = __webpack_require__(/*! ../common/utils */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/common/utils.js\").isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  this.delimiters = [];   // Emphasis-like delimiters\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n\n  if (nesting < 0) { this.level--; }\n  token.level = this.level;\n  if (nesting > 0) { this.level++; }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/state_inline.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/strikethrough.js":
/*!**********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/strikethrough.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// ~~strike through~~\n//\n\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i, scanned, token, len, ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) { return false; }\n\n  if (len % 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch + ch;\n\n    state.delimiters.push({\n      marker: marker,\n      jump:   i,\n      token:  state.tokens.length - 1,\n      level:  state.level,\n      end:    -1,\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function strikethrough(state) {\n  var i, j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      delimiters = state.delimiters,\n      max = state.delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    token         = state.tokens[startDelim.token];\n    token.type    = 's_open';\n    token.tag     = 's';\n    token.nesting = 1;\n    token.markup  = '~~';\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = 's_close';\n    token.tag     = 's';\n    token.nesting = -1;\n    token.markup  = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/strikethrough.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text.js":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n};\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParcerInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n};*/\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text_collapse.js":
/*!**********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text_collapse.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Merge adjacent text nodes into one, and re-calculate all token levels\n//\n\n\n\nmodule.exports = function text_collapse(state) {\n  var curr, last,\n      level = 0,\n      tokens = state.tokens,\n      max = state.tokens.length;\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels\n    level += tokens[curr].nesting;\n    tokens[curr].level = level;\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr]; }\n\n      last++;\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/rules_inline/text_collapse.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/token.js":
/*!*************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/token.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Token class\n\n\n\n\n/**\n * class Token\n **/\n\n/**\n * new Token(type, tag, nesting)\n *\n * Create new token and fill passed properties.\n **/\nfunction Token(type, tag, nesting) {\n  /**\n   * Token#type -> String\n   *\n   * Type of the token (string, e.g. \"paragraph_open\")\n   **/\n  this.type     = type;\n\n  /**\n   * Token#tag -> String\n   *\n   * html tag name, e.g. \"p\"\n   **/\n  this.tag      = tag;\n\n  /**\n   * Token#attrs -> Array\n   *\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n   **/\n  this.attrs    = null;\n\n  /**\n   * Token#map -> Array\n   *\n   * Source map info. Format: `[ line_begin, line_end ]`\n   **/\n  this.map      = null;\n\n  /**\n   * Token#nesting -> Number\n   *\n   * Level change (number in {-1, 0, 1} set), where:\n   *\n   * -  `1` means the tag is opening\n   * -  `0` means the tag is self-closing\n   * - `-1` means the tag is closing\n   **/\n  this.nesting  = nesting;\n\n  /**\n   * Token#level -> Number\n   *\n   * nesting level, the same as `state.level`\n   **/\n  this.level    = 0;\n\n  /**\n   * Token#children -> Array\n   *\n   * An array of child nodes (inline and img tokens)\n   **/\n  this.children = null;\n\n  /**\n   * Token#content -> String\n   *\n   * In a case of self-closing tag (code, html, fence, etc.),\n   * it has contents of this tag.\n   **/\n  this.content  = '';\n\n  /**\n   * Token#markup -> String\n   *\n   * '*' or '_' for emphasis, fence string for fence, etc.\n   **/\n  this.markup   = '';\n\n  /**\n   * Token#info -> String\n   *\n   * fence infostring\n   **/\n  this.info     = '';\n\n  /**\n   * Token#meta -> Object\n   *\n   * A place for plugins to store an arbitrary data\n   **/\n  this.meta     = null;\n\n  /**\n   * Token#block -> Boolean\n   *\n   * True for block-level tokens, false for inline tokens.\n   * Used in renderer to calculate line breaks\n   **/\n  this.block    = false;\n\n  /**\n   * Token#hidden -> Boolean\n   *\n   * If it's true, ignore this element when rendering. Used for tight lists\n   * to hide paragraphs.\n   **/\n  this.hidden   = false;\n}\n\n\n/**\n * Token.attrIndex(name) -> Number\n *\n * Search attribute index by name.\n **/\nToken.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n\n  if (!this.attrs) { return -1; }\n\n  attrs = this.attrs;\n\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) { return i; }\n  }\n  return -1;\n};\n\n\n/**\n * Token.attrPush(attrData)\n *\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\n **/\nToken.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [ attrData ];\n  }\n};\n\n\n/**\n * Token.attrSet(name, value)\n *\n * Set `name` attribute to `value`. Override old value if exists.\n **/\nToken.prototype.attrSet = function attrSet(name, value) {\n  var idx = this.attrIndex(name),\n      attrData = [ name, value ];\n\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\n\n\n/**\n * Token.attrGet(name)\n *\n * Get the value of attribute `name`, or null if it does not exist.\n **/\nToken.prototype.attrGet = function attrGet(name) {\n  var idx = this.attrIndex(name), value = null;\n  if (idx >= 0) {\n    value = this.attrs[idx][1];\n  }\n  return value;\n};\n\n\n/**\n * Token.attrJoin(name, value)\n *\n * Join value to existing attribute via space. Or create new attribute if not\n * exists. Useful to operate with token classes.\n **/\nToken.prototype.attrJoin = function attrJoin(name, value) {\n  var idx = this.attrIndex(name);\n\n  if (idx < 0) {\n    this.attrPush([ name, value ]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n  }\n};\n\n\nmodule.exports = Token;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/lib/token.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/decode.js":
/*!****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/decode.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\n/* eslint-disable no-bitwise */\n\nvar decodeCache = {};\n\nfunction getDecodeCache(exclude) {\n  var i, ch, cache = decodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = decodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache;\n}\n\n\n// Decode percent-encoded string.\n//\nfunction decode(string, exclude) {\n  var cache;\n\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n    var i, l, b1, b2, b3, b4, chr,\n        result = '';\n\n    for (i = 0, l = seq.length; i < l; i += 3) {\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue;\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result;\n  });\n}\n\n\ndecode.defaultChars   = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\n\nmodule.exports = decode;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/decode.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/encode.js":
/*!****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/encode.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\n\nmodule.exports = encode;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/encode.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/format.js":
/*!****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/format.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\nmodule.exports = function format(url) {\n  var result = '';\n\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n\n  return result;\n};\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/format.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/index.js":
/*!***************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports.encode = __webpack_require__(/*! ./encode */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/encode.js\");\nmodule.exports.decode = __webpack_require__(/*! ./decode */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/decode.js\");\nmodule.exports.format = __webpack_require__(/*! ./format */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/format.js\");\nmodule.exports.parse  = __webpack_require__(/*! ./parse */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/parse.js\");\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/parse.js":
/*!***************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/parse.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = [ '\\'' ].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\n    hostEndingChars = [ '/', '?', '#' ],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    /* eslint-disable no-script-url */\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n    /* eslint-enable no-script-url */\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l, lowerProto, hec, slashes,\n      rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nmodule.exports = urlParse;\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/mdurl/parse.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/orderedmap/index.js":
/*!********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/orderedmap/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key)\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this\n    var found = self.find(key), content = self.content.slice()\n    if (found == -1) {\n      content.push(newKey || key, value)\n    } else {\n      content[found + 1] = value\n      if (newKey) content[found] = newKey\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key)\n    if (found == -1) return this\n    var content = this.content.slice()\n    content.splice(found, 2)\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice()\n    content.push(key, value)\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice()\n    var found = without.find(place)\n    content.splice(found == -1 ? content.length : found, 0, key, value)\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1])\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map)\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map)\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this\n    map = OrderedMap.from(map)\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i])\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n}\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = []\n  if (value) for (var prop in value) content.push(prop, value[prop])\n  return new OrderedMap(content)\n}\n\nmodule.exports = OrderedMap\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/orderedmap/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-commands/dist/commands.js":
/*!**************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-commands/dist/commands.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) { return false }\n  if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    { return false }\n\n  var $cut = findCutBefore($cursor);\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    var range = $cursor.blockRange(), target = range && prosemirrorTransform.liftTarget(range);\n    if (target == null) { return false }\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n    return true\n  }\n\n  var before = $cut.nodeBefore;\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    { return true }\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || prosemirrorState.NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());\n      tr.setSelection(textblockAt(before, \"end\") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                      : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n      dispatch(tr.scrollIntoView());\n    }\n    return true\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild))\n    { if (node.isTextblock) { return true } }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nfunction selectNodeBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    { return false }\n\n  var $cut = findCutBefore($cursor), node = $cut && $cut.nodeBefore;\n  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }\n    if ($pos.node(i).type.spec.isolating) { break }\n  } }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    { return false }\n\n  var $cut = findCutAfter($cursor);\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) { return false }\n\n  var after = $cut.nodeAfter;\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) { return true }\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || prosemirrorState.NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());\n      tr.setSelection(textblockAt(after, \"start\") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                      : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n      dispatch(tr.scrollIntoView());\n    }\n    return true\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nfunction selectNodeForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    { return false }\n\n  var $cut = findCutAfter($cursor), node = $cut && $cut.nodeAfter;\n  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) { return false }\n  if (dispatch)\n    { dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {\n    var parent = $pos.node(i);\n    if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }\n    if (parent.type.spec.isolating) { break }\n  } }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nfunction joinUp(state, dispatch) {\n  var sel = state.selection, nodeSel = sel instanceof prosemirrorState.NodeSelection, point;\n  if (nodeSel) {\n    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) { return false }\n    point = sel.from;\n  } else {\n    point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);\n    if (point == null) { return false }\n  }\n  if (dispatch) {\n    var tr = state.tr.join(point);\n    if (nodeSel) { tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nfunction joinDown(state, dispatch) {\n  var sel = state.selection, point;\n  if (sel instanceof prosemirrorState.NodeSelection) {\n    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) { return false }\n    point = sel.to;\n  } else {\n    point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);\n    if (point == null) { return false }\n  }\n  if (dispatch)\n    { dispatch(state.tr.join(point).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to), target = range && prosemirrorTransform.liftTarget(range);\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }\n  if (dispatch) { dispatch(state.tr.insertText(\"\\n\").scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }\n  var above = $head.node(-1), after = $head.indexAfter(-1), type = above.contentMatchAt(after).defaultType;\n  if (!above.canReplaceWith(after, after, type)) { return false }\n  if (dispatch) {\n    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nfunction createParagraphNear(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if ($from.parent.inlineContent || $to.parent.inlineContent) { return false }\n  var type = $from.parent.contentMatchAt($to.indexAfter()).defaultType;\n  if (!type || !type.isTextblock) { return false }\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n  if (!$cursor || $cursor.parent.content.size) { return false }\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n    if (prosemirrorTransform.canSplit(state.doc, before)) {\n      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }\n      return true\n    }\n  }\n  var range = $cursor.blockRange(), target = range && prosemirrorTransform.liftTarget(range);\n  if (target == null) { return false }\n  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) { return false }\n    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }\n    return true\n  }\n\n  if (!$from.parent.isBlock) { return false }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size;\n    var tr = state.tr;\n    if (state.selection instanceof prosemirrorState.TextSelection) { tr.deleteSelection(); }\n    var deflt = $from.depth == 0 ? null : $from.node(-1).contentMatchAt($from.indexAfter(-1)).defaultType;\n    var types = atEnd && deflt ? [{type: deflt}] : null;\n    var can = prosemirrorTransform.canSplit(tr.doc, $from.pos, 1, types);\n    if (!types && !can && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}];\n      can = true;\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&\n          $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), prosemirrorModel.Fragment.from(deflt.create(), $from.parent)))\n        { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }\n    }\n    dispatch(tr.scrollIntoView());\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nfunction splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (function (tr) {\n    var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n    if (marks) { tr.ensureMarks(marks); }\n    dispatch(tr);\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nfunction selectParentNode(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var to = ref.to;\n  var pos;\n  var same = $from.sharedDepth(to);\n  if (same == 0) { return false }\n  pos = $from.before(same);\n  if (dispatch) { dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos))); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nfunction selectAll(state, dispatch) {\n  if (dispatch) { dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc))); }\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos)))\n    { return false }\n  if (dispatch)\n    { dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView()); }\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n  if (before.type.spec.isolating || after.type.spec.isolating) { return false }\n  if (joinMaybeClear(state, $cut, dispatch)) { return true }\n\n  if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize, wrap = prosemirrorModel.Fragment.empty;\n      for (var i = conn.length - 1; i >= 0; i--)\n        { wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap)); }\n      wrap = prosemirrorModel.Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));\n      var joinAt = end + 2 * conn.length;\n      if (prosemirrorTransform.canJoin(tr.doc, joinAt)) { tr.join(joinAt); }\n      dispatch(tr.scrollIntoView());\n    }\n    return true\n  }\n\n  var selAfter = prosemirrorState.Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && prosemirrorTransform.liftTarget(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }\n    return true\n  }\n\n  return false\n}\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nfunction wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);\n    if (!wrapping) { return false }\n    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nfunction setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (node, pos) {\n      if (applicable) { return false }\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        var $pos = state.doc.resolve(pos), index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n    if (!applicable) { return false }\n    if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  var loop = function ( i ) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) { return false }\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n    if (can) { return { v: true } }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nfunction toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var $cursor = ref.$cursor;\n    var ranges = ref.ranges;\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          { dispatch(state.tr.removeStoredMark(markType)); }\n        else\n          { dispatch(state.tr.addStoredMark(markType.create(attrs))); }\n      } else {\n        var has = false, tr = state.tr;\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var ref$1 = ranges[i];\n          var $from = ref$1.$from;\n          var $to = ref$1.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n        for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n          var ref$2 = ranges[i$1];\n          var $from$1 = ref$2.$from;\n          var $to$1 = ref$2.$to;\n          if (has) { tr.removeMark($from$1.pos, $to$1.pos, markType); }\n          else { tr.addMark($from$1.pos, $to$1.pos, markType.create(attrs)); }\n        }\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) { return dispatch(tr) }\n\n    var ranges = [];\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n      for (var j = 0; j < ranges.length; j++)\n        { ranges[j] = map.map(ranges[j]); }\n      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); });\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    var joinable = [];\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1], to = ranges[i$1 + 1];\n      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n        if (!after) { break }\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after))\n            { joinable.push(pos); }\n        }\n        pos += after.nodeSize;\n      }\n    }\n    // Join the joinable points\n    joinable.sort(function (a, b) { return a - b; });\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (prosemirrorTransform.canJoin(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]); }\n    }\n    dispatch(tr);\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable;\n    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; };\n  }\n  return function (state, dispatch) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable)); }\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nfunction chainCommands() {\n  var commands = [], len = arguments.length;\n  while ( len-- ) commands[ len ] = arguments[ len ];\n\n  return function(state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++)\n      { if (commands[i](state, dispatch, view)) { return true } }\n    return false\n  }\n}\n\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n};\nfor (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }\n\n// declare global: os, navigator\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false;\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexports.deleteSelection = deleteSelection;\nexports.joinBackward = joinBackward;\nexports.selectNodeBackward = selectNodeBackward;\nexports.joinForward = joinForward;\nexports.selectNodeForward = selectNodeForward;\nexports.joinUp = joinUp;\nexports.joinDown = joinDown;\nexports.lift = lift;\nexports.newlineInCode = newlineInCode;\nexports.exitCode = exitCode;\nexports.createParagraphNear = createParagraphNear;\nexports.liftEmptyBlock = liftEmptyBlock;\nexports.splitBlock = splitBlock;\nexports.splitBlockKeepMarks = splitBlockKeepMarks;\nexports.selectParentNode = selectParentNode;\nexports.selectAll = selectAll;\nexports.wrapIn = wrapIn;\nexports.setBlockType = setBlockType;\nexports.toggleMark = toggleMark;\nexports.autoJoin = autoJoin;\nexports.chainCommands = chainCommands;\nexports.pcBaseKeymap = pcBaseKeymap;\nexports.macBaseKeymap = macBaseKeymap;\nexports.baseKeymap = baseKeymap;\n//# sourceMappingURL=commands.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-commands/dist/commands.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-dropcursor/dist/dropcursor.js":
/*!******************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-dropcursor/dist/dropcursor.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\n\nfunction dropCursor(options) {\n  if ( options === void 0 ) options = {};\n\n  return new prosemirrorState.Plugin({\n    view: function view(editorView) { return new DropCursorView(editorView, options) }\n  })\n}\n\nvar DropCursorView = function DropCursorView(editorView, options) {\n  var this$1 = this;\n\n  this.editorView = editorView;\n  this.width = options.width || 1;\n  this.color = options.color || \"black\";\n  this.cursorPos = null;\n  this.element = null;\n  this.timeout = null;\n\n  this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(function (name) {\n    var handler = function (e) { return this$1[name](e); };\n    editorView.dom.addEventListener(name, handler);\n    return {name: name, handler: handler}\n  });\n};\n\nDropCursorView.prototype.destroy = function destroy () {\n    var this$1 = this;\n\n  this.handlers.forEach(function (ref) {\n      var name = ref.name;\n      var handler = ref.handler;\n\n      return this$1.editorView.dom.removeEventListener(name, handler);\n    });\n};\n\nDropCursorView.prototype.update = function update (editorView, prevState) {\n  if (this.cursorPos != null && prevState.doc != editorView.state.doc) { this.updateOverlay(); }\n};\n\nDropCursorView.prototype.setCursor = function setCursor (pos) {\n  if (pos == this.cursorPos) { return }\n  this.cursorPos = pos;\n  if (pos == null) {\n    this.element.remove();\n    this.element = null;\n  } else {\n    this.updateOverlay();\n  }\n};\n\nDropCursorView.prototype.updateOverlay = function updateOverlay () {\n  var $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;\n  if (!$pos.parent.inlineContent) {\n    var before = $pos.nodeBefore, after = $pos.nodeAfter;\n    if (before || after) {\n      var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ?before.nodeSize : 0)).getBoundingClientRect();\n      var top = before ? nodeRect.bottom : nodeRect.top;\n      if (before && after)\n        { top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2; }\n      rect = {left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2};\n    }\n  }\n  if (!rect) {\n    var coords = this.editorView.coordsAtPos(this.cursorPos);\n    rect = {left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom};\n  }\n\n  var parent = this.editorView.dom.offsetParent;\n  if (!this.element) {\n    this.element = parent.appendChild(document.createElement(\"div\"));\n    this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none; background-color: \" + this.color;\n  }\n  var parentRect = parent == document.body && getComputedStyle(parent).position == \"static\"\n      ? {left: -pageXOffset, top: -pageYOffset} : parent.getBoundingClientRect();\n  this.element.style.left = (rect.left - parentRect.left) + \"px\";\n  this.element.style.top = (rect.top - parentRect.top) + \"px\";\n  this.element.style.width = (rect.right - rect.left) + \"px\";\n  this.element.style.height = (rect.bottom - rect.top) + \"px\";\n};\n\nDropCursorView.prototype.scheduleRemoval = function scheduleRemoval (timeout) {\n    var this$1 = this;\n\n  clearTimeout(this.timeout);\n  this.timeout = setTimeout(function () { return this$1.setCursor(null); }, timeout);\n};\n\nDropCursorView.prototype.dragover = function dragover (event) {\n  var pos = this.editorView.posAtCoords({left: event.clientX, top: event.clientY});\n  if (pos) {\n    var target = pos.pos;\n    if (this.editorView.dragging && this.editorView.dragging.slice) {\n      target = prosemirrorTransform.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);\n      if (target == null) { target = pos.pos; }\n    }\n    this.setCursor(target);\n    this.scheduleRemoval(5000);\n  }\n};\n\nDropCursorView.prototype.dragend = function dragend () {\n  this.scheduleRemoval(20);\n};\n\nDropCursorView.prototype.drop = function drop () {\n  this.scheduleRemoval(20);\n};\n\nDropCursorView.prototype.dragleave = function dragleave (event) {\n  if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n    { this.setCursor(null); }\n};\n\nexports.dropCursor = dropCursor;\n//# sourceMappingURL=dropcursor.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-dropcursor/dist/dropcursor.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-gapcursor/dist/index.js":
/*!************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-gapcursor/dist/index.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-keymap/dist/keymap.js\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\nvar prosemirrorView = __webpack_require__(/*! prosemirror-view */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\n\n// ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\nvar GapCursor = (function (Selection$$1) {\n  function GapCursor($pos) {\n    Selection$$1.call(this, $pos, $pos);\n  }\n\n  if ( Selection$$1 ) GapCursor.__proto__ = Selection$$1;\n  GapCursor.prototype = Object.create( Selection$$1 && Selection$$1.prototype );\n  GapCursor.prototype.constructor = GapCursor;\n\n  GapCursor.prototype.map = function map (doc, mapping) {\n    var $pos = doc.resolve(mapping.map(this.head));\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection$$1.near($pos)\n  };\n\n  GapCursor.prototype.content = function content () { return prosemirrorModel.Slice.empty };\n\n  GapCursor.prototype.eq = function eq (other) {\n    return other instanceof GapCursor && other.head == this.head\n  };\n\n  GapCursor.prototype.toJSON = function toJSON () {\n    return {type: \"gapcursor\", pos: this.head}\n  };\n\n  GapCursor.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.pos != \"number\") { throw new RangeError(\"Invalid input for GapCursor.fromJSON\") }\n    return new GapCursor(doc.resolve(json.pos))\n  };\n\n  GapCursor.prototype.getBookmark = function getBookmark () { return new GapBookmark(this.anchor) };\n\n  GapCursor.valid = function valid ($pos) {\n    var parent = $pos.parent;\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) { return false }\n    var override = parent.type.spec.allowGapCursor;\n    if (override != null) { return override }\n    var deflt = parent.contentMatchAt($pos.index()).defaultType;\n    return deflt && deflt.isTextblock\n  };\n\n  GapCursor.findFrom = function findFrom ($pos, dir, mustMove) {\n    if (!mustMove && GapCursor.valid($pos)) { return $pos }\n\n    var pos = $pos.pos, next = null;\n    // Scan up from this position\n    for (var d = $pos.depth;; d--) {\n      var parent = $pos.node(d);\n      if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n        next = parent.maybeChild(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n        break\n      } else if (d == 0) {\n        return null\n      }\n      pos += dir;\n      var $cur = $pos.doc.resolve(pos);\n      if (GapCursor.valid($cur)) { return $cur }\n    }\n\n    // And then down into the next node\n    for (;;) {\n      next = dir > 0 ? next.firstChild : next.lastChild;\n      if (!next) { break }\n      pos += dir;\n      var $cur$1 = $pos.doc.resolve(pos);\n      if (GapCursor.valid($cur$1)) { return $cur$1 }\n    }\n\n    return null\n  };\n\n  return GapCursor;\n}(prosemirrorState.Selection));\n\nGapCursor.prototype.visible = false;\n\nprosemirrorState.Selection.jsonID(\"gapcursor\", GapCursor);\n\nvar GapBookmark = function GapBookmark(pos) {\n  this.pos = pos;\n};\nGapBookmark.prototype.map = function map (mapping) {\n  return new GapBookmark(mapping.map(this.pos))\n};\nGapBookmark.prototype.resolve = function resolve (doc) {\n  var $pos = doc.resolve(this.pos);\n  return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos)\n};\n\nfunction closedBefore($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.index(d);\n    // At the start of this parent, look at next one\n    if (index == 0) { continue }\n    // See if the node before (or its first ancestor) is closed\n    for (var before = $pos.node(d).child(index - 1);; before = before.lastChild) {\n      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) { return true }\n      if (before.inlineContent) { return false }\n    }\n  }\n  // Hit start of document\n  return true\n}\n\nfunction closedAfter($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.indexAfter(d), parent = $pos.node(d);\n    if (index == parent.childCount) { continue }\n    for (var after = parent.child(index);; after = after.firstChild) {\n      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) { return true }\n      if (after.inlineContent) { return false }\n    }\n  }\n  return true\n}\n\n// :: () → Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\nvar gapCursor = function() {\n  return new prosemirrorState.Plugin({\n    props: {\n      decorations: drawGapCursor,\n\n      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) { return new GapCursor($head) }\n      },\n\n      handleClick: handleClick,\n      handleKeyDown: handleKeyDown\n    }\n  })\n};\n\nvar handleKeyDown = prosemirrorKeymap.keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\n\nfunction arrow(axis, dir) {\n  var dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n  return function(state, dispatch, view) {\n    var sel = state.selection;\n    var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n    if (sel instanceof prosemirrorState.TextSelection) {\n      if (!view.endOfTextblock(dirStr)) { return false }\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n    var $found = GapCursor.findFrom($start, dir, mustMove);\n    if (!$found) { return false }\n    if (dispatch) { dispatch(state.tr.setSelection(new GapCursor($found))); }\n    return true\n  }\n}\n\nfunction handleClick(view, pos, event) {\n  var $pos = view.state.doc.resolve(pos);\n  if (!GapCursor.valid($pos)) { return false }\n  var ref = view.posAtCoords({left: event.clientX, top: event.clientY});\n  var inside = ref.inside;\n  if (inside > -1 && prosemirrorState.NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) { return false }\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) { return null }\n  var node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return prosemirrorView.DecorationSet.create(state.doc, [prosemirrorView.Decoration.widget(state.selection.head, node, {key: \"gapcursor\"})])\n}\n\nexports.gapCursor = gapCursor;\nexports.GapCursor = GapCursor;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-gapcursor/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-history/dist/history.js":
/*!************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-history/dist/history.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar RopeSequence = _interopDefault(__webpack_require__(/*! rope-sequence */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/rope-sequence/dist/index.js\"));\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nvar max_empty_items = 500;\n\nvar Branch = function Branch(items, eventCount) {\n  this.items = items;\n  this.eventCount = eventCount;\n};\n\n// : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n// Pop the latest event off the branch's history and apply it\n// to a document transform.\nBranch.prototype.popEvent = function popEvent (state, preserveItems) {\n    var this$1 = this;\n\n  if (this.eventCount == 0) { return null }\n\n  var end = this.items.length;\n  for (;; end--) {\n    var next = this$1.items.get(end - 1);\n    if (next.selection) { --end; break }\n  }\n\n  var remap, mapFrom;\n  if (preserveItems) {\n    remap = this.remapping(end, this.items.length);\n    mapFrom = remap.maps.length;\n  }\n  var transform = state.tr;\n  var selection, remaining;\n  var addAfter = [], addBefore = [];\n\n  this.items.forEach(function (item, i) {\n    if (!item.step) {\n      if (!remap) {\n        remap = this$1.remapping(end, i + 1);\n        mapFrom = remap.maps.length;\n      }\n      mapFrom--;\n      addBefore.push(item);\n      return\n    }\n\n    if (remap) {\n      addBefore.push(new Item(item.map));\n      var step = item.step.map(remap.slice(mapFrom)), map;\n\n      if (step && transform.maybeStep(step).doc) {\n        map = transform.mapping.maps[transform.mapping.maps.length - 1];\n        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));\n      }\n      mapFrom--;\n      if (map) { remap.appendMap(map, mapFrom); }\n    } else {\n      transform.maybeStep(item.step);\n    }\n\n    if (item.selection) {\n      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);\n      return false\n    }\n  }, this.items.length, 0);\n\n  return {remaining: remaining, transform: transform, selection: selection}\n};\n\n// : (Transform, ?SelectionBookmark, Object) → Branch\n// Create a new branch with the given transform added.\nBranch.prototype.addTransform = function addTransform (transform, selection, histOptions, preserveItems) {\n  var newItems = [], eventCount = this.eventCount;\n  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n\n  for (var i = 0; i < transform.steps.length; i++) {\n    var step = transform.steps[i].invert(transform.docs[i]);\n    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0);\n    if (merged = lastItem && lastItem.merge(item)) {\n      item = merged;\n      if (i) { newItems.pop(); }\n      else { oldItems = oldItems.slice(0, oldItems.length - 1); }\n    }\n    newItems.push(item);\n    if (selection) {\n      eventCount++;\n      selection = null;\n    }\n    if (!preserveItems) { lastItem = item; }\n  }\n  var overflow = eventCount - histOptions.depth;\n  if (overflow > DEPTH_OVERFLOW) {\n    oldItems = cutOffEvents(oldItems, overflow);\n    eventCount -= overflow;\n  }\n  return new Branch(oldItems.append(newItems), eventCount)\n};\n\nBranch.prototype.remapping = function remapping (from, to) {\n  var maps = new prosemirrorTransform.Mapping;\n  this.items.forEach(function (item, i) {\n    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n        ? mirrorPos = maps.maps.length - item.mirrorOffset : null;\n    maps.appendMap(item.map, mirrorPos);\n  }, from, to);\n  return maps\n};\n\nBranch.prototype.addMaps = function addMaps (array) {\n  if (this.eventCount == 0) { return this }\n  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)\n};\n\n// : (Transform, number)\n// When the collab module receives remote changes, the history has\n// to know about those, so that it can adjust the steps that were\n// rebased on top of the remote changes, and include the position\n// maps for the remote changes in its array of items.\nBranch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {\n  if (!this.eventCount) { return this }\n\n  var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n\n  var mapping = rebasedTransform.mapping;\n  var newUntil = rebasedTransform.steps.length;\n  var eventCount = this.eventCount;\n  this.items.forEach(function (item) { if (item.selection) { eventCount--; } }, start);\n\n  var iRebased = rebasedCount;\n  this.items.forEach(function (item) {\n    var pos = mapping.getMirror(--iRebased);\n    if (pos == null) { return }\n    newUntil = Math.min(newUntil, pos);\n    var map = mapping.maps[pos];\n    if (item.step) {\n      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n      var selection = item.selection && item.selection.map(mapping.slice(iRebased, pos));\n      if (selection) { eventCount++; }\n      rebasedItems.push(new Item(map, step, selection));\n    } else {\n      rebasedItems.push(new Item(map));\n    }\n  }, start);\n\n  var newMaps = [];\n  for (var i = rebasedCount; i < newUntil; i++)\n    { newMaps.push(new Item(mapping.maps[i])); }\n  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n  var branch = new Branch(items, eventCount);\n\n  if (branch.emptyItemCount() > max_empty_items)\n    { branch = branch.compress(this.items.length - rebasedItems.length); }\n  return branch\n};\n\nBranch.prototype.emptyItemCount = function emptyItemCount () {\n  var count = 0;\n  this.items.forEach(function (item) { if (!item.step) { count++; } });\n  return count\n};\n\n// Compressing a branch means rewriting it to push the air (map-only\n// items) out. During collaboration, these naturally accumulate\n// because each remote change adds one. The `upto` argument is used\n// to ensure that only the items below a given level are compressed,\n// because `rebased` relies on a clean, untouched set of items in\n// order to associate old items with rebased steps.\nBranch.prototype.compress = function compress (upto) {\n    if ( upto === void 0 ) upto = this.items.length;\n\n  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n  var items = [], events = 0;\n  this.items.forEach(function (item, i) {\n    if (i >= upto) {\n      items.push(item);\n      if (item.selection) { events++; }\n    } else if (item.step) {\n      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n      mapFrom--;\n      if (map) { remap.appendMap(map, mapFrom); }\n      if (step) {\n        var selection = item.selection && item.selection.map(remap.slice(mapFrom));\n        if (selection) { events++; }\n        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n        if (merged = items.length && items[last].merge(newItem))\n          { items[last] = merged; }\n        else\n          { items.push(newItem); }\n      }\n    } else if (item.map) {\n      mapFrom--;\n    }\n  }, this.items.length, 0);\n  return new Branch(RopeSequence.from(items.reverse()), events)\n};\n\nBranch.empty = new Branch(RopeSequence.empty, 0);\n\nfunction cutOffEvents(items, n) {\n  var cutPoint;\n  items.forEach(function (item, i) {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i;\n      return false\n    }\n  });\n  return items.slice(cutPoint)\n}\n\nvar Item = function Item(map, step, selection, mirrorOffset) {\n  this.map = map;\n  this.step = step;\n  this.selection = selection;\n  this.mirrorOffset = mirrorOffset;\n};\n\nItem.prototype.merge = function merge (other) {\n  if (this.step && other.step && !other.selection) {\n    var step = other.step.merge(this.step);\n    if (step) { return new Item(step.getMap().invert(), step, this.selection) }\n  }\n};\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nvar HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {\n  this.done = done;\n  this.undone = undone;\n  this.prevRanges = prevRanges;\n  this.prevTime = prevTime;\n};\n\nvar DEPTH_OVERFLOW = 20;\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  var historyTr = tr.getMeta(historyKey), rebased;\n  if (historyTr) { return historyTr.historyState }\n\n  if (tr.getMeta(closeHistoryKey)) { history = new HistoryState(history.done, history.undone, null, 0); }\n\n  var appended = tr.getMeta(\"appendedTransaction\");\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      { return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime) }\n    else\n      { return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime) }\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    var newGroup = history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n        !appended && !isAdjacentTo(tr, history.prevRanges);\n    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) { return false }\n  if (!transform.docChanged) { return true }\n  var adjacent = false;\n  transform.mapping.maps[0].forEach(function (start, end) {\n    for (var i = 0; i < prevRanges.length; i += 2)\n      { if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        { adjacent = true; } }\n  });\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  var result = [];\n  map.forEach(function (_from, _to, from, to) { return result.push(from, to); });\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) { return null }\n  var result = [];\n  for (var i = 0; i < ranges.length; i += 2) {\n    var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) { result.push(from, to); }\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;\n  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) { return }\n\n  var selection = pop.selection.resolve(pop.transform.doc);\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems);\n\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo: redo, historyState: newHist}).scrollIntoView());\n}\n\nvar cachedPreserveItems = false;\nvar cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  var plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (var i = 0; i < plugins.length; i++) { if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break\n    } }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nvar historyKey = new prosemirrorState.PluginKey(\"history\");\nvar closeHistoryKey = new prosemirrorState.PluginKey(\"closeHistory\");\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nfunction history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500};\n  return new prosemirrorState.Plugin({\n    key: historyKey,\n\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config: config\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nfunction undo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) { return false }\n  if (dispatch) { histTransaction(hist, state, dispatch, false); }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nfunction redo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) { return false }\n  if (dispatch) { histTransaction(hist, state, dispatch, true); }\n  return true\n}\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0\n}\n\nexports.HistoryState = HistoryState;\nexports.closeHistory = closeHistory;\nexports.history = history;\nexports.undo = undo;\nexports.redo = redo;\nexports.undoDepth = undoDepth;\nexports.redoDepth = redoDepth;\n//# sourceMappingURL=history.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-history/dist/history.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-inputrules/dist/index.js":
/*!*************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-inputrules/dist/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nvar InputRule = function InputRule(match, handler) {\n  this.match = match;\n  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n};\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    var insert = string;\n    if (match[1]) {\n      var offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      var cutOff = start - end;\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n    var marks = state.doc.resolve(start).marks();\n    return state.tr.replaceWith(start, end, state.schema.text(insert, marks))\n  }\n}\n\nvar MAX_MATCH = 500;\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nfunction inputRules(ref) {\n  var rules = ref.rules;\n\n  return new prosemirrorState.Plugin({\n    state: {\n      init: function init() { return null },\n      apply: function apply(tr, prev) {\n        var stored = tr.getMeta(this);\n        if (stored) { return stored }\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput: function handleTextInput(view, from, to, text) {\n        var this$1 = this;\n\n        var state = view.state, $from = state.doc.resolve(from);\n        if ($from.parent.type.spec.code) { return false }\n        var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                                  null, \"\\ufffc\") + text;\n        for (var i = 0; i < rules.length; i++) {\n          var match = rules[i].match.exec(textBefore);\n          var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n          if (!tr) { continue }\n          view.dispatch(tr.setMeta(this$1, {transform: tr, from: from, to: to, text: text}));\n          return true\n        }\n        return false\n      }\n    },\n\n    isInputRules: true\n  })\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nfunction undoInputRule(state, dispatch) {\n  var plugins = state.plugins;\n  for (var i = 0; i < plugins.length; i++) {\n    var plugin = plugins[i], undoable = (void 0);\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        var tr = state.tr, toUndo = undoable.transform;\n        for (var j = toUndo.steps.length - 1; j >= 0; j--)\n          { tr.step(toUndo.steps[j].invert(toUndo.docs[j])); }\n        var marks = tr.doc.resolve(undoable.from).marks();\n        dispatch(tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks)));\n      }\n      return true\n    }\n  }\n  return false\n}\n\n// :: InputRule Converts double dashes to an emdash.\nvar emDash = new InputRule(/--$/, \"—\");\n// :: InputRule Converts three dots to an ellipsis character.\nvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n// :: InputRule “Smart” opening double quotes.\nvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n// :: InputRule “Smart” closing double quotes.\nvar closeDoubleQuote = new InputRule(/\"$/, \"”\");\n// :: InputRule “Smart” opening single quotes.\nvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n// :: InputRule “Smart” closing single quotes.\nvar closeSingleQuote = new InputRule(/'$/, \"’\");\n\n// :: [InputRule] Smart-quote related input rules.\nvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nfunction wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    var tr = state.tr.delete(start, end);\n    var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);\n    if (!wrapping) { return null }\n    tr.wrap(range, wrapping);\n    var before = tr.doc.resolve(start - 1).nodeBefore;\n    if (before && before.type == nodeType && prosemirrorTransform.canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      { tr.join(start - 1); }\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var $start = state.doc.resolve(start);\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) { return null }\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n\nexports.InputRule = InputRule;\nexports.inputRules = inputRules;\nexports.undoInputRule = undoInputRule;\nexports.emDash = emDash;\nexports.ellipsis = ellipsis;\nexports.openDoubleQuote = openDoubleQuote;\nexports.closeDoubleQuote = closeDoubleQuote;\nexports.openSingleQuote = openSingleQuote;\nexports.closeSingleQuote = closeSingleQuote;\nexports.smartQuotes = smartQuotes;\nexports.wrappingInputRule = wrappingInputRule;\nexports.textblockTypeInputRule = textblockTypeInputRule;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-inputrules/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-keymap/dist/keymap.js":
/*!**********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-keymap/dist/keymap.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar keyName = _interopDefault(__webpack_require__(/*! w3c-keyname */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/w3c-keyname/index.js\"));\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n\n// declare global: navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n  if (result == \"Space\") { result = \" \"; }\n  var alt, ctrl, shift, meta;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true; } }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { result = \"Alt-\" + result; }\n  if (ctrl) { result = \"Ctrl-\" + result; }\n  if (meta) { result = \"Meta-\" + result; }\n  if (shift) { result = \"Shift-\" + result; }\n  return result\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null);\n  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) { name = \"Alt-\" + name; }\n  if (event.ctrlKey) { name = \"Ctrl-\" + name; }\n  if (event.metaKey) { name = \"Meta-\" + name; }\n  if (shift !== false && event.shiftKey) { name = \"Shift-\" + name; }\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nfunction keymap(bindings) {\n  return new prosemirrorState.Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) handles them.\nfunction keydownHandler(bindings) {\n  var map = normalize(bindings);\n  return function(view, event) {\n    var name = keyName(event), isChar = name.length == 1 && name != \" \", baseName;\n    var direct = map[modifiers(name, event, !isChar)];\n    if (direct && direct(view.state, view.dispatch, view)) { return true }\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&\n        (baseName = keyName.base[event.keyCode]) && baseName != name) {\n      var fromCode = map[modifiers(baseName, event, true)];\n      if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }\n    }\n    return false\n  }\n}\n\nexports.keymap = keymap;\nexports.keydownHandler = keydownHandler;\n//# sourceMappingURL=keymap.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-keymap/dist/keymap.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-markdown/dist/index.js":
/*!***********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-markdown/dist/index.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\nvar markdownit = _interopDefault(__webpack_require__(/*! markdown-it */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/markdown-it/index.js\"));\n\n// ::Schema Document schema for the data model used by CommonMark.\nvar schema = new prosemirrorModel.Schema({\n  nodes: {\n    doc: {\n      content: \"block+\"\n    },\n\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{tag: \"p\"}],\n      toDOM: function toDOM() { return [\"p\", 0] }\n    },\n\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{tag: \"blockquote\"}],\n      toDOM: function toDOM() { return [\"blockquote\", 0] }\n    },\n\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{tag: \"hr\"}],\n      toDOM: function toDOM() { return [\"div\", [\"hr\"]] }\n    },\n\n    heading: {\n      attrs: {level: {default: 1}},\n      content: \"inline*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n                 {tag: \"h2\", attrs: {level: 2}},\n                 {tag: \"h3\", attrs: {level: 3}},\n                 {tag: \"h4\", attrs: {level: 4}},\n                 {tag: \"h5\", attrs: {level: 5}},\n                 {tag: \"h6\", attrs: {level: 6}}],\n      toDOM: function toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n    },\n\n    code_block: {\n      content: \"text*\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      attrs: {params: {default: \"\"}},\n      parseDOM: [{tag: \"pre\", preserveWhitespace: true, getAttrs: function (node) { return ({params: node.getAttribute(\"data-params\")}); }}],\n      toDOM: function toDOM(node) { return [\"pre\", node.attrs.params ? {\"data-params\": node.attrs.params} : {}, [\"code\", 0]] }\n    },\n\n    ordered_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {order: {default: 1}, tight: {default: false}},\n      parseDOM: [{tag: \"ol\", getAttrs: function getAttrs(dom) {\n        return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1,\n                tight: dom.hasAttribute(\"data-tight\")}\n      }}],\n      toDOM: function toDOM(node) {\n        return [\"ol\", {start: node.attrs.order == 1 ? null : node.attrs.order,\n                       \"data-tight\": node.attrs.tight ? \"true\" : null}, 0]\n      }\n    },\n\n    bullet_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {tight: {default: false}},\n      parseDOM: [{tag: \"ul\", getAttrs: function (dom) { return ({tight: dom.hasAttribute(\"data-tight\")}); }}],\n      toDOM: function toDOM(node) { return [\"ul\", {\"data-tight\": node.attrs.tight ? \"true\" : null}, 0] }\n    },\n\n    list_item: {\n      content: \"paragraph block*\",\n      defining: true,\n      parseDOM: [{tag: \"li\"}],\n      toDOM: function toDOM() { return [\"li\", 0] }\n    },\n\n    text: {\n      group: \"inline\",\n      toDOM: function toDOM(node) { return node.text }\n    },\n\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {default: null},\n        title: {default: null}\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{tag: \"img[src]\", getAttrs: function getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\")\n        }\n      }}],\n      toDOM: function toDOM(node) { return [\"img\", node.attrs] }\n    },\n\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{tag: \"br\"}],\n      toDOM: function toDOM() { return [\"br\"] }\n    }\n  },\n\n  marks: {\n    em: {\n      parseDOM: [{tag: \"i\"}, {tag: \"em\"},\n                 {style: \"font-style\", getAttrs: function (value) { return value == \"italic\" && null; }}],\n      toDOM: function toDOM() { return [\"em\"] }\n    },\n\n    strong: {\n      parseDOM: [{tag: \"b\"}, {tag: \"strong\"},\n                 {style: \"font-weight\", getAttrs: function (value) { return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null; }}],\n      toDOM: function toDOM() { return [\"strong\"] }\n    },\n\n    link: {\n      attrs: {\n        href: {},\n        title: {default: null}\n      },\n      inclusive: false,\n      parseDOM: [{tag: \"a[href]\", getAttrs: function getAttrs(dom) {\n        return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n      }}],\n      toDOM: function toDOM(node) { return [\"a\", node.attrs] }\n    },\n\n    code: {\n      parseDOM: [{tag: \"code\"}],\n      toDOM: function toDOM() { return [\"code\"] }\n    }\n  }\n});\n\nfunction maybeMerge(a, b) {\n  if (a.isText && b.isText && prosemirrorModel.Mark.sameSet(a.marks, b.marks))\n    { return a.copy(a.text + b.text) }\n}\n\n// Object used to track the context of a running parse.\nvar MarkdownParseState = function MarkdownParseState(schema$$1, tokenHandlers) {\n  this.schema = schema$$1;\n  this.stack = [{type: schema$$1.topNodeType, content: []}];\n  this.marks = prosemirrorModel.Mark.none;\n  this.tokenHandlers = tokenHandlers;\n};\n\nMarkdownParseState.prototype.top = function top () {\n  return this.stack[this.stack.length - 1]\n};\n\nMarkdownParseState.prototype.push = function push (elt) {\n  if (this.stack.length) { this.top().content.push(elt); }\n};\n\n// : (string)\n// Adds the given text to the current position in the document,\n// using the current marks as styling.\nMarkdownParseState.prototype.addText = function addText (text) {\n  if (!text) { return }\n  var nodes = this.top().content, last = nodes[nodes.length - 1];\n  var node = this.schema.text(text, this.marks), merged;\n  if (last && (merged = maybeMerge(last, node))) { nodes[nodes.length - 1] = merged; }\n  else { nodes.push(node); }\n};\n\n// : (Mark)\n// Adds the given mark to the set of active marks.\nMarkdownParseState.prototype.openMark = function openMark (mark) {\n  this.marks = mark.addToSet(this.marks);\n};\n\n// : (Mark)\n// Removes the given mark from the set of active marks.\nMarkdownParseState.prototype.closeMark = function closeMark (mark) {\n  this.marks = mark.removeFromSet(this.marks);\n};\n\nMarkdownParseState.prototype.parseTokens = function parseTokens (toks) {\n    var this$1 = this;\n\n  for (var i = 0; i < toks.length; i++) {\n    var tok = toks[i];\n    var handler = this$1.tokenHandlers[tok.type];\n    if (!handler)\n      { throw new Error(\"Token type `\" + tok.type + \"` not supported by Markdown parser\") }\n    handler(this$1, tok);\n  }\n};\n\n// : (NodeType, ?Object, ?[Node]) → ?Node\n// Add a node at the current position.\nMarkdownParseState.prototype.addNode = function addNode (type, attrs, content) {\n  var node = type.createAndFill(attrs, content, this.marks);\n  if (!node) { return null }\n  this.push(node);\n  return node\n};\n\n// : (NodeType, ?Object)\n// Wrap subsequent content in a node of the given type.\nMarkdownParseState.prototype.openNode = function openNode (type, attrs) {\n  this.stack.push({type: type, attrs: attrs, content: []});\n};\n\n// : () → ?Node\n// Close and return the node that is currently on top of the stack.\nMarkdownParseState.prototype.closeNode = function closeNode () {\n  if (this.marks.length) { this.marks = prosemirrorModel.Mark.none; }\n  var info = this.stack.pop();\n  return this.addNode(info.type, info.attrs, info.content)\n};\n\nfunction attrs(spec, token) {\n  if (spec.getAttrs) { return spec.getAttrs(token) }\n  // For backwards compatibility when `attrs` is a Function\n  else if (spec.attrs instanceof Function) { return spec.attrs(token) }\n  else { return spec.attrs }\n}\n\n// Code content is represented as a single token with a `content`\n// property in Markdown-it.\nfunction noOpenClose(type) {\n  return type == \"code_inline\" || type == \"code_block\" || type == \"fence\"\n}\n\nfunction withoutTrailingNewline(str) {\n  return str[str.length - 1] == \"\\n\" ? str.slice(0, str.length - 1) : str\n}\n\nfunction noOp() {}\n\nfunction tokenHandlers(schema$$1, tokens) {\n  var handlers = Object.create(null);\n  var loop = function ( type ) {\n    var spec = tokens[type];\n    if (spec.block) {\n      var nodeType = schema$$1.nodeType(spec.block);\n      if (noOpenClose(type)) {\n        handlers[type] = function (state, tok) {\n          state.openNode(nodeType, attrs(spec, tok));\n          state.addText(withoutTrailingNewline(tok.content));\n          state.closeNode();\n        };\n      } else {\n        handlers[type + \"_open\"] = function (state, tok) { return state.openNode(nodeType, attrs(spec, tok)); };\n        handlers[type + \"_close\"] = function (state) { return state.closeNode(); };\n      }\n    } else if (spec.node) {\n      var nodeType$1 = schema$$1.nodeType(spec.node);\n      handlers[type] = function (state, tok) { return state.addNode(nodeType$1, attrs(spec, tok)); };\n    } else if (spec.mark) {\n      var markType = schema$$1.marks[spec.mark];\n      if (noOpenClose(type)) {\n        handlers[type] = function (state, tok) {\n          state.openMark(markType.create(attrs(spec, tok)));\n          state.addText(withoutTrailingNewline(tok.content));\n          state.closeMark(markType);\n        };\n      } else {\n        handlers[type + \"_open\"] = function (state, tok) { return state.openMark(markType.create(attrs(spec, tok))); };\n        handlers[type + \"_close\"] = function (state) { return state.closeMark(markType); };\n      }\n    } else if (spec.ignore) {\n      if (noOpenClose(type)) {\n        handlers[type] = noOp;\n      } else {\n        handlers[type + '_open'] = noOp;\n        handlers[type + '_close'] = noOp;\n      }\n    } else {\n      throw new RangeError(\"Unrecognized parsing spec \" + JSON.stringify(spec))\n    }\n  };\n\n  for (var type in tokens) loop( type );\n\n  handlers.text = function (state, tok) { return state.addText(tok.content); };\n  handlers.inline = function (state, tok) { return state.parseTokens(tok.children); };\n  handlers.softbreak = handlers.softbreak || (function (state) { return state.addText(\"\\n\"); });\n\n  return handlers\n}\n\n// ::- A configuration of a Markdown parser. Such a parser uses\n// [markdown-it](https://github.com/markdown-it/markdown-it) to\n// tokenize a file, and then runs the custom rules it is given over\n// the tokens to create a ProseMirror document tree.\nvar MarkdownParser = function MarkdownParser(schema$$1, tokenizer, tokens) {\n  // :: Object The value of the `tokens` object used to construct\n  // this parser. Can be useful to copy and modify to base other\n  // parsers on.\n  this.tokens = tokens;\n  this.schema = schema$$1;\n  this.tokenizer = tokenizer;\n  this.tokenHandlers = tokenHandlers(schema$$1, tokens);\n};\n\n// :: (string) → Node\n// Parse a string as [CommonMark](http://commonmark.org/) markup,\n// and create a ProseMirror document as prescribed by this parser's\n// rules.\nMarkdownParser.prototype.parse = function parse (text) {\n  var state = new MarkdownParseState(this.schema, this.tokenHandlers), doc;\n  state.parseTokens(this.tokenizer.parse(text, {}));\n  do { doc = state.closeNode(); } while (state.stack.length)\n  return doc\n};\n\n// :: MarkdownParser\n// A parser parsing unextended [CommonMark](http://commonmark.org/),\n// without inline HTML, and producing a document in the basic schema.\nvar defaultMarkdownParser = new MarkdownParser(schema, markdownit(\"commonmark\", {html: false}), {\n  blockquote: {block: \"blockquote\"},\n  paragraph: {block: \"paragraph\"},\n  list_item: {block: \"list_item\"},\n  bullet_list: {block: \"bullet_list\"},\n  ordered_list: {block: \"ordered_list\", getAttrs: function (tok) { return ({order: +tok.attrGet(\"order\") || 1}); }},\n  heading: {block: \"heading\", getAttrs: function (tok) { return ({level: +tok.tag.slice(1)}); }},\n  code_block: {block: \"code_block\"},\n  fence: {block: \"code_block\", getAttrs: function (tok) { return ({params: tok.info || \"\"}); }},\n  hr: {node: \"horizontal_rule\"},\n  image: {node: \"image\", getAttrs: function (tok) { return ({\n    src: tok.attrGet(\"src\"),\n    title: tok.attrGet(\"title\") || null,\n    alt: tok.children[0] && tok.children[0].content || null\n  }); }},\n  hardbreak: {node: \"hard_break\"},\n\n  em: {mark: \"em\"},\n  strong: {mark: \"strong\"},\n  link: {mark: \"link\", getAttrs: function (tok) { return ({\n    href: tok.attrGet(\"href\"),\n    title: tok.attrGet(\"title\") || null\n  }); }},\n  code_inline: {mark: \"code\"}\n});\n\n// ::- A specification for serializing a ProseMirror document as\n// Markdown/CommonMark text.\nvar MarkdownSerializer = function MarkdownSerializer(nodes, marks) {\n  // :: Object<(MarkdownSerializerState, Node)> The node serializer\n  // functions for this serializer.\n  this.nodes = nodes;\n  // :: Object The mark serializer info.\n  this.marks = marks;\n};\n\n// :: (Node, ?Object) → string\n// Serialize the content of the given node to\n// [CommonMark](http://commonmark.org/).\nMarkdownSerializer.prototype.serialize = function serialize (content, options) {\n  var state = new MarkdownSerializerState(this.nodes, this.marks, options);\n  state.renderContent(content);\n  return state.out\n};\n\n// :: MarkdownSerializer\n// A serializer for the [basic schema](#schema).\nvar defaultMarkdownSerializer = new MarkdownSerializer({\n  blockquote: function blockquote(state, node) {\n    state.wrapBlock(\"> \", null, node, function () { return state.renderContent(node); });\n  },\n  code_block: function code_block(state, node) {\n    state.write(\"```\" + (node.attrs.params || \"\") + \"\\n\");\n    state.text(node.textContent, false);\n    state.ensureNewLine();\n    state.write(\"```\");\n    state.closeBlock(node);\n  },\n  heading: function heading(state, node) {\n    state.write(state.repeat(\"#\", node.attrs.level) + \" \");\n    state.renderInline(node);\n    state.closeBlock(node);\n  },\n  horizontal_rule: function horizontal_rule(state, node) {\n    state.write(node.attrs.markup || \"---\");\n    state.closeBlock(node);\n  },\n  bullet_list: function bullet_list(state, node) {\n    state.renderList(node, \"  \", function () { return (node.attrs.bullet || \"*\") + \" \"; });\n  },\n  ordered_list: function ordered_list(state, node) {\n    var start = node.attrs.order || 1;\n    var maxW = String(start + node.childCount - 1).length;\n    var space = state.repeat(\" \", maxW + 2);\n    state.renderList(node, space, function (i) {\n      var nStr = String(start + i);\n      return state.repeat(\" \", maxW - nStr.length) + nStr + \". \"\n    });\n  },\n  list_item: function list_item(state, node) {\n    state.renderContent(node);\n  },\n  paragraph: function paragraph(state, node) {\n    state.renderInline(node);\n    state.closeBlock(node);\n  },\n\n  image: function image(state, node) {\n    state.write(\"![\" + state.esc(node.attrs.alt || \"\") + \"](\" + state.esc(node.attrs.src) +\n                (node.attrs.title ? \" \" + state.quote(node.attrs.title) : \"\") + \")\");\n  },\n  hard_break: function hard_break(state, node, parent, index) {\n    for (var i = index + 1; i < parent.childCount; i++)\n      { if (parent.child(i).type != node.type) {\n        state.write(\"\\\\\\n\");\n        return\n      } }\n  },\n  text: function text(state, node) {\n    state.text(node.text);\n  }\n}, {\n  em: {open: \"*\", close: \"*\", mixable: true, expelEnclosingWhitespace: true},\n  strong: {open: \"**\", close: \"**\", mixable: true, expelEnclosingWhitespace: true},\n  link: {\n    open: \"[\",\n    close: function close(state, mark) {\n      return \"](\" + state.esc(mark.attrs.href) + (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") + \")\"\n    }\n  },\n  code: {open: \"`\", close: \"`\", escape: false}\n});\n\n// ::- This is an object used to track state and expose\n// methods related to markdown serialization. Instances are passed to\n// node and mark serialization methods (see `toMarkdown`).\nvar MarkdownSerializerState = function MarkdownSerializerState(nodes, marks, options) {\n  this.nodes = nodes;\n  this.marks = marks;\n  this.delim = this.out = \"\";\n  this.closed = false;\n  this.inTightList = false;\n  // :: Object\n  // The options passed to the serializer.\n  // tightLists:: ?bool\n  // Whether to render lists in a tight style. This can be overridden\n  // on a node level by specifying a tight attribute on the node.\n  // Defaults to false.\n  this.options = options || {};\n  if (typeof this.options.tightLists == \"undefined\")\n    { this.options.tightLists = false; }\n};\n\nMarkdownSerializerState.prototype.flushClose = function flushClose (size) {\n    var this$1 = this;\n\n  if (this.closed) {\n    if (!this.atBlank()) { this.out += \"\\n\"; }\n    if (size == null) { size = 2; }\n    if (size > 1) {\n      var delimMin = this.delim;\n      var trim = /\\s+$/.exec(delimMin);\n      if (trim) { delimMin = delimMin.slice(0, delimMin.length - trim[0].length); }\n      for (var i = 1; i < size; i++)\n        { this$1.out += delimMin + \"\\n\"; }\n    }\n    this.closed = false;\n  }\n};\n\n// :: (string, ?string, Node, ())\n// Render a block, prefixing each line with `delim`, and the first\n// line in `firstDelim`. `node` should be the node that is closed at\n// the end of the block, and `f` is a function that renders the\n// content of the block.\nMarkdownSerializerState.prototype.wrapBlock = function wrapBlock (delim, firstDelim, node, f) {\n  var old = this.delim;\n  this.write(firstDelim || delim);\n  this.delim += delim;\n  f();\n  this.delim = old;\n  this.closeBlock(node);\n};\n\nMarkdownSerializerState.prototype.atBlank = function atBlank () {\n  return /(^|\\n)$/.test(this.out)\n};\n\n// :: ()\n// Ensure the current content ends with a newline.\nMarkdownSerializerState.prototype.ensureNewLine = function ensureNewLine () {\n  if (!this.atBlank()) { this.out += \"\\n\"; }\n};\n\n// :: (?string)\n// Prepare the state for writing output (closing closed paragraphs,\n// adding delimiters, and so on), and then optionally add content\n// (unescaped) to the output.\nMarkdownSerializerState.prototype.write = function write (content) {\n  this.flushClose();\n  if (this.delim && this.atBlank())\n    { this.out += this.delim; }\n  if (content) { this.out += content; }\n};\n\n// :: (Node)\n// Close the block for the given node.\nMarkdownSerializerState.prototype.closeBlock = function closeBlock (node) {\n  this.closed = node;\n};\n\n// :: (string, ?bool)\n// Add the given text to the document. When escape is not `false`,\n// it will be escaped.\nMarkdownSerializerState.prototype.text = function text (text$1, escape) {\n    var this$1 = this;\n\n  var lines = text$1.split(\"\\n\");\n  for (var i = 0; i < lines.length; i++) {\n    var startOfLine = this$1.atBlank() || this$1.closed;\n    this$1.write();\n    this$1.out += escape !== false ? this$1.esc(lines[i], startOfLine) : lines[i];\n    if (i != lines.length - 1) { this$1.out += \"\\n\"; }\n  }\n};\n\n// :: (Node)\n// Render the given node as a block.\nMarkdownSerializerState.prototype.render = function render (node, parent, index) {\n  if (typeof parent == \"number\") { throw new Error(\"!\") }\n  this.nodes[node.type.name](this, node, parent, index);\n};\n\n// :: (Node)\n// Render the contents of `parent` as block nodes.\nMarkdownSerializerState.prototype.renderContent = function renderContent (parent) {\n    var this$1 = this;\n\n  parent.forEach(function (node, _, i) { return this$1.render(node, parent, i); });\n};\n\n// :: (Node)\n// Render the contents of `parent` as inline content.\nMarkdownSerializerState.prototype.renderInline = function renderInline (parent) {\n    var this$1 = this;\n\n  var active = [], trailing = \"\";\n  var progress = function (node, _, index) {\n    var marks = node ? node.marks : [];\n\n    // Remove marks from `hard_break` that are the last node inside\n    // that mark to prevent parser edge cases with new lines just\n    // before closing marks.\n    // (FIXME it'd be nice if we had a schema-agnostic way to\n    // identify nodes that serialize as hard breaks)\n    if (node && node.type.name === \"hard_break\")\n      { marks = marks.filter(function (m) {\n        if (index + 1 == parent.childCount) { return false }\n        var next = parent.child(index + 1);\n        return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text))\n      }); }\n\n    var leading = trailing;\n    trailing = \"\";\n    // If whitespace has to be expelled from the node, adjust\n    // leading and trailing accordingly.\n    if (node && node.isText && marks.some(function (mark) {\n      var info = this$1.marks[mark.type.name];\n      return info && info.expelEnclosingWhitespace\n    })) {\n      var ref = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text);\n        var lead = ref[1];\n        var inner$1 = ref[2];\n        var trail = ref[3];\n      leading += lead;\n      trailing = trail;\n      if (lead || trail) {\n        node = inner$1 ? node.withText(inner$1) : null;\n        if (!node) { marks = active; }\n      }\n    }\n\n    var inner = marks.length && marks[marks.length - 1], noEsc = inner && this$1.marks[inner.type.name].escape === false;\n    var len = marks.length - (noEsc ? 1 : 0);\n\n    // Try to reorder 'mixable' marks, such as em and strong, which\n    // in Markdown may be opened and closed in different order, so\n    // that order of the marks for the token matches the order in\n    // active.\n    outer: for (var i = 0; i < len; i++) {\n      var mark = marks[i];\n      if (!this$1.marks[mark.type.name].mixable) { break }\n      for (var j = 0; j < active.length; j++) {\n        var other = active[j];\n        if (!this$1.marks[other.type.name].mixable) { break }\n        if (mark.eq(other)) {\n          if (i > j)\n            { marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len)); }\n          else if (j > i)\n            { marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len)); }\n          continue outer\n        }\n      }\n    }\n\n    // Find the prefix of the mark set that didn't change\n    var keep = 0;\n    while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) { ++keep; }\n\n    // Close the marks that need to be closed\n    while (keep < active.length)\n      { this$1.text(this$1.markString(active.pop(), false), false); }\n\n    // Output any previously expelled trailing whitespace outside the marks\n    if (leading) { this$1.text(leading); }\n\n    // Open the marks that need to be opened\n    if (node) {\n      while (active.length < len) {\n        var add = marks[active.length];\n        active.push(add);\n        this$1.text(this$1.markString(add, true), false);\n      }\n\n      // Render the node. Special case code marks, since their content\n      // may not be escaped.\n      if (noEsc && node.isText)\n        { this$1.text(this$1.markString(inner, true) + node.text + this$1.markString(inner, false), false); }\n      else\n        { this$1.render(node, parent, index); }\n    }\n  };\n  parent.forEach(progress);\n  progress(null);\n};\n\n// :: (Node, string, (number) → string)\n// Render a node's content as a list. `delim` should be the extra\n// indentation added to all lines except the first in an item,\n// `firstDelim` is a function going from an item index to a\n// delimiter for the first line of the item.\nMarkdownSerializerState.prototype.renderList = function renderList (node, delim, firstDelim) {\n    var this$1 = this;\n\n  if (this.closed && this.closed.type == node.type)\n    { this.flushClose(3); }\n  else if (this.inTightList)\n    { this.flushClose(1); }\n\n  var isTight = typeof node.attrs.tight != \"undefined\" ? node.attrs.tight : this.options.tightLists;\n  var prevTight = this.inTightList;\n  this.inTightList = isTight;\n  node.forEach(function (child, _, i) {\n    if (i && isTight) { this$1.flushClose(1); }\n    this$1.wrapBlock(delim, firstDelim(i), node, function () { return this$1.render(child, node, i); });\n  });\n  this.inTightList = prevTight;\n};\n\n// :: (string, ?bool) → string\n// Escape the given string so that it can safely appear in Markdown\n// content. If `startOfLine` is true, also escape characters that\n// has special meaning only at the start of the line.\nMarkdownSerializerState.prototype.esc = function esc (str, startOfLine) {\n  str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\");\n  if (startOfLine) { str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\d+)\\./, \"$1\\\\.\"); }\n  return str\n};\n\nMarkdownSerializerState.prototype.quote = function quote (str) {\n  var wrap = str.indexOf('\"') == -1 ? '\"\"' : str.indexOf(\"'\") == -1 ? \"''\" : \"()\";\n  return wrap[0] + str + wrap[1]\n};\n\n// :: (string, number) → string\n// Repeat the given string `n` times.\nMarkdownSerializerState.prototype.repeat = function repeat (str, n) {\n  var out = \"\";\n  for (var i = 0; i < n; i++) { out += str; }\n  return out\n};\n\n// : (Mark, bool) → string\n// Get the markdown string for a given opening or closing mark.\nMarkdownSerializerState.prototype.markString = function markString (mark, open) {\n  var info = this.marks[mark.type.name];\n  var value = open ? info.open : info.close;\n  return typeof value == \"string\" ? value : value(this, mark)\n};\n\n// :: (string) → { leading: ?string, trailing: ?string }\n// Get leading and trailing whitespace from a string. Values of\n// leading or trailing property of the return object will be undefined\n// if there is no match.\nMarkdownSerializerState.prototype.getEnclosingWhitespace = function getEnclosingWhitespace (text) {\n  return {\n    leading: (text.match(/^(\\s+)/) || [])[0],\n    trailing: (text.match(/(\\s+)$/) || [])[0]\n  }\n};\n\n// Defines a parser and serializer for [CommonMark](http://commonmark.org/) text.\n\nexports.schema = schema;\nexports.defaultMarkdownParser = defaultMarkdownParser;\nexports.MarkdownParser = MarkdownParser;\nexports.MarkdownSerializer = MarkdownSerializer;\nexports.defaultMarkdownSerializer = defaultMarkdownSerializer;\nexports.MarkdownSerializerState = MarkdownSerializerState;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-markdown/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js":
/*!*******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar crel = _interopDefault(__webpack_require__(/*! crel */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/crel/crel.js\"));\nvar prosemirrorCommands = __webpack_require__(/*! prosemirror-commands */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-commands/dist/commands.js\");\nvar prosemirrorHistory = __webpack_require__(/*! prosemirror-history */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-history/dist/history.js\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n\nvar SVG = \"http://www.w3.org/2000/svg\";\nvar XLINK = \"http://www.w3.org/1999/xlink\";\n\nvar prefix$1 = \"ProseMirror-icon\";\n\nfunction hashPath(path) {\n  var hash = 0;\n  for (var i = 0; i < path.length; i++)\n    { hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0; }\n  return hash\n}\n\nfunction getIcon(icon) {\n  var node = document.createElement(\"div\");\n  node.className = prefix$1;\n  if (icon.path) {\n    var name = \"pm-icon-\" + hashPath(icon.path).toString(16);\n    if (!document.getElementById(name)) { buildSVG(name, icon); }\n    var svg = node.appendChild(document.createElementNS(SVG, \"svg\"));\n    svg.style.width = (icon.width / icon.height) + \"em\";\n    var use = svg.appendChild(document.createElementNS(SVG, \"use\"));\n    use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(document.location)[1] + \"#\" + name);\n  } else if (icon.dom) {\n    node.appendChild(icon.dom.cloneNode(true));\n  } else {\n    node.appendChild(document.createElement(\"span\")).textContent = icon.text || '';\n    if (icon.css) { node.firstChild.style.cssText = icon.css; }\n  }\n  return node\n}\n\nfunction buildSVG(name, data) {\n  var collection = document.getElementById(prefix$1 + \"-collection\");\n  if (!collection) {\n    collection = document.createElementNS(SVG, \"svg\");\n    collection.id = prefix$1 + \"-collection\";\n    collection.style.display = \"none\";\n    document.body.insertBefore(collection, document.body.firstChild);\n  }\n  var sym = document.createElementNS(SVG, \"symbol\");\n  sym.id = name;\n  sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height);\n  var path = sym.appendChild(document.createElementNS(SVG, \"path\"));\n  path.setAttribute(\"d\", data.path);\n  collection.appendChild(sym);\n}\n\nvar prefix = \"ProseMirror-menu\";\n\n// ::- An icon or label that, when clicked, executes a command.\nvar MenuItem = function MenuItem(spec) {\n  // :: MenuItemSpec\n  // The spec used to create the menu item.\n  this.spec = spec;\n};\n\n// :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}\n// Renders the icon according to its [display\n// spec](#menu.MenuItemSpec.display), and adds an event handler which\n// executes the command when the representation is clicked.\nMenuItem.prototype.render = function render (view) {\n  var spec = this.spec;\n  var dom = spec.render ? spec.render(view)\n      : spec.icon ? getIcon(spec.icon)\n      : spec.label ? crel(\"div\", null, translate(view, spec.label))\n      : null;\n  if (!dom) { throw new RangeError(\"MenuItem without icon or label property\") }\n  if (spec.title) {\n    var title = (typeof spec.title === \"function\" ? spec.title(view.state) : spec.title);\n    dom.setAttribute(\"title\", translate(view, title));\n  }\n  if (spec.class) { dom.classList.add(spec.class); }\n  if (spec.css) { dom.style.cssText += spec.css; }\n\n  dom.addEventListener(\"mousedown\", function (e) {\n    e.preventDefault();\n    if (!dom.classList.contains(prefix + \"-disabled\"))\n      { spec.run(view.state, view.dispatch, view, e); }\n  });\n\n  function update(state) {\n    if (spec.select) {\n      var selected = spec.select(state);\n      dom.style.display = selected ? \"\" : \"none\";\n      if (!selected) { return false }\n    }\n    var enabled = true;\n    if (spec.enable) {\n      enabled = spec.enable(state) || false;\n      setClass(dom, prefix + \"-disabled\", !enabled);\n    }\n    if (spec.active) {\n      var active = enabled && spec.active(state) || false;\n      setClass(dom, prefix + \"-active\", active);\n    }\n    return true\n  }\n\n  return {dom: dom, update: update}\n};\n\nfunction translate(view, text) {\n  return view._props.translate ? view._props.translate(text) : text\n}\n\n// MenuItemSpec:: interface\n// The configuration object passed to the `MenuItem` constructor.\n//\n//   run:: (EditorState, (Transaction), EditorView, dom.Event)\n//   The function to execute when the menu item is activated.\n//\n//   select:: ?(EditorState) → bool\n//   Optional function that is used to determine whether the item is\n//   appropriate at the moment. Deselected items will be hidden.\n//\n//   enable:: ?(EditorState) → bool\n//   Function that is used to determine if the item is enabled. If\n//   given and returning false, the item will be given a disabled\n//   styling.\n//\n//   active:: ?(EditorState) → bool\n//   A predicate function to determine whether the item is 'active' (for\n//   example, the item for toggling the strong mark might be active then\n//   the cursor is in strong text).\n//\n//   render:: ?(EditorView) → dom.Node\n//   A function that renders the item. You must provide either this,\n//   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).\n//\n//   icon:: ?Object\n//   Describes an icon to show for this item. The object may specify\n//   an SVG icon, in which case its `path` property should be an [SVG\n//   path\n//   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),\n//   and `width` and `height` should provide the viewbox in which that\n//   path exists. Alternatively, it may have a `text` property\n//   specifying a string of text that makes up the icon, with an\n//   optional `css` property giving additional CSS styling for the\n//   text. _Or_ it may contain `dom` property containing a DOM node.\n//\n//   label:: ?string\n//   Makes the item show up as a text label. Mostly useful for items\n//   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object\n//   should have a `label` property providing the text to display.\n//\n//   title:: ?union<string, (EditorState) → string>\n//   Defines DOM title (mouseover) text for the item.\n//\n//   class:: ?string\n//   Optionally adds a CSS class to the item's DOM representation.\n//\n//   css:: ?string\n//   Optionally adds a string of inline CSS to the item's DOM\n//   representation.\n//\n//   execEvent:: ?string\n//   Defines which event on the command's DOM representation should\n//   trigger the execution of the command. Defaults to mousedown.\n\nvar lastMenuEvent = {time: 0, node: null};\nfunction markMenuEvent(e) {\n  lastMenuEvent.time = Date.now();\n  lastMenuEvent.node = e.target;\n}\nfunction isMenuEvent(wrapper) {\n  return Date.now() - 100 < lastMenuEvent.time &&\n    lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)\n}\n\n// ::- A drop-down menu, displayed as a label with a downwards-pointing\n// triangle to the right of it.\nvar Dropdown = function Dropdown(content, options) {\n  this.options = options || {};\n  this.content = Array.isArray(content) ? content : [content];\n};\n\n// :: (EditorView) → {dom: dom.Node, update: (EditorState)}\n// Render the dropdown menu and sub-items.\nDropdown.prototype.render = function render (view) {\n    var this$1 = this;\n\n  var content = renderDropdownItems(this.content, view);\n\n  var label = crel(\"div\", {class: prefix + \"-dropdown \" + (this.options.class || \"\"),\n                           style: this.options.css},\n                   translate(view, this.options.label));\n  if (this.options.title) { label.setAttribute(\"title\", translate(view, this.options.title)); }\n  var wrap = crel(\"div\", {class: prefix + \"-dropdown-wrap\"}, label);\n  var open = null, listeningOnClose = null;\n  var close = function () {\n    if (open && open.close()) {\n      open = null;\n      window.removeEventListener(\"mousedown\", listeningOnClose);\n    }\n  };\n  label.addEventListener(\"mousedown\", function (e) {\n    e.preventDefault();\n    markMenuEvent(e);\n    if (open) {\n      close();\n    } else {\n      open = this$1.expand(wrap, content.dom);\n      window.addEventListener(\"mousedown\", listeningOnClose = function () {\n        if (!isMenuEvent(wrap)) { close(); }\n      });\n    }\n  });\n\n  function update(state) {\n    var inner = content.update(state);\n    wrap.style.display = inner ? \"\" : \"none\";\n    return inner\n  }\n\n  return {dom: wrap, update: update}\n};\n\nDropdown.prototype.expand = function expand (dom, items) {\n  var menuDOM = crel(\"div\", {class: prefix + \"-dropdown-menu \" + (this.options.class || \"\")}, items);\n\n  var done = false;\n  function close() {\n    if (done) { return }\n    done = true;\n    dom.removeChild(menuDOM);\n    return true\n  }\n  dom.appendChild(menuDOM);\n  return {close: close, node: menuDOM}\n};\n\nfunction renderDropdownItems(items, view) {\n  var rendered = [], updates = [];\n  for (var i = 0; i < items.length; i++) {\n    var ref = items[i].render(view);\n    var dom = ref.dom;\n    var update = ref.update;\n    rendered.push(crel(\"div\", {class: prefix + \"-dropdown-item\"}, dom));\n    updates.push(update);\n  }\n  return {dom: rendered, update: combineUpdates(updates, rendered)}\n}\n\nfunction combineUpdates(updates, nodes) {\n  return function (state) {\n    var something = false;\n    for (var i = 0; i < updates.length; i++) {\n      var up = updates[i](state);\n      nodes[i].style.display = up ? \"\" : \"none\";\n      if (up) { something = true; }\n    }\n    return something\n  }\n}\n\n// ::- Represents a submenu wrapping a group of elements that start\n// hidden and expand to the right when hovered over or tapped.\nvar DropdownSubmenu = function DropdownSubmenu(content, options) {\n  this.options = options || {};\n  this.content = Array.isArray(content) ? content : [content];\n};\n\n// :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}\n// Renders the submenu.\nDropdownSubmenu.prototype.render = function render (view) {\n  var items = renderDropdownItems(this.content, view);\n\n  var label = crel(\"div\", {class: prefix + \"-submenu-label\"}, translate(view, this.options.label));\n  var wrap = crel(\"div\", {class: prefix + \"-submenu-wrap\"}, label,\n                 crel(\"div\", {class: prefix + \"-submenu\"}, items.dom));\n  var listeningOnClose = null;\n  label.addEventListener(\"mousedown\", function (e) {\n    e.preventDefault();\n    markMenuEvent(e);\n    setClass(wrap, prefix + \"-submenu-wrap-active\");\n    if (!listeningOnClose)\n      { window.addEventListener(\"mousedown\", listeningOnClose = function () {\n        if (!isMenuEvent(wrap)) {\n          wrap.classList.remove(prefix + \"-submenu-wrap-active\");\n          window.removeEventListener(\"mousedown\", listeningOnClose);\n          listeningOnClose = null;\n        }\n      }); }\n  });\n\n  function update(state) {\n    var inner = items.update(state);\n    wrap.style.display = inner ? \"\" : \"none\";\n    return inner\n  }\n  return {dom: wrap, update: update}\n};\n\n// :: (EditorView, [union<MenuElement, [MenuElement]>]) → {dom: ?dom.DocumentFragment, update: (EditorState) → bool}\n// Render the given, possibly nested, array of menu elements into a\n// document fragment, placing separators between them (and ensuring no\n// superfluous separators appear when some of the groups turn out to\n// be empty).\nfunction renderGrouped(view, content) {\n  var result = document.createDocumentFragment();\n  var updates = [], separators = [];\n  for (var i = 0; i < content.length; i++) {\n    var items = content[i], localUpdates = [], localNodes = [];\n    for (var j = 0; j < items.length; j++) {\n      var ref = items[j].render(view);\n      var dom = ref.dom;\n      var update$1 = ref.update;\n      var span = crel(\"span\", {class: prefix + \"item\"}, dom);\n      result.appendChild(span);\n      localNodes.push(span);\n      localUpdates.push(update$1);\n    }\n    if (localUpdates.length) {\n      updates.push(combineUpdates(localUpdates, localNodes));\n      if (i < content.length - 1)\n        { separators.push(result.appendChild(separator())); }\n    }\n  }\n\n  function update(state) {\n    var something = false, needSep = false;\n    for (var i = 0; i < updates.length; i++) {\n      var hasContent = updates[i](state);\n      if (i) { separators[i - 1].style.display = needSep && hasContent ? \"\" : \"none\"; }\n      needSep = hasContent;\n      if (hasContent) { something = true; }\n    }\n    return something\n  }\n  return {dom: result, update: update}\n}\n\nfunction separator() {\n  return crel(\"span\", {class: prefix + \"separator\"})\n}\n\n// :: Object\n// A set of basic editor-related icons. Contains the properties\n// `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,\n// `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each\n// holding an object that can be used as the `icon` option to\n// `MenuItem`.\nvar icons = {\n  join: {\n    width: 800, height: 900,\n    path: \"M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z\"\n  },\n  lift: {\n    width: 1024, height: 1024,\n    path: \"M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z\"\n  },\n  selectParentNode: {text: \"\\u2b1a\", css: \"font-weight: bold\"},\n  undo: {\n    width: 1024, height: 1024,\n    path: \"M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z\"\n  },\n  redo: {\n    width: 1024, height: 1024,\n    path: \"M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z\"\n  },\n  strong: {\n    width: 805, height: 1024,\n    path: \"M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z\"\n  },\n  em: {\n    width: 585, height: 1024,\n    path: \"M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z\"\n  },\n  code: {\n    width: 896, height: 1024,\n    path: \"M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z\"\n  },\n  link: {\n    width: 951, height: 1024,\n    path: \"M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z\"\n  },\n  bulletList: {\n    width: 768, height: 896,\n    path: \"M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z\"\n  },\n  orderedList: {\n    width: 768, height: 896,\n    path: \"M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z\"\n  },\n  blockquote: {\n    width: 640, height: 896,\n    path: \"M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z\"\n  }\n};\n\n// :: MenuItem\n// Menu item for the `joinUp` command.\nvar joinUpItem = new MenuItem({\n  title: \"Join with above block\",\n  run: prosemirrorCommands.joinUp,\n  select: function (state) { return prosemirrorCommands.joinUp(state); },\n  icon: icons.join\n});\n\n// :: MenuItem\n// Menu item for the `lift` command.\nvar liftItem = new MenuItem({\n  title: \"Lift out of enclosing block\",\n  run: prosemirrorCommands.lift,\n  select: function (state) { return prosemirrorCommands.lift(state); },\n  icon: icons.lift\n});\n\n// :: MenuItem\n// Menu item for the `selectParentNode` command.\nvar selectParentNodeItem = new MenuItem({\n  title: \"Select parent node\",\n  run: prosemirrorCommands.selectParentNode,\n  select: function (state) { return prosemirrorCommands.selectParentNode(state); },\n  icon: icons.selectParentNode\n});\n\n// :: MenuItem\n// Menu item for the `undo` command.\nvar undoItem = new MenuItem({\n  title: \"Undo last change\",\n  run: prosemirrorHistory.undo,\n  enable: function (state) { return prosemirrorHistory.undo(state); },\n  icon: icons.undo\n});\n\n// :: MenuItem\n// Menu item for the `redo` command.\nvar redoItem = new MenuItem({\n  title: \"Redo last undone change\",\n  run: prosemirrorHistory.redo,\n  enable: function (state) { return prosemirrorHistory.redo(state); },\n  icon: icons.redo\n});\n\n// :: (NodeType, Object) → MenuItem\n// Build a menu item for wrapping the selection in a given node type.\n// Adds `run` and `select` properties to the ones present in\n// `options`. `options.attrs` may be an object or a function.\nfunction wrapItem(nodeType, options) {\n  var passedOptions = {\n    run: function run(state, dispatch) {\n      // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))\n      return prosemirrorCommands.wrapIn(nodeType, options.attrs)(state, dispatch)\n    },\n    select: function select(state) {\n      return prosemirrorCommands.wrapIn(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)\n    }\n  };\n  for (var prop in options) { passedOptions[prop] = options[prop]; }\n  return new MenuItem(passedOptions)\n}\n\n// :: (NodeType, Object) → MenuItem\n// Build a menu item for changing the type of the textblock around the\n// selection to the given type. Provides `run`, `active`, and `select`\n// properties. Others must be given in `options`. `options.attrs` may\n// be an object to provide the attributes for the textblock node.\nfunction blockTypeItem(nodeType, options) {\n  var command = prosemirrorCommands.setBlockType(nodeType, options.attrs);\n  var passedOptions = {\n    run: command,\n    enable: function enable(state) { return command(state) },\n    active: function active(state) {\n      var ref = state.selection;\n      var $from = ref.$from;\n      var to = ref.to;\n      var node = ref.node;\n      if (node) { return node.hasMarkup(nodeType, options.attrs) }\n      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)\n    }\n  };\n  for (var prop in options) { passedOptions[prop] = options[prop]; }\n  return new MenuItem(passedOptions)\n}\n\n// Work around classList.toggle being broken in IE11\nfunction setClass(dom, cls, on) {\n  if (on) { dom.classList.add(cls); }\n  else { dom.classList.remove(cls); }\n}\n\nvar prefix$2 = \"ProseMirror-menubar\";\n\nfunction isIOS() {\n  if (typeof navigator == \"undefined\") { return false }\n  var agent = navigator.userAgent;\n  return !/Edge\\/\\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\\/\\w+/.test(agent)\n}\n\n// :: (Object) → Plugin\n// A plugin that will place a menu bar above the editor. Note that\n// this involves wrapping the editor in an additional `<div>`.\n//\n//   options::-\n//   Supports the following options:\n//\n//     content:: [[MenuElement]]\n//     Provides the content of the menu, as a nested array to be\n//     passed to `renderGrouped`.\n//\n//     floating:: ?bool\n//     Determines whether the menu floats, i.e. whether it sticks to\n//     the top of the viewport when the editor is partially scrolled\n//     out of view.\nfunction menuBar(options) {\n  return new prosemirrorState.Plugin({\n    view: function view(editorView) { return new MenuBarView(editorView, options) }\n  })\n}\n\nvar MenuBarView = function MenuBarView(editorView, options) {\n  var this$1 = this;\n\n  this.editorView = editorView;\n  this.options = options;\n\n  this.wrapper = crel(\"div\", {class: prefix$2 + \"-wrapper\"});\n  this.menu = this.wrapper.appendChild(crel(\"div\", {class: prefix$2}));\n  this.menu.className = prefix$2;\n  this.spacer = null;\n\n  editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);\n  this.wrapper.appendChild(editorView.dom);\n\n  this.maxHeight = 0;\n  this.widthForMaxHeight = 0;\n  this.floating = false;\n\n  var ref = renderGrouped(this.editorView, this.options.content);\n  var dom = ref.dom;\n  var update = ref.update;\n  this.contentUpdate = update;\n  this.menu.appendChild(dom);\n  this.update();\n\n  if (options.floating && !isIOS()) {\n    this.updateFloat();\n    var potentialScrollers = getAllWrapping(this.wrapper);\n    this.scrollFunc = function (e) {\n      var root = this$1.editorView.root;\n      if (!(root.body || root).contains(this$1.wrapper)) {\n          potentialScrollers.forEach(function (el) { return el.removeEventListener(\"scroll\", this$1.scrollFunc); });\n      } else {\n          this$1.updateFloat(e.target.getBoundingClientRect && e.target);\n      }\n    };\n    potentialScrollers.forEach(function (el) { return el.addEventListener('scroll', this$1.scrollFunc); });\n  }\n};\n\nMenuBarView.prototype.update = function update () {\n  this.contentUpdate(this.editorView.state);\n\n  if (this.floating) {\n    this.updateScrollCursor();\n  } else {\n    if (this.menu.offsetWidth != this.widthForMaxHeight) {\n      this.widthForMaxHeight = this.menu.offsetWidth;\n      this.maxHeight = 0;\n    }\n    if (this.menu.offsetHeight > this.maxHeight) {\n      this.maxHeight = this.menu.offsetHeight;\n      this.menu.style.minHeight = this.maxHeight + \"px\";\n    }\n  }\n};\n\nMenuBarView.prototype.updateScrollCursor = function updateScrollCursor () {\n  var selection = this.editorView.root.getSelection();\n  if (!selection.focusNode) { return }\n  var rects = selection.getRangeAt(0).getClientRects();\n  var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];\n  if (!selRect) { return }\n  var menuRect = this.menu.getBoundingClientRect();\n  if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {\n    var scrollable = findWrappingScrollable(this.wrapper);\n    if (scrollable) { scrollable.scrollTop -= (menuRect.bottom - selRect.top); }\n  }\n};\n\nMenuBarView.prototype.updateFloat = function updateFloat (scrollAncestor) {\n  var parent = this.wrapper, editorRect = parent.getBoundingClientRect(),\n      top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;\n\n  if (this.floating) {\n    if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {\n      this.floating = false;\n      this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = \"\";\n      this.menu.style.display = \"\";\n      this.spacer.parentNode.removeChild(this.spacer);\n      this.spacer = null;\n    } else {\n      var border = (parent.offsetWidth - parent.clientWidth) / 2;\n      this.menu.style.left = (editorRect.left + border) + \"px\";\n      this.menu.style.display = (editorRect.top > window.innerHeight ? \"none\" : \"\");\n      if (scrollAncestor) { this.menu.style.top = top + \"px\"; }\n    }\n  } else {\n    if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {\n      this.floating = true;\n      var menuRect = this.menu.getBoundingClientRect();\n      this.menu.style.left = menuRect.left + \"px\";\n      this.menu.style.width = menuRect.width + \"px\";\n      if (scrollAncestor) { this.menu.style.top = top + \"px\"; }\n      this.menu.style.position = \"fixed\";\n      this.spacer = crel(\"div\", {class: prefix$2 + \"-spacer\", style: (\"height: \" + (menuRect.height) + \"px\")});\n      parent.insertBefore(this.spacer, this.menu);\n    }\n  }\n};\n\nMenuBarView.prototype.destroy = function destroy () {\n  if (this.wrapper.parentNode)\n    { this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper); }\n};\n\n// Not precise, but close enough\nfunction selectionIsInverted(selection) {\n  if (selection.anchorNode == selection.focusNode) { return selection.anchorOffset > selection.focusOffset }\n  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING\n}\n\nfunction findWrappingScrollable(node) {\n  for (var cur = node.parentNode; cur; cur = cur.parentNode)\n    { if (cur.scrollHeight > cur.clientHeight) { return cur } }\n}\n\nfunction getAllWrapping(node) {\n    var res = [window];\n    for (var cur = node.parentNode; cur; cur = cur.parentNode)\n        { res.push(cur); }\n    return res\n}\n\n// !! This module defines a number of building blocks for ProseMirror\n// menus, along with a [menu bar](#menu.menuBar) implementation.\n\n// MenuElement:: interface\n// The types defined in this module aren't the only thing you can\n// display in your menu. Anything that conforms to this interface can\n// be put into a menu structure.\n//\n//   render:: (pm: EditorView) → {dom: dom.Node, update: (EditorState) → bool}\n//   Render the element for display in the menu. Must return a DOM\n//   element and a function that can be used to update the element to\n//   a new state. The `update` function will return false if the\n//   update hid the entire element.\n\nexports.MenuItem = MenuItem;\nexports.Dropdown = Dropdown;\nexports.DropdownSubmenu = DropdownSubmenu;\nexports.renderGrouped = renderGrouped;\nexports.icons = icons;\nexports.joinUpItem = joinUpItem;\nexports.liftItem = liftItem;\nexports.selectParentNodeItem = selectParentNodeItem;\nexports.undoItem = undoItem;\nexports.redoItem = redoItem;\nexports.wrapItem = wrapItem;\nexports.blockTypeItem = blockTypeItem;\nexports.menuBar = menuBar;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar OrderedMap = _interopDefault(__webpack_require__(/*! orderedmap */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/orderedmap/index.js\"));\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      { return a.childCount == b.childCount ? null : pos }\n\n    var childA = a.child(i), childB = b.child(i);\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) { return pos }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++)\n        { pos++; }\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) { return inner }\n    }\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      { return iA == iB ? null : {a: posA, b: posB} }\n\n    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size; posB -= size;\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--;\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) { return inner }\n    }\n    posA -= size; posB -= size;\n  }\n}\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nvar Fragment = function Fragment(content, size) {\n  var this$1 = this;\n\n  this.content = content;\n  // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n  this.size = size || 0;\n  if (size == null) { for (var i = 0; i < content.length; i++)\n    { this$1.size += content[i].nodeSize; } }\n};\n\nvar prototypeAccessors$1 = { firstChild: {},lastChild: {},childCount: {} };\n\n// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\nFragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {\n    var this$1 = this;\n    if ( nodeStart === void 0 ) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this$1.content[i], end = pos + child.nodeSize;\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start),\n                         Math.min(child.content.size, to - start),\n                         f, nodeStart + start);\n    }\n    pos = end;\n  }\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\nFragment.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.size, f);\n};\n\n// : (number, number, ?string, ?string) → string\nFragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  var text = \"\", separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text\n};\n\n// :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\nFragment.prototype.append = function append (other) {\n  if (!other.size) { return this }\n  if (!this.size) { return other }\n  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n  for (; i < other.content.length; i++) { content.push(other.content[i]); }\n  return new Fragment(content, this.size + other.size)\n};\n\n// :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\nFragment.prototype.cut = function cut (from, to) {\n    var this$1 = this;\n\n  if (to == null) { to = this.size; }\n  if (from == 0 && to == this.size) { return this }\n  var result = [], size = 0;\n  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this$1.content[i], end = pos + child.nodeSize;\n    if (end > from) {\n      if (pos < from || end > to) {\n        if (child.isText)\n          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }\n        else\n          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }\n      }\n      result.push(child);\n      size += child.nodeSize;\n    }\n    pos = end;\n  } }\n  return new Fragment(result, size)\n};\n\nFragment.prototype.cutByIndex = function cutByIndex (from, to) {\n  if (from == to) { return Fragment.empty }\n  if (from == 0 && to == this.content.length) { return this }\n  return new Fragment(this.content.slice(from, to))\n};\n\n// :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\nFragment.prototype.replaceChild = function replaceChild (index, node) {\n  var current = this.content[index];\n  if (current == node) { return this }\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\nFragment.prototype.addToStart = function addToStart (node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n};\n\n// : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\nFragment.prototype.addToEnd = function addToEnd (node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n};\n\n// :: (Fragment) → bool\n// Compare this fragment to another one.\nFragment.prototype.eq = function eq (other) {\n    var this$1 = this;\n\n  if (this.content.length != other.content.length) { return false }\n  for (var i = 0; i < this.content.length; i++)\n    { if (!this$1.content[i].eq(other.content[i])) { return false } }\n  return true\n};\n\n// :: ?Node\n// The first child of the fragment, or `null` if it is empty.\nprototypeAccessors$1.firstChild.get = function () { return this.content.length ? this.content[0] : null };\n\n// :: ?Node\n// The last child of the fragment, or `null` if it is empty.\nprototypeAccessors$1.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };\n\n// :: number\n// The number of child nodes in this fragment.\nprototypeAccessors$1.childCount.get = function () { return this.content.length };\n\n// :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\nFragment.prototype.child = function child (index) {\n  var found = this.content[index];\n  if (!found) { throw new RangeError(\"Index \" + index + \" out of range for \" + this) }\n  return found\n};\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nFragment.prototype.maybeChild = function maybeChild (index) {\n  return this.content[index]\n};\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nFragment.prototype.forEach = function forEach (f) {\n    var this$1 = this;\n\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this$1.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n};\n\n// :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\nFragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {\n    if ( pos === void 0 ) pos = 0;\n\n  return findDiffStart(this, other, pos)\n};\n\n// :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\nFragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {\n    if ( pos === void 0 ) pos = this.size;\n    if ( otherPos === void 0 ) otherPos = other.size;\n\n  return findDiffEnd(this, other, pos, otherPos)\n};\n\n// : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\nFragment.prototype.findIndex = function findIndex (pos, round) {\n    var this$1 = this;\n    if ( round === void 0 ) round = -1;\n\n  if (pos == 0) { return retIndex(0, pos) }\n  if (pos == this.size) { return retIndex(this.content.length, pos) }\n  if (pos > this.size || pos < 0) { throw new RangeError((\"Position \" + pos + \" outside of fragment (\" + (this) + \")\")) }\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this$1.child(i), end = curPos + cur.nodeSize;\n    if (end >= pos) {\n      if (end == pos || round > 0) { return retIndex(i + 1, end) }\n      return retIndex(i, curPos)\n    }\n    curPos = end;\n  }\n};\n\n// :: () → string\n// Return a debugging string that describes this fragment.\nFragment.prototype.toString = function toString () { return \"<\" + this.toStringInner() + \">\" };\n\nFragment.prototype.toStringInner = function toStringInner () { return this.content.join(\", \") };\n\n// :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\nFragment.prototype.toJSON = function toJSON () {\n  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null\n};\n\n// :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\nFragment.fromJSON = function fromJSON (schema, value) {\n  if (!value) { return Fragment.empty }\n  if (!Array.isArray(value)) { throw new RangeError(\"Invalid input for Fragment.fromJSON\") }\n  return new Fragment(value.map(schema.nodeFromJSON))\n};\n\n// :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\nFragment.fromArray = function fromArray (array) {\n  if (!array.length) { return Fragment.empty }\n  var joined, size = 0;\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) { joined = array.slice(0, i); }\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n  return new Fragment(joined || array, size)\n};\n\n// :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\nFragment.from = function from (nodes) {\n  if (!nodes) { return Fragment.empty }\n  if (nodes instanceof Fragment) { return nodes }\n  if (Array.isArray(nodes)) { return this.fromArray(nodes) }\n  return new Fragment([nodes], nodes.nodeSize)\n};\n\nObject.defineProperties( Fragment.prototype, prototypeAccessors$1 );\n\nvar found = {index: 0, offset: 0};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) { return true }\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) { return false }\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) { return false }\n  if (array) {\n    if (a.length != b.length) { return false }\n    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }\n  } else {\n    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }\n    for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  }\n  return true\n}\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type;\n  // :: Object\n  // The attributes associated with this mark.\n  this.attrs = attrs;\n};\n\n// :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\nMark.prototype.addToSet = function addToSet (set) {\n    var this$1 = this;\n\n  var copy, placed = false;\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n    if (this$1.eq(other)) { return set }\n    if (this$1.type.excludes(other.type)) {\n      if (!copy) { copy = set.slice(0, i); }\n    } else if (other.type.excludes(this$1.type)) {\n      return set\n    } else {\n      if (!placed && other.type.rank > this$1.type.rank) {\n        if (!copy) { copy = set.slice(0, i); }\n        copy.push(this$1);\n        placed = true;\n      }\n      if (copy) { copy.push(other); }\n    }\n  }\n  if (!copy) { copy = set.slice(); }\n  if (!placed) { copy.push(this); }\n  return copy\n};\n\n// :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\nMark.prototype.removeFromSet = function removeFromSet (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (this$1.eq(set[i]))\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\nMark.prototype.isInSet = function isInSet (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (this$1.eq(set[i])) { return true } }\n  return false\n};\n\n// :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\nMark.prototype.eq = function eq (other) {\n  return this == other ||\n    (this.type == other.type && compareDeep(this.attrs, other.attrs))\n};\n\n// :: () → Object\n// Convert this mark to a JSON-serializeable representation.\nMark.prototype.toJSON = function toJSON () {\n    var this$1 = this;\n\n  var obj = {type: this.type.name};\n  for (var _ in this$1.attrs) {\n    obj.attrs = this$1.attrs;\n    break\n  }\n  return obj\n};\n\n// :: (Schema, Object) → Mark\nMark.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Mark.fromJSON\") }\n  var type = schema.marks[json.type];\n  if (!type) { throw new RangeError((\"There is no mark type \" + (json.type) + \" in this schema\")) }\n  return type.create(json.attrs)\n};\n\n// :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\nMark.sameSet = function sameSet (a, b) {\n  if (a == b) { return true }\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++)\n    { if (!a[i].eq(b[i])) { return false } }\n  return true\n};\n\n// :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\nMark.setFrom = function setFrom (marks) {\n  if (!marks || marks.length == 0) { return Mark.none }\n  if (marks instanceof Mark) { return [marks] }\n  var copy = marks.slice();\n  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });\n  return copy\n};\n\n// :: [Mark] The empty set of marks.\nMark.none = [];\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\";\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content;\n  // :: number The open depth at the start.\n  this.openStart = openStart;\n  // :: number The open depth at the end.\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$2 = { size: {} };\n\n// :: number\n// The size this slice would add when inserted into a document.\nprototypeAccessors$2.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd\n};\n\nSlice.prototype.insertAt = function insertAt (pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd)\n};\n\nSlice.prototype.removeBetween = function removeBetween (from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n};\n\n// :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\nSlice.prototype.eq = function eq (other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n};\n\nSlice.prototype.toString = function toString () {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n};\n\n// :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\nSlice.prototype.toJSON = function toJSON () {\n  if (!this.content.size) { return null }\n  var json = {content: this.content.toJSON()};\n  if (this.openStart > 0) { json.openStart = this.openStart; }\n  if (this.openEnd > 0) { json.openEnd = this.openEnd; }\n  return json\n};\n\n// :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\nSlice.fromJSON = function fromJSON (schema, json) {\n  if (!json) { return Slice.empty }\n  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n    { throw new RangeError(\"Invalid input for Slice.fromJSON\") }\n  return new Slice(Fragment.fromJSON(schema, json.content), json.openStart || 0, json.openEnd || 0)\n};\n\n// :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\nSlice.maxOpen = function maxOpen (fragment, openIsolating) {\n    if ( openIsolating === void 0 ) openIsolating=true;\n\n  var openStart = 0, openEnd = 0;\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }\n  return new Slice(fragment, openStart, openEnd)\n};\n\nObject.defineProperties( Slice.prototype, prototypeAccessors$2 );\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError(\"Removing non-flat range\") }\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) { throw new RangeError(\"Removing non-flat range\") }\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) { return null }\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    { throw new ReplaceError(\"Inserted content deeper than insertion position\") }\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    { throw new ReplaceError(\"Inconsistent open depths\") }\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    var parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    { throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name) }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    { target[last] = child.withText(target[last].text + child.text); }\n  else\n    { target.push(child); }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }\n  if ($end && $end.depth == depth && $end.textOffset)\n    { addNode($end.nodeBefore, target); }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    { throw new ReplaceError(\"Invalid content for node \" + node.type.name) }\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--)\n    { node = $along.node(i).copy(Fragment.from(node)); }\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path;\n  // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n  this.depth = path.length / 3 - 1;\n  // :: number The offset this position has into its parent node.\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$3 = { parent: {},doc: {},textOffset: {},nodeAfter: {},nodeBefore: {} };\n\nResolvedPos.prototype.resolveDepth = function resolveDepth (val) {\n  if (val == null) { return this.depth }\n  if (val < 0) { return this.depth + val }\n  return val\n};\n\n// :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\nprototypeAccessors$3.parent.get = function () { return this.node(this.depth) };\n\n// :: Node\n// The root node in which the position was resolved.\nprototypeAccessors$3.doc.get = function () { return this.node(0) };\n\n// :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\nResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };\n\n// :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 2 and `p.index(1)` is 3.\nResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };\n\n// :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\nResolvedPos.prototype.indexAfter = function indexAfter (depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n};\n\n// :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\nResolvedPos.prototype.start = function start (depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n};\n\n// :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\nResolvedPos.prototype.end = function end (depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size\n};\n\n// :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `level` is `this.depth + 1`, the original\n// position.\nResolvedPos.prototype.before = function before (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position before the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n};\n\n// :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `level` is `this.depth + 1`.\nResolvedPos.prototype.after = function after (depth) {\n  depth = this.resolveDepth(depth);\n  if (!depth) { throw new RangeError(\"There is no position after the top-level node\") }\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n};\n\n// :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\nprototypeAccessors$3.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };\n\n// :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\nprototypeAccessors$3.nodeAfter.get = function () {\n  var parent = this.parent, index = this.index(this.depth);\n  if (index == parent.childCount) { return null }\n  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child\n};\n\n// :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\nprototypeAccessors$3.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n  if (dOff) { return this.parent.child(index).cut(0, dOff) }\n  return index == 0 ? null : this.parent.child(index - 1)\n};\n\n// :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\nResolvedPos.prototype.marks = function marks () {\n  var parent = this.parent, index = this.index();\n\n  // In an empty parent, return the empty array\n  if (parent.content.size == 0) { return Mark.none }\n\n  // When inside a text node, just return the text node's marks\n  if (this.textOffset) { return parent.child(index).marks }\n\n  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n  // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n  if (!main) { var tmp = main; main = other; other = tmp; }\n\n  // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n  var marks = main.marks;\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n\n  return marks\n};\n\n// :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\nResolvedPos.prototype.marksAcross = function marksAcross ($end) {\n  var after = this.parent.maybeChild(this.index());\n  if (!after || !after.isInline) { return null }\n\n  var marks = after.marks, next = $end.parent.maybeChild($end.index());\n  for (var i = 0; i < marks.length; i++)\n    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n      { marks = marks[i--].removeFromSet(marks); } }\n  return marks\n};\n\n// :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\nResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {\n    var this$1 = this;\n\n  for (var depth = this.depth; depth > 0; depth--)\n    { if (this$1.start(depth) <= pos && this$1.end(depth) >= pos) { return depth } }\n  return 0\n};\n\n// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\nResolvedPos.prototype.blockRange = function blockRange (other, pred) {\n    var this$1 = this;\n    if ( other === void 0 ) other = this;\n\n  if (other.pos < this.pos) { return other.blockRange(this) }\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n    { if (other.pos <= this$1.end(d) && (!pred || pred(this$1.node(d))))\n      { return new NodeRange(this$1, other, d) } }\n};\n\n// :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\nResolvedPos.prototype.sameParent = function sameParent (other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\nResolvedPos.prototype.max = function max (other) {\n  return other.pos > this.pos ? other : this\n};\n\n// :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\nResolvedPos.prototype.min = function min (other) {\n  return other.pos < this.pos ? other : this\n};\n\nResolvedPos.prototype.toString = function toString () {\n    var this$1 = this;\n\n  var str = \"\";\n  for (var i = 1; i <= this.depth; i++)\n    { str += (str ? \"/\" : \"\") + this$1.node(i).type.name + \"_\" + this$1.index(i - 1); }\n  return str + \":\" + this.parentOffset\n};\n\nResolvedPos.resolve = function resolve (doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError(\"Position \" + pos + \" out of range\") }\n  var path = [];\n  var start = 0, parentOffset = pos;\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n      var index = ref.index;\n      var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n    if (!rem) { break }\n    node = node.child(index);\n    if (node.isText) { break }\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n  return new ResolvedPos(pos, path, parentOffset)\n};\n\nResolvedPos.resolveCached = function resolveCached (doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n    if (cached.pos == pos && cached.doc == doc) { return cached }\n  }\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result\n};\n\nObject.defineProperties( ResolvedPos.prototype, prototypeAccessors$3 );\n\nvar resolveCache = [];\nvar resolveCachePos = 0;\nvar resolveCacheSize = 12;\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from;\n  // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n  this.$to = $to;\n  // :: number The depth of the node that this range points into.\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = { start: {},end: {},parent: {},startIndex: {},endIndex: {} };\n\n// :: number The position at the start of the range.\nprototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };\n// :: number The position at the end of the range.\nprototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };\n\n// :: Node The parent node that the range points into.\nprototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };\n// :: number The start index of the range in the parent node.\nprototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };\n// :: number The end index of the range in the parent node.\nprototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };\n\nObject.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );\n\nvar emptyAttrs = Object.create(null);\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type;\n\n  // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n  this.attrs = attrs;\n\n  // :: Fragment\n  // A container holding the node's children.\n  this.content = content || Fragment.empty;\n\n  // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors = { nodeSize: {},childCount: {},textContent: {},firstChild: {},lastChild: {},isBlock: {},isTextblock: {},inlineContent: {},isInline: {},isText: {},isLeaf: {},isAtom: {} };\n\n// text:: ?string\n// For text nodes, this contains the node's text content.\n\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\nprototypeAccessors.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };\n\n// :: number\n// The number of children that the node has.\nprototypeAccessors.childCount.get = function () { return this.content.childCount };\n\n// :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\nNode.prototype.child = function child (index) { return this.content.child(index) };\n\n// :: (number) → ?Node\n// Get the child node at the given index, if it exists.\nNode.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };\n\n// :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\nNode.prototype.forEach = function forEach (f) { this.content.forEach(f); };\n\n// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\nNode.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {\n    if ( startPos === void 0 ) startPos = 0;\n\n  this.content.nodesBetween(from, to, f, startPos, this);\n};\n\n// :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\nNode.prototype.descendants = function descendants (f) {\n  this.nodesBetween(0, this.content.size, f);\n};\n\n// :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\nprototypeAccessors.textContent.get = function () { return this.textBetween(0, this.content.size, \"\") };\n\n// :: (number, number, ?string, ?string) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted whenever a new\n// block node is started. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\nNode.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText)\n};\n\n// :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\nprototypeAccessors.firstChild.get = function () { return this.content.firstChild };\n\n// :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\nprototypeAccessors.lastChild.get = function () { return this.content.lastChild };\n\n// :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\nNode.prototype.eq = function eq (other) {\n  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n};\n\n// :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\nNode.prototype.sameMarkup = function sameMarkup (other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks)\n};\n\n// :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\nNode.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {\n  return this.type == type &&\n    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n    Mark.sameSet(this.marks, marks || Mark.none)\n};\n\n// :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\nNode.prototype.copy = function copy (content) {\n    if ( content === void 0 ) content = null;\n\n  if (content == this.content) { return this }\n  return new this.constructor(this.type, this.attrs, content, this.marks)\n};\n\n// :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\nNode.prototype.mark = function mark (marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n};\n\n// :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\nNode.prototype.cut = function cut (from, to) {\n  if (from == 0 && to == this.content.size) { return this }\n  return this.copy(this.content.cut(from, to))\n};\n\n// :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\nNode.prototype.slice = function slice (from, to, includeParents) {\n    if ( to === void 0 ) to = this.content.size;\n    if ( includeParents === void 0 ) includeParents = false;\n\n  if (from == to) { return Slice.empty }\n\n  var $from = this.resolve(from), $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth), node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth)\n};\n\n// :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\nNode.prototype.replace = function replace$1 (from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice)\n};\n\n// :: (number) → ?Node\n// Find the node directly after the given position.\nNode.prototype.nodeAt = function nodeAt (pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n      var index = ref.index;\n      var offset = ref.offset;\n    node = node.maybeChild(index);\n    if (!node) { return null }\n    if (offset == pos || node.isText) { return node }\n    pos -= offset + 1;\n  }\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childAfter = function childAfter (pos) {\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  return {node: this.content.maybeChild(index), index: index, offset: offset}\n};\n\n// :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\nNode.prototype.childBefore = function childBefore (pos) {\n  if (pos == 0) { return {node: null, index: 0, offset: 0} }\n  var ref = this.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }\n  var node = this.content.child(index - 1);\n  return {node: node, index: index - 1, offset: offset - node.nodeSize}\n};\n\n// :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\nNode.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };\n\nNode.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };\n\n// :: (number, number, MarkType) → bool\n// Test whether a mark of the given type occurs in this document\n// between the two given positions.\nNode.prototype.rangeHasMark = function rangeHasMark (from, to, type) {\n  var found = false;\n  if (to > from) { this.nodesBetween(from, to, function (node) {\n    if (type.isInSet(node.marks)) { found = true; }\n    return !found\n  }); }\n  return found\n};\n\n// :: bool\n// True when this is a block (non-inline node)\nprototypeAccessors.isBlock.get = function () { return this.type.isBlock };\n\n// :: bool\n// True when this is a textblock node, a block node with inline\n// content.\nprototypeAccessors.isTextblock.get = function () { return this.type.isTextblock };\n\n// :: bool\n// True when this node has inline content.\nprototypeAccessors.inlineContent.get = function () { return this.type.inlineContent };\n\n// :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\nprototypeAccessors.isInline.get = function () { return this.type.isInline };\n\n// :: bool\n// True when this is a text node.\nprototypeAccessors.isText.get = function () { return this.type.isText };\n\n// :: bool\n// True when this is a leaf node.\nprototypeAccessors.isLeaf.get = function () { return this.type.isLeaf };\n\n// :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\nprototypeAccessors.isAtom.get = function () { return this.type.isAtom };\n\n// :: () → string\n// Return a string representation of this node for debugging\n// purposes.\nNode.prototype.toString = function toString () {\n  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n  var name = this.type.name;\n  if (this.content.size)\n    { name += \"(\" + this.content.toStringInner() + \")\"; }\n  return wrapMarks(this.marks, name)\n};\n\n// :: (number) → ContentMatch\n// Get the content match in this node at the given index.\nNode.prototype.contentMatchAt = function contentMatchAt (index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n  if (!match) { throw new Error(\"Called contentMatchAt on a node with invalid content\") }\n  return match\n};\n\n// :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\nNode.prototype.canReplace = function canReplace (from, to, replacement, start, end) {\n    var this$1 = this;\n    if ( replacement === void 0 ) replacement = Fragment.empty;\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = replacement.childCount;\n\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n  if (!two || !two.validEnd) { return false }\n  for (var i = start; i < end; i++) { if (!this$1.type.allowsMarks(replacement.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\nNode.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) { return false }\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false\n};\n\n// :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\nNode.prototype.canAppend = function canAppend (other) {\n  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }\n  else { return this.type.compatibleContent(other.type) }\n};\n\n// Unused. Left for backwards compatibility.\nNode.prototype.defaultContentType = function defaultContentType (at) {\n  return this.contentMatchAt(at).defaultType\n};\n\n// :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\nNode.prototype.check = function check () {\n  if (!this.type.validContent(this.content))\n    { throw new RangeError((\"Invalid content for node \" + (this.type.name) + \": \" + (this.content.toString().slice(0, 50)))) }\n  this.content.forEach(function (node) { return node.check(); });\n};\n\n// :: () → Object\n// Return a JSON-serializeable representation of this node.\nNode.prototype.toJSON = function toJSON () {\n    var this$1 = this;\n\n  var obj = {type: this.type.name};\n  for (var _ in this$1.attrs) {\n    obj.attrs = this$1.attrs;\n    break\n  }\n  if (this.content.size)\n    { obj.content = this.content.toJSON(); }\n  if (this.marks.length)\n    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }\n  return obj\n};\n\n// :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\nNode.fromJSON = function fromJSON (schema, json) {\n  if (!json) { throw new RangeError(\"Invalid input for Node.fromJSON\") }\n  var marks = null;\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) { throw new RangeError(\"Invalid mark data for Node.fromJSON\") }\n    marks = json.marks.map(schema.markFromJSON);\n  }\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") { throw new RangeError(\"Invalid text node in JSON\") }\n    return schema.text(json.text, marks)\n  }\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks)\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors );\n\nvar TextNode = (function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) { throw new RangeError(\"Empty text nodes are not allowed\") }\n\n    this.text = content;\n  }\n\n  if ( Node ) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create( Node && Node.prototype );\n  TextNode.prototype.constructor = TextNode;\n\n  var prototypeAccessors$1 = { textContent: {},nodeSize: {} };\n\n  TextNode.prototype.toString = function toString () {\n    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  };\n\n  prototypeAccessors$1.textContent.get = function () { return this.text };\n\n  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };\n\n  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };\n\n  TextNode.prototype.mark = function mark (marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  };\n\n  TextNode.prototype.withText = function withText (text) {\n    if (text == this.text) { return this }\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  };\n\n  TextNode.prototype.cut = function cut (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) { return this }\n    return this.withText(this.text.slice(from, to))\n  };\n\n  TextNode.prototype.eq = function eq (other) {\n    return this.sameMarkup(other) && this.text == other.text\n  };\n\n  TextNode.prototype.toJSON = function toJSON () {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base\n  };\n\n  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );\n\n  return TextNode;\n}(Node));\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--)\n    { str = marks[i].type.name + \"(\" + str + \")\"; }\n  return str\n}\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$5 = { inlineContent: {},defaultType: {},edgeCount: {} };\n\nContentMatch.parse = function parse (string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n  if (stream.next == null) { return ContentMatch.empty }\n  var expr = parseExpr(stream);\n  if (stream.next) { stream.err(\"Unexpected trailing text\"); }\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match\n};\n\n// :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\nContentMatch.prototype.matchType = function matchType (type) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.next.length; i += 2)\n    { if (this$1.next[i] == type) { return this$1.next[i + 1] } }\n  return null\n};\n\n// :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\nContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = frag.childCount;\n\n  var cur = this;\n  for (var i = start; cur && i < end; i++)\n    { cur = cur.matchType(frag.child(i).type); }\n  return cur\n};\n\nprototypeAccessors$5.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false\n};\n\n// :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\nprototypeAccessors$5.defaultType.get = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this$1.next[i];\n    if (!(type.isText || type.hasRequiredAttrs())) { return type }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible (other) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.next.length; i += 2)\n    { for (var j = 0; j < other.next.length; j += 2)\n      { if (this$1.next[i] == other.next[j]) { return true } } }\n  return false\n};\n\n// :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\nContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {\n    if ( toEnd === void 0 ) toEnd = false;\n    if ( startIndex === void 0 ) startIndex = 0;\n\n  var seen = [this];\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n    if (finished && (!toEnd || finished.validEnd))\n      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i], next = match.next[i + 1];\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n        if (found) { return found }\n      }\n    }\n  }\n\n  return search(this, [])\n};\n\n// :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\nContentMatch.prototype.findWrapping = function findWrapping (target) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.wrapCache.length; i += 2)\n    { if (this$1.wrapCache[i] == target) { return this$1.wrapCache[i + 1] } }\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping (target) {\n  var seen = Object.create(null), active = [{match: this, type: null, via: null}];\n  while (active.length) {\n    var current = active.shift(), match = current.match;\n    if (match.matchType(target)) {\n      var result = [];\n      for (var obj = current; obj.type; obj = obj.via)\n        { result.push(obj.type); }\n      return result.reverse()\n    }\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({match: type.contentMatch, type: type, via: current});\n        seen[type.name] = true;\n      }\n    }\n  }\n};\n\n// :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\nprototypeAccessors$5.edgeCount.get = function () {\n  return this.next.length >> 1\n};\n\n// :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_th outgoing edge from this node in the finite\n// automaton that describes the content expression.\nContentMatch.prototype.edge = function edge (n) {\n  var i = n << 1;\n  if (i > this.next.length) { throw new RangeError((\"There's no \" + n + \"th edge in this content match\")) }\n  return {type: this.next[i], next: this.next[i + 1]}\n};\n\nContentMatch.prototype.toString = function toString () {\n  var seen = [];\n  function scan(m) {\n    seen.push(m);\n    for (var i = 1; i < m.next.length; i += 2)\n      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }\n  }\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)\n      { out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]); }\n    return out\n  }).join(\"\\n\")\n};\n\nObject.defineProperties( ContentMatch.prototype, prototypeAccessors$5 );\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n  if (this.tokens[this.tokens.length - 1] == \"\") { this.tokens.pop(); }\n  if (this.tokens[0] == \"\") { this.tokens.unshift(); }\n};\n\nvar prototypeAccessors$1$3 = { next: {} };\n\nprototypeAccessors$1$3.next.get = function () { return this.tokens[this.pos] };\n\nTokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };\n\nTokenStream.prototype.err = function err (str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") };\n\nObject.defineProperties( TokenStream.prototype, prototypeAccessors$1$3 );\n\nfunction parseExpr(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSeq(stream)); }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do { exprs.push(parseExprSubscript(stream)); }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs: exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\"))\n      { expr = {type: \"plus\", expr: expr}; }\n    else if (stream.eat(\"*\"))\n      { expr = {type: \"star\", expr: expr}; }\n    else if (stream.eat(\"?\"))\n      { expr = {type: \"opt\", expr: expr}; }\n    else if (stream.eat(\"{\"))\n      { expr = parseExprRange(stream, expr); }\n    else { break }\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) { stream.err(\"Expected number, got '\" + stream.next + \"'\"); }\n  var result = Number(stream.next);\n  stream.pos++;\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") { max = parseNum(stream); }\n    else { max = -1; }\n  }\n  if (!stream.eat(\"}\")) { stream.err(\"Unclosed braced range\"); }\n  return {type: \"range\", min: min, max: max, expr: expr}\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes, type = types[name];\n  if (type) { return [type] }\n  var result = [];\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }\n  }\n  if (result.length == 0) { stream.err(\"No node type or group '\" + name + \"' found\"); }\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) { stream.err(\"Missing closing paren\"); }\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) { stream.inline = type.isInline; }\n      else if (stream.inline != type.isInline) { stream.err(\"Mixing inline and block content\"); }\n      return {type: \"name\", value: type}\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs: exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    var edge = {term: term, to: to};\n    nfa[from].push(edge);\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) { return next }\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return a - b }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp)\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n      if (!term && result.indexOf(to) == -1) { scan(to); }\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) { return }\n        var known = out.indexOf(term), set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) { out.push(term, set = []); }\n          if (set.indexOf(node) == -1) { set.push(node); }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i], dead = !state.validEnd, nodes = [];\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j], next = state.next[j + 1];\n      nodes.push(node.name);\n      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }\n      if (work.indexOf(next) == -1) { work.push(next); }\n    }\n    if (dead) { stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position\"); }\n  }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) { return null }\n    defaults[attrName] = attr.default;\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) { given = attr.default; }\n      else { throw new RangeError(\"No value supplied for attribute \" + name) }\n    }\n    built[name] = given;\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name;\n\n  // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n  this.schema = schema;\n\n  // :: NodeSpec\n  // The spec that this type is based on\n  this.spec = spec;\n\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n\n  this.defaultAttrs = defaultAttrs(this.attrs);\n\n  // :: ContentMatch\n  // The starting match of the node type's content expression.\n  this.contentMatch = null;\n\n  // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n  this.markSet = null;\n\n  // :: bool\n  // True if this node type has inline content.\n  this.inlineContent = null;\n\n  // :: bool\n  // True if this is a block type\n  this.isBlock = !(spec.inline || name == \"text\");\n\n  // :: bool\n  // True if this is the text node type.\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$4 = { isInline: {},isTextblock: {},isLeaf: {},isAtom: {} };\n\n// :: bool\n// True if this is an inline type.\nprototypeAccessors$4.isInline.get = function () { return !this.isBlock };\n\n// :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\nprototypeAccessors$4.isTextblock.get = function () { return this.isBlock && this.inlineContent };\n\n// :: bool\n// True for node types that allow no content.\nprototypeAccessors$4.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };\n\n// :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\nprototypeAccessors$4.isAtom.get = function () { return this.isLeaf || this.spec.atom };\n\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs (ignore) {\n    var this$1 = this;\n\n  for (var n in this$1.attrs)\n    { if (this$1.attrs[n].isRequired && (!ignore || !(n in ignore))) { return true } }\n  return false\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent (other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch)\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {\n  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }\n  else { return computeAttrs(this.attrs, attrs) }\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\nNodeType.prototype.create = function create (attrs, content, marks) {\n  if (this.isText) { throw new Error(\"NodeType.create can't construct text nodes\") }\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\nNodeType.prototype.createChecked = function createChecked (attrs, content, marks) {\n  content = Fragment.from(content);\n  if (!this.validContent(content))\n    { throw new RangeError(\"Invalid content for node \" + this.name) }\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n};\n\n// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\nNodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n    if (!before) { return null }\n    content = before.append(content);\n  }\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n  if (!after) { return null }\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n};\n\n// :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\nNodeType.prototype.validContent = function validContent (content) {\n    var this$1 = this;\n\n  var result = this.contentMatch.matchFragment(content);\n  if (!result || !result.validEnd) { return false }\n  for (var i = 0; i < content.childCount; i++)\n    { if (!this$1.allowsMarks(content.child(i).marks)) { return false } }\n  return true\n};\n\n// :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\nNodeType.prototype.allowsMarkType = function allowsMarkType (markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1\n};\n\n// :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\nNodeType.prototype.allowsMarks = function allowsMarks (marks) {\n    var this$1 = this;\n\n  if (this.markSet == null) { return true }\n  for (var i = 0; i < marks.length; i++) { if (!this$1.allowsMarkType(marks[i].type)) { return false } }\n  return true\n};\n\n// :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\nNodeType.prototype.allowedMarks = function allowedMarks (marks) {\n    var this$1 = this;\n\n  if (this.markSet == null) { return marks }\n  var copy;\n  for (var i = 0; i < marks.length; i++) {\n    if (!this$1.allowsMarkType(marks[i].type)) {\n      if (!copy) { copy = marks.slice(0, i); }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n  return !copy ? marks : copy.length ? copy : Mark.empty\n};\n\nNodeType.compile = function compile (nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });\n\n  var topType = schema.spec.topNode || \"doc\";\n  if (!result[topType]) { throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\") }\n  if (!result.text) { throw new RangeError(\"Every schema needs a 'text' type\") }\n  for (var _ in result.text.attrs) { throw new RangeError(\"The text node type should not have attributes\") }\n\n  return result\n};\n\nObject.defineProperties( NodeType.prototype, prototypeAccessors$4 );\n\n// Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$2 = { isRequired: {} };\n\nprototypeAccessors$1$2.isRequired.get = function () {\n  return !this.hasDefault\n};\n\nObject.defineProperties( Attribute.prototype, prototypeAccessors$1$2 );\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name;\n\n  // :: Schema\n  // The schema that this mark type instance is part of.\n  this.schema = schema;\n\n  // :: MarkSpec\n  // The spec on which the type is based.\n  this.spec = spec;\n\n  this.attrs = initAttrs(spec.attrs);\n\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n};\n\n// :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\nMarkType.prototype.create = function create (attrs) {\n  if (!attrs && this.instance) { return this.instance }\n  return new Mark(this, computeAttrs(this.attrs, attrs))\n};\n\nMarkType.compile = function compile (marks, schema) {\n  var result = Object.create(null), rank = 0;\n  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });\n  return result\n};\n\n// :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\nMarkType.prototype.removeFromSet = function removeFromSet (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this$1)\n      { return set.slice(0, i).concat(set.slice(i + 1)) } }\n  return set\n};\n\n// :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\nMarkType.prototype.isInSet = function isInSet (set) {\n    var this$1 = this;\n\n  for (var i = 0; i < set.length; i++)\n    { if (set[i].type == this$1) { return set[i] } }\n};\n\n// :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\nMarkType.prototype.excludes = function excludes (other) {\n  return this.excluded.indexOf(other) > -1\n};\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nvar Schema = function Schema(spec) {\n  var this$1 = this;\n\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n  for (var prop in spec) { this$1.spec[prop] = spec[prop]; }\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks);\n\n  // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n  this.nodes = NodeType.compile(this.spec.nodes, this);\n\n  // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n  this.marks = MarkType.compile(this.spec.marks, this);\n\n  var contentExprCache = Object.create(null);\n  for (var prop$1 in this$1.nodes) {\n    if (prop$1 in this$1.marks)\n      { throw new RangeError(prop$1 + \" can not be both a node and a mark\") }\n    var type = this$1.nodes[prop$1], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] ||\n      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this$1.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null :\n      markExpr ? gatherMarks(this$1, markExpr.split(\" \")) :\n      markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n  for (var prop$2 in this$1.marks) {\n    var type$1 = this$1.marks[prop$2], excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this$1, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this);\n\n  // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n\n  // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n};\n\n// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\nSchema.prototype.node = function node (type, attrs, content, marks) {\n  if (typeof type == \"string\")\n    { type = this.nodeType(type); }\n  else if (!(type instanceof NodeType))\n    { throw new RangeError(\"Invalid node type: \" + type) }\n  else if (type.schema != this)\n    { throw new RangeError(\"Node type from different schema used (\" + type.name + \")\") }\n\n  return type.createChecked(attrs, content, marks)\n};\n\n// :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\nSchema.prototype.text = function text (text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))\n};\n\n// :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\nSchema.prototype.mark = function mark (type, attrs) {\n  if (typeof type == \"string\") { type = this.marks[type]; }\n  return type.create(attrs)\n};\n\n// :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\nSchema.prototype.nodeFromJSON = function nodeFromJSON (json) {\n  return Node.fromJSON(this, json)\n};\n\n// :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\nSchema.prototype.markFromJSON = function markFromJSON (json) {\n  return Mark.fromJSON(this, json)\n};\n\nSchema.prototype.nodeType = function nodeType (name) {\n  var found = this.nodes[name];\n  if (!found) { throw new RangeError(\"Unknown node type: \" + name) }\n  return found\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n        if (name == \"_\" || (mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1))\n          { found.push(ok = mark$1); }\n      }\n    }\n    if (!ok) { throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\") }\n  }\n  return found\n}\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   propery's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return undefined to indicate that the match failed.)\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this;\n\n  // :: Schema\n  // The schema into which the parser parses.\n  this.schema = schema;\n  // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n\n  rules.forEach(function (rule) {\n    if (rule.tag) { this$1.tags.push(rule); }\n    else if (rule.style) { this$1.styles.push(rule); }\n  });\n};\n\n// :: (dom.Node, ?ParseOptions) → Node\n// Parse a document from the content of a DOM node.\nDOMParser.prototype.parse = function parse (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish()\n};\n\n// :: (dom.Node, ?ParseOptions) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\nDOMParser.prototype.parseSlice = function parseSlice (dom, options) {\n    if ( options === void 0 ) options = {};\n\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish())\n};\n\nDOMParser.prototype.matchTag = function matchTag (dom, context) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.tags.length; i++) {\n    var rule = this$1.tags[i];\n    if (matches(dom, rule.tag) &&\n        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n        (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n        if (result === false) { continue }\n        rule.attrs = result;\n      }\n      return rule\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle (prop, value, context) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.styles.length; i++) {\n    var rule = this$1.styles[i];\n    if (rule.style.indexOf(prop) != 0 ||\n        rule.context && !context.matchesContext(rule.context) ||\n        // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        rule.style.length > prop.length &&\n        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n      { continue }\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n      if (result === false) { continue }\n      rule.attrs = result;\n    }\n    return rule\n  }\n};\n\n// : (Schema) → [ParseRule]\nDOMParser.schemaRules = function schemaRules (schema) {\n  var result = [];\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority, i = 0;\n    for (; i < result.length; i++) {\n      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n      if (nextPriority < priority) { break }\n    }\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function ( name ) {\n    var rules = schema.marks[name].spec.parseDOM;\n    if (rules) { rules.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.mark = name;\n    }); }\n  };\n\n    for (var name in schema.marks) loop( name );\n  var loop$1 = function ( name ) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n    if (rules$1) { rules$1.forEach(function (rule) {\n      insert(rule = copy(rule));\n      rule.node = name$1;\n    }); }\n  };\n\n    for (var name$1 in schema.nodes) loop$1( name );\n  return result\n};\n\n// :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\nDOMParser.fromSchema = function fromSchema (schema) {\n  return schema.cached.domParser ||\n    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n};\n\n// : Object<bool> The block-level tags in HTML5\nvar blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\n\n// : Object<bool> The tags that we normally ignore.\nvar ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n};\n\n// : Object<bool> List tags.\nvar listTags = {ol: true, ul: true};\n\n// Using a bitfield for node context options\nvar OPT_PRESERVE_WS = 1;\nvar OPT_PRESERVE_WS_FULL = 2;\nvar OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(preserveWhitespace) {\n  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = [];\n  this.marks = marks;\n  this.activeMarks = Mark.none;\n};\n\nNodeContext.prototype.findWrapping = function findWrapping (node) {\n  if (!this.match) {\n    if (!this.type) { return [] }\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch, wrap;\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap\n      } else {\n        return null\n      }\n    }\n  }\n  return this.match.findWrapping(node.type)\n};\n\nNodeContext.prototype.finish = function finish (openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n    var last = this.content[this.content.length - 1], m;\n    if (last && last.isText && (m = /\\s+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) { this.content.pop(); }\n      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }\n    }\n  }\n  var content = Fragment.from(this.content);\n  if (!openEnd && this.match)\n    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser;\n  // : Object The options passed to this parse.\n  this.options = options;\n  this.isOpen = open;\n  this.pendingMarks = [];\n  var topNode = options.topNode, topContext;\n  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);\n  if (topNode)\n    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true,\n                                 options.topMatch || topNode.type.contentMatch, topOptions); }\n  else if (open)\n    { topContext = new NodeContext(null, null, Mark.none, true, null, topOptions); }\n  else\n    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions); }\n  this.nodes = [topContext];\n  // : [Mark] The current set of marks\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = { top: {},currentPos: {} };\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open]\n};\n\n// : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\nParseContext.prototype.addDOM = function addDOM (dom) {\n    var this$1 = this;\n\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null;\n    if (marks != null) { for (var i = 0; i < marks.length; i++) { this$1.addPendingMark(marks[i]); } }\n    this.addElement(dom);\n    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this$1.removePendingMark(marks[i$1]); } }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode (dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n  if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\\S/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/\\s+/g, \" \");\n      // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n      if (/^\\s/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n        if (!nodeBefore ||\n            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n            (nodeBefore.isText && /\\s$/.test(nodeBefore.text)))\n          { value = value.slice(1); }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    }\n    if (value) { this.insertNode(this.parser.schema.text(value)); }\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n};\n\n// : (dom.Element)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\nParseContext.prototype.addElement = function addElement (dom) {\n  var name = dom.nodeName.toLowerCase();\n  if (listTags.hasOwnProperty(name)) { normalizeList(dom); }\n  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) || this.parser.matchTag(dom, this);\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n  } else if (!rule || rule.skip) {\n    if (rule && rule.skip.nodeType) { dom = rule.skip; }\n    var sync, top = this.top, oldNeedsBlock = this.needsBlock;\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n      if (!top.type) { this.needsBlock = true; }\n    }\n    this.addAll(dom);\n    if (sync) { this.sync(top); }\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule);\n  }\n};\n\n// Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\nParseContext.prototype.readStyles = function readStyles (styles) {\n    var this$1 = this;\n\n  var marks = Mark.none;\n  for (var i = 0; i < styles.length; i += 2) {\n    var rule = this$1.parser.matchStyle(styles[i], styles[i + 1], this$1);\n    if (!rule) { continue }\n    if (rule.ignore) { return null }\n    marks = this$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n  }\n  return marks\n};\n\n// : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\nParseContext.prototype.addElementByRule = function addElementByRule (dom, rule) {\n    var this$1 = this;\n\n  var sync, nodeType, markType, mark;\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n    if (nodeType.isLeaf) { this.insertNode(nodeType.create(rule.attrs)); }\n    else { sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace); }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });\n  } else {\n    var contentDOM = rule.contentElement;\n    if (typeof contentDOM == \"string\") { contentDOM = dom.querySelector(contentDOM); }\n    else if (typeof contentDOM == \"function\") { contentDOM = contentDOM(dom); }\n    if (!contentDOM) { contentDOM = dom; }\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n  if (sync) { this.sync(startIn); this.open--; }\n  if (mark) { this.removePendingMark(mark); }\n  return true\n};\n\n// : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\nParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {\n    var this$1 = this;\n\n  var index = startIndex || 0;\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n           end = endIndex == null ? null : parent.childNodes[endIndex];\n       dom != end; dom = dom.nextSibling, ++index) {\n    this$1.findAtPoint(parent, index);\n    this$1.addDOM(dom);\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n      { this$1.sync(sync); }\n  }\n  this.findAtPoint(parent, index);\n};\n\n// Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\nParseContext.prototype.findPlace = function findPlace (node) {\n    var this$1 = this;\n\n  var route, sync;\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this$1.nodes[depth];\n    var found = cx.findWrapping(node);\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n      if (!found.length) { break }\n    }\n    if (cx.solid) { break }\n  }\n  if (!route) { return false }\n  this.sync(sync);\n  for (var i = 0; i < route.length; i++)\n    { this$1.enterInner(route[i], null, false); }\n  return true\n};\n\n// : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\nParseContext.prototype.insertNode = function insertNode (node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n    if (block) { this.enterInner(block); }\n  }\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    this.applyPendingMarks(top);\n    if (top.match) { top.match = top.match.matchType(node.type); }\n    var marks = top.activeMarks;\n    for (var i = 0; i < node.marks.length; i++)\n      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n        { marks = node.marks[i].addToSet(marks); } }\n    top.content.push(node.mark(marks));\n  }\n};\n\nParseContext.prototype.applyPendingMarks = function applyPendingMarks (top) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.pendingMarks.length; i++) {\n    var mark = this$1.pendingMarks[i];\n    if ((!top.type || top.type.allowsMarkType(mark.type)) && !mark.type.isInSet(top.activeMarks)) {\n      top.activeMarks = mark.addToSet(top.activeMarks);\n      this$1.pendingMarks.splice(i--, 1);\n    }\n  }\n};\n\n// : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\nParseContext.prototype.enter = function enter (type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n  if (ok) {\n    this.applyPendingMarks(this.top);\n    this.enterInner(type, attrs, true, preserveWS);\n  }\n  return ok\n};\n\n// Open a node of the given type\nParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);\n  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, solid, null, options));\n  this.open++;\n};\n\n// Make sure all nodes above this.open are finished and added to\n// their parents\nParseContext.prototype.closeExtra = function closeExtra (openEnd) {\n    var this$1 = this;\n\n  var i = this.nodes.length - 1;\n  if (i > this.open) {\n    for (; i > this.open; i--) { this$1.nodes[i - 1].content.push(this$1.nodes[i].finish(openEnd)); }\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish () {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n};\n\nParseContext.prototype.sync = function sync (to) {\n    var this$1 = this;\n\n  for (var i = this.open; i >= 0; i--) { if (this$1.nodes[i] == to) {\n    this$1.open = i;\n    return\n  } }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark (mark) {\n  this.pendingMarks.push(mark);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark (mark) {\n  var found = this.pendingMarks.lastIndexOf(mark);\n  if (found > -1) {\n    this.pendingMarks.splice(found, 1);\n  } else {\n    var top = this.top;\n    top.activeMarks = mark.removeFromSet(top.activeMarks);\n  }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n    var this$1 = this;\n\n  this.closeExtra();\n  var pos = 0;\n  for (var i = this.open; i >= 0; i--) {\n    var content = this$1.nodes[i].content;\n    for (var j = content.length - 1; j >= 0; j--)\n      { pos += content[j].nodeSize; }\n    if (i) { pos++; }\n  }\n  return pos\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {\n    var this$1 = this;\n\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].node == parent && this$1.find[i].offset == offset)\n      { this$1.find[i].pos = this$1.currentPos; }\n  } }\n};\n\nParseContext.prototype.findInside = function findInside (parent) {\n    var this$1 = this;\n\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1.find[i].node))\n      { this$1.find[i].pos = this$1.currentPos; }\n  } }\n};\n\nParseContext.prototype.findAround = function findAround (parent, content, before) {\n    var this$1 = this;\n\n  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1.find[i].node)) {\n      var pos = content.compareDocumentPosition(this$1.find[i].node);\n      if (pos & (before ? 2 : 4))\n        { this$1.find[i].pos = this$1.currentPos; }\n    }\n  } }\n};\n\nParseContext.prototype.findInText = function findInText (textNode) {\n    var this$1 = this;\n\n  if (this.find) { for (var i = 0; i < this.find.length; i++) {\n    if (this$1.find[i].node == textNode)\n      { this$1.find[i].pos = this$1.currentPos - (textNode.nodeValue.length - this$1.find[i].offset); }\n  } }\n};\n\n// : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\nParseContext.prototype.matchesContext = function matchesContext (context) {\n    var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1)\n    { return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this) }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) { continue }\n        for (; depth >= minDepth; depth--)\n          { if (match(i - 1, depth)) { return true } }\n        return false\n      } else {\n        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type\n            : option && depth >= minDepth ? option.node(depth - minDepth).type\n            : null;\n        if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n          { return false }\n        depth--;\n      }\n    }\n    return true\n  };\n  return match(parts.length - 1, this.open)\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext () {\n    var this$1 = this;\n\n  var $context = this.options.context;\n  if ($context) { for (var d = $context.depth; d >= 0; d--) {\n    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }\n  } }\n  for (var name in this$1.parser.schema.nodes) {\n    var type = this$1.parser.schema.nodes[name];\n    if (type.isTextblock && type.defaultAttrs) { return type }\n  }\n};\n\nObject.defineProperties( ParseContext.prototype, prototypeAccessors$6 );\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }\n  return result\n}\n\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  return copy\n}\n\n// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element. If the second\n// element is plain object, it is interpreted as a set of attributes\n// for the element. Any elements after that (including the 2nd if it's\n// not an attribute object) are interpreted as children of the DOM\n// elements, and must either be valid `DOMOutputSpec` values, or the\n// number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. It it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {};\n  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n  // The mark serialization functions.\n  this.marks = marks || {};\n};\n\n// :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\nDOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  if (!target) { target = doc(options).createDocumentFragment(); }\n\n  var top = target, active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) { active = []; }\n      var keep = 0, rendered = 0;\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n        if (!this$1.marks[next.type.name]) { rendered++; continue }\n        if (!next.eq(active[keep])) { break }\n        keep += 2; rendered++;\n      }\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n    top.appendChild(this$1.serializeNode(node, options));\n  });\n\n  return target\n};\n\n// :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\nDOMSerializer.prototype.serializeNode = function serializeNode (node, options) {\n    if ( options === void 0 ) options = {};\n\n  var ref =\n      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    var dom = ref.dom;\n    var contentDOM = ref.contentDOM;\n  if (contentDOM) {\n    if (node.isLeaf)\n      { throw new RangeError(\"Content hole not allowed in a leaf node spec\") }\n    if (options.onContent)\n      { options.onContent(node, contentDOM, options); }\n    else\n      { this.serializeFragment(node.content, options, contentDOM); }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeNodeAndMarks = function serializeNodeAndMarks (node, options) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n  var dom = this.serializeNode(node, options);\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this$1.serializeMark(node.marks[i], node.isInline, options);\n    if (wrap) {\n      (wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n  return dom\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {\n    if ( options === void 0 ) options = {};\n\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n};\n\n// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\nDOMSerializer.renderSpec = function renderSpec (doc, structure) {\n  if (typeof structure == \"string\")\n    { return {dom: doc.createTextNode(structure)} }\n  if (structure.nodeType != null)\n    { return {dom: structure} }\n  var dom = doc.createElement(structure[0]), contentDOM = null;\n  var attrs = structure[1], start = 1;\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) {\n      if (name == \"style\") { dom.style.cssText = attrs[name]; }\n      else if (attrs[name] != null) { dom.setAttribute(name, attrs[name]); }\n    }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start)\n        { throw new RangeError(\"Content hole must be the only child of its parent node\") }\n      return {dom: dom, contentDOM: dom}\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child);\n        var inner = ref.dom;\n        var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) { throw new RangeError(\"Multiple content holes\") }\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {dom: dom, contentDOM: contentDOM}\n};\n\n// :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\nDOMSerializer.fromSchema = function fromSchema (schema) {\n  return schema.cached.domSerializer ||\n    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n};\n\n// : (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\nDOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {\n  var result = gatherToDOM(schema.nodes);\n  if (!result.text) { result.text = function (node) { return node.text; }; }\n  return result\n};\n\n// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\nDOMSerializer.marksFromSchema = function marksFromSchema (schema) {\n  return gatherToDOM(schema.marks)\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) { result[name] = toDOM; }\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n\nexports.Node = Node;\nexports.ResolvedPos = ResolvedPos;\nexports.NodeRange = NodeRange;\nexports.Fragment = Fragment;\nexports.Slice = Slice;\nexports.ReplaceError = ReplaceError;\nexports.Mark = Mark;\nexports.Schema = Schema;\nexports.NodeType = NodeType;\nexports.MarkType = MarkType;\nexports.ContentMatch = ContentMatch;\nexports.DOMParser = DOMParser;\nexports.DOMSerializer = DOMSerializer;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-basic/dist/schema-basic.js":
/*!**********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-basic/dist/schema-basic.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\n\n// :: Object\n// [Specs](#model.NodeSpec) for the nodes defined in this schema.\nvar nodes = {\n  // :: NodeSpec The top level document node.\n  doc: {\n    content: \"block+\"\n  },\n\n  // :: NodeSpec A plain paragraph textblock. Represented in the DOM\n  // as a `<p>` element.\n  paragraph: {\n    content: \"inline*\",\n    group: \"block\",\n    parseDOM: [{tag: \"p\"}],\n    toDOM: function toDOM() { return [\"p\", 0] }\n  },\n\n  // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\n  blockquote: {\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{tag: \"blockquote\"}],\n    toDOM: function toDOM() { return [\"blockquote\", 0] }\n  },\n\n  // :: NodeSpec A horizontal rule (`<hr>`).\n  horizontal_rule: {\n    group: \"block\",\n    parseDOM: [{tag: \"hr\"}],\n    toDOM: function toDOM() { return [\"hr\"] }\n  },\n\n  // :: NodeSpec A heading textblock, with a `level` attribute that\n  // should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n  // `<h6>` elements.\n  heading: {\n    attrs: {level: {default: 1}},\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    parseDOM: [{tag: \"h1\", attrs: {level: 1}},\n               {tag: \"h2\", attrs: {level: 2}},\n               {tag: \"h3\", attrs: {level: 3}},\n               {tag: \"h4\", attrs: {level: 4}},\n               {tag: \"h5\", attrs: {level: 5}},\n               {tag: \"h6\", attrs: {level: 6}}],\n    toDOM: function toDOM(node) { return [\"h\" + node.attrs.level, 0] }\n  },\n\n  // :: NodeSpec A code listing. Disallows marks or non-text inline\n  // nodes by default. Represented as a `<pre>` element with a\n  // `<code>` element inside of it.\n  code_block: {\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    parseDOM: [{tag: \"pre\", preserveWhitespace: \"full\"}],\n    toDOM: function toDOM() { return [\"pre\", [\"code\", 0]] }\n  },\n\n  // :: NodeSpec The text node.\n  text: {\n    group: \"inline\"\n  },\n\n  // :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n  // `alt`, and `href` attributes. The latter two default to the empty\n  // string.\n  image: {\n    inline: true,\n    attrs: {\n      src: {},\n      alt: {default: null},\n      title: {default: null}\n    },\n    group: \"inline\",\n    draggable: true,\n    parseDOM: [{tag: \"img[src]\", getAttrs: function getAttrs(dom) {\n      return {\n        src: dom.getAttribute(\"src\"),\n        title: dom.getAttribute(\"title\"),\n        alt: dom.getAttribute(\"alt\")\n      }\n    }}],\n    toDOM: function toDOM(node) { return [\"img\", node.attrs] }\n  },\n\n  // :: NodeSpec A hard line break, represented in the DOM as `<br>`.\n  hard_break: {\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    parseDOM: [{tag: \"br\"}],\n    toDOM: function toDOM() { return [\"br\"] }\n  }\n};\n\n// :: Object [Specs](#model.MarkSpec) for the marks in the schema.\nvar marks = {\n  // :: MarkSpec A link. Has `href` and `title` attributes. `title`\n  // defaults to the empty string. Rendered and parsed as an `<a>`\n  // element.\n  link: {\n    attrs: {\n      href: {},\n      title: {default: null}\n    },\n    inclusive: false,\n    parseDOM: [{tag: \"a[href]\", getAttrs: function getAttrs(dom) {\n      return {href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\")}\n    }}],\n    toDOM: function toDOM(node) { return [\"a\", node.attrs] }\n  },\n\n  // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n  // Has parse rules that also match `<i>` and `font-style: italic`.\n  em: {\n    parseDOM: [{tag: \"i\"}, {tag: \"em\"}, {style: \"font-style=italic\"}],\n    toDOM: function toDOM() { return [\"em\"] }\n  },\n\n  // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n  // also match `<b>` and `font-weight: bold`.\n  strong: {\n    parseDOM: [{tag: \"strong\"},\n               // This works around a Google Docs misbehavior where\n               // pasted content will be inexplicably wrapped in `<b>`\n               // tags with a font-weight normal.\n               {tag: \"b\", getAttrs: function (node) { return node.style.fontWeight != \"normal\" && null; }},\n               {style: \"font-weight\", getAttrs: function (value) { return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null; }}],\n    toDOM: function toDOM() { return [\"strong\"] }\n  },\n\n  // :: MarkSpec Code font mark. Represented as a `<code>` element.\n  code: {\n    parseDOM: [{tag: \"code\"}],\n    toDOM: function toDOM() { return [\"code\"] }\n  }\n};\n\n// :: Schema\n// This schema rougly corresponds to the document schema used by\n// [CommonMark](http://commonmark.org/), minus the list elements,\n// which are defined in the [`prosemirror-schema-list`](#schema-list)\n// module.\n//\n// To reuse elements from this schema, extend or read from its\n// `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).\nvar schema = new prosemirrorModel.Schema({nodes: nodes, marks: marks});\n\nexports.nodes = nodes;\nexports.marks = marks;\nexports.schema = schema;\n//# sourceMappingURL=schema-basic.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-basic/dist/schema-basic.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-list/dist/schema-list.js":
/*!********************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-list/dist/schema-list.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\n\nvar olDOM = [\"ol\", 0];\nvar ulDOM = [\"ul\", 0];\nvar liDOM = [\"li\", 0];\n\n// :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\nvar orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs: function getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {start: node.attrs.order}, 0]\n  }\n};\n\n// :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\nvar bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM: function toDOM() { return ulDOM }\n};\n\n// :: NodeSpec\n// A list item (`<li>`) spec.\nvar listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM: function toDOM() { return liDOM },\n  defining: true\n};\n\nfunction add(obj, props) {\n  var copy = {};\n  for (var prop in obj) { copy[prop] = obj[prop]; }\n  for (var prop$1 in props) { copy[prop$1] = props[prop$1]; }\n  return copy\n}\n\n// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nfunction wrapInList(listType, attrs) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to), doJoin = false, outerRange = range;\n    if (!range) { return false }\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) { return false }\n      var $insert = state.doc.resolve(range.start - 2);\n      outerRange = new prosemirrorModel.NodeRange($insert, $insert, range.depth);\n      if (range.endIndex < range.parent.childCount)\n        { range = new prosemirrorModel.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth); }\n      doJoin = true;\n    }\n    var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range);\n    if (!wrap) { return false }\n    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()); }\n    return true\n  }\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = prosemirrorModel.Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }\n\n  tr.step(new prosemirrorTransform.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));\n\n  var found = 0;\n  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == listType) { found = i$1 + 1; } }\n  var splitDepth = wrappers.length - found;\n\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {\n    if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(i$2).nodeSize;\n  }\n  return tr\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nfunction splitListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var node = ref.node;\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) { return false }\n    var grandParent = $from.node(-1);\n    if (grandParent.type != itemType) { return false }\n    if ($from.parent.content.size == 0) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType ||\n          $from.index(-2) != $from.node(-2).childCount - 1) { return false }\n      if (dispatch) {\n        var wrap = prosemirrorModel.Fragment.empty, keepItem = $from.index(-1) > 0;\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--)\n          { wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap)); }\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));\n        var tr$1 = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new prosemirrorModel.Slice(wrap, keepItem ? 3 : 2, 2));\n        tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n        dispatch(tr$1.scrollIntoView());\n      }\n      return true\n    }\n    var nextType = $to.pos == $from.end() ? grandParent.defaultContentType(0) : null;\n    var tr = state.tr.delete($from.pos, $to.pos);\n    var types = nextType && [null, {type: nextType}];\n    if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types)) { return false }\n    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()); }\n    return true\n  }\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nfunction liftListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });\n    if (!range) { return false }\n    if (!dispatch) { return true }\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      { return liftToOuterList(state, dispatch, itemType, range) }\n    else // Outer list node\n      { return liftOutOfList(state, dispatch, range) }\n  }\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                  new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new prosemirrorModel.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  dispatch(tr.lift(range, prosemirrorTransform.liftTarget(range)).scrollIntoView());\n  return true\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr, list = range.parent;\n  // Merge the list items into a single big item\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n  var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1), indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,\n                         item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list))))\n    { return false }\n  var start = $start.pos, end = start + item.nodeSize;\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,\n                                new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty)))\n                                          .append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))),\n                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true\n}\n\n// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nfunction sinkListItem(itemType) {\n  return function(state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });\n    if (!range) { return false }\n    var startIndex = range.startIndex;\n    if (startIndex == 0) { return false }\n    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) { return false }\n\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.copy(inner)))),\n                            nestedBefore ? 3 : 1, 0);\n      var before = range.start, after = range.end;\n      dispatch(state.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView());\n    }\n    return true\n  }\n}\n\nexports.orderedList = orderedList;\nexports.bulletList = bulletList;\nexports.listItem = listItem;\nexports.addListNodes = addListNodes;\nexports.wrapInList = wrapInList;\nexports.splitListItem = splitListItem;\nexports.liftListItem = liftListItem;\nexports.sinkListItem = sinkListItem;\n//# sourceMappingURL=schema-list.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-list/dist/schema-list.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\n\nvar classesById = Object.create(null);\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nvar Selection = function Selection($anchor, $head, ranges) {\n  // :: [SelectionRange]\n  // The ranges covered by the selection.\n  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  // :: ResolvedPos\n  // The resolved anchor of the selection (the side that stays in\n  // place when the selection is modified).\n  this.$anchor = $anchor;\n  // :: ResolvedPos\n  // The resolved head of the selection (the side that moves when\n  // the selection is modified).\n  this.$head = $head;\n};\n\nvar prototypeAccessors = { anchor: {},head: {},from: {},to: {},$from: {},$to: {},empty: {} };\n\n// :: number\n// The selection's anchor, as an unresolved position.\nprototypeAccessors.anchor.get = function () { return this.$anchor.pos };\n\n// :: number\n// The selection's head.\nprototypeAccessors.head.get = function () { return this.$head.pos };\n\n// :: number\n// The lower bound of the selection's main range.\nprototypeAccessors.from.get = function () { return this.$from.pos };\n\n// :: number\n// The upper bound of the selection's main range.\nprototypeAccessors.to.get = function () { return this.$to.pos };\n\n// :: ResolvedPos\n// The resolved lowerbound of the selection's main range.\nprototypeAccessors.$from.get = function () {\n  return this.ranges[0].$from\n};\n\n// :: ResolvedPos\n// The resolved upper bound of the selection's main range.\nprototypeAccessors.$to.get = function () {\n  return this.ranges[0].$to\n};\n\n// :: bool\n// Indicates whether the selection contains any content.\nprototypeAccessors.empty.get = function () {\n  var ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++)\n    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }\n  return true\n};\n\n// eq:: (Selection) → bool\n// Test whether the selection is the same as another selection.\n\n// map:: (doc: Node, mapping: Mappable) → Selection\n// Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n// should be the new document to which we are mapping.\n\n// :: () → Slice\n// Get the content of this selection as a slice.\nSelection.prototype.content = function content () {\n  return this.$from.node(0).slice(this.from, this.to, true)\n};\n\n// :: (Transaction, ?Slice)\n// Replace the selection with a slice or, if no slice is given,\n// delete the selection. Will append to the given transaction.\nSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = prosemirrorModel.Slice.empty;\n\n  // Put the new selection at the position after the inserted\n  // content. When that ended in an inline node, search backwards,\n  // to get the position after that node. If not, search forward.\n  var lastNode = content.content.lastChild, lastParent = null;\n  for (var i = 0; i < content.openEnd; i++) {\n    lastParent = lastNode;\n    lastNode = lastNode.lastChild;\n  }\n\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n    var ref = ranges[i$1];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? prosemirrorModel.Slice.empty : content);\n    if (i$1 == 0)\n      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }\n  }\n};\n\n// :: (Transaction, Node)\n// Replace the selection with the given node, appending the changes\n// to the given transaction.\nSelection.prototype.replaceWith = function replaceWith (tr, node) {\n  var mapFrom = tr.steps.length, ranges = this.ranges;\n  for (var i = 0; i < ranges.length; i++) {\n    var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n    var from = mapping.map($from.pos), to = mapping.map($to.pos);\n    if (i) {\n      tr.deleteRange(from, to);\n    } else {\n      tr.replaceRangeWith(from, to, node);\n      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n    }\n  }\n};\n\n// toJSON:: () → Object\n// Convert the selection to a JSON representation. When implementing\n// this for a custom selection class, make sure to give the object a\n// `type` property whose value matches the ID under which you\n// [registered](#state.Selection^jsonID) your class.\n\n// :: (ResolvedPos, number, ?bool) → ?Selection\n// Find a valid cursor or leaf node selection starting at the given\n// position and searching back if `dir` is negative, and forward if\n// positive. When `textOnly` is true, only consider cursor\n// selections. Will return null when no valid selection position is\n// found.\nSelection.findFrom = function findFrom ($pos, dir, textOnly) {\n  var inner = $pos.parent.inlineContent ? new TextSelection($pos)\n      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n  if (inner) { return inner }\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0\n        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n    if (found) { return found }\n  }\n};\n\n// :: (ResolvedPos, ?number) → Selection\n// Find a valid cursor or leaf node selection near the given\n// position. Searches forward first by default, but if `bias` is\n// negative, it will search backwards first.\nSelection.near = function near ($pos, bias) {\n    if ( bias === void 0 ) bias = 1;\n\n  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the start of\n// the given document. Will return an\n// [`AllSelection`](#state.AllSelection) if no valid position\n// exists.\nSelection.atStart = function atStart (doc) {\n  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n};\n\n// :: (Node) → Selection\n// Find the cursor or leaf node selection closest to the end of the\n// given document.\nSelection.atEnd = function atEnd (doc) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n};\n\n// :: (Node, Object) → Selection\n// Deserialize the JSON representation of a selection. Must be\n// implemented for custom classes (as a static class method).\nSelection.fromJSON = function fromJSON (doc, json) {\n  if (!json || !json.type) { throw new RangeError(\"Invalid input for Selection.fromJSON\") }\n  var cls = classesById[json.type];\n  if (!cls) { throw new RangeError((\"No selection type \" + (json.type) + \" defined\")) }\n  return cls.fromJSON(doc, json)\n};\n\n// :: (string, constructor<Selection>)\n// To be able to deserialize selections from JSON, custom selection\n// classes must register themselves with an ID string, so that they\n// can be disambiguated. Try to pick something that's unlikely to\n// clash with classes from other modules.\nSelection.jsonID = function jsonID (id, selectionClass) {\n  if (id in classesById) { throw new RangeError(\"Duplicate use of selection JSON ID \" + id) }\n  classesById[id] = selectionClass;\n  selectionClass.prototype.jsonID = id;\n  return selectionClass\n};\n\n// :: () → SelectionBookmark\n// Get a [bookmark](#state.SelectionBookmark) for this selection,\n// which is a value that can be mapped without having access to a\n// current document, and later resolved to a real selection for a\n// given document again. (This is used mostly by the history to\n// track and restore old selections.) The default implementation of\n// this method just converts the selection to a text selection and\n// returns the bookmark for that.\nSelection.prototype.getBookmark = function getBookmark () {\n  return TextSelection.between(this.$anchor, this.$head).getBookmark()\n};\n\nObject.defineProperties( Selection.prototype, prototypeAccessors );\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true;\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nvar SelectionRange = function SelectionRange($from, $to) {\n  // :: ResolvedPos\n  // The lower bound of the range.\n  this.$from = $from;\n  // :: ResolvedPos\n  // The upper bound of the range.\n  this.$to = $to;\n};\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nvar TextSelection = (function (Selection) {\n  function TextSelection($anchor, $head) {\n    if ( $head === void 0 ) $head = $anchor;\n\n    Selection.call(this, $anchor, $head);\n  }\n\n  if ( Selection ) TextSelection.__proto__ = Selection;\n  TextSelection.prototype = Object.create( Selection && Selection.prototype );\n  TextSelection.prototype.constructor = TextSelection;\n\n  var prototypeAccessors$1 = { $cursor: {} };\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };\n\n  TextSelection.prototype.map = function map (doc, mapping) {\n    var $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) { return Selection.near($head) }\n    var $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  };\n\n  TextSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = prosemirrorModel.Slice.empty;\n\n    Selection.prototype.replace.call(this, tr, content);\n    if (content == prosemirrorModel.Slice.empty) {\n      var marks = this.$from.marksAcross(this.$to);\n      if (marks) { tr.ensureMarks(marks); }\n    }\n  };\n\n  TextSelection.prototype.eq = function eq (other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  };\n\n  TextSelection.prototype.getBookmark = function getBookmark () {\n    return new TextBookmark(this.anchor, this.head)\n  };\n\n  TextSelection.prototype.toJSON = function toJSON () {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  };\n\n  TextSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      { throw new RangeError(\"Invalid input for TextSelection.fromJSON\") }\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  TextSelection.create = function create (doc, anchor, head) {\n    if ( head === void 0 ) head = anchor;\n\n    var $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  };\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  TextSelection.between = function between ($anchor, $head, bias) {\n    var dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }\n    if (!$head.parent.inlineContent) {\n      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) { $head = found.$head; }\n      else { return Selection.near($head, bias) }\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }\n      }\n    }\n    return new TextSelection($anchor, $head)\n  };\n\n  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );\n\n  return TextSelection;\n}(Selection));\n\nSelection.jsonID(\"text\", TextSelection);\n\nvar TextBookmark = function TextBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nTextBookmark.prototype.map = function map (mapping) {\n  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nTextBookmark.prototype.resolve = function resolve (doc) {\n  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n};\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nvar NodeSelection = (function (Selection) {\n  function NodeSelection($pos) {\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    Selection.call(this, $pos, $end);\n    // :: Node The selected node.\n    this.node = node;\n  }\n\n  if ( Selection ) NodeSelection.__proto__ = Selection;\n  NodeSelection.prototype = Object.create( Selection && Selection.prototype );\n  NodeSelection.prototype.constructor = NodeSelection;\n\n  NodeSelection.prototype.map = function map (doc, mapping) {\n    var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n    var $pos = doc.resolve(pos);\n    if (deleted) { return Selection.near($pos) }\n    return new NodeSelection($pos)\n  };\n\n  NodeSelection.prototype.content = function content () {\n    return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0)\n  };\n\n  NodeSelection.prototype.eq = function eq (other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  };\n\n  NodeSelection.prototype.toJSON = function toJSON () {\n    return {type: \"node\", anchor: this.anchor}\n  };\n\n  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };\n\n  NodeSelection.fromJSON = function fromJSON (doc, json) {\n    if (typeof json.anchor != \"number\")\n      { throw new RangeError(\"Invalid input for NodeSelection.fromJSON\") }\n    return new NodeSelection(doc.resolve(json.anchor))\n  };\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  NodeSelection.create = function create (doc, from) {\n    return new this(doc.resolve(from))\n  };\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  NodeSelection.isSelectable = function isSelectable (node) {\n    return !node.isText && node.type.spec.selectable !== false\n  };\n\n  return NodeSelection;\n}(Selection));\n\nNodeSelection.prototype.visible = false;\n\nSelection.jsonID(\"node\", NodeSelection);\n\nvar NodeBookmark = function NodeBookmark(anchor) {\n  this.anchor = anchor;\n};\nNodeBookmark.prototype.map = function map (mapping) {\n  var ref = mapping.mapResult(this.anchor);\n    var deleted = ref.deleted;\n    var pos = ref.pos;\n  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n};\nNodeBookmark.prototype.resolve = function resolve (doc) {\n  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }\n  return Selection.near($pos)\n};\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nvar AllSelection = (function (Selection) {\n  function AllSelection(doc) {\n    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n\n  if ( Selection ) AllSelection.__proto__ = Selection;\n  AllSelection.prototype = Object.create( Selection && Selection.prototype );\n  AllSelection.prototype.constructor = AllSelection;\n\n  AllSelection.prototype.toJSON = function toJSON () { return {type: \"all\"} };\n\n  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };\n\n  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };\n\n  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };\n\n  return AllSelection;\n}(Selection));\n\nSelection.jsonID(\"all\", AllSelection);\n\nvar AllBookmark = {\n  map: function map() { return this },\n  resolve: function resolve(doc) { return new AllSelection(doc) }\n};\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) { return TextSelection.create(doc, pos) }\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) { return inner }\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) { return }\n  var step = tr.steps[last];\n  if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) { return }\n  var map = tr.mapping.maps[last], end;\n  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar UPDATED_SEL = 1;\nvar UPDATED_MARKS = 2;\nvar UPDATED_SCROLL = 4;\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nvar Transaction = (function (Transform$$1) {\n  function Transaction(state) {\n    Transform$$1.call(this, state.doc);\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0;\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null);\n  }\n\n  if ( Transform$$1 ) Transaction.__proto__ = Transform$$1;\n  Transaction.prototype = Object.create( Transform$$1 && Transform$$1.prototype );\n  Transaction.prototype.constructor = Transaction;\n\n  var prototypeAccessors = { selection: {},selectionSet: {},storedMarksSet: {},isGeneric: {},scrolledIntoView: {} };\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  prototypeAccessors.selection.get = function () {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection\n  };\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  Transaction.prototype.setSelection = function setSelection (selection) {\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this\n  };\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  prototypeAccessors.selectionSet.get = function () {\n    return (this.updated & UPDATED_SEL) > 0\n  };\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this\n  };\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  Transaction.prototype.ensureMarks = function ensureMarks (marks) {\n    if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      { this.setStoredMarks(marks); }\n    return this\n  };\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  Transaction.prototype.addStoredMark = function addStoredMark (mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  };\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  prototypeAccessors.storedMarksSet.get = function () {\n    return (this.updated & UPDATED_MARKS) > 0\n  };\n\n  Transaction.prototype.addStep = function addStep (step, doc) {\n    Transform$$1.prototype.addStep.call(this, step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  };\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  Transaction.prototype.setTime = function setTime (time) {\n    this.time = time;\n    return this\n  };\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  Transaction.prototype.replaceSelection = function replaceSelection (slice) {\n    this.selection.replace(this, slice);\n    return this\n  };\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {\n    var selection = this.selection;\n    if (inheritMarks !== false)\n      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none))); }\n    selection.replaceWith(this, node);\n    return this\n  };\n\n  // :: () → Transaction\n  // Delete the selection.\n  Transaction.prototype.deleteSelection = function deleteSelection () {\n    this.selection.replace(this);\n    return this\n  };\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  Transaction.prototype.insertText = function insertText (text, from, to) {\n    if ( to === void 0 ) to = from;\n\n    var schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text) { return this.deleteSelection() }\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) { return this.deleteRange(from, to) }\n      var marks = this.storedMarks;\n      if (!marks) {\n        var $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      return this.replaceRangeWith(from, to, schema.text(text, marks))\n    }\n  };\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  Transaction.prototype.setMeta = function setMeta (key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this\n  };\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  Transaction.prototype.getMeta = function getMeta (key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  };\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  prototypeAccessors.isGeneric.get = function () {\n    var this$1 = this;\n\n    for (var _ in this$1.meta) { return false }\n    return true\n  };\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  Transaction.prototype.scrollIntoView = function scrollIntoView () {\n    this.updated |= UPDATED_SCROLL;\n    return this\n  };\n\n  prototypeAccessors.scrolledIntoView.get = function () {\n    return (this.updated & UPDATED_SCROLL) > 0\n  };\n\n  Object.defineProperties( Transaction.prototype, prototypeAccessors );\n\n  return Transaction;\n}(prosemirrorTransform.Transform));\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nvar FieldDesc = function FieldDesc(name, desc, self) {\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n};\n\nvar baseFields = [\n  new FieldDesc(\"doc\", {\n    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply: function apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply: function apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init: function init(config) { return config.storedMarks || null },\n    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init: function init() { return 0 },\n    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n];\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = function Configuration(schema, plugins) {\n  var this$1 = this;\n\n  this.schema = schema;\n  this.fields = baseFields.concat();\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  if (plugins) { plugins.forEach(function (plugin) {\n    if (this$1.pluginsByKey[plugin.key])\n      { throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\") }\n    this$1.plugins.push(plugin);\n    this$1.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state)\n      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }\n  }); }\n};\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nvar EditorState = function EditorState(config) {\n  this.config = config;\n};\n\nvar prototypeAccessors$1 = { schema: {},plugins: {},tr: {} };\n\n// doc:: Node\n// The current document.\n\n// selection:: Selection\n// The selection.\n\n// storedMarks:: ?[Mark]\n// A set of marks to apply to the next input. Will be null when\n// no explicit marks have been set.\n\n// :: Schema\n// The schema of the state's document.\nprototypeAccessors$1.schema.get = function () {\n  return this.config.schema\n};\n\n// :: [Plugin]\n// The plugins that are active in this state.\nprototypeAccessors$1.plugins.get = function () {\n  return this.config.plugins\n};\n\n// :: (Transaction) → EditorState\n// Apply the given transaction to produce a new state.\nEditorState.prototype.apply = function apply (tr) {\n  return this.applyTransaction(tr).state\n};\n\n// : (Transaction) → ?Transaction\nEditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {\n    var this$1 = this;\n    if ( ignore === void 0 ) ignore = -1;\n\n  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {\n    var plugin = this$1.config.plugins[i];\n    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this$1))\n      { return false }\n  } }\n  return true\n};\n\n// :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n// Verbose variant of [`apply`](#state.EditorState.apply) that\n// returns the precise transactions that were applied (which might\n// be influenced by the [transaction\n// hooks](#state.PluginSpec.filterTransaction) of\n// plugins) along with the new state.\nEditorState.prototype.applyTransaction = function applyTransaction (rootTr) {\n    var this$1 = this;\n\n  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }\n\n  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n  // This loop repeatedly gives plugins a chance to respond to\n  // transactions as new transactions are added, making sure to only\n  // pass the transactions the plugin did not see before.\n  outer: for (;;) {\n    var haveNew = false;\n    for (var i = 0; i < this.config.plugins.length; i++) {\n      var plugin = this$1.config.plugins[i];\n      if (plugin.spec.appendTransaction) {\n        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this$1;\n        var tr = n < trs.length &&\n            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n        if (tr && newState.filterTransaction(tr, i)) {\n          tr.setMeta(\"appendedTransaction\", rootTr);\n          if (!seen) {\n            seen = [];\n            for (var j = 0; j < this.config.plugins.length; j++)\n              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this$1, n: 0}); }\n          }\n          trs.push(tr);\n          newState = newState.applyInner(tr);\n          haveNew = true;\n        }\n        if (seen) { seen[i] = {state: newState, n: trs.length}; }\n      }\n    }\n    if (!haveNew) { return {state: newState, transactions: trs} }\n  }\n};\n\n// : (Transaction) → EditorState\nEditorState.prototype.applyInner = function applyInner (tr) {\n    var this$1 = this;\n\n  if (!tr.before.eq(this.doc)) { throw new RangeError(\"Applying a mismatched transaction\") }\n  var newInstance = new EditorState(this.config), fields = this.config.fields;\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    newInstance[field.name] = field.apply(tr, this$1[field.name], this$1, newInstance);\n  }\n  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this$1, tr, newInstance); }\n  return newInstance\n};\n\n// :: Transaction\n// Start a [transaction](#state.Transaction) from this state.\nprototypeAccessors$1.tr.get = function () { return new Transaction(this) };\n\n// :: (Object) → EditorState\n// Create a new state.\n//\n// config::- Configuration options. Must contain `schema` or `doc` (or both).\n//\n//    schema:: ?Schema\n//    The schema to use.\n//\n//    doc:: ?Node\n//    The starting document.\n//\n//    selection:: ?Selection\n//    A valid selection in the document.\n//\n//    storedMarks:: ?[Mark]\n//    The initial set of [stored marks](#state.EditorState.storedMarks).\n//\n//    plugins:: ?[Plugin]\n//    The plugins that should be active in this state.\nEditorState.create = function create (config) {\n  var $config = new Configuration(config.schema || config.doc.type.schema, config.plugins);\n  var instance = new EditorState($config);\n  for (var i = 0; i < $config.fields.length; i++)\n    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }\n  return instance\n};\n\n// :: (Object) → EditorState\n// Create a new state based on this one, but with an adjusted set of\n// active plugins. State fields that exist in both sets of plugins\n// are kept unchanged. Those that no longer exist are dropped, and\n// those that are new are initialized using their\n// [`init`](#state.StateField.init) method, passing in the new\n// configuration object..\n//\n// config::- configuration options\n//\n//   schema:: ?Schema\n//   New schema to use.\n//\n//   plugins:: ?[Plugin]\n//   New set of active plugins.\nEditorState.prototype.reconfigure = function reconfigure (config) {\n    var this$1 = this;\n\n  var $config = new Configuration(config.schema || this.schema, config.plugins);\n  var fields = $config.fields, instance = new EditorState($config);\n  for (var i = 0; i < fields.length; i++) {\n    var name = fields[i].name;\n    instance[name] = this$1.hasOwnProperty(name) ? this$1[name] : fields[i].init(config, instance);\n  }\n  return instance\n};\n\n// :: (?union<Object<Plugin>, string, number>) → Object\n// Serialize this state to JSON. If you want to serialize the state\n// of plugins, pass an object mapping property names to use in the\n// resulting JSON object to plugin objects. The argument may also be\n// a string or number, in which case it is ignored, to support the\n// way `JSON.stringify` calls `toString` methods.\nEditorState.prototype.toJSON = function toJSON (pluginFields) {\n    var this$1 = this;\n\n  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};\n  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }\n  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {\n    if (prop == \"doc\" || prop == \"selection\")\n      { throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\") }\n    var plugin = pluginFields[prop], state = plugin.spec.state;\n    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this$1[plugin.key]); }\n  } }\n  return result\n};\n\n// :: (Object, Object, ?Object<Plugin>) → EditorState\n// Deserialize a JSON representation of a state. `config` should\n// have at least a `schema` field, and should contain array of\n// plugins to initialize the state with. `pluginFields` can be used\n// to deserialize the state of plugins, by associating plugin\n// instances with the property names they use in the JSON object.\n//\n// config::- configuration options\n//\n//   schema:: Schema\n//   The schema to use.\n//\n//   plugins:: ?[Plugin]\n//   The set of active plugins.\nEditorState.fromJSON = function fromJSON (config, json, pluginFields) {\n  if (!json) { throw new RangeError(\"Invalid input for EditorState.fromJSON\") }\n  if (!config.schema) { throw new RangeError(\"Required config field 'schema' missing\") }\n  var $config = new Configuration(config.schema, config.plugins);\n  var instance = new EditorState($config);\n  $config.fields.forEach(function (field) {\n    if (field.name == \"doc\") {\n      instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);\n    } else if (field.name == \"selection\") {\n      instance.selection = Selection.fromJSON(instance.doc, json.selection);\n    } else if (field.name == \"storedMarks\") {\n      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }\n    } else {\n      if (pluginFields) { for (var prop in pluginFields) {\n        var plugin = pluginFields[prop], state = plugin.spec.state;\n        if (plugin.key == field.name && state && state.fromJSON &&\n            Object.prototype.hasOwnProperty.call(json, prop)) {\n          // This field belongs to a plugin mapped to a JSON field, read it from there.\n          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n          return\n        }\n      } }\n      instance[field.name] = field.init(config, instance);\n    }\n  });\n  return instance\n};\n\n// Kludge to allow the view to track mappings between different\n// instances of a state.\nEditorState.addApplyListener = function addApplyListener (f) {\n  applyListeners.push(f);\n};\nEditorState.removeApplyListener = function removeApplyListener (f) {\n  var found = applyListeners.indexOf(f);\n  if (found > -1) { applyListeners.splice(found, 1); }\n};\n\nObject.defineProperties( EditorState.prototype, prototypeAccessors$1 );\n\nvar applyListeners = [];\n\n// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) { val = val.bind(self); }\n    else if (prop == \"handleDOMEvents\") { val = bindProps(val, self, {}); }\n    target[prop] = val;\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nvar Plugin = function Plugin(spec) {\n  // :: EditorProps\n  // The [props](#view.EditorProps) exported by this plugin.\n  this.props = {};\n  if (spec.props) { bindProps(spec.props, this, this.props); }\n  // :: Object\n  // The plugin's [spec object](#state.PluginSpec).\n  this.spec = spec;\n  this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n};\n\n// :: (EditorState) → any\n// Extract the plugin's state field from an editor state.\nPlugin.prototype.getState = function getState (state) { return state[this.key] };\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nvar keys = Object.create(null);\n\nfunction createKey(name) {\n  if (name in keys) { return name + \"$\" + ++keys[name] }\n  keys[name] = 0;\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nvar PluginKey = function PluginKey(name) {\nif ( name === void 0 ) name = \"key\";\n this.key = createKey(name); };\n\n// :: (EditorState) → ?Plugin\n// Get the active plugin with this key, if any, from an editor\n// state.\nPluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };\n\n// :: (EditorState) → ?any\n// Get the plugin's state from an editor state.\nPluginKey.prototype.getState = function getState (state) { return state[this.key] };\n\nexports.Selection = Selection;\nexports.SelectionRange = SelectionRange;\nexports.TextSelection = TextSelection;\nexports.NodeSelection = NodeSelection;\nexports.AllSelection = AllSelection;\nexports.Transaction = Transaction;\nexports.EditorState = EditorState;\nexports.Plugin = Plugin;\nexports.PluginKey = PluginKey;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-tables/dist/index.js":
/*!*********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-tables/dist/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\nvar prosemirrorView = __webpack_require__(/*! prosemirror-view */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\nvar prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-keymap/dist/keymap.js\");\n\n// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nvar readFromCache, addToCache;\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != \"undefined\") {\n  var cache = new WeakMap;\n  readFromCache = function (key) { return cache.get(key); };\n  addToCache = function (key, value) {\n    cache.set(key, value);\n    return value\n  };\n} else {\n  var cache$1 = [], cacheSize = 10, cachePos = 0;\n  readFromCache = function (key) {\n    for (var i = 0; i < cache$1.length; i += 2)\n      { if (cache$1[i] == key) { return cache$1[i + 1] } }\n  };\n  addToCache = function (key, value) {\n    if (cachePos == cacheSize) { cachePos = 0; }\n    cache$1[cachePos++] = key;\n    return cache$1[cachePos++] = value\n  };\n}\n\nvar Rect = function Rect(left, top, right, bottom) {\n  this.left = left; this.top = top; this.right = right; this.bottom = bottom;\n};\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nvar TableMap = function TableMap(width, height, map, problems) {\n  // :: number The width of the table\n  this.width = width;\n  // :: number The table's height\n  this.height = height;\n  // :: [number] A width * height array with the start position of\n  // the cell covering that part of the table in each slot\n  this.map = map;\n  // An optional array of problems (cell overlap or non-rectangular\n  // shape) for the table, used by the table normalizer.\n  this.problems = problems;\n};\n\n// :: (number) → Rect\n// Find the dimensions of the cell at the given position.\nTableMap.prototype.findCell = function findCell (pos) {\n  for (var i = 0; i < this.map.length; i++) {\n    var curPos = this.map[i];\n    if (curPos != pos) { continue }\n    var left = i % this.width, top = (i / this.width) | 0;\n    var right = left + 1, bottom = top + 1;\n    for (var j = 1; right < this.width && this.map[i + j] == curPos; j++) { right++; }\n    for (var j$1 = 1; bottom < this.height && this.map[i + (this.width * j$1)] == curPos; j$1++) { bottom++; }\n    return new Rect(left, top, right, bottom)\n  }\n  throw new RangeError(\"No cell with offset \" + pos + \" found\")\n};\n\n// :: (number) → number\n// Find the left side of the cell at the given position.\nTableMap.prototype.colCount = function colCount (pos) {\n  for (var i = 0; i < this.map.length; i++)\n    { if (this.map[i] == pos) { return i % this.width } }\n  throw new RangeError(\"No cell with offset \" + pos + \" found\")\n};\n\n// :: (number, string, number) → ?number\n// Find the next cell in the given direction, starting from the cell\n// at `pos`, if any.\nTableMap.prototype.nextCell = function nextCell (pos, axis, dir) {\n  var ref = this.findCell(pos);\n    var left = ref.left;\n    var right = ref.right;\n    var top = ref.top;\n    var bottom = ref.bottom;\n  if (axis == \"horiz\") {\n    if (dir < 0 ? left == 0 : right == this.width) { return null }\n    return this.map[top * this.width + (dir < 0 ? left - 1 : right)]\n  } else {\n    if (dir < 0 ? top == 0 : bottom == this.height) { return null }\n    return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)]\n  }\n};\n\n// :: (number, number) → Rect\n// Get the rectangle spanning the two given cells.\nTableMap.prototype.rectBetween = function rectBetween (a, b) {\n  var ref = this.findCell(a);\n    var leftA = ref.left;\n    var rightA = ref.right;\n    var topA = ref.top;\n    var bottomA = ref.bottom;\n  var ref$1 = this.findCell(b);\n    var leftB = ref$1.left;\n    var rightB = ref$1.right;\n    var topB = ref$1.top;\n    var bottomB = ref$1.bottom;\n  return new Rect(Math.min(leftA, leftB), Math.min(topA, topB),\n                  Math.max(rightA, rightB), Math.max(bottomA, bottomB))\n};\n\n// :: (Rect) → [number]\n// Return the position of all cells that have the top left corner in\n// the given rectangle.\nTableMap.prototype.cellsInRect = function cellsInRect (rect) {\n  var result = [], seen = [];\n  for (var row = rect.top; row < rect.bottom; row++) {\n    for (var col = rect.left; col < rect.right; col++) {\n      var index = row * this.width + col, pos = this.map[index];\n      if (seen.indexOf(pos) > -1) { continue }\n      seen.push(pos);\n      if ((col != rect.left || !col || this.map[index - 1] != pos) &&\n          (row != rect.top || !row || this.map[index - this.width] != pos))\n        { result.push(pos); }\n    }\n  }\n  return result\n};\n\n// :: (number, number, Node) → number\n// Return the position at which the cell at the given row and column\n// starts, or would start, if a cell started there.\nTableMap.prototype.positionAt = function positionAt (row, col, table) {\n  for (var i = 0, rowStart = 0;; i++) {\n    var rowEnd = rowStart + table.child(i).nodeSize;\n    if (i == row) {\n      var index = col + row * this.width, rowEndIndex = (row + 1) * this.width;\n      // Skip past cells from previous rows (via rowspan)\n      while (index < rowEndIndex && this.map[index] < rowStart) { index++; }\n      return index == rowEndIndex ? rowEnd - 1 : this.map[index]\n    }\n    rowStart = rowEnd;\n  }\n};\n\n// :: (Node) → TableMap\n// Find the table map for the given table node.\nTableMap.get = function get (table) {\n  return readFromCache(table) || addToCache(table, computeMap(table))\n};\n\n// Compute a table map.\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\") { throw new RangeError(\"Not a table node: \" + table.type.name) }\n  var width = findWidth(table), height = table.childCount;\n  var map = [], mapPos = 0, problems = null, colWidths = [];\n  for (var i = 0, e = width * height; i < e; i++) { map[i] = 0; }\n\n  for (var row = 0, pos = 0; row < height; row++) {\n    var rowNode = table.child(row);\n    pos++;\n    for (var i$1 = 0;; i$1++) {\n      while (mapPos < map.length && map[mapPos] != 0) { mapPos++; }\n      if (i$1 == rowNode.childCount) { break }\n      var cellNode = rowNode.child(i$1);\n      var ref = cellNode.attrs;\n      var colspan = ref.colspan;\n      var rowspan = ref.rowspan;\n      var colwidth = ref.colwidth;\n      for (var h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({type: \"overlong_rowspan\", pos: pos, n: rowspan - h});\n          break\n        }\n        var start = mapPos + (h * width);\n        for (var w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            { map[start + w] = pos; }\n          else\n            { (problems || (problems = [])).push({type: \"collision\", row: row, pos: pos, n: colspan - w}); }\n          var colW = colwidth && colwidth[w];\n          if (colW) {\n            var widthIndex = ((start + w) % width) * 2, prev = colWidths[widthIndex];\n            if (prev == null || (prev != colW && colWidths[widthIndex + 1] == 1)) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    var expectedPos = (row + 1) * width, missing = 0;\n    while (mapPos < expectedPos) { if (map[mapPos++] == 0) { missing++; } }\n    if (missing) { (problems || (problems = [])).push({type: \"missing\", row: row, n: missing}); }\n    pos++;\n  }\n\n  var tableMap = new TableMap(width, height, map, problems), badWidths = false;\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2)\n    { if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) { badWidths = true; } }\n  if (badWidths) { findBadColWidths(tableMap, colWidths, table); }\n\n  return tableMap\n}\n\nfunction findWidth(table) {\n  var width = -1, hasRowSpan = false;\n  for (var row = 0; row < table.childCount; row++) {\n    var rowNode = table.child(row), rowWidth = 0;\n    if (hasRowSpan) { for (var j = 0; j < row; j++) {\n      var prevRow = table.child(j);\n      for (var i = 0; i < prevRow.childCount; i++) {\n        var cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) { rowWidth += cell.attrs.colspan; }\n      }\n    } }\n    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {\n      var cell$1 = rowNode.child(i$1);\n      rowWidth += cell$1.attrs.colspan;\n      if (cell$1.attrs.rowspan > 1) { hasRowSpan = true; }\n    }\n    if (width == -1)\n      { width = rowWidth; }\n    else if (width != rowWidth)\n      { width = Math.max(width, rowWidth); }\n  }\n  return width\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) { map.problems = []; }\n  for (var i = 0, seen = []; i < map.map.length; i++) {\n    var pos = map.map[i];\n    if (seen.indexOf(pos) > -1) { continue }\n    seen.push(pos);\n    var node = table.nodeAt(pos), updated = null;\n    for (var j = 0; j < node.attrs.colspan; j++) {\n      var col = (i + j) % map.width, colWidth = colWidths[col * 2];\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth))\n        { (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth; }\n    }\n    if (updated) { map.problems.unshift({type: \"colwidth mismatch\", pos: pos, colwidth: updated}); }\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) { return attrs.colwidth.slice() }\n  var result = [];\n  for (var i = 0; i < attrs.colspan; i++) { result.push(0); }\n  return result\n}\n\n// Various helper function for working with tables\n\nvar key = new prosemirrorState.PluginKey(\"selectingCells\");\n\nfunction cellAround($pos) {\n  for (var d = $pos.depth - 1; d > 0; d--)\n    { if ($pos.node(d).type.spec.tableRole == \"row\") { return $pos.node(0).resolve($pos.before(d + 1)) } }\n  return null\n}\n\nfunction cellWrapping($pos) {\n  for (var d = $pos.depth - 1; d > 0; d--) {\n    var role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === 'header_cell') { return $pos.node(d) }\n  }\n  return null\n}\n\nfunction isInTable(state) {\n  var $head = state.selection.$head;\n  for (var d = $head.depth; d > 0; d--) { if ($head.node(d).type.spec.tableRole == \"row\") { return true } }\n  return false\n}\n\nfunction selectionCell(state) {\n  var sel = state.selection;\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor\n  }\n  return cellAround(sel.$head) || cellNear(sel.$head)\n}\n\nfunction cellNear($pos) {\n  for (var after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    var role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") { return $pos.doc.resolve(pos) }\n  }\n  for (var before = $pos.nodeBefore, pos$1 = $pos.pos; before; before = before.lastChild, pos$1--) {\n    var role$1 = before.type.spec.tableRole;\n    if (role$1 == \"cell\" || role$1 == \"header_cell\") { return $pos.doc.resolve(pos$1 - before.nodeSize) }\n  }\n}\n\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && $pos.nodeAfter\n}\n\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize)\n}\n\nfunction inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1)\n}\n\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1))\n}\n\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1))\n}\n\nfunction nextCell($pos, axis, dir) {\n  var start = $pos.start(-1), map = TableMap.get($pos.node(-1));\n  var moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved)\n}\n\nfunction setAttr(attrs, name, value) {\n  var result = {};\n  for (var prop in attrs) { result[prop] = attrs[prop]; }\n  result[name] = value;\n  return result\n}\n\nfunction rmColSpan(attrs, pos, n) {\n  if ( n === void 0 ) n=1;\n\n  var result = setAttr(attrs, \"colspan\", attrs.colspan - n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(function (w) { return w > 0; })) { result.colwidth = null; }\n  }\n  return result\n}\n\nfunction addColSpan(attrs, pos, n) {\n  if ( n === void 0 ) n=1;\n\n  var result = setAttr(attrs, \"colspan\", attrs.colspan + n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (var i = 0; i < n; i++) { result.colwidth.splice(pos, 0, 0); }\n  }\n  return result\n}\n\n// This file defines a ProseMirror selection subclass that models\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nvar CellSelection = /*@__PURE__*/(function (Selection) {\n  function CellSelection($anchorCell, $headCell) {\n    if ( $headCell === void 0 ) $headCell = $anchorCell;\n\n    var table = $anchorCell.node(-1), map = TableMap.get(table), start = $anchorCell.start(-1);\n    var rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    var cells = map.cellsInRect(rect).filter(function (p) { return p != $headCell.pos - start; });\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - start);\n    var ranges = cells.map(function (pos) {\n      var cell = table.nodeAt(pos), from = pos + start + 1;\n      return new prosemirrorState.SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size))\n    });\n    Selection.call(this, ranges[0].$from, ranges[0].$to, ranges);\n    // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n    this.$anchorCell = $anchorCell;\n    // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n    this.$headCell = $headCell;\n  }\n\n  if ( Selection ) CellSelection.__proto__ = Selection;\n  CellSelection.prototype = Object.create( Selection && Selection.prototype );\n  CellSelection.prototype.constructor = CellSelection;\n\n  CellSelection.prototype.map = function map (doc, mapping) {\n    var $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    var $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        { return CellSelection.rowSelection($anchorCell, $headCell) }\n      else if (tableChanged && this.isColSelection())\n        { return CellSelection.colSelection($anchorCell, $headCell) }\n      else\n        { return new CellSelection($anchorCell, $headCell) }\n    }\n    return prosemirrorState.TextSelection.between($anchorCell, $headCell)\n  };\n\n  // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  CellSelection.prototype.content = function content () {\n    var table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);\n    var rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);\n    var seen = [], rows = [];\n    for (var row = rect.top; row < rect.bottom; row++) {\n      var rowContent = [];\n      for (var index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        var pos = map.map[index];\n        if (seen.indexOf(pos) == -1) {\n          seen.push(pos);\n          var cellRect = map.findCell(pos), cell = table.nodeAt(pos);\n          var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;\n          if (extraLeft > 0 || extraRight > 0) {\n            var attrs = cell.attrs;\n            if (extraLeft > 0) { attrs = rmColSpan(attrs, 0, extraLeft); }\n            if (extraRight > 0) { attrs = rmColSpan(attrs, attrs.colspan - extraRight, extraRight); }\n            if (cellRect.left < rect.left) { cell = cell.type.createAndFill(attrs); }\n            else { cell = cell.type.create(attrs, cell.content); }\n          }\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            var attrs$1 = setAttr(cell.attrs, \"rowspan\", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));\n            if (cellRect.top < rect.top) { cell = cell.type.createAndFill(attrs$1); }\n            else { cell = cell.type.create(attrs$1, cell.content); }\n          }\n          rowContent.push(cell);\n        }\n      }\n      rows.push(table.child(row).copy(prosemirrorModel.Fragment.from(rowContent)));\n    }\n\n    var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(fragment), 1, 1)\n  };\n\n  CellSelection.prototype.replace = function replace (tr, content) {\n    if ( content === void 0 ) content = prosemirrorModel.Slice.empty;\n\n    var mapFrom = tr.steps.length, ranges = this.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var ref = ranges[i];\n      var $from = ref.$from;\n      var $to = ref.$to;\n      var mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirrorModel.Slice.empty : content);\n    }\n    var sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) { tr.setSelection(sel); }\n  };\n\n  CellSelection.prototype.replaceWith = function replaceWith (tr, node) {\n    this.replace(tr, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));\n  };\n\n  CellSelection.prototype.forEachCell = function forEachCell (f) {\n    var table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);\n    var cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));\n    for (var i = 0; i < cells.length; i++)\n      { f(table.nodeAt(cells[i]), start + cells[i]); }\n  };\n\n  // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  CellSelection.prototype.isColSelection = function isColSelection () {\n    var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) { return false }\n    var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount\n  };\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  CellSelection.colSelection = function colSelection ($anchorCell, $headCell) {\n    if ( $headCell === void 0 ) $headCell = $anchorCell;\n\n    var map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);\n    var anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        { $anchorCell = doc.resolve(start + map.map[anchorRect.left]); }\n      if (headRect.bottom < map.height)\n        { $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]); }\n    } else {\n      if (headRect.top > 0)\n        { $headCell = doc.resolve(start + map.map[headRect.left]); }\n      if (anchorRect.bottom < map.height)\n        { $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]); }\n    }\n    return new CellSelection($anchorCell, $headCell)\n  };\n\n  // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  CellSelection.prototype.isRowSelection = function isRowSelection () {\n    var map = TableMap.get(this.$anchorCell.node(-1)), start = this.$anchorCell.start(-1);\n    var anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start);\n    if (Math.min(anchorLeft, headLeft) > 0) { return false }\n    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width\n  };\n\n  CellSelection.prototype.eq = function eq (other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n  };\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  CellSelection.rowSelection = function rowSelection ($anchorCell, $headCell) {\n    if ( $headCell === void 0 ) $headCell = $anchorCell;\n\n    var map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);\n    var anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);\n    var doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        { $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]); }\n      if (headRect.right < map.width)\n        { $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]); }\n    } else {\n      if (headRect.left > 0)\n        { $headCell = doc.resolve(start + map.map[headRect.top * map.width]); }\n      if (anchorRect.right < map.width)\n        { $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]); }\n    }\n    return new CellSelection($anchorCell, $headCell)\n  };\n\n  CellSelection.prototype.toJSON = function toJSON () {\n    return {type: \"cell\", anchor: this.$anchorCell.pos, head: this.$headCell.pos}\n  };\n\n  CellSelection.fromJSON = function fromJSON (doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  };\n\n  // :: (Node, number, ?number) → CellSelection\n  CellSelection.create = function create (doc, anchorCell, headCell) {\n    if ( headCell === void 0 ) headCell = anchorCell;\n\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell))\n  };\n\n  CellSelection.prototype.getBookmark = function getBookmark () { return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos) };\n\n  return CellSelection;\n}(prosemirrorState.Selection));\n\nCellSelection.prototype.visible = false;\n\nprosemirrorState.Selection.jsonID(\"cell\", CellSelection);\n\nvar CellBookmark = function CellBookmark(anchor, head) {\n  this.anchor = anchor;\n  this.head = head;\n};\nCellBookmark.prototype.map = function map (mapping) {\n  return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head))\n};\nCellBookmark.prototype.resolve = function resolve (doc) {\n  var $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n  if ($anchorCell.parent.type.spec.tableRole == \"row\" &&\n      $headCell.parent.type.spec.tableRole == \"row\" &&\n      $anchorCell.index() < $anchorCell.parent.childCount &&\n      $headCell.index() < $headCell.parent.childCount &&\n      inSameTable($anchorCell, $headCell))\n    { return new CellSelection($anchorCell, $headCell) }\n  else\n    { return prosemirrorState.Selection.near($headCell, 1) }\n};\n\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) { return null }\n  var cells = [];\n  state.selection.forEachCell(function (node, pos) {\n    cells.push(prosemirrorView.Decoration.node(pos, pos + node.nodeSize, {class: \"selectedCell\"}));\n  });\n  return prosemirrorView.DecorationSet.create(state.doc, cells)\n}\n\nfunction isCellBoundarySelection(ref) {\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) { return false } // Cheap elimination\n  var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    { if ($from.after(depth + 1) < $from.end(depth)) { break } }\n  for (var d = $to.depth; d >= 0; d--, beforeTo--)\n    { if ($to.before(d + 1) > $to.start(d)) { break } }\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole)\n}\n\nfunction isTextSelectionAcrossCells(ref) {\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  var fromCellBoundaryNode;\n  var toCellBoundaryNode;\n\n  for (var i = $from.depth; i > 0; i--) {\n    var node = $from.node(i);\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (var i$1 = $to.depth; i$1 > 0; i$1--) {\n    var node$1 = $to.node(i$1);\n    if (node$1.type.spec.tableRole === 'cell' || node$1.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node$1;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0\n}\n\nfunction normalizeSelection(state, tr) {\n  var sel = (tr || state).selection, doc = (tr || state).doc, normalize, role;\n  if (sel instanceof prosemirrorState.NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      var $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else {\n      var map = TableMap.get(sel.node), start = sel.from + 1;\n      var lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof prosemirrorState.TextSelection && isCellBoundarySelection(sel)) {\n    normalize = prosemirrorState.TextSelection.create(doc, sel.from);\n  } else if (sel instanceof prosemirrorState.TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = prosemirrorState.TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    { (tr || (tr = state.tr)).setSelection(normalize); }\n  return tr\n}\n\n// Helper for creating a schema that supports tables.\n\nfunction getCellAttrs(dom, extraAttrs) {\n  var widthAttr = dom.getAttribute(\"data-colwidth\");\n  var widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map(function (s) { return Number(s); }) : null;\n  var colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  var result = {\n    colspan: colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (var prop in extraAttrs) {\n    var getter = extraAttrs[prop].getFromDOM;\n    var value = getter && getter(dom);\n    if (value != null) { result[prop] = value; }\n  }\n  return result\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  var attrs = {};\n  if (node.attrs.colspan != 1) { attrs.colspan = node.attrs.colspan; }\n  if (node.attrs.rowspan != 1) { attrs.rowspan = node.attrs.rowspan; }\n  if (node.attrs.colwidth)\n    { attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\"); }\n  for (var prop in extraAttrs) {\n    var setter = extraAttrs[prop].setDOMAttr;\n    if (setter) { setter(node.attrs[prop], attrs); }\n  }\n  return attrs\n}\n\n// :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\nfunction tableNodes(options) {\n  var extraAttrs = options.cellAttributes || {};\n  var cellAttrs = {\n    colspan: {default: 1},\n    rowspan: {default: 1},\n    colwidth: {default: null}\n  };\n  for (var prop in extraAttrs)\n    { cellAttrs[prop] = {default: extraAttrs[prop].default}; }\n\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{tag: \"table\"}],\n      toDOM: function toDOM() { return [\"table\", [\"tbody\", 0]] }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{tag: \"tr\"}],\n      toDOM: function toDOM() { return [\"tr\", 0] }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [{tag: \"td\", getAttrs: function (dom) { return getCellAttrs(dom, extraAttrs); }}],\n      toDOM: function toDOM(node) { return [\"td\", setCellAttrs(node, extraAttrs), 0] }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [{tag: \"th\", getAttrs: function (dom) { return getCellAttrs(dom, extraAttrs); }}],\n      toDOM: function toDOM(node) { return [\"th\", setCellAttrs(node, extraAttrs), 0] }\n    }\n  }\n}\n\nfunction tableNodeTypes(schema) {\n  var result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (var name in schema.nodes) {\n      var type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) { result[role] = type; }\n    }\n  }\n  return result\n}\n\n// Utilities used for copy/paste handling.\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nfunction pastedCells(slice) {\n  if (!slice.size) { return null }\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n  var first = content.firstChild, role = first.type.spec.tableRole;\n  var schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (var i = 0; i < content.childCount; i++) {\n      var cells = content.child(i).content;\n      var left = i ? 0 : Math.max(0, openStart - 1);\n      var right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) { cells = fitSlice(tableNodeTypes(schema).row, new prosemirrorModel.Slice(cells, left, right)).content; }\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new prosemirrorModel.Slice(content, openStart, openEnd)).content : content);\n  } else {\n    return null\n  }\n  return ensureRectangular(schema, rows)\n}\n\n// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema, rows) {\n  var widths = [];\n  for (var i = 0; i < rows.length; i++) {\n    var row = rows[i];\n    for (var j = row.childCount - 1; j >= 0; j--) {\n      var ref = row.child(j).attrs;\n      var rowspan = ref.rowspan;\n      var colspan = ref.colspan;\n      for (var r = i; r < i + rowspan; r++)\n        { widths[r] = (widths[r] || 0) + colspan; }\n    }\n  }\n  var width = 0;\n  for (var r$1 = 0; r$1 < widths.length; r$1++) { width = Math.max(width, widths[r$1]); }\n  for (var r$2 = 0; r$2 < widths.length; r$2++) {\n    if (r$2 >= rows.length) { rows.push(prosemirrorModel.Fragment.empty); }\n    if (widths[r$2] < width) {\n      var empty = tableNodeTypes(schema).cell.createAndFill(), cells = [];\n      for (var i$1 = widths[r$2]; i$1 < width; i$1++) { cells.push(empty); }\n      rows[r$2] = rows[r$2].append(prosemirrorModel.Fragment.from(cells));\n    }\n  }\n  return {height: rows.length, width: width, rows: rows}\n}\n\nfunction fitSlice(nodeType, slice) {\n  var node = nodeType.createAndFill();\n  var tr = new prosemirrorTransform.Transform(node).replace(0, node.content.size, slice);\n  return tr.doc\n}\n\n// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nfunction clipCells(ref, newWidth, newHeight) {\n  var width = ref.width;\n  var height = ref.height;\n  var rows = ref.rows;\n\n  if (width != newWidth) {\n    var added = [], newRows = [];\n    for (var row = 0; row < rows.length; row++) {\n      var frag = rows[row], cells = [];\n      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {\n        var cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          { cell = cell.type.create(rmColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content); }\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (var j = 1; j < cell.attrs.rowspan; j++)\n          { added[row + j] = (added[row + j] || 0) + cell.attrs.colspan; }\n      }\n      newRows.push(prosemirrorModel.Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    var newRows$1 = [];\n    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {\n      var cells$1 = [], source = rows[i$1 % height];\n      for (var j$1 = 0; j$1 < source.childCount; j$1++) {\n        var cell$1 = source.child(j$1);\n        if (row$1 + cell$1.attrs.rowspan > newHeight)\n          { cell$1 = cell$1.type.create(setAttr(cell$1.attrs, \"rowspan\", newHeight - cell$1.attrs.rowspan), cell$1.content); }\n        cells$1.push(cell$1);\n      }\n      newRows$1.push(prosemirrorModel.Fragment.from(cells$1));\n    }\n    rows = newRows$1;\n    height = newHeight;\n  }\n\n  return {width: width, height: height, rows: rows}\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  var schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty, emptyHead;\n  if (width > map.width) {\n    for (var row = 0, rowEnd = 0; row < map.height; row++) {\n      var rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      var cells = [], add = (void 0);\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        { add = empty || (empty = types.cell.createAndFill()); }\n      else\n        { add = emptyHead || (emptyHead = types.header_cell.createAndFill()); }\n      for (var i = map.width; i < width; i++) { cells.push(add); }\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    var cells$1 = [];\n    for (var i$1 = 0, start$1 = (map.height - 1) * map.width; i$1 < Math.max(map.width, width); i$1++) {\n      var header = i$1 >= map.width ? false :\n          table.nodeAt(map.map[start$1 + i$1]).type == types.header_cell;\n      cells$1.push(header\n                 ? (emptyHead || (emptyHead = types.header_cell.createAndFill()))\n                 : (empty || (empty = types.cell.createAndFill())));\n    }\n\n    var emptyRow = types.row.create(null, prosemirrorModel.Fragment.from(cells$1)), rows = [];\n    for (var i$2 = map.height; i$2 < height; i$2++) { rows.push(emptyRow); }\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead)\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) { return false }\n  var found = false;\n  for (var col = left; col < right; col++) {\n    var index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      var cell = table.nodeAt(pos);\n      var ref = map.findCell(pos);\n      var cellTop = ref.top;\n      var cellLeft = ref.left;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, \"rowspan\", top - cellTop));\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n                cell.type.createAndFill(setAttr(cell.attrs, \"rowspan\", (cellTop + cell.attrs.rowspan) - top)));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) { return false }\n  var found = false;\n  for (var row = top; row < bottom; row++) {\n    var index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      var cell = table.nodeAt(pos), cellLeft = map.colCount(pos);\n      var updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, rmColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(rmColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map = TableMap.get(table);\n  var top = rect.top;\n  var left = rect.left;\n  var right = left + cells.width, bottom = top + cells.height;\n  var tr = state.tr, mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) { recomp(); }\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) { recomp(); }\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) { recomp(); }\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) { recomp(); }\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) { recomp(); }\n\n  for (var row = top; row < bottom; row++) {\n    var from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart),\n               new prosemirrorModel.Slice(cells.rows[row - top], 0, 0));\n  }\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n                                    tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// This file defines a number of helpers for wiring up user input to\n\nvar handleKeyDown = prosemirrorKeymap.keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1),\n\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n\n  \"Backspace\": deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  \"Delete\": deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) { return false }\n  if (dispatch) { dispatch(state.tr.setSelection(selection).scrollIntoView()); }\n  return true\n}\n\nfunction arrow(axis, dir) {\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, prosemirrorState.Selection.near(sel.$headCell, dir))\n    }\n    if (axis != \"horiz\" && !sel.empty) { return false }\n    var end = atEndOfCell(view, axis, dir);\n    if (end == null) { return false }\n    if (axis == \"horiz\") {\n      return maybeSetSelection(state, dispatch, prosemirrorState.Selection.near(state.doc.resolve(sel.head + dir), dir))\n    } else {\n      var $cell = state.doc.resolve(end), $next = nextCell($cell, axis, dir), newSel;\n      if ($next) { newSel = prosemirrorState.Selection.near($next, 1); }\n      else if (dir < 0) { newSel = prosemirrorState.Selection.near(state.doc.resolve($cell.before(-1)), -1); }\n      else { newSel = prosemirrorState.Selection.near(state.doc.resolve($cell.after(-1)), 1); }\n      return maybeSetSelection(state, dispatch, newSel)\n    }\n  }\n}\n\nfunction shiftArrow(axis, dir) {\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    if (!(sel instanceof CellSelection)) {\n      var end = atEndOfCell(view, axis, dir);\n      if (end == null) { return false }\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n    var $head = nextCell(sel.$headCell, axis, dir);\n    if (!$head) { return false }\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head))\n  }\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  var sel = state.selection;\n  if (!(sel instanceof CellSelection)) { return false }\n  if (dispatch) {\n    var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell(function (cell, pos) {\n      if (!cell.content.eq(baseContent))\n        { tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1),\n                   new prosemirrorModel.Slice(baseContent, 0, 0)); }\n    });\n    if (tr.docChanged) { dispatch(tr); }\n  }\n  return true\n}\n\nfunction handleTripleClick(view, pos) {\n  var doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) { return false }\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true\n}\n\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) { return false }\n  var cells = pastedCells(slice), sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells) { cells = {width: 1, height: 1, rows: [prosemirrorModel.Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]}; }\n    var table = sel.$anchorCell.node(-1), start = sel.$anchorCell.start(-1);\n    var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true\n  } else if (cells) {\n    var $cell = selectionCell(view.state), start$1 = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) { return }\n\n  var startDOMCell = domInCell(view, startEvent.target), $anchor;\n  if (startEvent.shiftKey && (view.state.selection instanceof CellSelection)) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell &&\n             ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n             cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor, event) {\n    var $head = cellUnderMouse(view, event);\n    var starting = key.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) { $head = $anchor; }\n      else { return }\n    }\n    var selection = new CellSelection($anchor, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      var tr = view.state.tr.setSelection(selection);\n      if (starting) { tr.setMeta(key, $anchor.pos); }\n      view.dispatch(tr);\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (key.getState(view.state) != null) { view.dispatch(view.state.tr.setMeta(key, -1)); }\n  }\n\n  function move(event) {\n    var anchor = key.getState(view.state), $anchor;\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) { return stop() }\n    }\n    if ($anchor) { setCellSelection($anchor, event); }\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof prosemirrorState.TextSelection)) { return null }\n  var ref = view.state.selection;\n  var $head = ref.$head;\n  for (var d = $head.depth - 1; d >= 0; d--) {\n    var parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) { return null }\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      var cellPos = $head.before(d);\n      var dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n      return view.endOfTextblock(dirStr) ? cellPos : null\n    }\n  }\n  return null\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode)\n    { if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") { return dom } }\n}\n\nfunction cellUnderMouse(view, event) {\n  var mousePos = view.posAtCoords({left: event.clientX, top: event.clientY});\n  if (!mousePos) { return null }\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null\n}\n\n// This file defines helpers for normalizing tables, making sure no\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old, cur, offset, f) {\n  var oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (var i = 0, j = 0; i < curSize; i++) {\n    var child = cur.child(i);\n    for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      { changedDescendants(old.child(j), child, offset + 1, f); }\n    else\n      { child.nodesBetween(0, child.content.size, f, offset + 1); }\n    offset += child.nodeSize;\n  }\n}\n\n// :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nfunction fixTables(state, oldState) {\n  var tr, check = function (node, pos) {\n    if (node.type.spec.tableRole == \"table\") { tr = fixTable(state, node, pos, tr); }\n  };\n  if (!oldState) { state.doc.descendants(check); }\n  else if (oldState.doc != state.doc) { changedDescendants(oldState.doc, state.doc, 0, check); }\n  return tr\n}\n\n// : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nfunction fixTable(state, table, tablePos, tr) {\n  var map = TableMap.get(table);\n  if (!map.problems) { return tr }\n  if (!tr) { tr = state.tr; }\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  var mustAdd = [];\n  for (var i = 0; i < map.height; i++) { mustAdd.push(0); }\n  for (var i$1 = 0; i$1 < map.problems.length; i$1++) {\n    var prob = map.problems[i$1];\n    if (prob.type == \"collision\") {\n      var cell = table.nodeAt(prob.pos);\n      for (var j = 0; j < cell.attrs.rowspan; j++) { mustAdd[prob.row + j] += prob.n; }\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, rmColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      var cell$1 = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, \"rowspan\", cell$1.attrs.rowspan - prob.n));\n    } else if (prob.type == \"colwidth mismatch\") {\n      var cell$2 = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, \"colwidth\", prob.colwidth));\n    }\n  }\n  var first, last;\n  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) { if (mustAdd[i$2]) {\n    if (first == null) { first = i$2; }\n    last = i$2;\n  } }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (var i$3 = 0, pos = tablePos + 1; i$3 < map.height; i$3++) {\n    var row = table.child(i$3);\n    var end = pos + row.nodeSize;\n    var add = mustAdd[i$3];\n    if (add > 0) {\n      var tableNodeType = 'cell';\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n      var nodes = [];\n      for (var j$1 = 0; j$1 < add; j$1++)\n        { nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill()); }\n      var side = (i$3 == 0 || first == i$3 - 1) && last == i$3 ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr\n}\n\n// This file defines a number of table-related commands.\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nfunction selectedRect(state) {\n  var sel = state.selection, $pos = selectionCell(state);\n  var table = $pos.node(-1), tableStart = $pos.start(-1), map = TableMap.get(table);\n  var rect;\n  if (sel instanceof CellSelection)\n    { rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart); }\n  else\n    { rect = map.findCell($pos.pos - tableStart); }\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect\n}\n\nfunction columnIsHeader(map, table, col) {\n  var headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (var row = 0; row < map.height; row++)\n    { if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      { return false } }\n  return true\n}\n\n// Add a column at the given position in a table.\nfunction addColumn(tr, ref, col) {\n  var map = ref.map;\n  var tableStart = ref.tableStart;\n  var table = ref.table;\n\n  var refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn))\n    { refColumn = col == 0 || col == map.width ? null : 0; }\n\n  for (var row = 0; row < map.height; row++) {\n    var index = row * map.width + col;\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      var pos = map.map[index], cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null,\n                       addColSpan(cell.attrs, col - map.colCount(pos)));\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1;\n    } else {\n      var type = refColumn == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn]).type;\n      var pos$1 = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());\n    }\n  }\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true\n}\n\nfunction removeColumn(tr, ref, col) {\n  var map = ref.map;\n  var table = ref.table;\n  var tableStart = ref.tableStart;\n\n  var mapStart = tr.mapping.maps.length;\n  for (var row = 0; row < map.height;) {\n    var index = row * map.width + col, pos = map.map[index], cell = table.nodeAt(pos);\n    // If this is part of a col-spanning cell\n    if ((col > 0 && map.map[index - 1] == pos) || (col < map.width - 1 && map.map[index + 1] == pos)) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null,\n                       rmColSpan(cell.attrs, col - map.colCount(pos)));\n    } else {\n      var start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += cell.attrs.rowspan;\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state), tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) { return false }\n    for (var i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) { break }\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true\n}\n\nfunction rowIsHeader(map, table, row) {\n  var headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (var col = 0; col < map.width; col++)\n    { if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      { return false } }\n  return true\n}\n\nfunction addRow(tr, ref, row) {\n  var map = ref.map;\n  var tableStart = ref.tableStart;\n  var table = ref.table;\n\n  var rowPos = tableStart;\n  for (var i = 0; i < row; i++) { rowPos += table.child(i).nodeSize; }\n  var cells = [], refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    { refRow = row == 0 || row == map.height ? null : 0; }\n  for (var col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      var pos = map.map[index], attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, \"rowspan\", attrs.rowspan + 1));\n      col += attrs.colspan - 1;\n    } else {\n      var type = refRow == null ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true\n}\n\nfunction removeRow(tr, ref, row) {\n  var map = ref.map;\n  var table = ref.table;\n  var tableStart = ref.tableStart;\n\n  var rowPos = 0;\n  for (var i = 0; i < row; i++) { rowPos += table.child(i).nodeSize; }\n  var nextRow = rowPos + table.child(row).nodeSize;\n\n  var mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (var col = 0, index = row * map.width; col < map.width; col++, index++) {\n    var pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      var attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, \"rowspan\", attrs.rowspan - 1));\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      var cell = table.nodeAt(pos);\n      var copy = cell.type.create(setAttr(cell.attrs, \"rowspan\", cell.attrs.rowspan - 1), cell.content);\n      var newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) { return false }\n  if (dispatch) {\n    var rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) { return false }\n    for (var i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) { break }\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true\n}\n\nfunction isEmpty(cell) {\n  var c = cell.content;\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0\n}\n\nfunction cellsOverlapRectangle(ref, rect) {\n  var width = ref.width;\n  var height = ref.height;\n  var map = ref.map;\n\n  var indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (var i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] ||\n        rect.right < width && map[indexRight] == map[indexRight + 1]) { return true }\n    indexLeft += width; indexRight += width;\n  }\n  for (var i$1 = rect.left; i$1 < rect.right; i$1++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] ||\n        rect.bottom < height && map[indexBottom] == map[indexBottom + width]) { return true }\n    indexTop++; indexBottom++;\n  }\n  return false\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nfunction mergeCells(state, dispatch) {\n  var sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) { return false }\n  var rect = selectedRect(state);\n  var map = rect.map;\n  if (cellsOverlapRectangle(map, rect)) { return false }\n  if (dispatch) {\n    var tr = state.tr, seen = [], content = prosemirrorModel.Fragment.empty, mergedPos, mergedCell;\n    for (var row = rect.top; row < rect.bottom; row++) {\n      for (var col = rect.left; col < rect.right; col++) {\n        var cellPos = map.map[row * map.width + col], cell = rect.table.nodeAt(cellPos);\n        if (seen.indexOf(cellPos) > -1) { continue }\n        seen.push(cellPos);\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) { content = content.append(cell.content); }\n          var mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null,\n                     setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, (rect.right - rect.left) - mergedCell.attrs.colspan),\n                             \"rowspan\", rect.bottom - rect.top));\n    if (content.size) {\n      var end = mergedPos + 1 + mergedCell.content.size;\n      var start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n  return true\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells.\nfunction splitCell(state, dispatch) {\n  var sel = state.selection;\n  var cellNode, cellPos;\n  if (!(sel instanceof CellSelection)) {\n    cellNode = cellWrapping(sel.$from);\n    if (!cellNode) { return false }\n    cellPos = cellAround(sel.$from).pos;\n  } else {\n    if (sel.$anchorCell.pos != sel.$headCell.pos) { return false }\n    cellNode = sel.$anchorCell.nodeAfter;\n    cellPos = sel.$anchorCell.pos;\n  }\n  if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {return false}\n  if (dispatch) {\n    var baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;\n    if (baseAttrs.rowspan > 1) { baseAttrs = setAttr(baseAttrs, \"rowspan\", 1); }\n    if (baseAttrs.colspan > 1) { baseAttrs = setAttr(baseAttrs, \"colspan\", 1); }\n    var rect = selectedRect(state), tr = state.tr;\n    for (var i = 0; i < rect.right - rect.left; i++)\n      { attrs.push(colwidth ? setAttr(baseAttrs, \"colwidth\", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs); }\n    var lastCell, cellType = tableNodeTypes(state.schema)[cellNode.type.spec.tableRole];\n    for (var row = 0; row < rect.bottom; row++) {\n      if (row >= rect.top) {\n        var pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) { pos += cellNode.nodeSize; }\n        for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {\n          if (col == rect.left && row == rect.top) { continue }\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), cellType.createAndFill(attrs[i$1]));\n        }\n      }\n    }\n    tr.setNodeMarkup(cellPos, null, attrs[0]);\n    if (sel instanceof CellSelection)\n      { tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),\n                                        lastCell && tr.doc.resolve(lastCell))); }\n    dispatch(tr);\n  }\n  return true\n}\n\n// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    var $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) { return false }\n    if (dispatch) {\n      var tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        { state.selection.forEachCell(function (node, pos) {\n          if (node.attrs[name] !== value)\n            { tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value)); }\n        }); }\n      else\n        { tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value)); }\n      dispatch(tr);\n    }\n    return true\n  }\n}\n\nfunction toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    if (dispatch) {\n      var types = tableNodeTypes(state.schema);\n      var rect = selectedRect(state), tr = state.tr;\n      var cells = rect.map.cellsInRect(type == \"column\" ? new Rect(rect.left, 0, rect.right, rect.map.height) :\n                                       type == \"row\" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);\n      var nodes = cells.map(function (pos) { return rect.table.nodeAt(pos); });\n      for (var i = 0; i < cells.length; i++) // Remove headers, if any\n        { if (nodes[i].type == types.header_cell)\n          { tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs); } }\n      if (tr.steps.length == 0) { for (var i$1 = 0; i$1 < cells.length; i$1++) // No headers removed, add instead\n        { tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes[i$1].attrs); } }\n      dispatch(tr);\n    }\n    return true\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\nvar toggleHeaderRow = toggleHeader(\"row\");\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\nvar toggleHeaderColumn = toggleHeader(\"column\");\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\nvar toggleHeaderCell = toggleHeader(\"cell\");\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    var before = $cell.nodeBefore;\n    if (before) { return $cell.pos - before.nodeSize }\n    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      var rowNode = $cell.node(-1).child(row);\n      if (rowNode.childCount) { return rowEnd - 1 - rowNode.lastChild.nodeSize }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) { return $cell.pos + $cell.nodeAfter.nodeSize }\n    var table = $cell.node(-1);\n    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table.childCount; row$1++) {\n      var rowNode$1 = table.child(row$1);\n      if (rowNode$1.childCount) { return rowStart + 1 }\n      rowStart += rowNode$1.nodeSize;\n    }\n  }\n}\n\n// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) { return false }\n    var cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) { return }\n    if (dispatch) {\n      var $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(prosemirrorState.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\nfunction deleteTable(state, dispatch) {\n  var $pos = state.selection.$anchor;\n  for (var d = $pos.depth; d > 0; d--) {\n    var node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch) { dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()); }\n      return true\n    }\n  }\n  return false\n}\n\nvar TableView = function TableView(node, cellMinWidth) {\n  this.node = node;\n  this.cellMinWidth = cellMinWidth;\n  this.dom = document.createElement(\"div\");\n  this.dom.className = \"tableWrapper\";\n  this.table = this.dom.appendChild(document.createElement(\"table\"));\n  this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n  updateColumns(node, this.colgroup, this.table, cellMinWidth);\n  this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n};\n\nTableView.prototype.update = function update (node) {\n  if (node.type != this.node.type) { return false }\n  this.node = node;\n  updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n  return true\n};\n\nTableView.prototype.ignoreMutation = function ignoreMutation (record) {\n  return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target))\n};\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var totalWidth = 0, fixedWidth = true;\n  var nextDOM = colgroup.firstChild, row = node.firstChild;\n  for (var i = 0, col = 0; i < row.childCount; i++) {\n    var ref = row.child(i).attrs;\n    var colspan = ref.colspan;\n    var colwidth = ref.colwidth;\n    for (var j = 0; j < colspan; j++, col++) {\n      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      var cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) { fixedWidth = false; }\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) { nextDOM.style.width = cssWidth; }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    var after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\nvar key$1 = new prosemirrorState.PluginKey(\"tableColumnResizing\");\n\nfunction columnResizing(ref) {\n  if ( ref === void 0 ) ref = {};\n  var handleWidth = ref.handleWidth; if ( handleWidth === void 0 ) handleWidth = 5;\n  var cellMinWidth = ref.cellMinWidth; if ( cellMinWidth === void 0 ) cellMinWidth = 25;\n  var View = ref.View; if ( View === void 0 ) View = TableView;\n  var lastColumnResizable = ref.lastColumnResizable; if ( lastColumnResizable === void 0 ) lastColumnResizable = true;\n\n  var plugin = new prosemirrorState.Plugin({\n    key: key$1,\n    state: {\n      init: function init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] =\n          function (node, view) { return new View(node, cellMinWidth, view); };\n        return new ResizeState(-1, false)\n      },\n      apply: function apply(tr, prev) {\n        return prev.apply(tr)\n      }\n    },\n    props: {\n      attributes: function attributes(state) {\n        var pluginState = key$1.getState(state);\n        return pluginState.activeHandle > -1 ? {class: \"resize-cursor\"} : null\n      },\n\n      handleDOMEvents: {\n        mousemove: function mousemove(view, event) { handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable); },\n        mouseleave: function mouseleave(view) { handleMouseLeave(view); },\n        mousedown: function mousedown(view, event) { handleMouseDown$1(view, event, cellMinWidth); }\n      },\n\n      decorations: function decorations(state) {\n        var pluginState = key$1.getState(state);\n        if (pluginState.activeHandle > -1) { return handleDecorations(state, pluginState.activeHandle) }\n      },\n\n      nodeViews: {}\n    }\n  });\n  return plugin\n}\n\nvar ResizeState = function ResizeState(activeHandle, dragging) {\n  this.activeHandle = activeHandle;\n  this.dragging = dragging;\n};\n\nResizeState.prototype.apply = function apply (tr) {\n  var state = this, action = tr.getMeta(key$1);\n  if (action && action.setHandle != null)\n    { return new ResizeState(action.setHandle, null) }\n  if (action && action.setDragging !== undefined)\n    { return new ResizeState(state.activeHandle, action.setDragging) }\n  if (state.activeHandle > -1 && tr.docChanged) {\n    var handle = tr.mapping.map(state.activeHandle, -1);\n    if (!pointsAtCell(tr.doc.resolve(handle))) { handle = null; }\n    state = new ResizeState(handle, state.dragging);\n  }\n  return state\n};\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  var pluginState = key$1.getState(view.state);\n\n  if (!pluginState.dragging) {\n    var target = domCellAround(event.target), cell = -1;\n    if (target) {\n      var ref = target.getBoundingClientRect();\n      var left = ref.left;\n      var right = ref.right;\n      if (event.clientX - left <= handleWidth)\n        { cell = edgeCell(view, event, \"left\"); }\n      else if (right - event.clientX <= handleWidth)\n        { cell = edgeCell(view, event, \"right\"); }\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        var $cell = view.state.doc.resolve(cell);\n        var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n        var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  var pluginState = key$1.getState(view.state);\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) { updateHandle(view, -1); }\n}\n\nfunction handleMouseDown$1(view, event, cellMinWidth) {\n  var pluginState = key$1.getState(view.state);\n  if (pluginState.activeHandle == -1 || pluginState.dragging) { return false }\n\n  var cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(key$1, {setDragging: {startX: event.clientX, startWidth: width}}));\n\n  function finish(event) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    var pluginState = key$1.getState(view.state);\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(key$1, {setDragging: null}));\n    }\n  }\n  function move(event) {\n    if (!event.which) { return finish(event) }\n    var pluginState = key$1.getState(view.state);\n    var dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true\n}\n\nfunction currentColWidth(view, cellPos, ref) {\n  var colspan = ref.colspan;\n  var colwidth = ref.colwidth;\n\n  var width = colwidth && colwidth[colwidth.length - 1];\n  if (width) { return width }\n  var dom = view.domAtPos(cellPos);\n  var node = dom.node.childNodes[dom.offset];\n  var domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) { for (var i = 0; i < colspan; i++) { if (colwidth[i]) {\n    domWidth -= colwidth[i];\n    parts--;\n  } } }\n  return domWidth / parts\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    { target = target.classList.contains(\"ProseMirror\") ? null : target.parentNode; }\n  return target\n}\n\nfunction edgeCell(view, event, side) {\n  var ref = view.posAtCoords({left: event.clientX, top: event.clientY});\n  var pos = ref.pos;\n  var $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) { return -1 }\n  if (side == \"right\") { return $cell.pos }\n  var map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  var index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1]\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  var offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset)\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key$1, {setHandle: value}));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  var $cell = view.state.doc.resolve(cell);\n  var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  var tr = view.state.tr;\n  for (var row = 0; row < map.height; row++) {\n    var mapIndex = row * map.width + col;\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) { continue }\n    var pos = map.map[mapIndex];\n    var ref = table.nodeAt(pos);\n    var attrs = ref.attrs;\n    var index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) { continue }\n    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, \"colwidth\", colwidth));\n  }\n  if (tr.docChanged) { view.dispatch(tr); }\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  var $cell = view.state.doc.resolve(cell);\n  var table = $cell.node(-1), start = $cell.start(-1);\n  var col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  var dom = view.domAtPos($cell.start(-1)).node;\n  while (dom.nodeName != \"TABLE\") { dom = dom.parentNode; }\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  var result = [];\n  for (var i = 0; i < n; i++) { result.push(0); }\n  return result\n}\n\nfunction handleDecorations(state, cell) {\n  var decorations = [];\n  var $cell = state.doc.resolve(cell);\n  var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (var row = 0; row < map.height; row++) {\n    var index = col + row * map.width - 1;\n    // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if ((col == map.width || map.map[index] != map.map[index + 1]) &&\n        (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      var cellPos = map.map[index];\n      var pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      var dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(prosemirrorView.Decoration.widget(pos, dom));\n    }\n  }\n  return prosemirrorView.DecorationSet.create(state.doc, decorations)\n}\n\n// This file defines a plugin that handles the drawing of cell\n\n// :: () → Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\nfunction tableEditing() {\n  return new prosemirrorState.Plugin({\n    key: key,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init: function init() { return null },\n      apply: function apply(tr, cur) {\n        var set = tr.getMeta(key);\n        if (set != null) { return set == -1 ? null : set }\n        if (cur == null || !tr.docChanged) { return cur }\n        var ref = tr.mapping.mapResult(cur);\n        var deleted = ref.deleted;\n        var pos = ref.pos;\n        return deleted ? null : pos\n      }\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n\n      createSelectionBetween: function createSelectionBetween(view) {\n        if (key.getState(view.state) != null) { return view.state.selection }\n      },\n\n      handleTripleClick: handleTripleClick,\n\n      handleKeyDown: handleKeyDown,\n\n      handlePaste: handlePaste\n    },\n\n    appendTransaction: function appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState))\n    }\n  })\n}\n\nexports.tableEditing = tableEditing;\nexports.fixTables = fixTables;\nexports.handlePaste = handlePaste;\nexports.cellAround = cellAround;\nexports.isInTable = isInTable;\nexports.selectionCell = selectionCell;\nexports.moveCellForward = moveCellForward;\nexports.inSameTable = inSameTable;\nexports.findCell = findCell;\nexports.colCount = colCount;\nexports.nextCell = nextCell;\nexports.tableNodes = tableNodes;\nexports.CellSelection = CellSelection;\nexports.TableMap = TableMap;\nexports.columnResizing = columnResizing;\nexports.columnResizingPluginKey = key$1;\nexports.updateColumnsOnResize = updateColumns;\nexports.__pastedCells = pastedCells;\nexports.__insertCells = insertCells;\nexports.__clipCells = clipCells;\nexports.addColumn = addColumn;\nexports.addColumnBefore = addColumnBefore;\nexports.addColumnAfter = addColumnAfter;\nexports.removeColumn = removeColumn;\nexports.deleteColumn = deleteColumn;\nexports.addRow = addRow;\nexports.addRowBefore = addRowBefore;\nexports.addRowAfter = addRowAfter;\nexports.removeRow = removeRow;\nexports.deleteRow = deleteRow;\nexports.mergeCells = mergeCells;\nexports.splitCell = splitCell;\nexports.setCellAttr = setCellAttr;\nexports.toggleHeaderRow = toggleHeaderRow;\nexports.toggleHeaderColumn = toggleHeaderColumn;\nexports.toggleHeaderCell = toggleHeaderCell;\nexports.goToNextCell = goToNextCell;\nexports.deleteTable = deleteTable;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-tables/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js":
/*!************************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\n\n// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if ( deleted === void 0 ) deleted = false;\n  if ( recover === void 0 ) recover = null;\n\n  // :: number The mapped version of the position.\n  this.pos = pos;\n  // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n  this.deleted = deleted;\n  this.recover = recover;\n};\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nvar StepMap = function StepMap(ranges, inverted) {\n  if ( inverted === void 0 ) inverted = false;\n\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover (value) {\n    var this$1 = this;\n\n  var diff = 0, index = recoverIndex(value);\n  if (!this.inverted) { for (var i = 0; i < index; i++)\n    { diff += this$1.ranges[i * 3 + 2] - this$1.ranges[i * 3 + 1]; } }\n  return this.ranges[index * 3] + diff + recoverOffset(value)\n};\n\n// : (number, ?number) → MapResult\nStepMap.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\n// : (number, ?number) → number\nStepMap.prototype.map = function map (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, true) };\n\nStepMap.prototype._map = function _map (pos, assoc, simple) {\n    var this$1 = this;\n\n  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this$1.ranges[i] - (this$1.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this$1.ranges[i + oldIndex], newSize = this$1.ranges[i + newIndex], end = start + oldSize;\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n      if (simple) { return result }\n      var recover = makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n    }\n    diff += newSize - oldSize;\n  }\n  return simple ? pos + diff : new MapResult(pos + diff)\n};\n\nStepMap.prototype.touches = function touches (pos, recover) {\n    var this$1 = this;\n\n  var diff = 0, index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this$1.ranges[i] - (this$1.inverted ? diff : 0);\n    if (start > pos) { break }\n    var oldSize = this$1.ranges[i + oldIndex], end = start + oldSize;\n    if (pos <= end && i == index * 3) { return true }\n    diff += this$1.ranges[i + newIndex] - oldSize;\n  }\n  return false\n};\n\n// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\nStepMap.prototype.forEach = function forEach (f) {\n    var this$1 = this;\n\n  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this$1.ranges[i], oldStart = start - (this$1.inverted ? diff : 0), newStart = start + (this$1.inverted ? 0 : diff);\n    var oldSize = this$1.ranges[i + oldIndex], newSize = this$1.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n};\n\n// :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\nStepMap.prototype.invert = function invert () {\n  return new StepMap(this.ranges, !this.inverted)\n};\n\nStepMap.prototype.toString = function toString () {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n};\n\n// :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\nStepMap.offset = function offset (n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n};\n\nStepMap.empty = new StepMap([]);\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || [];\n  // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n  this.from = from || 0;\n  // :: number\n  // The end position in the `maps` array.\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n};\n\n// :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\nMapping.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.maps.length;\n\n  return new Mapping(this.maps, this.mirror, from, to)\n};\n\nMapping.prototype.copy = function copy () {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n};\n\n// :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\nMapping.prototype.appendMap = function appendMap (map, mirrors) {\n  this.to = this.maps.push(map);\n  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }\n};\n\n// :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\nMapping.prototype.appendMapping = function appendMapping (mapping) {\n    var this$1 = this;\n\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this$1.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n};\n\n// :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\nMapping.prototype.getMirror = function getMirror (n) {\n    var this$1 = this;\n\n  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)\n    { if (this$1.mirror[i] == n) { return this$1.mirror[i + (i % 2 ? -1 : 1)] } } }\n};\n\nMapping.prototype.setMirror = function setMirror (n, m) {\n  if (!this.mirror) { this.mirror = []; }\n  this.mirror.push(n, m);\n};\n\n// :: (Mapping)\n// Append the inverse of the given mapping to this one.\nMapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {\n    var this$1 = this;\n\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this$1.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n};\n\n// () → Mapping\n// Create an inverted version of this mapping.\nMapping.prototype.invert = function invert () {\n  var inverse = new Mapping;\n  inverse.appendMappingInverted(this);\n  return inverse\n};\n\n// : (number, ?number) → number\n// Map a position through this mapping.\nMapping.prototype.map = function map (pos, assoc) {\n    var this$1 = this;\n    if ( assoc === void 0 ) assoc = 1;\n\n  if (this.mirror) { return this._map(pos, assoc, true) }\n  for (var i = this.from; i < this.to; i++)\n    { pos = this$1.maps[i].map(pos, assoc); }\n  return pos\n};\n\n// : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\nMapping.prototype.mapResult = function mapResult (pos, assoc) {\n  if ( assoc === void 0 ) assoc = 1;\n return this._map(pos, assoc, false) };\n\nMapping.prototype._map = function _map (pos, assoc, simple) {\n    var this$1 = this;\n\n  var deleted = false, recoverables = null;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this$1.maps[i], rec = recoverables && recoverables[i];\n    if (rec != null && map.touches(pos, rec)) {\n      pos = map.recover(rec);\n      continue\n    }\n\n    var result = map.mapResult(pos, assoc);\n    if (result.recover != null) {\n      var corr = this$1.getMirror(i);\n      if (corr != null && corr > i && corr < this$1.to) {\n        if (result.deleted) {\n          i = corr;\n          pos = this$1.maps[corr].recover(result.recover);\n          continue\n        } else {\n          (recoverables || (recoverables = Object.create(null)))[corr] = result.recover;\n        }\n      }\n    }\n\n    if (result.deleted) { deleted = true; }\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted)\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc;\n  // :: [Step]\n  // The steps in this transform.\n  this.steps = [];\n  // :: [Node]\n  // The documents before each of the steps.\n  this.docs = [];\n  // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n  this.mapping = new Mapping;\n};\n\nvar prototypeAccessors = { before: {},docChanged: {} };\n\n// :: Node The starting document.\nprototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };\n\n// :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\nTransform.prototype.step = function step (object) {\n  var result = this.maybeStep(object);\n  if (result.failed) { throw new TransformError(result.failed) }\n  return this\n};\n\n// :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\nTransform.prototype.maybeStep = function maybeStep (step) {\n  var result = step.apply(this.doc);\n  if (!result.failed) { this.addStep(step, result.doc); }\n  return result\n};\n\n// :: bool\n// True when the document has been changed (when there are any\n// steps).\nprototypeAccessors.docChanged.get = function () {\n  return this.steps.length > 0\n};\n\nTransform.prototype.addStep = function addStep (step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties( Transform.prototype, prototypeAccessors );\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nvar stepsByID = Object.create(null);\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nvar Step = function Step () {};\n\nStep.prototype.apply = function apply (_doc) { return mustOverride() };\n\n// :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\nStep.prototype.getMap = function getMap () { return StepMap.empty };\n\n// :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\nStep.prototype.invert = function invert (_doc) { return mustOverride() };\n\n// :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\nStep.prototype.map = function map (_mapping) { return mustOverride() };\n\n// :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\nStep.prototype.merge = function merge (_other) { return null };\n\n// :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\nStep.prototype.toJSON = function toJSON () { return mustOverride() };\n\n// :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\nStep.fromJSON = function fromJSON (schema, json) {\n  if (!json || !json.stepType) { throw new RangeError(\"Invalid input for Step.fromJSON\") }\n  var type = stepsByID[json.stepType];\n  if (!type) { throw new RangeError((\"No step type \" + (json.stepType) + \" defined\")) }\n  return type.fromJSON(schema, json)\n};\n\n// :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\nStep.jsonID = function jsonID (id, stepClass) {\n  if (id in stepsByID) { throw new RangeError(\"Duplicate use of step JSON ID \" + id) }\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass\n};\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc;\n  // :: ?string Text providing information about a failed step.\n  this.failed = failed;\n};\n\n// :: (Node) → StepResult\n// Create a successful step result.\nStepResult.ok = function ok (doc) { return new StepResult(doc, null) };\n\n// :: (string) → StepResult\n// Create a failed step result.\nStepResult.fail = function fail (message) { return new StepResult(null, message) };\n\n// :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\nStepResult.fromReplace = function fromReplace (doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice))\n  } catch (e) {\n    if (e instanceof prosemirrorModel.ReplaceError) { return StepResult.fail(e.message) }\n    throw e\n  }\n};\n\n// ::- Replace a part of the document with a slice of new content.\nvar ReplaceStep = (function (Step$$1) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step$$1.call(this);\n    this.from = from;\n    this.to = to;\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if ( Step$$1 ) ReplaceStep.__proto__ = Step$$1;\n  ReplaceStep.prototype = Object.create( Step$$1 && Step$$1.prototype );\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply (doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      { return StepResult.fail(\"Structure replace would overwrite content\") }\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  };\n\n  ReplaceStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  };\n\n  ReplaceStep.prototype.invert = function invert (doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  };\n\n  ReplaceStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted) { return null }\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  };\n\n  ReplaceStep.prototype.merge = function merge (other) {\n    if (!(other instanceof ReplaceStep) || other.structure != this.structure) { return null }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty\n          : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty\n          : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure)\n    } else {\n      return null\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replace\", from: this.from, to: this.to};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\") }\n    return new ReplaceStep(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure)\n  };\n\n  return ReplaceStep;\n}(Step));\n\nStep.jsonID(\"replace\", ReplaceStep);\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nvar ReplaceAroundStep = (function (Step$$1) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step$$1.call(this);\n    this.from = from;\n    this.to = to;\n    this.gapFrom = gapFrom;\n    this.gapTo = gapTo;\n    this.slice = slice;\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if ( Step$$1 ) ReplaceAroundStep.__proto__ = Step$$1;\n  ReplaceAroundStep.prototype = Object.create( Step$$1 && Step$$1.prototype );\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply (doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      { return StepResult.fail(\"Structure gap-replace would overwrite content\") }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      { return StepResult.fail(\"Gap is not a flat range\") }\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted) { return StepResult.fail(\"Content does not fit in gap\") }\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap () {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert (doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON () {\n    var json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};\n    if (this.slice.size) { json.slice = this.slice.toJSON(); }\n    if (this.structure) { json.structure = true; }\n    return json\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      { throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\") }\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  };\n\n  return ReplaceAroundStep;\n}(Step));\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) { return true }\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      { return depth }\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n\n  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  var start = gapStart, end = gapEnd;\n\n  var before = prosemirrorModel.Fragment.empty, openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--)\n    { if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = prosemirrorModel.Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    } }\n  var after = prosemirrorModel.Fragment.empty, openEnd = 0;\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)\n    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = prosemirrorModel.Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    } }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new prosemirrorModel.Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n};\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if ( innerRange === void 0 ) innerRange = range;\n\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) { return null }\n  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type: type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) { return null }\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) { return null }\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n  for (var i = startIndex; innerMatch && i < endIndex; i++)\n    { innerMatch = innerMatch.matchType(parent.child(i).type); }\n  if (!innerMatch || !innerMatch.validEnd) { return null }\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  var content = prosemirrorModel.Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--)\n    { content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }\n\n  var start = range.start, end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true))\n};\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to, type, attrs) {\n  var this$1 = this;\n  if ( to === void 0 ) to = from;\n\n  if (!type.isTextblock) { throw new RangeError(\"Type given to setBlockType should be a textblock\") }\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false\n    }\n  });\n  return this\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n  if (!node) { throw new RangeError(\"No node at given position\") }\n  if (!type) { type = node.type; }\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }\n\n  if (!type.validContent(node.content))\n    { throw new RangeError(\"Invalid content for node type \" + type.name) }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true))\n};\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = doc.resolve(pos), base = $pos.depth - depth;\n  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    { return false }\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d), index$1 = $pos.index(d);\n    if (node.type.spec.isolating) { return false }\n    var rest = node.content.cutByIndex(index$1, node.childCount);\n    var after = (typesAfter && typesAfter[i]) || node;\n    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }\n    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))\n      { return false }\n  }\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth, typesAfter) {\n  if ( depth === void 0 ) depth = 1;\n\n  var $pos = this.doc.resolve(pos), before = prosemirrorModel.Fragment.empty, after = prosemirrorModel.Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  return this.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth, true)))\n};\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos), index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nfunction joinPoint(doc, pos, dir) {\n  if ( dir === void 0 ) dir = -1;\n\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = (void 0), after = (void 0);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      after = $pos.node(d).maybeChild($pos.index(d) + 1);\n    } else {\n      before = $pos.node(d).maybeChild($pos.index(d) - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after)) { return pos }\n    if (d == 0) { break }\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth) {\n  if ( depth === void 0 ) depth = 1;\n\n  var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);\n  return this.step(step)\n};\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }\n\n  if ($pos.parentOffset == 0)\n    { for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }\n      if (index > 0) { return null }\n    } }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }\n      if (index$1 < $pos.node(d$1).childCount) { return null }\n    } }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) { return pos }\n  var content = slice.content;\n  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      if (pass == 1\n          ? $pos.node(d).canReplace(insertPos, insertPos, content)\n          : $pos.node(d).contentMatchAt(insertPos).findWrapping(content.firstChild.type))\n        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }\n    }\n  }\n  return null\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }\n    if (child.isInline) { child = f(child, parent, i); }\n    mapped.push(child);\n  }\n  return prosemirrorModel.Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nvar AddMarkStep = (function (Step$$1) {\n  function AddMarkStep(from, to, mark) {\n    Step$$1.call(this);\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n\n  if ( Step$$1 ) AddMarkStep.__proto__ = Step$$1;\n  AddMarkStep.prototype = Object.create( Step$$1 && Step$$1.prototype );\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!parent.type.allowsMarkType(this$1.mark.type)) { return node }\n      return node.mark(this$1.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  AddMarkStep.prototype.invert = function invert () {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  };\n\n  AddMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  AddMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark) }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  AddMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\") }\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return AddMarkStep;\n}(Step));\n\nStep.jsonID(\"addMark\", AddMarkStep);\n\n// ::- Remove a mark from all inline content between two positions.\nvar RemoveMarkStep = (function (Step$$1) {\n  function RemoveMarkStep(from, to, mark) {\n    Step$$1.call(this);\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n\n  if ( Step$$1 ) RemoveMarkStep.__proto__ = Step$$1;\n  RemoveMarkStep.prototype = Object.create( Step$$1 && Step$$1.prototype );\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply (doc) {\n    var this$1 = this;\n\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  };\n\n  RemoveMarkStep.prototype.invert = function invert () {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  };\n\n  RemoveMarkStep.prototype.map = function map (mapping) {\n    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  };\n\n  RemoveMarkStep.prototype.merge = function merge (other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      { return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark) }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON () {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      { throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\") }\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  };\n\n  return RemoveMarkStep;\n}(Step));\n\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  var this$1 = this;\n\n  var removed = [], added = [], removing = null, adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) { return }\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            { removing.to = end; }\n          else\n            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }\n        }\n      }\n\n      if (adding && adding.to == start)\n        { adding.to = end; }\n      else\n        { added.push(adding = new AddMarkStep(start, end, mark)); }\n    }\n  });\n\n  removed.forEach(function (s) { return this$1.step(s); });\n  added.forEach(function (s) { return this$1.step(s); });\n  return this\n};\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark) {\n  var this$1 = this;\n  if ( mark === void 0 ) mark = null;\n\n  var matched = [], step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) { return }\n    step++;\n    var toRemove = null;\n    if (mark instanceof prosemirrorModel.MarkType) {\n      var found = mark.isInSet(node.marks);\n      if (found) { toRemove = [found]; }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) { toRemove = [mark]; }\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i], found$1 = (void 0);\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }\n        }\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });\n  return this\n};\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match) {\n  var this$1 = this;\n  if ( match === void 0 ) match = parentType.contentMatch;\n\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [], cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i), end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))\n        { this$1.step(new RemoveMarkStep(cur, end, child.marks[j])); } }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);\n    this.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));\n  }\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this$1.step(delSteps[i$1]); }\n  return this\n};\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nfunction replaceStep(doc, from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = prosemirrorModel.Slice.empty;\n\n  if (from == to && !slice.size) { return null }\n\n  var $from = doc.resolve(from), $to = doc.resolve(to);\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }\n  var placed = placeSlice($from, slice);\n\n  var fittedLeft = fitLeft($from, placed);\n  var fitted = fitRight($from, $to, fittedLeft);\n  if (!fitted) { return null }\n  if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {\n    var d = $to.depth, after = $to.after(d);\n    while (d > 1 && after == $to.end(--d)) { ++after; }\n    var fittedAfter = fitRight($from, doc.resolve(after), fittedLeft);\n    if (fittedAfter)\n      { return new ReplaceAroundStep(from, after, to, $to.end(), fittedAfter, fittedLeft.size) }\n  }\n  return fitted.size || from != to ? new ReplaceStep(from, to, fitted) : null\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to, slice) {\n  if ( to === void 0 ) to = from;\n  if ( slice === void 0 ) slice = prosemirrorModel.Slice.empty;\n\n  var step = replaceStep(this.doc, from, to, slice);\n  if (step) { this.step(step); }\n  return this\n};\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, prosemirrorModel.Slice.empty)\n};\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n};\n\n\n\nfunction fitLeftInner($from, depth, placed, placedBelow) {\n  var content = prosemirrorModel.Fragment.empty, openEnd = 0, placedHere = placed[depth];\n  if ($from.depth > depth) {\n    var inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere);\n    openEnd = inner.openEnd + 1;\n    content = prosemirrorModel.Fragment.from($from.node(depth + 1).copy(inner.content));\n  }\n\n  if (placedHere) {\n    content = content.append(placedHere.content);\n    openEnd = placedHere.openEnd;\n  }\n  if (placedBelow) {\n    content = content.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(prosemirrorModel.Fragment.empty, true));\n    openEnd = 0;\n  }\n\n  return {content: content, openEnd: openEnd}\n}\n\nfunction fitLeft($from, placed) {\n  var ref = fitLeftInner($from, 0, placed, false);\n  var content = ref.content;\n  var openEnd = ref.openEnd;\n  return new prosemirrorModel.Slice(content, $from.depth, openEnd || 0)\n}\n\nfunction fitRightJoin(content, parent, $from, $to, depth, openStart, openEnd) {\n  var match, count = content.childCount, matchCount = count - (openEnd > 0 ? 1 : 0);\n  var parentNode = openStart < 0 ? parent : $from.node(depth);\n  if (openStart < 0)\n    { match = parentNode.contentMatchAt(matchCount); }\n  else if (count == 1 && openEnd > 0)\n    { match = parentNode.contentMatchAt(openStart ? $from.index(depth) : $from.indexAfter(depth)); }\n  else\n    { match = parentNode.contentMatchAt($from.indexAfter(depth))\n      .matchFragment(content, count > 0 && openStart ? 1 : 0, matchCount); }\n\n  var toNode = $to.node(depth);\n  if (openEnd > 0 && depth < $to.depth) {\n    var after = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content.lastChild);\n    var joinable$1 = match.fillBefore(after, true);\n    // Can't insert content if there's a single node stretched across this gap\n    if (joinable$1 && joinable$1.size && openStart > 0 && count == 1) { joinable$1 = null; }\n\n    if (joinable$1) {\n      var inner = fitRightJoin(content.lastChild.content, content.lastChild, $from, $to,\n                               depth + 1, count == 1 ? openStart - 1 : -1, openEnd - 1);\n      if (inner) {\n        var last = content.lastChild.copy(inner);\n        if (joinable$1.size)\n          { return content.cutByIndex(0, count - 1).append(joinable$1).addToEnd(last) }\n        else\n          { return content.replaceChild(count - 1, last) }\n      }\n    }\n  }\n  if (openEnd > 0)\n    { match = match.matchType((count == 1 && openStart > 0 ? $from.node(depth + 1) : content.lastChild).type); }\n\n  // If we're here, the next level can't be joined, so we see what\n  // happens if we leave it open.\n  var toIndex = $to.index(depth);\n  if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) { return null }\n  var joinable = match.fillBefore(toNode.content, true, toIndex);\n  for (var i = toIndex; joinable && i < toNode.content.childCount; i++)\n    { if (!parentNode.type.allowsMarks(toNode.content.child(i).marks)) { joinable = null; } }\n  if (!joinable) { return null }\n\n  if (openEnd > 0) {\n    var closed = fitRightClosed(content.lastChild, openEnd - 1, $from, depth + 1,\n                                count == 1 ? openStart - 1 : -1);\n    content = content.replaceChild(count - 1, closed);\n  }\n  content = content.append(joinable);\n  if ($to.depth > depth)\n    { content = content.addToEnd(fitRightSeparate($to, depth + 1)); }\n  return content\n}\n\nfunction fitRightClosed(node, openEnd, $from, depth, openStart) {\n  var match, content = node.content, count = content.childCount;\n  if (openStart >= 0)\n    { match = $from.node(depth).contentMatchAt($from.indexAfter(depth))\n      .matchFragment(content, openStart > 0 ? 1 : 0, count); }\n  else\n    { match = node.contentMatchAt(count); }\n\n  if (openEnd > 0) {\n    var closed = fitRightClosed(content.lastChild, openEnd - 1, $from, depth + 1,\n                                count == 1 ? openStart - 1 : -1);\n    content = content.replaceChild(count - 1, closed);\n  }\n\n  return node.copy(content.append(match.fillBefore(prosemirrorModel.Fragment.empty, true)))\n}\n\nfunction fitRightSeparate($to, depth) {\n  var node = $to.node(depth);\n  var fill = node.contentMatchAt(0).fillBefore(node.content, true, $to.index(depth));\n  if ($to.depth > depth) { fill = fill.addToEnd(fitRightSeparate($to, depth + 1)); }\n  return node.copy(fill)\n}\n\nfunction normalizeSlice(content, openStart, openEnd) {\n  while (openStart > 0 && openEnd > 0 && content.childCount == 1) {\n    content = content.firstChild.content;\n    openStart--;\n    openEnd--;\n  }\n  return new prosemirrorModel.Slice(content, openStart, openEnd)\n}\n\n// : (ResolvedPos, ResolvedPos, number, Slice) → Slice\nfunction fitRight($from, $to, slice) {\n  var fitted = fitRightJoin(slice.content, $from.node(0), $from, $to, 0, slice.openStart, slice.openEnd);\n  if (!fitted) { return null }\n  return normalizeSlice(fitted, slice.openStart, $to.depth)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\nfunction canMoveText($from, $to, slice) {\n  if (!$to.parent.isTextblock) { return false }\n\n  var parent = slice.openEnd ? nodeRight(slice.content, slice.openEnd)\n      : $from.node($from.depth - (slice.openStart - slice.openEnd));\n  if (!parent.isTextblock) { return false }\n  for (var i = $to.index(); i < $to.parent.childCount; i++)\n    { if (!parent.type.allowsMarks($to.parent.child(i).marks)) { return false } }\n  var match;\n  if (slice.openEnd) {\n    match = parent.contentMatchAt(parent.childCount);\n  } else {\n    match = parent.contentMatchAt(parent.childCount);\n    if (slice.size) { match = match.matchFragment(slice.content, slice.openStart ? 1 : 0); }\n  }\n  match = match.matchFragment($to.parent.content, $to.index());\n  return match && match.validEnd\n}\n\nfunction nodeRight(content, depth) {\n  for (var i = 1; i < depth; i++) { content = content.lastChild.content; }\n  return content.lastChild\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// So placeSlice splits up a slice into a number of sub-slices,\n// along with information on where they can be placed on the given\n// left-side edge. It works by walking the open side of the slice,\n// from the inside out, and trying to find a landing spot for each\n// element, by simultaneously scanning over the gap side. When no\n// place is found for an open node's content, it is left in that node.\n\n// : (ResolvedPos, Slice) → [{content: Fragment, openEnd: number, depth: number}]\nfunction placeSlice($from, slice) {\n  var frontier = new Frontier($from);\n  for (var pass = 1; slice.size && pass <= 3; pass++)\n    { slice = frontier.placeSlice(slice.content, slice.openStart, slice.openEnd, pass); }\n  while (frontier.open.length) { frontier.closeNode(); }\n  return frontier.placed\n}\n\n// Helper class that models the open side of the insert position,\n// keeping track of the content match and already inserted content\n// at each depth.\nvar Frontier = function Frontier($pos) {\n  var this$1 = this;\n\n  // : [{parent: Node, match: ContentMatch, content: Fragment, wrapper: bool, openEnd: number, depth: number}]\n  this.open = [];\n  for (var d = 0; d <= $pos.depth; d++) {\n    var parent = $pos.node(d), match = parent.contentMatchAt($pos.indexAfter(d));\n    this$1.open.push({parent: parent, match: match, content: prosemirrorModel.Fragment.empty, wrapper: false, openEnd: 0, depth: d});\n  }\n  this.placed = [];\n};\n\n// : (Fragment, number, number, number, ?Node) → Slice\n// Tries to place the content of the given slice, and returns a\n// slice containing unplaced content.\n//\n// pass 1: try to fit directly\n// pass 2: allow wrapper nodes to be introduced\n// pass 3: allow unwrapping of nodes that aren't open\nFrontier.prototype.placeSlice = function placeSlice (fragment, openStart, openEnd, pass, parent) {\n    var this$1 = this;\n\n  if (openStart > 0) {\n    var first = fragment.firstChild;\n    var inner = this.placeSlice(first.content, Math.max(0, openStart - 1),\n                                openEnd && fragment.childCount == 1 ? openEnd - 1 : 0,\n                                pass, first);\n    if (inner.content != first.content) {\n      if (inner.content.size) {\n        fragment = fragment.replaceChild(0, first.copy(inner.content));\n        openStart = inner.openStart + 1;\n      } else {\n        if (fragment.childCount == 1) { openEnd = 0; }\n        fragment = fragment.cutByIndex(1);\n        openStart = 0;\n      }\n    }\n  }\n  var result = this.placeContent(fragment, openStart, openEnd, pass, parent);\n  if (pass > 2 && result.size && openStart == 0) {\n    for (var i = 0; i < result.content.childCount; i++) {\n      var child = result.content.child(i);\n      this$1.placeContent(child.content, 0,\n                        openEnd && i == result.content.childCount.length - 1 ? openEnd - 1 : 0,\n                        pass, child);\n    }\n    result = prosemirrorModel.Fragment.empty;\n  }\n  return result\n};\n\nFrontier.prototype.placeContent = function placeContent (fragment, openStart, openEnd, pass, parent) {\n    var this$1 = this;\n\n  var i = 0;\n  // Go over the fragment's children\n  for (; i < fragment.childCount; i++) {\n    var child = fragment.child(i), placed = false, last = i == fragment.childCount - 1;\n    // Try each open node in turn, starting from the innermost\n    for (var d = this.open.length - 1; d >= 0; d--) {\n      var open = this$1.open[d], wrap = (void 0);\n\n      // If pass > 1, it is allowed to wrap the node to help find a\n      // fit, so if findWrappeing returns something, we add open\n      // nodes to the frontier for that wrapping.\n      if (pass > 1 && (wrap = open.match.findWrapping(child.type)) &&\n          !(parent && wrap.length && wrap[wrap.length - 1] == parent.type)) {\n        while (this.open.length - 1 > d) { this$1.closeNode(); }\n        for (var w = 0; w < wrap.length; w++) {\n          open.match = open.match.matchType(wrap[w]);\n          d++;\n          open = {parent: wrap[w].create(),\n                  match: wrap[w].contentMatch,\n                  content: prosemirrorModel.Fragment.empty, wrapper: true, openEnd: 0, depth: d + w};\n          this$1.open.push(open);\n        }\n      }\n\n      // See if the child fits here\n      var match = open.match.matchType(child.type);\n      if (!match) {\n        var fill = open.match.fillBefore(prosemirrorModel.Fragment.from(child));\n        if (fill) {\n          for (var j = 0; j < fill.childCount; j++) {\n            var ch = fill.child(j);\n            this$1.addNode(open, ch, 0);\n            match = open.match.matchFragment(ch);\n          }\n        } else if (parent && open.match.matchType(parent.type)) {\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          break\n        } else {\n          continue\n        }\n      }\n\n      // Close open nodes above this one, since we're starting to\n      // add to this.\n      while (this.open.length - 1 > d) { this$1.closeNode(); }\n      // Strip marks from the child or close its start when necessary\n      child = child.mark(open.parent.type.allowedMarks(child.marks));\n      if (openStart) {\n        child = closeNodeStart(child, openStart, last ? openEnd : 0);\n        openStart = 0;\n      }\n      // Add the child to this open node and adjust its metadata\n      this$1.addNode(open, child, last ? openEnd : 0);\n      open.match = match;\n      if (last) { openEnd = 0; }\n      placed = true;\n      break\n    }\n    // As soon as we've failed to place a node we stop looking at\n    // later nodes\n    if (!placed) { break }\n  }\n  // Close the current open node if it's not the the root and we\n  // either placed up to the end of the node or the the current\n  // slice depth's node type matches the open node's type\n  if (this.open.length > 1 &&\n      (i > 0 && i == fragment.childCount ||\n       parent && this.open[this.open.length - 1].parent.type == parent.type))\n    { this.closeNode(); }\n\n  return new prosemirrorModel.Slice(fragment.cutByIndex(i), openStart, openEnd)\n};\n\nFrontier.prototype.addNode = function addNode (open, node, openEnd) {\n  open.content = closeFragmentEnd(open.content, open.openEnd).addToEnd(node);\n  open.openEnd = openEnd;\n};\n\nFrontier.prototype.closeNode = function closeNode () {\n  var open = this.open.pop();\n  if (open.content.size == 0) {\n    // Nothing here\n  } else if (open.wrapper) {\n    this.addNode(this.open[this.open.length - 1], open.parent.copy(open.content), open.openEnd + 1);\n  } else {\n    this.placed[open.depth] = {depth: open.depth, content: open.content, openEnd: open.openEnd};\n  }\n};\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  var content = node.content;\n  if (openStart > 1) {\n    var first = closeNodeStart(node.firstChild, openStart - 1, node.childCount == 1 ? openEnd - 1 : 0);\n    content = node.content.replaceChild(0, first);\n  }\n  var fill = node.type.contentMatch.fillBefore(content, openEnd == 0);\n  return node.copy(fill.append(content))\n}\n\nfunction closeNodeEnd(node, depth) {\n  var content = node.content;\n  if (depth > 1) {\n    var last = closeNodeEnd(node.lastChild, depth - 1);\n    content = node.content.replaceChild(node.childCount - 1, last);\n  }\n  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);\n  return node.copy(content.append(fill))\n}\n\nfunction closeFragmentEnd(fragment, depth) {\n  return depth ? fragment.replaceChild(fragment.childCount - 1, closeNodeEnd(fragment.lastChild, depth)) : fragment\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  var this$1 = this;\n\n  if (!slice.size) { return this.deleteRange(from, to) }\n\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    { return this.step(new ReplaceStep(from, to, slice)) }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to));\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.isolating) { break }\n    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }\n    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n\n  var leftNodes = [], preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) { break }\n    content = node.content;\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    { preferredDepth -= 1; }\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    { preferredDepth -= 2; }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) { continue }\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }\n      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        { return this$1.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd)) }\n    }\n  }\n\n  return this.replace(from, to, slice)\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen)\n    { fragment = parent.contentMatchAt(0).fillBefore(fragment, true).append(fragment); }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n    if (point != null) { from = to = point; }\n  }\n  return this.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0))\n};\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  var this$1 = this;\n\n  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i], last = i == covered.length - 1;\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      { return this$1.delete($from.start(depth), $to.end(depth)) }\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      { return this$1.delete($from.before(depth), $to.after(depth)) }\n  }\n  for (var d = 1; d <= $from.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d))\n      { return this$1.delete($from.before(d), to) }\n  }\n  return this.delete(from, to)\n};\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  var result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) { break }\n    if (start == $to.start(d)) { result.push(d); }\n  }\n  return result\n}\n\nexports.Transform = Transform;\nexports.TransformError = TransformError;\nexports.Step = Step;\nexports.StepResult = StepResult;\nexports.joinPoint = joinPoint;\nexports.canJoin = canJoin;\nexports.canSplit = canSplit;\nexports.insertPoint = insertPoint;\nexports.dropPoint = dropPoint;\nexports.liftTarget = liftTarget;\nexports.findWrapping = findWrapping;\nexports.StepMap = StepMap;\nexports.MapResult = MapResult;\nexports.Mapping = Mapping;\nexports.AddMarkStep = AddMarkStep;\nexports.RemoveMarkStep = RemoveMarkStep;\nexports.ReplaceStep = ReplaceStep;\nexports.ReplaceAroundStep = ReplaceAroundStep;\nexports.replaceStep = replaceStep;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js":
/*!*******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-transform/dist/index.js\");\n\nvar result = {};\nif (typeof navigator != \"undefined\" && typeof document != \"undefined\") {\n  var ie_edge = /Edge\\/(\\d+)/.exec(navigator.userAgent);\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n\n  result.mac = /Mac/.test(navigator.platform);\n  var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);\n  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;\n  result.gecko = !ie && /gecko\\/(\\d+)/i.test(navigator.userAgent);\n  result.gecko_version = result.gecko && +(/Firefox\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1];\n  var chrome = !ie && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\n  result.chrome = !!chrome;\n  result.chrome_version = chrome && +chrome[1];\n  result.ios = !ie && /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  result.android = /Android \\d/.test(navigator.userAgent);\n  result.webkit = !ie && 'WebkitAppearance' in document.documentElement.style;\n  result.safari = /Apple Computer/.test(navigator.vendor);\n  result.webkit_version = result.webkit && +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1];\n}\n\nvar domIndex = function(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) { return index }\n  }\n};\n\nvar parentNode = function(node) {\n  var parent = node.parentNode;\n  return parent && parent.nodeType == 11 ? parent.host : parent\n};\n\nvar textRange = function(node, from, to) {\n  var range = document.createRange();\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range\n};\n\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nvar isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n                        scanFor(node, off, targetNode, targetOff, 1))\n};\n\nvar atomElements = /^(img|br|input|textarea|hr)$/i;\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) { return true }\n    if (off == (dir < 0 ? 0 : nodeSize(node)) || node.nodeType == 3 && node.nodeValue == \"\\ufeff\") {\n      var parent = node.parentNode;\n      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        { return false }\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      off = dir < 0 ? nodeSize(node) : 0;\n    } else {\n      return false\n    }\n  }\n}\n\nfunction nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction hasBlockDesc(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock\n}\n\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nvar selectionCollapsed = function(domSel) {\n  var collapsed = domSel.isCollapsed;\n  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n    { collapsed = false; }\n  return collapsed\n};\n\nfunction windowRect(win) {\n  return {left: 0, right: win.innerWidth,\n          top: 0, bottom: win.innerHeight}\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side]\n}\n\nfunction scrollRectIntoView(view, rect, startDOM) {\n  var scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n  var doc = view.dom.ownerDocument, win = doc.defaultView;\n  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) { break }\n    if (parent.nodeType != 1) { continue }\n    var atTop = parent == doc.body || parent.nodeType != 1;\n    var bounding = atTop ? windowRect(win) : parent.getBoundingClientRect();\n    var moveX = 0, moveY = 0;\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      { moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\")); }\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\"); }\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      { moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\")); }\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      { moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\"); }\n    if (moveX || moveY) {\n      if (atTop) {\n        win.scrollBy(moveX, moveY);\n      } else {\n        if (moveY) { parent.scrollTop += moveY; }\n        if (moveX) { parent.scrollLeft += moveX; }\n      }\n    }\n    if (atTop) { break }\n  }\n}\n\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n  var doc = view.dom.ownerDocument;\n  var refDOM, refTop;\n  for (var x = (rect.left + rect.right) / 2, y = startY + 1;\n       y < Math.min(innerHeight, rect.bottom); y += 5) {\n    var dom = view.root.elementFromPoint(x, y);\n    if (dom == view.dom || !view.dom.contains(dom)) { continue }\n    var localRect = dom.getBoundingClientRect();\n    if (localRect.top >= startY - 20) {\n      refDOM = dom;\n      refTop = localRect.top;\n      break\n    }\n  }\n  var stack = [];\n  for (var dom$1 = view.dom; dom$1; dom$1 = parentNode(dom$1)) {\n    stack.push({dom: dom$1, top: dom$1.scrollTop, left: dom$1.scrollLeft});\n    if (dom$1 == doc.body) { break }\n  }\n  return {refDOM: refDOM, refTop: refTop, stack: stack}\n}\n\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos(ref) {\n  var refDOM = ref.refDOM;\n  var refTop = ref.refTop;\n  var stack = ref.stack;\n\n  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n  var dTop = newRefTop == 0 ? 0 : newRefTop - refTop;\n  for (var i = 0; i < stack.length; i++) {\n    var ref$1 = stack[i];\n    var dom = ref$1.dom;\n    var top = ref$1.top;\n    var left = ref$1.left;\n    if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }\n    if (dom.scrollLeft != left) { dom.scrollLeft = left; }\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  var closest, dxClosest = 2e8, coordsClosest, offset = 0;\n  var rowBot = coords.top, rowTop = coords.top;\n  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    var rects = (void 0);\n    if (child.nodeType == 1) { rects = child.getClientRects(); }\n    else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }\n    else { continue }\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot);\n        rowTop = Math.min(rect.top, rowTop);\n        var dx = rect.left > coords.left ? rect.left - coords.left\n            : rect.right < coords.left ? coords.left - rect.right : 0;\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;\n          if (child.nodeType == 1 && dx)\n            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }\n          continue\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                       coords.left >= rect.left && coords.top >= rect.bottom))\n        { offset = childIndex + 1; }\n    }\n  }\n  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }\n  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }\n  return findOffsetInNode(closest, coordsClosest)\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length;\n  var range = document.createRange();\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    var rect = singleRect(range, 1);\n    if (rect.top == rect.bottom) { continue }\n    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left &&\n        rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top)\n      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }\n  }\n  return {node: node, offset: 0}\n}\n\nfunction targetKludge(dom, coords) {\n  var parent = dom.parentNode;\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    { return parent }\n  return dom\n}\n\nfunction posFromElement(view, elt, coords) {\n  if (!view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) { return null }\n\n  var ref = findOffsetInNode(elt, coords);\n  var node = ref.node;\n  var offset = ref.offset;\n  var bias = -1;\n  if (node.nodeType == 1 && !node.firstChild) {\n    var rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n  return view.docView.posFromDOM(node, offset, bias)\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  // Browser (in caretPosition/RangeFromPoint) will agressively\n  // normalize towards nearby inline nodes. Since we are interested in\n  // positions between block nodes too, we first walk up the hierarchy\n  // of nodes to see if there are block nodes that the coordinates\n  // fall outside of. If so, we take the position before/after that\n  // block. If not, we call `posFromDOM` on the raw node/offset.\n  var outside = -1;\n  for (var cur = node;;) {\n    if (cur == view.dom) { break }\n    var desc = view.docView.nearestDesc(cur, true);\n    if (!desc) { return null }\n    if (desc.node.isBlock && desc.parent) {\n      var rect = desc.dom.getBoundingClientRect();\n      if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }\n      else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }\n      else { break }\n    }\n    cur = desc.dom.parentNode;\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)\n}\n\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n  var root = view.root, node, offset;\n  if (root.caretPositionFromPoint) {\n    var pos$1 = root.caretPositionFromPoint(coords.left, coords.top);\n    if (pos$1) { var assign;\n      ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }\n  }\n  if (!node && root.caretRangeFromPoint) {\n    var range = root.caretRangeFromPoint(coords.left, coords.top);\n    if (range) { var assign$1;\n      ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }\n  }\n\n  var elt = root.elementFromPoint(coords.left, coords.top + 1), pos;\n  if (!elt) { return null }\n  elt = targetKludge(elt, coords);\n  if (node) {\n    // Suspiciously specific kludge to work around caret*FromPoint\n    // never returning a position at the end of the document\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n        coords.top > node.lastChild.getBoundingClientRect().bottom)\n      { pos = view.state.doc.content.size; }\n    // Ignore positions directly after a BR, since caret*FromPoint\n    // 'round up' positions that would be more accurately places\n    // before the BR node.\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      { pos = posFromCaret(view, node, offset, coords); }\n  }\n  if (pos == null) {\n    pos = posFromElement(view, elt, coords);\n    if (pos == null) { return null }\n  }\n\n  var desc = view.docView.nearestDesc(elt, true);\n  return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}\n}\n\nfunction singleRect(object, bias) {\n  var rects = object.getClientRects();\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]\n}\n\n// : (EditorView, number) → {left: number, top: number, right: number, bottom: number}\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos) {\n  var ref = view.docView.domFromPos(pos);\n  var node = ref.node;\n  var offset = ref.offset;\n  var side, rect;\n  if (node.nodeType == 3) {\n    if (offset < node.nodeValue.length) {\n      rect = singleRect(textRange(node, offset, offset + 1), -1);\n      side = \"left\";\n    }\n    if ((!rect || rect.left == rect.right) && offset) {\n      rect = singleRect(textRange(node, offset - 1, offset), 1);\n      side = \"right\";\n    }\n  } else if (node.firstChild) {\n    if (offset < node.childNodes.length) {\n      var child = node.childNodes[offset];\n      rect = singleRect(child.nodeType == 3 ? textRange(child) : child, -1);\n      side = \"left\";\n    }\n    if ((!rect || rect.top == rect.bottom) && offset) {\n      var child$1 = node.childNodes[offset - 1];\n      rect = singleRect(child$1.nodeType == 3 ? textRange(child$1) : child$1, 1);\n      side = \"right\";\n    }\n  } else {\n    rect = node.getBoundingClientRect();\n    side = \"left\";\n  }\n  var x = rect[side];\n  return {top: rect.top, bottom: rect.bottom, left: x, right: x}\n}\n\nfunction withFlushedState(view, state, f) {\n  var viewState = view.state, active = view.root.activeElement;\n  if (viewState != state || !view.inDOMChange) { view.updateState(state); }\n  if (active != view.dom) { view.focus(); }\n  try {\n    return f()\n  } finally {\n    if (viewState != state) { view.updateState(viewState); }\n    if (active != view.dom) { active.focus(); }\n  }\n}\n\n// : (EditorView, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n  var sel = state.selection;\n  var $pos = dir == \"up\" ? sel.$anchor.min(sel.$head) : sel.$anchor.max(sel.$head);\n  if (!$pos.depth) { return false }\n  return withFlushedState(view, state, function () {\n    var ref = view.docView.domFromPos($pos.pos);\n    var dom = ref.node;\n    for (;;) {\n      var nearest = view.docView.nearestDesc(dom, true);\n      if (!nearest || nearest.node.isBlock) { break }\n      dom = nearest.dom.parentNode;\n    }\n    var coords = coordsAtPos(view, $pos.pos);\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      var boxes = (void 0);\n      if (child.nodeType == 1) { boxes = child.getClientRects(); }\n      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }\n      else { continue }\n      for (var i = 0; i < boxes.length; i++) {\n        var box = boxes[i];\n        if (box.bottom > box.top && (dir == \"up\" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))\n          { return false }\n      }\n    }\n    return true\n  })\n}\n\nvar maybeRTL = /[\\u0590-\\u08ac]/;\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  if (!$head.parent.isTextblock || !$head.depth) { return false }\n  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n  var sel = getSelection();\n  // If the textblock is all LTR, or the browser doesn't support\n  // Selection.modify (Edge), fall back to a primitive approach\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    { return dir == \"left\" || dir == \"backward\" ? atStart : atEnd }\n\n  return withFlushedState(view, state, function () {\n    // This is a huge hack, but appears to be the best we can\n    // currently do: use `Selection.modify` to move the selection by\n    // one character, and see if that moves the cursor out of the\n    // textblock (or doesn't move it at all, when at the start/end of\n    // the document).\n    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;\n    sel.modify(\"move\", dir, \"character\");\n    var parentDOM = view.docView.domAfterPos($head.before());\n    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||\n        (oldNode == sel.focusNode && oldOff == sel.focusOffset);\n    // Restore the previous selection\n    sel.removeAllRanges();\n    sel.addRange(oldRange);\n    return result\n  })\n}\n\nvar cachedState = null;\nvar cachedDir = null;\nvar cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) { return cachedResult }\n  cachedState = state; cachedDir = dir;\n  return cachedResult = dir == \"up\" || dir == \"down\"\n    ? endOfTextblockVertical(view, state, dir)\n    : endOfTextblockHorizontal(view, state, dir)\n}\n\n// NodeView:: interface\n//\n// By default, document nodes are rendered using the result of the\n// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed\n// entirely by the editor. For some use cases, such as embedded\n// node-specific editing interfaces, you want more control over\n// the behavior of a node's in-editor representation, and need to\n// [define](#view.EditorProps.nodeViews) a custom node view.\n//\n// Objects returned as node views must conform to this interface.\n//\n//   dom:: ?dom.Node\n//   The outer DOM node that represents the document node. When not\n//   given, the default strategy is used to create a DOM node.\n//\n//   contentDOM:: ?dom.Node\n//   The DOM node that should hold the node's content. Only meaningful\n//   if the node view also defines a `dom` property and if its node\n//   type is not a leaf node type. When this is present, ProseMirror\n//   will take care of rendering the node's children into it. When it\n//   is not present, the node view itself is responsible for rendering\n//   (or deciding not to render) its child nodes.\n//\n//   update:: ?(node: Node, decorations: [Decoration]) → bool\n//   When given, this will be called when the view is updating itself.\n//   It will be given a node (possibly of a different type), and an\n//   array of active decorations (which are automatically drawn, and\n//   the node view may ignore if it isn't interested in them), and\n//   should return true if it was able to update to that node, and\n//   false otherwise. If the node view has a `contentDOM` property (or\n//   no `dom` property), updating its child nodes will be handled by\n//   ProseMirror.\n//\n//   selectNode:: ?()\n//   Can be used to override the way the node's selected status (as a\n//   node selection) is displayed.\n//\n//   deselectNode:: ?()\n//   When defining a `selectNode` method, you should also provide a\n//   `deselectNode` method to remove the effect again.\n//\n//   setSelection:: ?(anchor: number, head: number, root: dom.Document)\n//   This will be called to handle setting the selection inside the\n//   node. The `anchor` and `head` positions are relative to the start\n//   of the node. By default, a DOM selection will be created between\n//   the DOM positions corresponding to those positions, but if you\n//   override it you can do something else.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to prevent the editor view from trying to handle some\n//   or all DOM events that bubble up from the node view. Events for\n//   which this returns true are not handled by the editor.\n//\n//   ignoreMutation:: ?(dom.MutationRecord) → bool\n//   Called when a DOM\n//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n//   happens within the view. Return false if the editor should\n//   re-parse the range around the mutation, true if it can safely be\n//   ignored.\n//\n//   destroy:: ?()\n//   Called when the node view is removed from the editor or the whole\n//   editor is destroyed.\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\n\nvar NOT_DIRTY = 0;\nvar CHILD_DIRTY = 1;\nvar CONTENT_DIRTY = 2;\nvar NODE_DIRTY = 3;\n\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nvar ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {\n  this.parent = parent;\n  this.children = children;\n  this.dom = dom;\n  // An expando property on the DOM node provides a link back to its\n  // description.\n  dom.pmViewDesc = this;\n  // This is the node that holds the child views. It may be null for\n  // descs that don't have children.\n  this.contentDOM = contentDOM;\n  this.dirty = NOT_DIRTY;\n};\n\nvar prototypeAccessors$1 = { beforePosition: {},size: {},border: {},posBefore: {},posAtStart: {},posAfter: {},posAtEnd: {},contentLost: {} };\n\n// Used to check whether a given description corresponds to a\n// widget/mark/node.\nViewDesc.prototype.matchesWidget = function matchesWidget () { return false };\nViewDesc.prototype.matchesMark = function matchesMark () { return false };\nViewDesc.prototype.matchesNode = function matchesNode () { return false };\nViewDesc.prototype.matchesHack = function matchesHack () { return false };\n\nprototypeAccessors$1.beforePosition.get = function () { return false };\n\n// : () → ?ParseRule\n// When parsing in-editor content (in domchange.js), we allow\n// descriptions to determine the parse rules that should be used to\n// parse them.\nViewDesc.prototype.parseRule = function parseRule () { return null };\n\n// : (dom.Event) → bool\n// Used by the editor's event handler to ignore events that come\n// from certain descs.\nViewDesc.prototype.stopEvent = function stopEvent () { return false };\n\n// The size of the content represented by this desc.\nprototypeAccessors$1.size.get = function () {\n    var this$1 = this;\n\n  var size = 0;\n  for (var i = 0; i < this.children.length; i++) { size += this$1.children[i].size; }\n  return size\n};\n\n// For block nodes, this represents the space taken up by their\n// start/end tokens.\nprototypeAccessors$1.border.get = function () { return 0 };\n\nViewDesc.prototype.destroy = function destroy () {\n    var this$1 = this;\n\n  this.parent = null;\n  if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }\n  for (var i = 0; i < this.children.length; i++)\n    { this$1.children[i].destroy(); }\n};\n\nViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {\n    var this$1 = this;\n\n  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {\n    var cur = this$1.children[i];\n    if (cur == child) { return pos }\n    pos += cur.size;\n  }\n};\n\nprototypeAccessors$1.posBefore.get = function () {\n  return this.parent.posBeforeChild(this)\n};\n\nprototypeAccessors$1.posAtStart.get = function () {\n  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0\n};\n\nprototypeAccessors$1.posAfter.get = function () {\n  return this.posBefore + this.size\n};\n\nprototypeAccessors$1.posAtEnd.get = function () {\n  return this.posAtStart + this.size - 2 * this.border\n};\n\n// : (dom.Node, number, ?number) → number\nViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {\n    var this$1 = this;\n\n  // If the DOM position is in the content, use the child desc after\n  // it to figure out a position.\n  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n    if (bias < 0) {\n      var domBefore, desc;\n      if (dom == this.contentDOM) {\n        domBefore = dom.childNodes[offset - 1];\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }\n        domBefore = dom.previousSibling;\n      }\n      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }\n      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart\n    } else {\n      var domAfter, desc$1;\n      if (dom == this.contentDOM) {\n        domAfter = dom.childNodes[offset];\n      } else {\n        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }\n        domAfter = dom.nextSibling;\n      }\n      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }\n      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd\n    }\n  }\n  // Otherwise, use various heuristics, falling back on the bias\n  // parameter, to determine whether to return the position at the\n  // start or at the end of this view desc.\n  var atEnd;\n  if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n  } else if (this.dom.firstChild) {\n    if (offset == 0) { for (var search = dom;; search = search.parentNode) {\n      if (search == this$1.dom) { atEnd = false; break }\n      if (search.parentNode.firstChild != search) { break }\n    } }\n    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {\n      if (search$1 == this$1.dom) { atEnd = true; break }\n      if (search$1.parentNode.lastChild != search$1) { break }\n    } }\n  }\n  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart\n};\n\n// Scan up the dom finding the first desc that is a descendant of\n// this one.\nViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {\n    var this$1 = this;\n\n  for (var first = true, cur = dom; cur; cur = cur.parentNode) {\n    var desc = this$1.getDesc(cur);\n    if (desc && (!onlyNodes || desc.node)) {\n      // If dom is outside of this desc's nodeDOM, don't count it.\n      if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom) : desc.nodeDOM == dom)) { first = false; }\n      else { return desc }\n    }\n  }\n};\n\nViewDesc.prototype.getDesc = function getDesc (dom) {\n    var this$1 = this;\n\n  var desc = dom.pmViewDesc;\n  for (var cur = desc; cur; cur = cur.parent) { if (cur == this$1) { return desc } }\n};\n\nViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {\n    var this$1 = this;\n\n  for (var scan = dom;; scan = scan.parentNode) {\n    var desc = this$1.getDesc(scan);\n    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }\n  }\n};\n\n// : (number) → ?NodeViewDesc\n// Find the desc for the node after the given pos, if any. (When a\n// parent node overrode rendering, there might not be one.)\nViewDesc.prototype.descAt = function descAt (pos) {\n    var this$1 = this;\n\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this$1.children[i], end = offset + child.size;\n    if (offset == pos && end != offset) {\n      while (!child.border && child.children.length) { child = child.children[0]; }\n      return child\n    }\n    if (pos < end) { return child.descAt(pos - offset - child.border) }\n    offset = end;\n  }\n};\n\n// : (number) → {node: dom.Node, offset: number}\nViewDesc.prototype.domFromPos = function domFromPos (pos) {\n    var this$1 = this;\n\n  if (!this.contentDOM) { return {node: this.dom, offset: 0} }\n  for (var offset = 0, i = 0;; i++) {\n    if (offset == pos) {\n      while (i < this.children.length && this.children[i].beforePosition) { i++; }\n      return {node: this$1.contentDOM, offset: i}\n    }\n    if (i == this$1.children.length) { throw new Error(\"Invalid position \" + pos) }\n    var child = this$1.children[i], end = offset + child.size;\n    if (pos < end) { return child.domFromPos(pos - offset - child.border) }\n    offset = end;\n  }\n};\n\n// Used to find a DOM range in a single parent for a given changed\n// range.\nViewDesc.prototype.parseRange = function parseRange (from, to, base) {\n    var this$1 = this;\n    if ( base === void 0 ) base = 0;\n\n  if (this.children.length == 0)\n    { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }\n\n  var fromOffset = -1, toOffset = -1;\n  for (var offset = 0, i = 0;; i++) {\n    var child = this$1.children[i], end = offset + child.size;\n    if (fromOffset == -1 && from <= end) {\n      var childBase = offset + child.border;\n      // FIXME maybe descend mark views to parse a narrower range?\n      if (from >= childBase && to <= end - child.border && child.node &&\n          child.contentDOM && this$1.contentDOM.contains(child.contentDOM))\n        { return child.parseRange(from - childBase, to - childBase, base + childBase) }\n\n      from = base + offset;\n      for (var j = i; j > 0; j--) {\n        var prev = this$1.children[j - 1];\n        if (prev.size && prev.dom.parentNode == this$1.contentDOM && !prev.emptyChildAt(1)) {\n          fromOffset = domIndex(prev.dom) + 1;\n          break\n        }\n        from -= prev.size;\n      }\n      if (fromOffset == -1) { fromOffset = 0; }\n    }\n    if (fromOffset > -1 && to <= end) {\n      to = base + end;\n      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {\n        var next = this$1.children[j$1];\n        if (next.size && next.dom.parentNode == this$1.contentDOM && !next.emptyChildAt(-1)) {\n          toOffset = domIndex(next.dom);\n          break\n        }\n        to += next.size;\n      }\n      if (toOffset == -1) { toOffset = this$1.contentDOM.childNodes.length; }\n      break\n    }\n    offset = end;\n  }\n  return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}\n};\n\nViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {\n  if (this.border || !this.contentDOM || !this.children.length) { return false }\n  var child = this.children[side < 0 ? 0 : this.children.length - 1];\n  return child.size == 0 || child.emptyChildAt(side)\n};\n\n// : (number) → dom.Node\nViewDesc.prototype.domAfterPos = function domAfterPos (pos) {\n  var ref = this.domFromPos(pos);\n    var node = ref.node;\n    var offset = ref.offset;\n  if (node.nodeType != 1 || offset == node.childNodes.length)\n    { throw new RangeError(\"No node after pos \" + pos) }\n  return node.childNodes[offset]\n};\n\n// : (number, number, dom.Document)\n// View descs are responsible for setting any selection that falls\n// entirely inside of them, so that custom implementations can do\n// custom things with the selection. Note that this falls apart when\n// a selection starts in such a node and ends in another, in which\n// case we just use whatever domFromPos produces as a best effort.\nViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {\n    var this$1 = this;\n\n  // If the selection falls entirely in a child, give it to that child\n  var from = Math.min(anchor, head), to = Math.max(anchor, head);\n  for (var i = 0, offset = 0; i < this.children.length; i++) {\n    var child = this$1.children[i], end = offset + child.size;\n    if (from > offset && to < end)\n      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }\n    offset = end;\n  }\n\n  var anchorDOM = this.domFromPos(anchor), headDOM = this.domFromPos(head);\n  var domSel = root.getSelection(), range = document.createRange();\n  if (!force &&\n      isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n      isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n    { return }\n\n  // Selection.extend can be used to create an 'inverted' selection\n  // (one where the focus is before the anchor), but not all\n  // browsers support it yet.\n  if (domSel.extend) {\n    range.setEnd(anchorDOM.node, anchorDOM.offset);\n    range.collapse(false);\n  } else {\n    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }\n    range.setEnd(headDOM.node, headDOM.offset);\n    range.setStart(anchorDOM.node, anchorDOM.offset);\n  }\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n  if (domSel.extend)\n    { domSel.extend(headDOM.node, headDOM.offset); }\n};\n\n// : (dom.MutationRecord) → bool\nViewDesc.prototype.ignoreMutation = function ignoreMutation (_mutation) {\n  return !this.contentDOM\n};\n\nprototypeAccessors$1.contentLost.get = function () {\n  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)\n};\n\n// Remove a subtree of the element tree that has been touched\n// by a DOM change, so that the next update will redraw it.\nViewDesc.prototype.markDirty = function markDirty (from, to) {\n    var this$1 = this;\n\n  for (var offset = 0, i = 0; i < this.children.length; i++) {\n    var child = this$1.children[i], end = offset + child.size;\n    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n      var startInside = offset + child.border, endInside = end - child.border;\n      if (from >= startInside && to <= endInside) {\n        this$1.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n        if (from == startInside && to == endInside && child.contentLost) { child.dirty = NODE_DIRTY; }\n        else { child.markDirty(from - startInside, to - startInside); }\n        return\n      } else {\n        child.dirty = NODE_DIRTY;\n      }\n    }\n    offset = end;\n  }\n  this.dirty = CONTENT_DIRTY;\n};\n\nObject.defineProperties( ViewDesc.prototype, prototypeAccessors$1 );\n\n// Reused array to avoid allocating fresh arrays for things that will\n// stay empty anyway.\nvar nothing = [];\n\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nvar WidgetViewDesc = (function (ViewDesc) {\n  function WidgetViewDesc(parent, widget, view, pos) {\n    var self, dom = widget.type.toDOM;\n    if (typeof dom == \"function\") { dom = dom(view, function () {\n      if (!self) { return pos }\n      if (self.parent) { return self.parent.posBeforeChild(self) }\n    }); }\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        var wrap = document.createElement(\"span\");\n        wrap.appendChild(dom);\n        dom = wrap;\n      }\n      dom.contentEditable = false;\n      dom.classList.add(\"ProseMirror-widget\");\n    }\n    ViewDesc.call(this, parent, nothing, dom, null);\n    this.widget = widget;\n    self = this;\n  }\n\n  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;\n  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  WidgetViewDesc.prototype.constructor = WidgetViewDesc;\n\n  var prototypeAccessors$1 = { beforePosition: {} };\n\n  prototypeAccessors$1.beforePosition.get = function () {\n    return this.widget.type.side < 0\n  };\n\n  WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)\n  };\n\n  WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };\n\n  WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {\n    var stop = this.widget.spec.stopEvent;\n    return stop ? stop(event) : false\n  };\n\n  Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );\n\n  return WidgetViewDesc;\n}(ViewDesc));\n\n// A cursor wrapper is used to put the cursor in when newly typed text\n// needs to be styled differently from its surrounding text (for\n// example through storedMarks), so that the style of the text doesn't\n// visually 'pop' between typing it and actually updating the view.\nvar CursorWrapperDesc = (function (WidgetViewDesc) {\n  function CursorWrapperDesc () {\n    WidgetViewDesc.apply(this, arguments);\n  }\n\n  if ( WidgetViewDesc ) CursorWrapperDesc.__proto__ = WidgetViewDesc;\n  CursorWrapperDesc.prototype = Object.create( WidgetViewDesc && WidgetViewDesc.prototype );\n  CursorWrapperDesc.prototype.constructor = CursorWrapperDesc;\n\n  CursorWrapperDesc.prototype.parseRule = function parseRule () {\n    var content;\n    for (var child = this.dom.firstChild; child; child = child.nextSibling) {\n      var add = (void 0);\n      if (child.nodeType == 3) {\n        var text = child.nodeValue.replace(/\\ufeff/g, \"\");\n        if (!text) { continue }\n        add = document.createTextNode(text);\n      } else if (child.textContent == \"\\ufeff\") {\n        continue\n      } else {\n        add = child.cloneNode(true);\n      }\n      if (!content) { content = document.createDocumentFragment(); }\n      content.appendChild(add);\n    }\n    if (content) { return {skip: content} }\n    else { return WidgetViewDesc.prototype.parseRule.call(this) }\n  };\n\n  CursorWrapperDesc.prototype.ignoreMutation = function ignoreMutation () { return false };\n\n  return CursorWrapperDesc;\n}(WidgetViewDesc));\n\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nvar MarkViewDesc = (function (ViewDesc) {\n  function MarkViewDesc(parent, mark, dom, contentDOM) {\n    ViewDesc.call(this, parent, [], dom, contentDOM);\n    this.mark = mark;\n  }\n\n  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;\n  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  MarkViewDesc.prototype.constructor = MarkViewDesc;\n\n  MarkViewDesc.create = function create (parent, mark, inline, view) {\n    var custom = view.nodeViews[mark.type.name];\n    var spec = custom && custom(mark, view, inline);\n    if (!spec || !spec.dom)\n      { spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)\n  };\n\n  MarkViewDesc.prototype.parseRule = function parseRule () { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} };\n\n  MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };\n\n  MarkViewDesc.prototype.markDirty = function markDirty (from, to) {\n    ViewDesc.prototype.markDirty.call(this, from, to);\n    // Move dirty info to nearest node view\n    if (this.dirty != NOT_DIRTY) {\n      var parent = this.parent;\n      while (!parent.node) { parent = parent.parent; }\n      if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }\n      this.dirty = NOT_DIRTY;\n    }\n  };\n\n  return MarkViewDesc;\n}(ViewDesc));\n\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nvar NodeViewDesc = (function (ViewDesc) {\n  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);\n    this.nodeDOM = nodeDOM;\n    this.node = node;\n    this.outerDeco = outerDeco;\n    this.innerDeco = innerDeco;\n    if (contentDOM) { this.updateChildren(view, pos); }\n  }\n\n  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;\n  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  NodeViewDesc.prototype.constructor = NodeViewDesc;\n\n  var prototypeAccessors$2 = { size: {},border: {} };\n\n  // By default, a node is rendered using the `toDOM` method from the\n  // node type spec. But client code can use the `nodeViews` spec to\n  // supply a custom node view, which can influence various aspects of\n  // the way the node works.\n  //\n  // (Using subclassing for this was intentionally decided against,\n  // since it'd require exposing a whole slew of finnicky\n  // implementation details to the user code that they probably will\n  // never need.)\n  NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {\n    var custom = view.nodeViews[node.type.name], descObj;\n    var spec = custom && custom(node, view, function () {\n      // (This is a function that allows the custom view to find its\n      // own position)\n      if (!descObj) { return pos }\n      if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }\n    }, outerDeco);\n\n    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n    if (node.isText) {\n      if (!dom) { dom = document.createTextNode(node.text); }\n      else if (dom.nodeType != 3) { throw new RangeError(\"Text must be rendered as a DOM text node\") }\n    } else if (!dom) {\n      var assign;\n      ((assign = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n      dom.contentEditable = false;\n      if (node.type.spec.draggable) { dom.draggable = true; }\n    }\n\n    var nodeDOM = dom;\n    dom = applyOuterDeco(dom, outerDeco, node);\n\n    if (spec)\n      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view) }\n    else if (node.isText)\n      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }\n    else\n      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }\n  };\n\n  NodeViewDesc.prototype.parseRule = function parseRule () {\n    var this$1 = this;\n\n    // Experimental kludge to allow opt-in re-parsing of nodes\n    if (this.node.type.spec.reparseInView) { return null }\n    // FIXME the assumption that this can always return the current\n    // attrs means that if the user somehow manages to change the\n    // attrs in the dom, that won't be picked up. Not entirely sure\n    // whether this is a problem\n    var rule = {node: this.node.type.name, attrs: this.node.attrs};\n    if (this.node.type.spec.code) { rule.preserveWhitespace = \"full\"; }\n    if (this.contentDOM && !this.contentLost) { rule.contentElement = this.contentDOM; }\n    else { rule.getContent = function () { return this$1.contentDOM ? prosemirrorModel.Fragment.empty : this$1.node.content; }; }\n    return rule\n  };\n\n  NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)\n  };\n\n  prototypeAccessors$2.size.get = function () { return this.node.nodeSize };\n\n  prototypeAccessors$2.border.get = function () { return this.node.isLeaf ? 0 : 1 };\n\n  // Syncs `this.children` to match `this.node.content` and the local\n  // decorations, possibly introducing nesting for marks. Then, in a\n  // separate step, syncs the DOM inside `this.contentDOM` to\n  // `this.children`.\n  NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {\n    var this$1 = this;\n\n    var updater = new ViewTreeUpdater(this), inline = this.node.inlineContent;\n    iterDeco(this.node, this.innerDeco, function (widget, i) {\n      if (widget.spec.marks)\n        { updater.syncToMarks(widget.spec.marks, inline, view); }\n      else if (widget.type.side >= 0)\n        { updater.syncToMarks(i == this$1.node.childCount ? prosemirrorModel.Mark.none : this$1.node.child(i).marks, inline, view); }\n      // If the next node is a desc matching this widget, reuse it,\n      // otherwise insert the widget as a new view desc.\n      updater.placeWidget(widget, view, pos);\n    }, function (child, outerDeco, innerDeco, i) {\n      // Make sure the wrapping mark descs match the node's marks.\n      updater.syncToMarks(child.marks, inline, view);\n      // Either find an existing desc that exactly matches this node,\n      // and drop the descs before it.\n      updater.findNodeMatch(child, outerDeco, innerDeco, i) ||\n        // Or try updating the next desc to reflect this node.\n        updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||\n        // Or just add it as a new desc.\n        updater.addNode(child, outerDeco, innerDeco, view, pos);\n      pos += child.nodeSize;\n    });\n    // Drop all remaining descs after the current position.\n    updater.syncToMarks(nothing, inline, view);\n    if (this.node.isTextblock) { updater.addTextblockHacks(); }\n    updater.destroyRest();\n\n    // Sync the DOM if anything changed\n    if (updater.changed || this.dirty == CONTENT_DIRTY) { this.renderChildren(); }\n  };\n\n  NodeViewDesc.prototype.renderChildren = function renderChildren () {\n    renderDescs(this.contentDOM, this.children, NodeViewDesc.is);\n    if (result.ios) { iosHacks(this.dom); }\n  };\n\n  // : (Node, [Decoration], DecorationSet, EditorView) → bool\n  // If this desc be updated to match the given node decoration,\n  // do so and return true.\n  NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateInner(node, outerDeco, innerDeco, view);\n    return true\n  };\n\n  NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco);\n    this.node = node;\n    this.innerDeco = innerDeco;\n    if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }\n    this.dirty = NOT_DIRTY;\n  };\n\n  NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }\n    var needsWrap = this.nodeDOM.nodeType != 1;\n    var oldDOM = this.dom;\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM,\n                              computeOuterDeco(this.outerDeco, this.node, needsWrap),\n                              computeOuterDeco(outerDeco, this.node, needsWrap));\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = null;\n      this.dom.pmViewDesc = this;\n    }\n    this.outerDeco = outerDeco;\n  };\n\n  // Mark this node as being the selected node.\n  NodeViewDesc.prototype.selectNode = function selectNode () {\n    this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n  };\n\n  // Remove selected node marking from this node.\n  NodeViewDesc.prototype.deselectNode = function deselectNode () {\n    this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n  };\n\n  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$2 );\n\n  return NodeViewDesc;\n}(ViewDesc));\n\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc);\n  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)\n}\n\nvar TextViewDesc = (function (NodeViewDesc) {\n  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);\n  }\n\n  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;\n  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  TextViewDesc.prototype.constructor = TextViewDesc;\n\n  TextViewDesc.prototype.parseRule = function parseRule () {\n    var parent = this.nodeDOM.parentNode;\n    return parent ? {skip: parent} : {ignore: true}\n  };\n\n  TextViewDesc.prototype.update = function update (node, outerDeco) {\n    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n        !node.sameMarkup(this.node)) { return false }\n    this.updateOuterDeco(outerDeco);\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue)\n      { this.nodeDOM.nodeValue = node.text; }\n    this.node = node;\n    this.dirty = NOT_DIRTY;\n    return true\n  };\n\n  TextViewDesc.prototype.inParent = function inParent () {\n    var parentDOM = this.parent.contentDOM;\n    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }\n    return false\n  };\n\n  TextViewDesc.prototype.domFromPos = function domFromPos (pos) {\n    return {node: this.nodeDOM, offset: pos}\n  };\n\n  TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {\n    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }\n    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)\n  };\n\n  TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return mutation.type != \"characterData\"\n  };\n\n  return TextViewDesc;\n}(NodeViewDesc));\n\n// A dummy desc used to tag trailing BR or span nodes created to work\n// around contentEditable terribleness.\nvar BRHackViewDesc = (function (ViewDesc) {\n  function BRHackViewDesc () {\n    ViewDesc.apply(this, arguments);\n  }\n\n  if ( ViewDesc ) BRHackViewDesc.__proto__ = ViewDesc;\n  BRHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );\n  BRHackViewDesc.prototype.constructor = BRHackViewDesc;\n\n  BRHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };\n  BRHackViewDesc.prototype.matchesHack = function matchesHack () { return this.dirty == NOT_DIRTY };\n\n  return BRHackViewDesc;\n}(ViewDesc));\n\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nvar CustomNodeViewDesc = (function (NodeViewDesc) {\n  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view) {\n    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view);\n    this.spec = spec;\n  }\n\n  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;\n  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );\n  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;\n\n  // A custom `update` method gets to decide whether the update goes\n  // through. If it does, and there's a `contentDOM` node, our logic\n  // updates the children.\n  CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY) { return false }\n    if (this.spec.update) {\n      var result$$1 = this.spec.update(node, outerDeco);\n      if (result$$1) { this.updateInner(node, outerDeco, innerDeco, view); }\n      return result$$1\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false\n    } else {\n      return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)\n    }\n  };\n\n  CustomNodeViewDesc.prototype.selectNode = function selectNode () {\n    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {\n    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n      : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);\n  };\n\n  CustomNodeViewDesc.prototype.destroy = function destroy () {\n    if (this.spec.destroy) { this.spec.destroy(); }\n    NodeViewDesc.prototype.destroy.call(this);\n  };\n\n  CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false\n  };\n\n  CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)\n  };\n\n  return CustomNodeViewDesc;\n}(NodeViewDesc));\n\n// : (dom.Node, [ViewDesc])\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs) {\n  var dom = parentDOM.firstChild;\n  for (var i = 0; i < descs.length; i++) {\n    var desc = descs[i], childDOM = desc.dom;\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) { dom = rm(dom); }\n      dom = dom.nextSibling;\n    } else {\n      parentDOM.insertBefore(childDOM, dom);\n    }\n    if (desc instanceof MarkViewDesc) {\n      var pos = dom ? dom.previousSibling : parentDOM.lastChild;\n      renderDescs(desc.contentDOM, desc.children);\n      dom = pos ? pos.nextSibling : parentDOM.firstChild;\n    }\n  }\n  while (dom) { dom = rm(dom); }\n}\n\nfunction OuterDecoLevel(nodeName) {\n  if (nodeName) { this.nodeName = nodeName; }\n}\nOuterDecoLevel.prototype = Object.create(null);\n\nvar noDeco = [new OuterDecoLevel];\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) { return noDeco }\n\n  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result$$1 = [top];\n\n  for (var i = 0; i < outerDeco.length; i++) {\n    var attrs = outerDeco[i].type.attrs, cur = top;\n    if (!attrs) { continue }\n    if (attrs.nodeName)\n      { result$$1.push(cur = new OuterDecoLevel(attrs.nodeName)); }\n\n    for (var name in attrs) {\n      var val = attrs[name];\n      if (val == null) { continue }\n      if (needsWrap && result$$1.length == 1)\n        { result$$1.push(cur = top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\")); }\n      if (name == \"class\") { cur.class = (cur.class ? cur.class + \" \" : \"\") + val; }\n      else if (name == \"style\") { cur.style = (cur.style ? cur.style + \";\" : \"\") + val; }\n      else if (name != \"nodeName\") { cur[name] = val; }\n    }\n  }\n\n  return result$$1\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  // Shortcut for trivial case\n  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }\n\n  var curDOM = nodeDOM;\n  for (var i = 0; i < curComputed.length; i++) {\n    var deco = curComputed[i], prev = prevComputed[i];\n    if (i) {\n      var parent = (void 0);\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n          (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {\n        curDOM = parent;\n      } else {\n        parent = document.createElement(deco.nodeName);\n        parent.appendChild(curDOM);\n        curDOM = parent;\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco);\n  }\n  return curDOM\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (var name in prev)\n    { if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      { dom.removeAttribute(name); } }\n  for (var name$1 in cur)\n    { if (name$1 != \"class\" && name$1 != \"style\" && name$1 != \"nodeName\" && cur[name$1] != prev[name$1])\n      { dom.setAttribute(name$1, cur[name$1]); } }\n  if (prev.class != cur.class) {\n    var prevList = prev.class ? prev.class.split(\" \") : nothing;\n    var curList = cur.class ? cur.class.split(\" \") : nothing;\n    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)\n      { dom.classList.remove(prevList[i]); } }\n    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)\n      { dom.classList.add(curList[i$1]); } }\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      var prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n      while (m = prop.exec(prev.style))\n        { dom.style[m[1].toLowerCase()] = \"\"; }\n    }\n    if (cur.style)\n      { dom.style.cssText += cur.style; }\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))\n}\n\n// : ([Decoration], [Decoration]) → bool\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) { return false }\n  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }\n  return true\n}\n\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n  var next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next\n}\n\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nvar ViewTreeUpdater = function ViewTreeUpdater(top) {\n  this.top = top;\n  // Index into `this.top`'s child array, represents the current\n  // update position.\n  this.index = 0;\n  // When entering a mark, the current top and index are pushed\n  // onto this.\n  this.stack = [];\n  // Tracks whether anything was changed\n  this.changed = false;\n\n  this.preMatched = preMatch(top.node.content, top.children);\n};\n\n// Destroy and remove the children between the given indices in\n// `this.top`.\nViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {\n    var this$1 = this;\n\n  if (start == end) { return }\n  for (var i = start; i < end; i++) { this$1.top.children[i].destroy(); }\n  this.top.children.splice(start, end - start);\n  this.changed = true;\n};\n\n// Destroy all remaining children in `this.top`.\nViewTreeUpdater.prototype.destroyRest = function destroyRest () {\n  this.destroyBetween(this.index, this.top.children.length);\n};\n\n// : ([Mark], EditorView)\n// Sync the current stack of mark descs with the given array of\n// marks, reusing existing mark descs when possible.\nViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {\n    var this$1 = this;\n\n  var keep = 0, depth = this.stack.length >> 1;\n  var maxKeep = Math.min(depth, marks.length);\n  while (keep < maxKeep &&\n         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]))\n    { keep++; }\n\n  while (keep < depth) {\n    this$1.destroyRest();\n    this$1.top.dirty = NOT_DIRTY;\n    this$1.index = this$1.stack.pop();\n    this$1.top = this$1.stack.pop();\n    depth--;\n  }\n  while (depth < marks.length) {\n    this$1.stack.push(this$1.top, this$1.index + 1);\n    var found = -1;\n    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n      if (this$1.top.children[i].matchesMark(marks[depth])) { found = i; break }\n    }\n    if (found > -1) {\n      if (found > this$1.index) {\n        this$1.changed = true;\n        this$1.top.children.splice(this$1.index, found - this$1.index);\n      }\n      this$1.top = this$1.top.children[this$1.index];\n    } else {\n      var markDesc = MarkViewDesc.create(this$1.top, marks[depth], inline, view);\n      this$1.top.children.splice(this$1.index, 0, markDesc);\n      this$1.top = markDesc;\n      this$1.changed = true;\n    }\n    this$1.index = 0;\n    depth++;\n  }\n};\n\n// : (Node, [Decoration], DecorationSet) → bool\n// Try to find a node desc matching the given data. Skip over it and\n// return true when successful.\nViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {\n    var this$1 = this;\n\n  for (var i = this.index, children = this.top.children, e = Math.min(children.length, i + 5); i < e; i++) {\n    var child = children[i], preMatched = (void 0);\n    if (child.matchesNode(node, outerDeco, innerDeco) &&\n        ((preMatched = this$1.preMatched.indexOf(child)) == -1 || preMatched == index)) {\n      this$1.destroyBetween(this$1.index, i);\n      this$1.index++;\n      return true\n    }\n  }\n  return false\n};\n\n// : (Node, [Decoration], DecorationSet, EditorView, Fragment, number) → bool\n// Try to update the next node, if any, to the given data. Checks\n// pre-matches to avoid overwriting nodes that could still be used.\nViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {\n  if (this.index == this.top.children.length) { return false }\n  var next = this.top.children[this.index];\n  if (next instanceof NodeViewDesc) {\n    var preMatch = this.preMatched.indexOf(next);\n    if (preMatch > -1 && preMatch != index) { return false }\n    var nextDOM = next.dom;\n    if (next.update(node, outerDeco, innerDeco, view)) {\n      if (next.dom != nextDOM) { this.changed = true; }\n      this.index++;\n      return true\n    }\n  }\n  return false\n};\n\n// : (Node, [Decoration], DecorationSet, EditorView)\n// Insert the node as a newly created node desc.\nViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {\n  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));\n  this.changed = true;\n};\n\nViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {\n  if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget)) {\n    this.index++;\n  } else {\n    var desc = new (widget.spec.isCursorWrapper ? CursorWrapperDesc : WidgetViewDesc)(this.top, widget, view, pos);\n    this.top.children.splice(this.index++, 0, desc);\n    this.changed = true;\n  }\n};\n\n// Make sure a textblock looks and behaves correctly in\n// contentEditable.\nViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {\n  var lastChild = this.top.children[this.index - 1];\n  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1]; }\n\n  if (!lastChild || // Empty textblock\n      !(lastChild instanceof TextViewDesc) ||\n      /\\n$/.test(lastChild.node.text)) {\n    if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {\n      this.index++;\n    } else {\n      var dom = document.createElement(\"br\");\n      this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null));\n      this.changed = true;\n    }\n  }\n};\n\n// : (Fragment, [ViewDesc]) → [ViewDesc]\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing\n// those for other nodes. Returns an array whose positions correspond\n// to node positions in the fragment, and whose elements are either\n// descs matched to the child at that index, or empty.\nfunction preMatch(frag, descs) {\n  var result$$1 = [], end = frag.childCount;\n  for (var i = descs.length - 1; end > 0 && i >= 0; i--) {\n    var desc = descs[i], node = desc.node;\n    if (!node) { continue }\n    if (node != frag.child(end - 1)) { break }\n    result$$1[--end] = desc;\n  }\n  return result$$1\n}\n\nfunction compareSide(a, b) { return a.type.side - b.type.side }\n\n// : (ViewDesc, DecorationSet, (Decoration), (Node, [Decoration], DecorationSet, number))\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  var locals = deco.locals(parent), offset = 0;\n  // Simple, cheap variant for when there are no local decorations\n  if (locals.length == 0) {\n    for (var i = 0; i < parent.childCount; i++) {\n      var child = parent.child(i);\n      onNode(child, locals, deco.forChild(offset, child), i);\n      offset += child.nodeSize;\n    }\n    return\n  }\n\n  var decoIndex = 0, active = [], restNode = null;\n  for (var parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      var widget = locals[decoIndex++], widgets = (void 0);\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }\n      if (widgets) {\n        widgets.sort(compareSide);\n        for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex); }\n      } else {\n        onWidget(widget, parentIndex);\n      }\n    }\n\n    var child$1 = (void 0);\n    if (restNode) {\n      child$1 = restNode;\n      restNode = null;\n    } else if (parentIndex < parent.childCount) {\n      child$1 = parent.child(parentIndex++);\n    } else {\n      break\n    }\n\n    for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }\n    while (decoIndex < locals.length && locals[decoIndex].from == offset) { active.push(locals[decoIndex++]); }\n\n    var end = offset + child$1.nodeSize;\n    if (child$1.isText) {\n      var cutAt = end;\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }\n      for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }\n      if (cutAt < end) {\n        restNode = child$1.cut(cutAt - offset);\n        child$1 = child$1.cut(0, cutAt - offset);\n        end = cutAt;\n      }\n    }\n\n    onNode(child$1, active.length ? active.slice() : nothing, deco.forChild(offset, child$1), parentIndex - 1);\n    offset = end;\n  }\n}\n\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    var oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\n\nfunction moveSelectionBlock(state, dir) {\n  var ref = state.selection;\n  var $anchor = ref.$anchor;\n  var $head = ref.$head;\n  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n  return $start && prosemirrorState.Selection.findFrom($start, dir)\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n  return true\n}\n\nfunction selectHorizontally(view, dir) {\n  var sel = view.state.selection;\n  if (sel instanceof prosemirrorState.TextSelection) {\n    if (!sel.empty) {\n      return false\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      var next = moveSelectionBlock(view.state, dir);\n      if (next && (next instanceof prosemirrorState.NodeSelection)) { return apply(view, next) }\n      return false\n    } else {\n      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n      if (node && prosemirrorState.NodeSelection.isSelectable(node)) {\n        var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n        if (node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)\n          { return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head)) }\n      }\n      return false\n    }\n  } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {\n    return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from))\n  } else {\n    var next$1 = moveSelectionBlock(view.state, dir);\n    if (next$1) { return apply(view, next$1) }\n    return false\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length\n}\n\nfunction isIgnorable(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\")\n}\n\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesLeft(view) {\n  var sel = view.root.getSelection();\n  var node = sel.focusNode, offset = sel.focusOffset;\n  if (!node) { return }\n  var moveNode, moveOffset, force = false;\n  // Gecko will do odd things when the selection is directly in front\n  // of a non-editable node, so in that case, move it into the next\n  // node if possible. Issue prosemirror/prosemirror#832.\n  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        if (node.nodeType == 3 && node.nodeValue.charAt(offset - 1) == \"\\ufeff\") {\n          // IE11's cursor will still be stuck when placed at the\n          // beginning of the cursor wrapper text node (#807)\n          if (result.ie && result.ie_version <= 11) { force = true; }\n          moveNode = node;\n          moveOffset = --offset;\n        } else { break }\n      } else {\n        var before = node.childNodes[offset - 1];\n        if (isIgnorable(before)) {\n          moveNode = node;\n          moveOffset = --offset;\n        } else if (before.nodeType == 3) {\n          node = before;\n          offset = node.nodeValue.length;\n        } else { break }\n      }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var prev = node.previousSibling;\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode;\n        moveOffset = domIndex(prev);\n        prev = prev.previousSibling;\n      }\n      if (!prev) {\n        node = node.parentNode;\n        if (node == view.dom) { break }\n        offset = 0;\n      } else {\n        node = prev;\n        offset = nodeLen(node);\n      }\n    }\n  }\n  if (force) { setSelFocus(view, sel, node, offset); }\n  else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }\n}\n\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesRight(view) {\n  var sel = view.root.getSelection();\n  var node = sel.focusNode, offset = sel.focusOffset;\n  if (!node) { return }\n  var len = nodeLen(node);\n  var moveNode, moveOffset;\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) { break }\n      var after = node.childNodes[offset];\n      if (isIgnorable(after)) {\n        moveNode = node;\n        moveOffset = ++offset;\n      }\n      else { break }\n    } else if (isBlockNode(node)) {\n      break\n    } else {\n      var next = node.nextSibling;\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode;\n        moveOffset = domIndex(next) + 1;\n        next = next.nextSibling;\n      }\n      if (!next) {\n        node = node.parentNode;\n        if (node == view.dom) { break }\n        offset = len = 0;\n      } else {\n        node = next;\n        offset = 0;\n        len = nodeLen(node);\n      }\n    }\n  }\n  if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }\n}\n\nfunction isBlockNode(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock\n}\n\nfunction setSelFocus(view, sel, node, offset) {\n  if (selectionCollapsed(sel)) {\n    var range = document.createRange();\n    range.setEnd(node, offset);\n    range.setStart(node, offset);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  } else if (sel.extend) {\n    sel.extend(node, offset);\n  }\n  view.selectionReader.storeDOMState(view.selection);\n}\n\n// : (EditorState, number)\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir) {\n  var sel = view.state.selection;\n  if (sel instanceof prosemirrorState.TextSelection && !sel.empty) { return false }\n  var $from = sel.$from;\n  var $to = sel.$to;\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    var next = moveSelectionBlock(view.state, dir);\n    if (next && (next instanceof prosemirrorState.NodeSelection))\n      { return apply(view, next) }\n  }\n  if (!$from.parent.inlineContent) {\n    var beyond = prosemirrorState.Selection.findFrom(dir < 0 ? $from : $to, dir);\n    return beyond ? apply(view, beyond) : true\n  }\n  return false\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof prosemirrorState.TextSelection)) { return true }\n  var ref = view.state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  var empty = ref.empty;\n  if (!$head.sameParent($anchor)) { return true }\n  if (!empty) { return false }\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) { return true }\n  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n  if (nextNode && !nextNode.isText) {\n    var tr = view.state.tr;\n    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }\n    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }\n    view.dispatch(tr);\n    return true\n  }\n  return false\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop();\n  node.contentEditable = state;\n  view.domObserver.start();\n}\n\n// Issue #867 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Chrome does really wrong things when the down arrow is\n// pressed when the cursor is directly at the start of a textblock and\n// has an uneditable node after it\nfunction chromeDownArrowBug(view) {\n  if (!result.chrome || view.state.selection.$head.parentOffset > 0) { return }\n  var ref = view.root.getSelection();\n  var focusNode = ref.focusNode;\n  var focusOffset = ref.focusOffset;\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n      focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    var child = focusNode.firstChild;\n    switchEditable(view, child, true);\n    setTimeout(function () { return switchEditable(view, child, false); }, 20);\n  }\n}\n\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\n\nfunction getMods(event) {\n  var result$$1 = \"\";\n  if (event.ctrlKey) { result$$1 += \"c\"; }\n  if (event.metaKey) { result$$1 += \"m\"; }\n  if (event.altKey) { result$$1 += \"a\"; }\n  if (event.shiftKey) { result$$1 += \"s\"; }\n  return result$$1\n}\n\nfunction captureKeyDown(view, event) {\n  var code = event.keyCode, mods = getMods(event);\n  if (code == 8 || (result.mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 46 || (result.mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 13 || code == 27) { // Enter, Esc\n    return true\n  } else if (code == 37) { // Left arrow\n    return selectHorizontally(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 39) { // Right arrow\n    return selectHorizontally(view, 1) || skipIgnoredNodesRight(view)\n  } else if (code == 38) { // Up arrow\n    return selectVertically(view, -1) || skipIgnoredNodesLeft(view)\n  } else if (code == 40) { // Down arrow\n    return chromeDownArrowBug(view) || selectVertically(view, 1) || skipIgnoredNodesRight(view)\n  } else if (mods == (result.mac ? \"m\" : \"c\") &&\n             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n    return true\n  }\n  return false\n}\n\nvar TrackedRecord = function TrackedRecord(prev, mapping, state) {\n  this.prev = prev;\n  this.mapping = mapping;\n  this.state = state;\n};\n\nvar TrackMappings = function TrackMappings(state) {\n  this.seen = [new TrackedRecord(null, null, state)];\n  // Kludge to listen to state changes globally in order to be able\n  // to find mappings from a given state to another.\n  prosemirrorState.EditorState.addApplyListener(this.track = this.track.bind(this));\n};\n\nTrackMappings.prototype.destroy = function destroy () {\n  prosemirrorState.EditorState.removeApplyListener(this.track);\n};\n\nTrackMappings.prototype.find = function find (state) {\n    var this$1 = this;\n\n  for (var i = this.seen.length - 1; i >= 0; i--) {\n    var record = this$1.seen[i];\n    if (record.state == state) { return record }\n  }\n};\n\nTrackMappings.prototype.track = function track (old, tr, state) {\n  var found = this.seen.length < 200 ? this.find(old) : null;\n  if (found)\n    { this.seen.push(new TrackedRecord(found, tr.docChanged ? tr.mapping : null, state)); }\n};\n\nTrackMappings.prototype.getMapping = function getMapping (state, appendTo) {\n  var found = this.find(state);\n  if (!found) { return null }\n  var mappings = [];\n  for (var rec = found; rec; rec = rec.prev)\n    { if (rec.mapping) { mappings.push(rec.mapping); } }\n  var result = appendTo || new prosemirrorTransform.Mapping;\n  for (var i = mappings.length - 1; i >= 0; i--)\n    { result.appendMapping(mappings[i]); }\n  return result\n};\n\n// Track the state of the DOM selection, creating transactions to\n// update the selection state when necessary.\nvar SelectionReader = function SelectionReader(view) {\n  var this$1 = this;\n\n  this.view = view;\n\n  // Track the state of the DOM selection.\n  this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;\n  this.lastSelection = view.state.selection;\n  this.ignoreUpdates = false;\n  this.suppressUpdates = false;\n  this.poller = poller(this);\n\n  this.focusFunc = (function () { return this$1.poller.start(hasFocusAndSelection(this$1.view)); }).bind(this);\n  this.blurFunc = this.poller.stop;\n\n  view.dom.addEventListener(\"focus\", this.focusFunc);\n  view.dom.addEventListener(\"blur\", this.blurFunc);\n\n  if (!view.editable) { this.poller.start(false); }\n};\n\nSelectionReader.prototype.destroy = function destroy () {\n  this.view.dom.removeEventListener(\"focus\", this.focusFunc);\n  this.view.dom.removeEventListener(\"blur\", this.blurFunc);\n  this.poller.stop();\n};\n\nSelectionReader.prototype.poll = function poll (origin) { this.poller.poll(origin); };\n\nSelectionReader.prototype.editableChanged = function editableChanged () {\n  if (!this.view.editable) { this.poller.start(); }\n  else if (!hasFocusAndSelection(this.view)) { this.poller.stop(); }\n};\n\n// : () → bool\n// Whether the DOM selection has changed from the last known state.\nSelectionReader.prototype.domChanged = function domChanged () {\n  var sel = this.view.root.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset\n};\n\n// Store the current state of the DOM selection.\nSelectionReader.prototype.storeDOMState = function storeDOMState (selection) {\n  var sel = this.view.root.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastHeadNode = sel.focusNode; this.lastHeadOffset = sel.focusOffset;\n  this.lastSelection = selection;\n};\n\nSelectionReader.prototype.clearDOMState = function clearDOMState () {\n  this.lastAnchorNode = this.lastSelection = null;\n};\n\n// : (?string)\n// When the DOM selection changes in a notable manner, modify the\n// current selection state to match.\nSelectionReader.prototype.readFromDOM = function readFromDOM (origin) {\n  if (this.ignoreUpdates || !this.domChanged() || !hasFocusAndSelection(this.view)) { return }\n  if (this.suppressUpdates) { return selectionToDOM(this.view) }\n  if (!this.view.inDOMChange) { this.view.domObserver.flush(); }\n  if (this.view.inDOMChange) { return }\n\n  var domSel = this.view.root.getSelection(), doc = this.view.state.doc;\n  var nearestDesc = this.view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n  var head = this.view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n  var $head = doc.resolve(head), $anchor, selection;\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head;\n    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }\n    if (nearestDesc && nearestDesc.node.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent) {\n      var pos = nearestDesc.posBefore;\n      selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc.resolve(pos));\n    }\n  } else {\n    $anchor = doc.resolve(this.view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset));\n  }\n\n  if (!selection) {\n    var bias = origin == \"pointer\" || (this.view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n    selection = selectionBetween(this.view, $anchor, $head, bias);\n  }\n  if (!this.view.state.selection.eq(selection)) {\n    var tr = this.view.state.tr.setSelection(selection);\n    if (origin == \"pointer\") { tr.setMeta(\"pointer\", true); }\n    else if (origin == \"key\") { tr.scrollIntoView(); }\n    this.view.dispatch(tr);\n  } else {\n    selectionToDOM(this.view);\n  }\n};\n\n// There's two polling models. On browsers that support the\n// selectionchange event (everything except Firefox < 52, basically), we\n// register a listener for that whenever the editor is focused.\nvar SelectionChangePoller = function SelectionChangePoller(reader) {\n  var this$1 = this;\n\n  this.listening = false;\n  this.curOrigin = null;\n  this.originTime = 0;\n  this.reader = reader;\n\n  this.readFunc = function () { return reader.readFromDOM(this$1.originTime > Date.now() - 50 ? this$1.curOrigin : null); };\n};\n\nSelectionChangePoller.prototype.poll = function poll (origin) {\n  this.curOrigin = origin;\n  this.originTime = Date.now();\n};\n\nSelectionChangePoller.prototype.start = function start (andRead) {\n  if (!this.listening) {\n    var doc = this.reader.view.dom.ownerDocument;\n    doc.addEventListener(\"selectionchange\", this.readFunc);\n    this.listening = true;\n    if (andRead) { this.readFunc(); }\n  }\n};\n\nSelectionChangePoller.prototype.stop = function stop () {\n  if (this.listening) {\n    var doc = this.reader.view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", this.readFunc);\n    this.listening = false;\n  }\n};\n\n// On Browsers that don't support the selectionchange event,\n// we use timeout-based polling.\nvar TimeoutPoller = function TimeoutPoller(reader) {\n  // The timeout ID for the poller when active.\n  this.polling = null;\n  this.reader = reader;\n  this.pollFunc = this.doPoll.bind(this, null);\n};\n\nTimeoutPoller.prototype.doPoll = function doPoll (origin) {\n  var view = this.reader.view;\n  if (view.focused || !view.editable) {\n    this.reader.readFromDOM(origin);\n    this.polling = setTimeout(this.pollFunc, 100);\n  } else {\n    this.polling = null;\n  }\n};\n\nTimeoutPoller.prototype.poll = function poll (origin) {\n  clearTimeout(this.polling);\n  this.polling = setTimeout(origin ? this.doPoll.bind(this, origin) : this.pollFunc, 0);\n};\n\nTimeoutPoller.prototype.start = function start () {\n  if (this.polling == null) { this.poll(); }\n};\n\nTimeoutPoller.prototype.stop = function stop () {\n  clearTimeout(this.polling);\n  this.polling = null;\n};\n\nfunction poller(reader) {\n  return new (\"onselectionchange\" in document ? SelectionChangePoller : TimeoutPoller)(reader)\n}\n\nfunction selectionToDOM(view, takeFocus, force) {\n  var sel = view.state.selection;\n  syncNodeSelection(view, sel);\n\n  if (view.editable && !view.hasFocus()) {\n    if (!takeFocus) { return }\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444\n    if (result.gecko && result.gecko_version <= 55) {\n      view.selectionReader.ignoreUpdates = true;\n      view.dom.focus();\n      view.selectionReader.ignoreUpdates = false;\n    }\n  } else if (!view.editable && !hasSelection(view) && !takeFocus) {\n    return\n  }\n\n  var reader = view.selectionReader;\n  if (reader.lastSelection && reader.lastSelection.eq(sel) && !reader.domChanged()) { return }\n\n  reader.ignoreUpdates = true;\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view);\n  } else {\n    var anchor = sel.anchor;\n    var head = sel.head;\n    var resetEditableFrom, resetEditableTo;\n    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        { resetEditableFrom = temporarilyEditableNear(view, sel.from); }\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        { resetEditableTo = temporarilyEditableNear(view, sel.to); }\n    }\n    view.docView.setSelection(anchor, head, view.root, force);\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) { resetEditableFrom.contentEditable = \"false\"; }\n      if (resetEditableTo) { resetEditableTo.contentEditable = \"false\"; }\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    } else if (anchor != head) {\n      view.dom.classList.add(\"ProseMirror-hideselection\");\n      if (\"onselectionchange\" in document) { removeClassOnSelectionChange(view); }\n    }\n  }\n\n  reader.storeDOMState(sel);\n  reader.ignoreUpdates = false;\n}\n\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\n\nvar brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;\n\nfunction temporarilyEditableNear(view, pos) {\n  var ref = view.docView.domFromPos(pos);\n  var node = ref.node;\n  var offset = ref.offset;\n  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n  var before = offset ? node.childNodes[offset - 1] : null;\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) {\n      after.contentEditable = \"true\";\n      return after\n    } else if (before) {\n      before.contentEditable = \"true\";\n      return before\n    }\n  }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  var doc = view.dom.ownerDocument;\n  doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard);\n  var domSel = view.root.getSelection();\n  var node = domSel.anchorNode, offset = domSel.anchorOffset;\n  doc.addEventListener(\"selectionchange\", view.hideSelectionGuard = function () {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.hideSelectionGuard);\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    }\n  });\n}\n\nfunction selectCursorWrapper(view) {\n  var domSel = view.root.getSelection(), range = document.createRange();\n  var node = view.cursorWrapper.dom;\n  range.setEnd(node, node.childNodes.length);\n  range.collapse(false);\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n  // Kludge to kill 'control selection' in IE11 when selecting an\n  // invisible cursor wrapper, since that would result in those weird\n  // resize handles and a selection that considers the absolutely\n  // positioned wrapper, rather than the root editable node, the\n  // focused element.\n  if (!view.state.selection.visible && result.ie && result.ie_version <= 11) {\n    node.disabled = true;\n    node.disabled = false;\n  }\n}\n\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof prosemirrorState.NodeSelection) {\n    var desc = view.docView.descAt(sel.from);\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view);\n      if (desc) { desc.selectNode(); }\n      view.lastSelectedViewDesc = desc;\n    }\n  } else {\n    clearNodeSelection(view);\n  }\n}\n\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    view.lastSelectedViewDesc.deselectNode();\n    view.lastSelectedViewDesc = null;\n  }\n}\n\nfunction selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", function (f) { return f(view, $anchor, $head); })\n    || prosemirrorState.TextSelection.between($anchor, $head, bias)\n}\n\nfunction hasFocusAndSelection(view) {\n  if (view.editable && view.root.activeElement != view.dom) { return false }\n  return hasSelection(view)\n}\n\nfunction hasSelection(view) {\n  var sel = view.root.getSelection();\n  if (!sel.anchorNode) { return false }\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))\n  } catch(_) {\n    return false\n  }\n}\n\nfunction nonInclusiveMark(mark) {\n  return mark.type.spec.inclusive === false\n}\n\nfunction needsCursorWrapper(state) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n  var visible = ref.visible;\n  var $pos = $head.pos == $anchor.pos && (!visible || $head.parent.inlineContent) ? $head : null;\n  if ($pos && (!visible || state.storedMarks || $pos.parent.content.length == 0 ||\n               $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.some(nonInclusiveMark)))\n    { return $pos }\n  else\n    { return null }\n}\n\nvar DOMChange = function DOMChange(view, composing) {\n  var this$1 = this;\n\n  this.view = view;\n  this.state = view.state;\n  this.composing = composing;\n  this.from = this.to = null;\n  this.typeOver = false;\n  this.timeout = composing ? null : setTimeout(function () { return this$1.finish(); }, DOMChange.commitTimeout);\n  this.trackMappings = new TrackMappings(view.state);\n\n  // If there have been changes since this DOM update started, we must\n  // map our start and end positions, as well as the new selection\n  // positions, through them. This tracks that mapping.\n  this.mapping = new prosemirrorTransform.Mapping;\n  this.mappingTo = view.state;\n};\n\nDOMChange.prototype.addRange = function addRange (from, to) {\n  if (this.from == null) {\n    this.from = from;\n    this.to = to;\n  } else {\n    this.from = Math.min(from, this.from);\n    this.to = Math.max(to, this.to);\n  }\n};\n\nDOMChange.prototype.changedRange = function changedRange () {\n  if (this.from == null) { return rangeAroundSelection(this.state.selection) }\n  var $from = this.state.doc.resolve(Math.min(this.from, this.state.selection.from)), $to = this.state.doc.resolve(this.to);\n  var shared = $from.sharedDepth(this.to);\n  return {from: $from.before(shared + 1), to: $to.after(shared + 1)}\n};\n\nDOMChange.prototype.markDirty = function markDirty (range) {\n  if (this.from == null) { this.view.docView.markDirty((range = range || this.changedRange()).from, range.to); }\n  else { this.view.docView.markDirty(this.from, this.to); }\n};\n\nDOMChange.prototype.stateUpdated = function stateUpdated (state) {\n  if (this.trackMappings.getMapping(state, this.mapping)) {\n    this.trackMappings.destroy();\n    this.trackMappings = new TrackMappings(state);\n    this.mappingTo = state;\n    return true\n  } else {\n    this.markDirty();\n    this.destroy();\n    return false\n  }\n};\n\nDOMChange.prototype.finish = function finish (force) {\n  clearTimeout(this.timeout);\n  if (this.composing && !force) { return }\n  this.view.domObserver.flush();\n  var range = this.changedRange();\n  this.markDirty(range);\n\n  this.destroy();\n  var sel = this.state.selection, allowTypeOver = this.typeOver && sel instanceof prosemirrorState.TextSelection &&\n      !sel.empty && sel.$head.sameParent(sel.$anchor);\n  readDOMChange(this.view, this.mapping, this.state, range, allowTypeOver);\n\n  // If the reading didn't result in a view update, force one by\n  // resetting the view to its current state.\n  if (this.view.docView.dirty) { this.view.updateState(this.view.state); }\n};\n\nDOMChange.prototype.destroy = function destroy () {\n  clearTimeout(this.timeout);\n  this.trackMappings.destroy();\n  this.view.inDOMChange = null;\n};\n\nDOMChange.prototype.compositionEnd = function compositionEnd () {\n    var this$1 = this;\n\n  if (this.composing) {\n    this.composing = false;\n    this.timeout = setTimeout(function () { return this$1.finish(); }, 50);\n  }\n};\n\nDOMChange.start = function start (view, composing) {\n  if (view.inDOMChange) {\n    if (composing) {\n      clearTimeout(view.inDOMChange.timeout);\n      view.inDOMChange.composing = true;\n    }\n  } else {\n    view.inDOMChange = new DOMChange(view, composing);\n  }\n  return view.inDOMChange\n};\nDOMChange.commitTimeout = 20;\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\n\nfunction parseBetween(view, oldState, range) {\n  var ref = view.docView.parseRange(range.from, range.to);\n  var parent = ref.node;\n  var fromOffset = ref.fromOffset;\n  var toOffset = ref.toOffset;\n  var from = ref.from;\n  var to = ref.to;\n\n  var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{node: anchor, offset: domSel.anchorOffset}];\n    if (!selectionCollapsed(domSel))\n      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }\n  }\n  // Work around issue in Chrome where backspacing sometimes replaces\n  // the deleted content with a random BR node (issues #799, #831)\n  if (result.chrome && view.lastKeyCode === 8) {\n    for (var off = toOffset; off > fromOffset; off--) {\n      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n      if (node.nodeType == \"BR\" && !desc) { toOffset = off; break }\n      if (!desc || desc.size) { break }\n    }\n  }\n  var startDoc = oldState.doc;\n  var parser = view.someProp(\"domParser\") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);\n  var $from = startDoc.resolve(from);\n  var sel = null, doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.spec.code ? \"full\" : true,\n    editableContent: true,\n    findPositions: find,\n    ruleFromNode: ruleFromNode(parser, $from),\n    context: $from\n  });\n  if (find && find[0].pos != null) {\n    var anchor$1 = find[0].pos, head = find[1] && find[1].pos;\n    if (head == null) { head = anchor$1; }\n    sel = {anchor: anchor$1 + from, head: head + from};\n  }\n  return {doc: doc, sel: sel, from: from, to: to}\n}\n\nfunction ruleFromNode(parser, context) {\n  return function (dom) {\n    var desc = dom.pmViewDesc;\n    if (desc) {\n      return desc.parseRule()\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n      // Safari replaces the list item or table cell with a BR\n      // directly in the list node (?!) if you delete the last\n      // character in a list item or table cell (#708, #862)\n      if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName))\n        { return parser.matchTag(document.createElement(\"li\"), context) }\n      else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName))\n        { return {ignore: true} }\n    }\n  }\n}\n\nfunction isAtEnd($pos, depth) {\n  for (var i = depth || 0; i < $pos.depth; i++)\n    { if ($pos.index(i) + 1 < $pos.node(i).childCount) { return false } }\n  return $pos.parentOffset == $pos.parent.content.size\n}\nfunction isAtStart($pos, depth) {\n  for (var i = depth || 0; i < $pos.depth; i++)\n    { if ($pos.index(0) > 0) { return false } }\n  return $pos.parentOffset == 0\n}\n\nfunction rangeAroundSelection(selection) {\n  // Intentionally uses $head/$anchor because those will correspond to the DOM selection\n  var $from = selection.$anchor.min(selection.$head), $to = selection.$anchor.max(selection.$head);\n\n  if ($from.sameParent($to) && $from.parent.inlineContent && $from.parentOffset && $to.parentOffset < $to.parent.content.size) {\n    var startOff = Math.max(0, $from.parentOffset);\n    var size = $from.parent.content.size;\n    var endOff = Math.min(size, $to.parentOffset);\n\n    if (startOff > 0)\n      { startOff = $from.parent.childBefore(startOff).offset; }\n    if (endOff < size) {\n      var after = $from.parent.childAfter(endOff);\n      endOff = after.offset + after.node.nodeSize;\n    }\n    var nodeStart = $from.start();\n    return {from: nodeStart + startOff, to: nodeStart + endOff}\n  } else {\n    for (var depth = 0;; depth++) {\n      var fromStart = isAtStart($from, depth + 1), toEnd = isAtEnd($to, depth + 1);\n      if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {\n        var from = $from.before(depth + 1), to = $to.after(depth + 1);\n        if (fromStart && $from.index(depth) > 0)\n          { from -= $from.node(depth).child($from.index(depth) - 1).nodeSize; }\n        if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount)\n          { to += $to.node(depth).child($to.index(depth) + 1).nodeSize; }\n        return {from: from, to: to}\n      }\n    }\n  }\n}\n\nfunction keyEvent(keyCode, key) {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"keydown\", true, true);\n  event.keyCode = keyCode;\n  event.key = event.code = key;\n  return event\n}\n\nfunction readDOMChange(view, mapping, oldState, range, allowTypeOver) {\n  var parse = parseBetween(view, oldState, range);\n\n  var doc = oldState.doc, compare = doc.slice(parse.from, parse.to);\n  var preferredPos, preferredSide;\n  // Prefer anchoring to end when Backspace is pressed\n  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {\n    preferredPos = oldState.selection.to;\n    preferredSide = \"end\";\n  } else {\n    preferredPos = oldState.selection.from;\n    preferredSide = \"start\";\n  }\n  view.lastKeyCode = null;\n\n  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n  if (!change) {\n    if (allowTypeOver) {\n      var state = view.state, sel = state.selection;\n      view.dispatch(state.tr.replaceSelectionWith(state.schema.text(state.doc.textBetween(sel.from, sel.to)), true).scrollIntoView());\n    } else if (parse.sel) {\n      var sel$1 = resolveSelection(view, view.state.doc, mapping, parse.sel);\n      if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }\n    }\n    return\n  }\n\n  var $from = parse.doc.resolveNoCache(change.start - parse.from);\n  var $to = parse.doc.resolveNoCache(change.endB - parse.from);\n  var nextSel;\n  // If this looks like the effect of pressing Enter, just dispatch an\n  // Enter key instead.\n  if (!$from.sameParent($to) && $from.pos < parse.doc.content.size &&\n      (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n      nextSel.head == $to.pos &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); }))\n    { return }\n  // Same for backspace\n  if (oldState.selection.anchor > change.start &&\n      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n      view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(8, \"Backspace\")); })) {\n    if (result.android && result.chrome) { // #820\n      view.selectionReader.suppressUpdates = true;\n      setTimeout(function () { return view.selectionReader.suppressUpdates = false; }, 50);\n    }\n    return\n  }\n\n  var from = mapping.map(change.start), to = mapping.map(change.endA, -1);\n\n  var tr, storedMarks, markChange, $from1;\n  if ($from.sameParent($to) && $from.parent.inlineContent) {\n    if ($from.pos == $to.pos) { // Deletion\n      tr = view.state.tr.delete(from, to);\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n    } else if ( // Adding or removing a mark\n      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&\n      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),\n                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))\n    ) {\n      tr = view.state.tr;\n      if (markChange.type == \"add\") { tr.addMark(from, to, markChange.mark); }\n      else { tr.removeMark(from, to, markChange.mark); }\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      // Both positions in the same text node -- simply insert text\n      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n      if (view.someProp(\"handleTextInput\", function (f) { return f(view, from, to, text); })) { return }\n      tr = view.state.tr.insertText(text, from, to);\n    }\n  }\n\n  if (!tr)\n    { tr = view.state.tr.replace(from, to, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }\n  if (parse.sel) {\n    var sel$2 = resolveSelection(view, tr.doc, mapping, parse.sel);\n    if (sel$2) { tr.setSelection(sel$2); }\n  }\n  if (storedMarks) { tr.ensureMarks(storedMarks); }\n  view.dispatch(tr.scrollIntoView());\n}\n\nfunction resolveSelection(view, doc, mapping, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }\n  return selectionBetween(view, doc.resolve(mapping.map(parsedSel.anchor)),\n                          doc.resolve(mapping.map(parsedSel.head)))\n}\n\n// : (Fragment, Fragment) → ?{mark: Mark, type: string}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n  var added = curMarks, removed = prevMarks, type, mark, update;\n  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }\n  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0];\n    type = \"add\";\n    update = function (node) { return node.mark(mark.addToSet(node.marks)); };\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0];\n    type = \"remove\";\n    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };\n  } else {\n    return null\n  }\n  var updated = [];\n  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }\n  if (prosemirrorModel.Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock ||\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos ||\n      // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    { return false }\n\n  var $start = old.resolve(start);\n  // Start must be at the end of a block\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    { return false }\n  var $next = old.resolve(skipClosingAndOpening($start, true, true));\n  // The next textblock must start before end and end near it\n  if (!$next.parent.isTextblock || $next.pos > end ||\n      skipClosingAndOpening($next, true, false) < end)\n    { return false }\n\n  // The fragments after the join point must match\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--;\n    end++;\n    fromEnd = false;\n  }\n  if (mayOpen) {\n    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n    while (next && !next.isLeaf) {\n      next = next.firstChild;\n      end++;\n    }\n  }\n  return end\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  var start = a.findDiffStart(b, pos);\n  if (start == null) { return null }\n  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);\n  var endA = ref.a;\n  var endB = ref.b;\n  if (preferredSide == \"end\") {\n    var adjust = Math.max(0, start - Math.min(endA, endB));\n    preferredPos -= endA + adjust - start;\n  }\n  if (endA < start && a.size < b.size) {\n    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n    start -= move;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n    start -= move$1;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n  return {start: start, endA: endA, endB: endB}\n}\n\nfunction serializeForClipboard(view, slice) {\n  var context = [];\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--;\n    openEnd--;\n    var node = content.firstChild;\n    context.push(node.type.name, node.type.hasRequiredAttrs() ? node.attrs : null);\n    content = node.content;\n  }\n\n  var serializer = view.someProp(\"clipboardSerializer\") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);\n  var wrap = document.createElement(\"div\");\n  wrap.appendChild(serializer.serializeFragment(content));\n\n  var firstChild = wrap.firstChild, needsWrap;\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (var i = needsWrap.length - 1; i >= 0; i--) {\n      var wrapper = document.createElement(needsWrap[i]);\n      while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }\n      wrap.appendChild(wrapper);\n    }\n    firstChild = wrap.firstChild;\n  }\n\n  if (firstChild && firstChild.nodeType == 1)\n    { firstChild.setAttribute(\"data-pm-slice\", (openStart + \" \" + openEnd + \" \" + (JSON.stringify(context)))); }\n\n  var text = view.someProp(\"clipboardTextSerializer\", function (f) { return f(slice); }) ||\n      slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n\n  return {dom: wrap, text: text}\n}\n\n// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n  var dom, inCode = $context.parent.type.spec.code, slice;\n  if (!html && !text) { return null }\n  var asText = text && (plainText || inCode || !html);\n  if (asText) {\n    view.someProp(\"transformPastedText\", function (f) { text = f(text); });\n    if (inCode) { return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text)), 0, 0) }\n    var parsed = view.someProp(\"clipboardTextParser\", function (f) { return f(text, $context); });\n    if (parsed) {\n      slice = parsed;\n    } else {\n      dom = document.createElement(\"div\");\n      text.trim().split(/(?:\\r\\n?|\\n)+/).forEach(function (block) {\n        dom.appendChild(document.createElement(\"p\")).textContent = block;\n      });\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", function (f) { return html = f(html); });\n    dom = readHTML(html);\n  }\n\n  var contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n  var sliceData = contextNode && /^(\\d+) (\\d+) (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\"));\n  if (!slice) {\n    var parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);\n    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context});\n  }\n  if (sliceData)\n    { slice = addContext(new prosemirrorModel.Slice(slice.content, Math.min(slice.openStart, +sliceData[1]),\n                                 Math.min(slice.openEnd, +sliceData[2])), sliceData[3]); }\n  else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n    { slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), false); }\n  view.someProp(\"transformPasted\", function (f) { slice = f(slice); });\n  return slice\n}\n\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) { return fragment }\n  var loop = function ( d ) {\n    var parent = $context.node(d);\n    var match = parent.contentMatchAt($context.index(d));\n    var lastWrap = (void 0), result = [];\n    fragment.forEach(function (node) {\n      if (!result) { return }\n      var wrap = match.findWrapping(node.type), inLast;\n      if (!wrap) { return result = null }\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast;\n      } else {\n        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }\n        var wrapped = withWrappers(node, wrap);\n        result.push(wrapped);\n        match = match.matchType(wrapped.type, wrapped.attrs);\n        lastWrap = wrap;\n      }\n    });\n    if (result) { return { v: prosemirrorModel.Fragment.from(result) } }\n  };\n\n  for (var d = $context.depth; d >= 0; d--) {\n    var returned = loop( d );\n\n    if ( returned ) return returned.v;\n  }\n  return fragment\n}\n\nfunction withWrappers(node, wrap, from) {\n  if ( from === void 0 ) from = 0;\n\n  for (var i = wrap.length - 1; i >= from; i--)\n    { node = wrap[i].create(null, prosemirrorModel.Fragment.from(node)); }\n  return node\n}\n\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }\n    var match = sibling.contentMatchAt(sibling.childCount);\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      { return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1)))) }\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) { return node }\n  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);\n  return node.copy(fragment.append(fill))\n}\n\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nvar wrapMap = {thead: [\"table\"], colgroup: [\"table\"], col: [\"table\", \"colgroup\"],\n                 tr: [\"table\", \"tbody\"], td: [\"table\", \"tbody\", \"tr\"], th: [\"table\", \"tbody\", \"tr\"]};\nvar detachedDoc = null;\nfunction readHTML(html) {\n  var metas = /(\\s*<meta [^>]*>)*/.exec(html);\n  if (metas) { html = html.slice(metas[0].length); }\n  var doc = detachedDoc || (detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n  var elt = doc.createElement(\"div\");\n  var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\\s]+)/i.exec(html), wrap, depth = 0;\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {\n    html = wrap.map(function (n) { return \"<\" + n + \">\"; }).join(\"\") + html + wrap.map(function (n) { return \"</\" + n + \">\"; }).reverse().join(\"\");\n    depth = wrap.length;\n  }\n  elt.innerHTML = html;\n  for (var i = 0; i < depth; i++) { elt = elt.firstChild; }\n  return elt\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) { return slice }\n  var schema = slice.content.firstChild.type.schema, array;\n  try { array = JSON.parse(context); }\n  catch(e) { return slice }\n  var content = slice.content;\n  var openStart = slice.openStart;\n  var openEnd = slice.openEnd;\n  for (var i = array.length - 2; i >= 0; i -= 2) {\n    var type = schema.nodes[array[i]];\n    if (!type || type.hasRequiredAttrs()) { break }\n    content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));\n    openStart++; openEnd++;\n  }\n  return new prosemirrorModel.Slice(content, openStart, openEnd)\n}\n\nvar observeOptions = {childList: true, characterData: true, attributes: true, subtree: true, characterDataOldValue: true};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nvar useCharData = result.ie && result.ie_version <= 11;\n\nvar DOMObserver = function DOMObserver(view) {\n  var this$1 = this;\n\n  this.view = view;\n  this.observer = window.MutationObserver &&\n    new window.MutationObserver(function (mutations) { return this$1.registerMutations(mutations); });\n  if (useCharData)\n    { this.onCharData = function (e) { return this$1.registerMutation({target: e.target, type: \"characterData\", oldValue: e.prevValue}); }; }\n};\n\nDOMObserver.prototype.start = function start () {\n  if (this.observer)\n    { this.observer.observe(this.view.dom, observeOptions); }\n  if (useCharData)\n    { this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData); }\n};\n\nDOMObserver.prototype.stop = function stop () {\n  if (this.observer) {\n    this.flush();\n    this.observer.disconnect();\n  }\n  if (useCharData)\n    { this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData); }\n};\n\nDOMObserver.prototype.flush = function flush () {\n  if (this.observer)\n    { this.registerMutations(this.observer.takeRecords()); }\n};\n\nDOMObserver.prototype.registerMutations = function registerMutations (mutations) {\n    var this$1 = this;\n\n  for (var i = 0; i < mutations.length; i++)\n    { this$1.registerMutation(mutations[i]); }\n};\n\nDOMObserver.prototype.registerMutation = function registerMutation (mut) {\n  if (!this.view.editable) { return }\n  var desc = this.view.docView.nearestDesc(mut.target);\n  if (mut.type == \"attributes\" &&\n      (desc == this.view.docView || mut.attributeName == \"contenteditable\")) { return }\n  if (!desc || desc.ignoreMutation(mut)) { return }\n\n  var from, to;\n  if (mut.type == \"childList\") {\n    var fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target\n        ? domIndex(mut.previousSibling) + 1 : 0;\n    if (fromOffset == -1) { return }\n    from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n    var toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target\n        ? domIndex(mut.nextSibling) : mut.target.childNodes.length;\n    if (toOffset == -1) { return }\n    to = desc.localPosFromDOM(mut.target, toOffset, 1);\n  } else if (mut.type == \"attributes\") {\n    from = desc.posAtStart - desc.border;\n    to = desc.posAtEnd + desc.border;\n  } else { // \"characterData\"\n    from = desc.posAtStart;\n    to = desc.posAtEnd;\n    // An event was generated for a text change that didn't change\n    // any text. Mark the dom change to fall back to assuming the\n    // selection was typed over with an identical value if it can't\n    // find another change.\n    if (mut.target.nodeValue == mut.oldValue) { DOMChange.start(this.view).typeOver = true; }\n  }\n\n  DOMChange.start(this.view).addRange(from, to);\n};\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nvar handlers = {};\nvar editHandlers = {};\n\nfunction initInput(view) {\n  view.shiftKey = false;\n  view.mouseDown = null;\n  view.inDOMChange = null;\n  view.lastKeyCode = null;\n  view.lastKeyCodeTime = 0;\n  view.domObserver = new DOMObserver(view);\n  view.domObserver.start();\n\n  view.eventHandlers = Object.create(null);\n  var loop = function ( event ) {\n    var handler = handlers[event];\n    view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n          (view.editable || !(event.type in editHandlers)))\n        { handler(view, event); }\n    });\n  };\n\n  for (var event in handlers) loop( event );\n  ensureListeners(view);\n}\n\nfunction destroyInput(view) {\n  view.domObserver.stop();\n  if (view.inDOMChange) { view.inDOMChange.destroy(); }\n  for (var type in view.eventHandlers)\n    { view.dom.removeEventListener(type, view.eventHandlers[type]); }\n}\n\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", function (currentHandlers) {\n    for (var type in currentHandlers) { if (!view.eventHandlers[type])\n      { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }\n  });\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", function (handlers) {\n    var handler = handlers[event.type];\n    return handler ? handler(view, event) || event.defaultPrevented : false\n  })\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) { return true }\n  if (event.defaultPrevented) { return false }\n  for (var node = event.target; node != view.dom; node = node.parentNode)\n    { if (!node || node.nodeType == 11 ||\n        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n      { return false } }\n  return true\n}\n\nfunction dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] &&\n      (view.editable || !(event.type in editHandlers)))\n    { handlers[event.type](view, event); }\n}\n\neditHandlers.keydown = function (view, event) {\n  view.shiftKey = event.keyCode == 16 || event.shiftKey;\n  if (view.inDOMChange) {\n    if (view.inDOMChange.composing) { return }\n    view.inDOMChange.finish();\n  }\n  view.lastKeyCode = event.keyCode;\n  view.lastKeyCodeTime = Date.now();\n  if (view.someProp(\"handleKeyDown\", function (f) { return f(view, event); }) || captureKeyDown(view, event))\n    { event.preventDefault(); }\n  else\n    { view.selectionReader.poll(\"key\"); }\n};\n\neditHandlers.keyup = function (view, e) {\n  if (e.keyCode == 16) { view.shiftKey = false; }\n};\n\neditHandlers.keypress = function (view, event) {\n  if (view.inDOMChange || !event.charCode ||\n      event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }\n\n  if (view.someProp(\"handleKeyPress\", function (f) { return f(view, event); })) {\n    event.preventDefault();\n    return\n  }\n\n  var sel = view.state.selection;\n  if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    var text = String.fromCharCode(event.charCode);\n    if (!view.someProp(\"handleTextInput\", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))\n      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }\n    event.preventDefault();\n  }\n};\n\nfunction eventCoords(event) { return {left: event.clientX, top: event.clientY} }\n\nvar lastClick = {time: 0, x: 0, y: 0, type: \"\"};\n\nfunction isNear(event, click) {\n  var dx = click.x - event.clientX, dy = click.y - event.clientY;\n  return dx * dx + dy * dy < 100\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside);\n  var loop = function ( i ) {\n    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))\n      { return { v: true } }\n  };\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var returned = loop( i );\n\n    if ( returned ) return returned.v;\n  }\n  return false\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) { view.focus(); }\n  var tr = view.state.tr.setSelection(selection);\n  if (origin == \"pointer\") { tr.setMeta(\"pointer\", true); }\n  view.dispatch(tr);\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) { return false }\n  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n  if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {\n    updateSelection(view, new prosemirrorState.NodeSelection($pos), \"pointer\");\n    return true\n  }\n  return false\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) { return false }\n  var sel = view.state.selection, selectedNode, selectAt;\n  if (sel instanceof prosemirrorState.NodeSelection) { selectedNode = sel.node; }\n\n  var $pos = view.state.doc.resolve(inside);\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    if (prosemirrorState.NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 &&\n          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        { selectAt = $pos.before(sel.$from.depth); }\n      else\n        { selectAt = $pos.before(i); }\n      break\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleClick\", function (f) { return f(view, pos, event); }) ||\n    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleDoubleClick\", function (f) { return f(view, pos, event); })\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n    view.someProp(\"handleTripleClick\", function (f) { return f(view, pos, event); }) ||\n    defaultTripleClick(view, inside)\n}\n\nfunction defaultTripleClick(view, inside) {\n  var doc = view.state.doc;\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, prosemirrorState.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n      return true\n    }\n    return false\n  }\n\n  var $pos = doc.resolve(inside);\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    var nodePos = $pos.before(i);\n    if (node.inlineContent)\n      { updateSelection(view, prosemirrorState.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\"); }\n    else if (prosemirrorState.NodeSelection.isSelectable(node))\n      { updateSelection(view, prosemirrorState.NodeSelection.create(doc, nodePos), \"pointer\"); }\n    else\n      { continue }\n    return true\n  }\n}\n\nfunction forceDOMFlush(view) {\n  if (!view.inDOMChange) { return false }\n  view.inDOMChange.finish(true);\n  return true\n}\n\nvar selectNodeModifier = result.mac ? \"metaKey\" : \"ctrlKey\";\n\nhandlers.mousedown = function (view, event) {\n  view.shiftKey = event.shiftKey;\n  var flushed = forceDOMFlush(view);\n  var now = Date.now(), type = \"singleClick\";\n  if (now - lastClick.time < 500 && isNear(event, lastClick) && !event[selectNodeModifier]) {\n    if (lastClick.type == \"singleClick\") { type = \"doubleClick\"; }\n    else if (lastClick.type == \"doubleClick\") { type = \"tripleClick\"; }\n  }\n  lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};\n\n  var pos = view.posAtCoords(eventCoords(event));\n  if (!pos) { return }\n\n  if (type == \"singleClick\")\n    { view.mouseDown = new MouseDown(view, pos, event, flushed); }\n  else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))\n    { event.preventDefault(); }\n  else\n    { view.selectionReader.poll(\"pointer\"); }\n};\n\nvar MouseDown = function MouseDown(view, pos, event, flushed) {\n  var this$1 = this;\n\n  this.view = view;\n  this.pos = pos;\n  this.event = event;\n  this.flushed = flushed;\n  this.selectNode = event[selectNodeModifier];\n  this.allowDefault = event.shiftKey;\n\n  var targetNode, targetPos;\n  if (pos.inside > -1) {\n    targetNode = view.state.doc.nodeAt(pos.inside);\n    targetPos = pos.inside;\n  } else {\n    var $pos = view.state.doc.resolve(pos.pos);\n    targetNode = $pos.parent;\n    targetPos = $pos.depth ? $pos.before() : 0;\n  }\n\n  this.mightDrag = null;\n  this.target = flushed ? null : event.target;\n  if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n      view.state.selection instanceof prosemirrorState.NodeSelection && targetPos == view.state.selection.from)\n    { this.mightDrag = {node: targetNode,\n                      pos: targetPos,\n                      addAttr: this.target && !this.target.draggable,\n                      setUneditable: this.target && result.gecko && !this.target.hasAttribute(\"contentEditable\")}; }\n\n  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n    this.view.domObserver.stop();\n    if (this.mightDrag.addAttr) { this.target.draggable = true; }\n    if (this.mightDrag.setUneditable)\n      { setTimeout(function () { return this$1.target.setAttribute(\"contentEditable\", \"false\"); }, 20); }\n    this.view.domObserver.start();\n  }\n\n  view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n  view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n  view.selectionReader.poll(\"pointer\");\n};\n\nMouseDown.prototype.done = function done () {\n  this.view.root.removeEventListener(\"mouseup\", this.up);\n  this.view.root.removeEventListener(\"mousemove\", this.move);\n  if (this.mightDrag && this.target) {\n    this.view.domObserver.stop();\n    if (this.mightDrag.addAttr) { this.target.draggable = false; }\n    if (this.mightDrag.setUneditable) { this.target.removeAttribute(\"contentEditable\"); }\n    this.view.domObserver.start();\n  }\n  this.view.mouseDown = null;\n};\n\nMouseDown.prototype.up = function up (event) {\n  this.done();\n\n  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))\n    { return }\n\n  if (this.allowDefault) {\n    // Force a cursor wrapper redraw if this was suppressed (to avoid an issue with IE drag-selection)\n    if (result.ie && needsCursorWrapper(this.view.state)) { this.view.updateState(this.view.state); }\n    this.view.selectionReader.poll(\"pointer\");\n  } else if (handleSingleClick(this.view, this.pos.pos, this.pos.inside, event, this.selectNode)) {\n    event.preventDefault();\n  } else if (this.flushed) {\n    updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(this.pos.pos)), \"pointer\");\n    event.preventDefault();\n  } else {\n    this.view.selectionReader.poll(\"pointer\");\n  }\n};\n\nMouseDown.prototype.move = function move (event) {\n  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n                             Math.abs(this.event.y - event.clientY) > 4))\n    { this.allowDefault = true; }\n  this.view.selectionReader.poll(\"pointer\");\n};\n\nhandlers.touchdown = function (view) {\n  forceDOMFlush(view);\n  view.selectionReader.poll(\"pointer\");\n};\n\nhandlers.contextmenu = function (view) { return forceDOMFlush(view); };\n\n// Input compositions are hard. Mostly because the events fired by\n// browsers are A) very unpredictable and inconsistent, and B) not\n// cancelable.\n//\n// ProseMirror has the problem that it must not update the DOM during\n// a composition, or the browser will cancel it. What it does is keep\n// long-running operations (delayed DOM updates) when a composition is\n// active.\n//\n// We _do not_ trust the information in the composition events which,\n// apart from being very uninformative to begin with, is often just\n// plain wrong. Instead, when a composition ends, we parse the dom\n// around the original selection, and derive an update from that.\n\neditHandlers.compositionstart = editHandlers.compositionupdate = function (view) {\n  DOMChange.start(view, true);\n};\n\neditHandlers.compositionend = function (view, e) {\n  if (!view.inDOMChange) {\n    // We received a compositionend without having seen any previous\n    // events for the composition. If there's data in the event\n    // object, we assume that it's a real change, and start a\n    // composition. Otherwise, we just ignore it.\n    if (e.data) { DOMChange.start(view, true); }\n    else { return }\n  }\n\n  view.inDOMChange.compositionEnd();\n};\n\neditHandlers.input = function (view) {\n  var change = DOMChange.start(view);\n  if (!change.composing) { change.finish(); }\n};\n\nfunction captureCopy(view, dom) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  var doc = dom.ownerDocument;\n  var wrap = doc.body.appendChild(doc.createElement(\"div\"));\n  wrap.appendChild(dom);\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  var sel = getSelection(), range = doc.createRange();\n  range.selectNodeContents(dom);\n  // Done because IE will fire a selectionchange moving the selection\n  // to its start when removeAllRanges is called and the editor still\n  // has focus (which will mess up the editor's selection state).\n  view.dom.blur();\n  sel.removeAllRanges();\n  sel.addRange(range);\n  setTimeout(function () {\n    doc.body.removeChild(wrap);\n    view.focus();\n  }, 50);\n}\n\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nvar brokenClipboardAPI = (result.ie && result.ie_version < 15) ||\n      (result.ios && result.webkit_version < 604);\n\nhandlers.copy = editHandlers.cut = function (view, e) {\n  var sel = view.state.selection, cut = e.type == \"cut\";\n  if (sel.empty) { return }\n\n  // IE and Edge's clipboard interface is completely broken\n  var data = brokenClipboardAPI ? null : e.clipboardData;\n  var slice = sel.content();\n  var ref = serializeForClipboard(view, slice);\n  var dom = ref.dom;\n  var text = ref.text;\n  if (data) {\n    e.preventDefault();\n    data.clearData();\n    data.setData(\"text/html\", dom.innerHTML);\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, dom);\n  }\n  if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\")); }\n};\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null\n}\n\nfunction capturePaste(view, e) {\n  var doc = view.dom.ownerDocument;\n  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;\n  var target = doc.body.appendChild(doc.createElement(plainText ? \"textarea\" : \"div\"));\n  if (!plainText) { target.contentEditable = \"true\"; }\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(function () {\n    view.focus();\n    doc.body.removeChild(target);\n    if (plainText) { doPaste(view, target.value, null, e); }\n    else { doPaste(view, target.textContent, target.innerHTML, e); }\n  }, 50);\n}\n\nfunction doPaste(view, text, html, e) {\n  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);\n  if (!slice) { return false }\n\n  if (view.someProp(\"handlePaste\", function (f) { return f(view, e, slice); })) { return true }\n\n  var singleNode = sliceSingleNode(slice);\n  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n  return true\n}\n\neditHandlers.paste = function (view, e) {\n  var data = brokenClipboardAPI ? null : e.clipboardData;\n  if (data && (doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), e) || data.files.length > 0))\n    { e.preventDefault(); }\n  else\n    { capturePaste(view, e); }\n};\n\nvar Dragging = function Dragging(slice, move) {\n  this.slice = slice;\n  this.move = move;\n};\n\nvar dragCopyModifier = result.mac ? \"altKey\" : \"ctrlKey\";\n\nhandlers.dragstart = function (view, e) {\n  var mouseDown = view.mouseDown;\n  if (mouseDown) { mouseDown.done(); }\n  if (!e.dataTransfer) { return }\n\n  var sel = view.state.selection;\n  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1: sel.to)) {\n    // In selection\n  } else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n  } else if (e.target && e.target.nodeType == 1) {\n    var desc = view.docView.nearestDesc(e.target, true);\n    if (!desc || !desc.node.type.spec.draggable || desc == view.docView) { return }\n    view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));\n  }\n  var slice = view.state.selection.content();\n  var ref = serializeForClipboard(view, slice);\n  var dom = ref.dom;\n  var text = ref.text;\n  e.dataTransfer.clearData();\n  e.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n  if (!brokenClipboardAPI) { e.dataTransfer.setData(\"text/plain\", text); }\n  view.dragging = new Dragging(slice, !e[dragCopyModifier]);\n};\n\nhandlers.dragend = function (view) {\n  window.setTimeout(function () { return view.dragging = null; }, 50);\n};\n\neditHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };\n\neditHandlers.drop = function (view, e) {\n  var dragging = view.dragging;\n  view.dragging = null;\n\n  if (!e.dataTransfer) { return }\n\n  var eventPos = view.posAtCoords(eventCoords(e));\n  if (!eventPos) { return }\n  var $mouse = view.state.doc.resolve(eventPos.pos);\n  if (!$mouse) { return }\n  var slice = dragging && dragging.slice ||\n      parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"),\n                         brokenClipboardAPI ? null : e.dataTransfer.getData(\"text/html\"), false, $mouse);\n  if (!slice) { return }\n\n  e.preventDefault();\n  if (view.someProp(\"handleDrop\", function (f) { return f(view, e, slice, dragging && dragging.move); })) { return }\n  var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n  if (insertPos == null) { insertPos = $mouse.pos; }\n\n  var tr = view.state.tr;\n  if (dragging && dragging.move) { tr.deleteSelection(); }\n\n  var pos = tr.mapping.map(insertPos);\n  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n  var beforeInsert = tr.doc;\n  if (isNode)\n    { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }\n  else\n    { tr.replaceRange(pos, pos, slice); }\n  if (tr.doc.eq(beforeInsert)) { return }\n\n  var $pos = tr.doc.resolve(pos);\n  if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) &&\n      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild))\n    { tr.setSelection(new prosemirrorState.NodeSelection($pos)); }\n  else\n    { tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(tr.mapping.map(insertPos)))); }\n  view.focus();\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\n\nhandlers.focus = function (view) {\n  if (!view.focused) {\n    view.dom.classList.add(\"ProseMirror-focused\");\n    view.focused = true;\n  }\n};\n\nhandlers.blur = function (view) {\n  if (view.focused) {\n    view.dom.classList.remove(\"ProseMirror-focused\");\n    view.focused = false;\n  }\n};\n\n// Make sure all handlers get registered\nfor (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }\n\nfunction compareObjs(a, b) {\n  if (a == b) { return true }\n  for (var p in a) { if (a[p] !== b[p]) { return false } }\n  for (var p$1 in b) { if (!(p$1 in a)) { return false } }\n  return true\n}\n\nvar WidgetType = function WidgetType(toDOM, spec) {\n  this.spec = spec || noSpec;\n  this.side = this.spec.side || 0;\n  this.toDOM = toDOM;\n};\n\nWidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n    var pos = ref.pos;\n    var deleted = ref.deleted;\n  return deleted ? null : new Decoration(pos - offset, pos - offset, this)\n};\n\nWidgetType.prototype.valid = function valid () { return true };\n\nWidgetType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof WidgetType &&\n     (this.spec.key && this.spec.key == other.spec.key ||\n      this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))\n};\n\nvar InlineType = function InlineType(attrs, spec) {\n  this.spec = spec || noSpec;\n  this.attrs = attrs;\n};\n\nInlineType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n  return from >= to ? null : new Decoration(from, to, this)\n};\n\nInlineType.prototype.valid = function valid (_, span) { return span.from < span.to };\n\nInlineType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.spec, other.spec))\n};\n\nInlineType.is = function is (span) { return span.type instanceof InlineType };\n\nvar NodeType = function NodeType(attrs, spec) {\n  this.spec = spec || noSpec;\n  this.attrs = attrs;\n};\n\nNodeType.prototype.map = function map (mapping, span, offset, oldOffset) {\n  var from = mapping.mapResult(span.from + oldOffset, 1);\n  if (from.deleted) { return null }\n  var to = mapping.mapResult(span.to + oldOffset, -1);\n  if (to.deleted || to.pos <= from.pos) { return null }\n  return new Decoration(from.pos - offset, to.pos - offset, this)\n};\n\nNodeType.prototype.valid = function valid (node, span) {\n  var ref = node.content.findIndex(span.from);\n    var index = ref.index;\n    var offset = ref.offset;\n  return offset == span.from && offset + node.child(index).nodeSize == span.to\n};\n\nNodeType.prototype.eq = function eq (other) {\n  return this == other ||\n    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n     compareObjs(this.spec, other.spec))\n};\n\n// ::- Decoration objects can be provided to the view through the\n// [`decorations` prop](#view.EditorProps.decorations). They come in\n// several variants—see the static members of this class for details.\nvar Decoration = function Decoration(from, to, type) {\n  // :: number\n  // The start position of the decoration.\n  this.from = from;\n  // :: number\n  // The end position. Will be the same as `from` for [widget\n  // decorations](#view.Decoration^widget).\n  this.to = to;\n  this.type = type;\n};\n\nvar prototypeAccessors$2 = { spec: {} };\n\nDecoration.prototype.copy = function copy (from, to) {\n  return new Decoration(from, to, this.type)\n};\n\nDecoration.prototype.eq = function eq (other) {\n  return this.type.eq(other.type) && this.from == other.from && this.to == other.to\n};\n\nDecoration.prototype.map = function map (mapping, offset, oldOffset) {\n  return this.type.map(mapping, this, offset, oldOffset)\n};\n\n// :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration\n// Creates a widget decoration, which is a DOM node that's shown in\n// the document at the given position. It is recommended that you\n// delay rendering the widget by passing a function that will be\n// called when the widget is actually drawn in a view, but you can\n// also directly pass a DOM node. `getPos` can be used to find the\n// widget's current document position.\n//\n// spec::- These options are supported:\n//\n//   side:: ?number\n//   Controls which side of the document position this widget is\n//   associated with. When negative, it is drawn before a cursor\n//   at its position, and content inserted at that position ends\n//   up after the widget. When zero (the default) or positive, the\n//   widget is drawn after the cursor and content inserted there\n//   ends up before the widget.\n//\n//   When there are multiple widgets at a given position, their\n//   `side` values determine the order in which they appear. Those\n//   with lower values appear first. The ordering of widgets with\n//   the same `side` value is unspecified.\n//\n//   When `marks` is null, `side` also determines the marks that\n//   the widget is wrapped in—those of the node before when\n//   negative, those of the node after when positive.\n//\n//   marks:: ?[Mark]\n//   The precise set of marks to draw around the widget.\n//\n//   stopEvent:: ?(event: dom.Event) → bool\n//   Can be used to control which DOM events, when they bubble out\n//   of this widget, the editor view should ignore.\n//\n//   key:: ?string\n//   When comparing decorations of this type (in order to decide\n//   whether it needs to be redrawn), ProseMirror will by default\n//   compare the widget DOM node by identity. If you pass a key,\n//   that key will be compared instead, which can be useful when\n//   you generate decorations on the fly and don't want to store\n//   and reuse DOM nodes. Make sure that any widgets with the same\n//   key are interchangeable—if widgets differ in, for example,\n//   the behavior of some event handler, they should get\n//   different keys.\nDecoration.widget = function widget (pos, toDOM, spec) {\n  return new Decoration(pos, pos, new WidgetType(toDOM, spec))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates an inline decoration, which adds the given attributes to\n// each inline node between `from` and `to`.\n//\n// spec::- These options are recognized:\n//\n//   inclusiveStart:: ?bool\n//   Determines how the left side of the decoration is\n//   [mapped](#transform.Position_Mapping) when content is\n//   inserted directly at that position. By default, the decoration\n//   won't include the new content, but you can set this to `true`\n//   to make it inclusive.\n//\n//   inclusiveEnd:: ?bool\n//   Determines how the right side of the decoration is mapped.\n//   See\n//   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).\nDecoration.inline = function inline (from, to, attrs, spec) {\n  return new Decoration(from, to, new InlineType(attrs, spec))\n};\n\n// :: (number, number, DecorationAttrs, ?Object) → Decoration\n// Creates a node decoration. `from` and `to` should point precisely\n// before and after a node in the document. That node, and only that\n// node, will receive the given attributes.\nDecoration.node = function node (from, to, attrs, spec) {\n  return new Decoration(from, to, new NodeType(attrs, spec))\n};\n\n// :: Object\n// The spec provided when creating this decoration. Can be useful\n// if you've stored extra information in that object.\nprototypeAccessors$2.spec.get = function () { return this.type.spec };\n\nObject.defineProperties( Decoration.prototype, prototypeAccessors$2 );\n\n// DecorationAttrs:: interface\n// A set of attributes to add to a decorated node. Most properties\n// simply directly correspond to DOM attributes of the same name,\n// which will be set to the property's value. These are exceptions:\n//\n//   class:: ?string\n//   A CSS class name or a space-separated set of class names to be\n//   _added_ to the classes that the node already had.\n//\n//   style:: ?string\n//   A string of CSS to be _added_ to the node's existing `style` property.\n//\n//   nodeName:: ?string\n//   When non-null, the target node is wrapped in a DOM element of\n//   this type (and the other attributes are applied to this element).\n\nvar none = [];\nvar noSpec = {};\n\n// ::- A collection of [decorations](#view.Decoration), organized in\n// such a way that the drawing algorithm can efficiently use and\n// compare them. This is a persistent data structure—it is not\n// modified, updates create a new value.\nvar DecorationSet = function DecorationSet(local, children) {\n  this.local = local && local.length ? local : none;\n  this.children = children && children.length ? children : none;\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Create a set of decorations, using the structure of the given\n// document.\nDecorationSet.create = function create (doc, decorations) {\n  return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty\n};\n\n// :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]\n// Find all decorations in this set which touch the given range\n// (including decorations that start or end directly at the\n// boundaries) and match the given predicate on their spec. When\n// `start` and `end` are omitted, all decorations in the set are\n// considered. When `predicate` isn't given, all decorations are\n// asssumed to match.\nDecorationSet.prototype.find = function find (start, end, predicate) {\n  var result = [];\n  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n  return result\n};\n\nDecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.local.length; i++) {\n    var span = this$1.local[i];\n    if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n      { result.push(span.copy(span.from + offset, span.to + offset)); }\n  }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {\n    if (this$1.children[i$1] < end && this$1.children[i$1 + 1] > start) {\n      var childOff = this$1.children[i$1] + 1;\n      this$1.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n    }\n  }\n};\n\n// :: (Mapping, Node, ?Object) → DecorationSet\n// Map the set of decorations in response to a change in the\n// document.\n//\n// options::- An optional set of options.\n//\n//   onRemove:: ?(decorationSpec: Object)\n//   When given, this function will be called for each decoration\n//   that gets dropped as a result of the mapping, passing the\n//   spec of that decoration.\nDecorationSet.prototype.map = function map (mapping, doc, options) {\n  if (this == empty || mapping.maps.length == 0) { return this }\n  return this.mapInner(mapping, doc, 0, 0, options || noSpec)\n};\n\nDecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {\n    var this$1 = this;\n\n  var newLocal;\n  for (var i = 0; i < this.local.length; i++) {\n    var mapped = this$1.local[i].map(mapping, offset, oldOffset);\n    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }\n    else if (options.onRemove) { options.onRemove(this$1.local[i].spec); }\n  }\n\n  if (this.children.length)\n    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }\n  else\n    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }\n};\n\n// :: (Node, [Decoration]) → DecorationSet\n// Add the given array of decorations to the ones in the set,\n// producing a new set. Needs access to the current document to\n// create the appropriate tree structure.\nDecorationSet.prototype.add = function add (doc, decorations) {\n  if (!decorations.length) { return this }\n  if (this == empty) { return DecorationSet.create(doc, decorations) }\n  return this.addInner(doc, decorations, 0)\n};\n\nDecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {\n    var this$1 = this;\n\n  var children, childIndex = 0;\n  doc.forEach(function (childNode, childOffset) {\n    var baseOffset = childOffset + offset, found;\n    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }\n\n    if (!children) { children = this$1.children.slice(); }\n    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }\n    if (children[childIndex] == childOffset)\n      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }\n    else\n      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }\n    childIndex += 3;\n  });\n\n  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,\n                           children || this.children)\n};\n\n// :: ([Decoration]) → DecorationSet\n// Create a new set that contains the decorations in this set, minus\n// the ones in the given array.\nDecorationSet.prototype.remove = function remove (decorations) {\n  if (decorations.length == 0 || this == empty) { return this }\n  return this.removeInner(decorations, 0)\n};\n\nDecorationSet.prototype.removeInner = function removeInner (decorations, offset) {\n    var this$1 = this;\n\n  var children = this.children, local = this.local;\n  for (var i = 0; i < children.length; i += 3) {\n    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;\n    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {\n      if (span.from > from && span.to < to) {\n        decorations[j] = null\n        ;(found || (found = [])).push(span);\n      }\n    } }\n    if (!found) { continue }\n    if (children == this$1.children) { children = this$1.children.slice(); }\n    var removed = children[i + 2].removeInner(found, from + 1);\n    if (removed != empty) {\n      children[i + 2] = removed;\n    } else {\n      children.splice(i, 3);\n      i -= 3;\n    }\n  }\n  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {\n    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].type.eq(span$1.type)) {\n      if (local == this$1.local) { local = this$1.local.slice(); }\n      local.splice(j$1--, 1);\n    } }\n  } } }\n  if (children == this.children && local == this.local) { return this }\n  return local.length || children.length ? new DecorationSet(local, children) : empty\n};\n\nDecorationSet.prototype.forChild = function forChild (offset, node) {\n    var this$1 = this;\n\n  if (this == empty) { return this }\n  if (node.isLeaf) { return DecorationSet.empty }\n\n  var child, local;\n  for (var i = 0; i < this.children.length; i += 3) { if (this$1.children[i] >= offset) {\n    if (this$1.children[i] == offset) { child = this$1.children[i + 2]; }\n    break\n  } }\n  var start = offset + 1, end = start + node.content.size;\n  for (var i$1 = 0; i$1 < this.local.length; i$1++) {\n    var dec = this$1.local[i$1];\n    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n      if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }\n    }\n  }\n  if (local) {\n    var localSet = new DecorationSet(local.sort(byPos));\n    return child ? new DecorationGroup([localSet, child]) : localSet\n  }\n  return child || empty\n};\n\nDecorationSet.prototype.eq = function eq (other) {\n    var this$1 = this;\n\n  if (this == other) { return true }\n  if (!(other instanceof DecorationSet) ||\n      this.local.length != other.local.length ||\n      this.children.length != other.children.length) { return false }\n  for (var i = 0; i < this.local.length; i++)\n    { if (!this$1.local[i].eq(other.local[i])) { return false } }\n  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)\n    { if (this$1.children[i$1] != other.children[i$1] ||\n        this$1.children[i$1 + 1] != other.children[i$1 + 1] ||\n        !this$1.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }\n  return false\n};\n\nDecorationSet.prototype.locals = function locals (node) {\n  return removeOverlap(this.localsInner(node))\n};\n\nDecorationSet.prototype.localsInner = function localsInner (node) {\n    var this$1 = this;\n\n  if (this == empty) { return none }\n  if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }\n  var result = [];\n  for (var i = 0; i < this.local.length; i++) {\n    if (!(this$1.local[i].type instanceof InlineType))\n      { result.push(this$1.local[i]); }\n  }\n  return result\n};\n\nvar empty = new DecorationSet();\n\n// :: DecorationSet\n// The empty set of decorations.\nDecorationSet.empty = empty;\n\nDecorationSet.removeOverlap = removeOverlap;\n\n// :- An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nvar DecorationGroup = function DecorationGroup(members) {\n  this.members = members;\n};\n\nDecorationGroup.prototype.forChild = function forChild (offset, child) {\n    var this$1 = this;\n\n  if (child.isLeaf) { return DecorationSet.empty }\n  var found = [];\n  for (var i = 0; i < this.members.length; i++) {\n    var result = this$1.members[i].forChild(offset, child);\n    if (result == empty) { continue }\n    if (result instanceof DecorationGroup) { found = found.concat(result.members); }\n    else { found.push(result); }\n  }\n  return DecorationGroup.from(found)\n};\n\nDecorationGroup.prototype.eq = function eq (other) {\n    var this$1 = this;\n\n  if (!(other instanceof DecorationGroup) ||\n      other.members.length != this.members.length) { return false }\n  for (var i = 0; i < this.members.length; i++)\n    { if (!this$1.members[i].eq(other.members[i])) { return false } }\n  return true\n};\n\nDecorationGroup.prototype.locals = function locals (node) {\n    var this$1 = this;\n\n  var result, sorted = true;\n  for (var i = 0; i < this.members.length; i++) {\n    var locals = this$1.members[i].localsInner(node);\n    if (!locals.length) { continue }\n    if (!result) {\n      result = locals;\n    } else {\n      if (sorted) {\n        result = result.slice();\n        sorted = false;\n      }\n      for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }\n    }\n  }\n  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none\n};\n\n// : ([DecorationSet]) → union<DecorationSet, DecorationGroup>\n// Create a group for the given array of decoration sets, or return\n// a single set when possible.\nDecorationGroup.from = function from (members) {\n  switch (members.length) {\n    case 0: return empty\n    case 1: return members[0]\n    default: return new DecorationGroup(members)\n  }\n};\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  var children = oldChildren.slice();\n\n  // Mark the children that are directly touched by changes, and\n  // move those that are after the changes.\n  var shift = function (oldStart, oldEnd, newStart, newEnd) {\n    for (var i = 0; i < children.length; i += 3) {\n      var end = children[i + 1], dSize = (void 0);\n      if (end == -1 || oldStart > end + oldOffset) { continue }\n      if (oldEnd >= children[i] + oldOffset) {\n        children[i + 1] = -1;\n      } else if (dSize = (newEnd - newStart) - (oldEnd - oldStart) + (oldOffset - offset)) {\n        children[i] += dSize;\n        children[i + 1] += dSize;\n      }\n    }\n  };\n  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }\n\n  // Find the child nodes that still correspond to a single node,\n  // recursively call mapInner on them and update their positions.\n  var mustRebuild = false;\n  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes\n    var from = mapping.map(children[i$1] + oldOffset), fromLocal = from - offset;\n    if (fromLocal < 0 || fromLocal >= node.content.size) {\n      mustRebuild = true;\n      continue\n    }\n    // Must read oldChildren because children was tagged with -1\n    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;\n    var ref = node.content.findIndex(fromLocal);\n    var index = ref.index;\n    var childOffset = ref.offset;\n    var childNode = node.maybeChild(index);\n    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, children[i$1] + oldOffset + 1, options);\n      if (mapped != empty) {\n        children[i$1] = fromLocal;\n        children[i$1 + 1] = toLocal;\n        children[i$1 + 2] = mapped;\n      } else {\n        children[i$1 + 1] = -2;\n        mustRebuild = true;\n      }\n    } else {\n      mustRebuild = true;\n    }\n  } }\n\n  // Remaining children must be collected and rebuilt into the appropriate structure\n  if (mustRebuild) {\n    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,\n                                                       offset, oldOffset, options);\n    var built = buildTree(decorations, node, 0, options);\n    newLocal = built.local;\n    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {\n      children.splice(i$2, 3);\n      i$2 -= 3;\n    } }\n    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {\n      var from$1 = built.children[i$3];\n      while (j < children.length && children[j] < from$1) { j += 3; }\n      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);\n    }\n  }\n\n  return new DecorationSet(newLocal && newLocal.sort(byPos), children)\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) { return spans }\n  var result = [];\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i];\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n  }\n  return result\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  // Gather all decorations from the remaining marked children\n  function gather(set, oldOffset) {\n    for (var i = 0; i < set.local.length; i++) {\n      var mapped = set.local[i].map(mapping, offset, oldOffset);\n      if (mapped) { decorations.push(mapped); }\n      else if (options.onRemove) { options.onRemove(set.local[i].spec); }\n    }\n    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)\n      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }\n  }\n  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)\n    { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }\n\n  return decorations\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) { return null }\n  var end = offset + node.nodeSize, found = null;\n  for (var i = 0, span = (void 0); i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      (found || (found = [])).push(span);\n      spans[i] = null;\n    }\n  }\n  return found\n}\n\nfunction withoutNulls(array) {\n  var result = [];\n  for (var i = 0; i < array.length; i++)\n    { if (array[i] != null) { result.push(array[i]); } }\n  return result\n}\n\n// : ([Decoration], Node, number) → DecorationSet\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtractet from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n  var children = [], hasNulls = false;\n  node.forEach(function (childNode, localStart) {\n    var found = takeSpansForNode(spans, childNode, localStart + offset);\n    if (found) {\n      hasNulls = true;\n      var subtree = buildTree(found, childNode, offset + localStart + 1, options);\n      if (subtree != empty)\n        { children.push(localStart, localStart + childNode.nodeSize, subtree); }\n    }\n  });\n  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {\n    if (options.onRemove) { options.onRemove(locals[i].spec); }\n    locals.splice(i--, 1);\n  } }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty\n}\n\n// : (Decoration, Decoration) → number\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to\n}\n\n// : ([Decoration]) → [Decoration]\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n  var working = spans;\n  for (var i = 0; i < working.length - 1; i++) {\n    var span = working[i];\n    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {\n      var next = working[j];\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) { working = spans.slice(); }\n          // Followed by a partially overlapping larger span. Split that\n          // span.\n          working[j] = next.copy(next.from, span.to);\n          insertAhead(working, j + 1, next.copy(span.to, next.to));\n        }\n        continue\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) { working = spans.slice(); }\n          // The end of this one overlaps with a subsequent span. Split\n          // this one.\n          working[i] = span.copy(span.from, next.from);\n          insertAhead(working, j, span.copy(next.from, span.to));\n        }\n        break\n      }\n    } }\n  }\n  return working\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) { i++; }\n  array.splice(i, 0, deco);\n}\n\n// : (EditorView) → union<DecorationSet, DecorationGroup>\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n  var found = [];\n  view.someProp(\"decorations\", function (f) {\n    var result = f(view.state);\n    if (result && result != empty) { found.push(result); }\n  });\n  if (view.cursorWrapper)\n    { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }\n  return DecorationGroup.from(found)\n}\n\n// ::- An editor view manages the DOM structure that represents an\n// editable document. Its state and behavior are determined by its\n// [props](#view.DirectEditorProps).\nvar EditorView = function EditorView(place, props) {\n  this._props = props;\n  // :: EditorState\n  // The view's current [state](#state.EditorState).\n  this.state = props.state;\n\n  this.dispatch = this.dispatch.bind(this);\n\n  this._root = null;\n  this.focused = false;\n\n  // :: dom.Element\n  // An editable DOM node containing the document. (You probably\n  // should not directly interfere with its content.)\n  this.dom = (place && place.mount) || document.createElement(\"div\");\n  if (place) {\n    if (place.appendChild) { place.appendChild(this.dom); }\n    else if (place.apply) { place(this.dom); }\n    else if (place.mount) { this.mounted = true; }\n  }\n\n  this.editable = getEditable(this);\n  this.redraw = false;\n  this.cursorWrapper = null;\n  updateCursorWrapper(this);\n  this.nodeViews = buildNodeViews(this);\n  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n\n  this.lastSelectedViewDesc = null;\n  // :: ?{slice: Slice, move: bool}\n  // When editor content is being dragged, this object contains\n  // information about the dragged slice and whether it is being\n  // copied or moved. At any other time, it is null.\n  this.dragging = null;\n  initInput(this); // Must be done before creating a SelectionReader\n\n  this.selectionReader = new SelectionReader(this);\n\n  this.pluginViews = [];\n  this.updatePluginViews();\n};\n\nvar prototypeAccessors = { props: {},root: {} };\n\n// :: DirectEditorProps\n// The view's current [props](#view.EditorProps).\nprototypeAccessors.props.get = function () {\n    var this$1 = this;\n\n  if (this._props.state != this.state) {\n    var prev = this._props;\n    this._props = {};\n    for (var name in prev) { this$1._props[name] = prev[name]; }\n    this._props.state = this.state;\n  }\n  return this._props\n};\n\n// :: (DirectEditorProps)\n// Update the view's props. Will immediately cause an update to\n// the DOM.\nEditorView.prototype.update = function update (props) {\n  if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }\n  this._props = props;\n  var nodeViews = buildNodeViews(this);\n  if (changedNodeViews(nodeViews, this.nodeViews)) {\n    this.nodeViews = nodeViews;\n    this.redraw = true;\n  }\n  this.updateState(props.state);\n};\n\n// :: (DirectEditorProps)\n// Update the view by updating existing props object with the object\n// given as argument. Equivalent to `view.update(Object.assign({},\n// view.props, props))`.\nEditorView.prototype.setProps = function setProps (props) {\n    var this$1 = this;\n\n  var updated = {};\n  for (var name in this$1._props) { updated[name] = this$1._props[name]; }\n  updated.state = this.state;\n  for (var name$1 in props) { updated[name$1] = props[name$1]; }\n  this.update(updated);\n};\n\n// :: (EditorState)\n// Update the editor's `state` prop, without touching any of the\n// other props.\nEditorView.prototype.updateState = function updateState (state) {\n    var this$1 = this;\n\n  var prev = this.state;\n  this.state = state;\n  if (prev.plugins != state.plugins) { ensureListeners(this); }\n\n  this.domObserver.flush();\n  if (this.inDOMChange && this.inDOMChange.stateUpdated(state)) { return }\n\n  var prevEditable = this.editable;\n  this.editable = getEditable(this);\n  updateCursorWrapper(this);\n  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n\n  var scroll = prev.config != state.config ? \"reset\"\n      : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n  var updateDoc = this.redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n  var updateSel = updateDoc || !state.selection.eq(prev.selection) || this.selectionReader.domChanged();\n  var oldScrollPos = scroll == \"preserve\" && updateSel && storeScrollPos(this);\n\n  if (updateSel) {\n    this.domObserver.stop();\n    var forceSelUpdate = false;\n    if (updateDoc) {\n      // Work around an issue in Chrome where changing the DOM\n      // around the active selection puts it into a broken state\n      // where the thing the user sees differs from the selection\n      // reported by the Selection object (#710)\n      var startSelContext = result.chrome && selectionContext(this.root);\n      if (this.redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n        this.docView.destroy();\n        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n        this.redraw = false;\n      }\n      this.selectionReader.clearDOMState();\n      if (startSelContext)\n        { forceSelUpdate = needChromeSelectionForce(startSelContext, this.root); }\n    }\n    selectionToDOM(this, false, forceSelUpdate);\n    this.domObserver.start();\n  }\n\n  if (prevEditable != this.editable) { this.selectionReader.editableChanged(); }\n  this.updatePluginViews(prev);\n\n  if (scroll == \"reset\") {\n    this.dom.scrollTop = 0;\n  } else if (scroll == \"to selection\") {\n    var startDOM = this.root.getSelection().focusNode;\n    if (this.someProp(\"handleScrollToSelection\", function (f) { return f(this$1); }))\n      {} // Handled\n    else if (state.selection instanceof prosemirrorState.NodeSelection)\n      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }\n    else\n      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head), startDOM); }\n  } else if (oldScrollPos) {\n    resetScrollPos(oldScrollPos);\n  }\n};\n\nEditorView.prototype.destroyPluginViews = function destroyPluginViews () {\n  var view;\n  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }\n};\n\nEditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {\n    var this$1 = this;\n\n  var plugins = this.state.plugins;\n  if (!prevState || prevState.plugins != plugins) {\n    this.destroyPluginViews();\n    for (var i = 0; i < plugins.length; i++) {\n      var plugin = plugins[i];\n      if (plugin.spec.view) { this$1.pluginViews.push(plugin.spec.view(this$1)); }\n    }\n  } else {\n    for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {\n      var pluginView = this$1.pluginViews[i$1];\n      if (pluginView.update) { pluginView.update(this$1, prevState); }\n    }\n  }\n};\n\n// :: (string, ?(prop: *) → *) → *\n// Goes over the values of a prop, first those provided directly,\n// then those from plugins (in order), and calls `f` every time a\n// non-undefined value is found. When `f` returns a truthy value,\n// that is immediately returned. When `f` isn't provided, it is\n// treated as the identity function (the prop value is returned\n// directly).\nEditorView.prototype.someProp = function someProp (propName, f) {\n  var prop = this._props && this._props[propName], value;\n  if (prop != null && (value = f ? f(prop) : prop)) { return value }\n  var plugins = this.state.plugins;\n  if (plugins) { for (var i = 0; i < plugins.length; i++) {\n    var prop$1 = plugins[i].props[propName];\n    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }\n  } }\n};\n\n// :: () → bool\n// Query whether the view has focus.\nEditorView.prototype.hasFocus = function hasFocus () {\n  return this.root.activeElement == this.dom\n};\n\n// :: ()\n// Focus the editor.\nEditorView.prototype.focus = function focus () {\n  this.domObserver.stop();\n  selectionToDOM(this, true);\n  this.domObserver.start();\n  if (this.editable) { this.dom.focus(); }\n};\n\n// :: union<dom.Document, dom.DocumentFragment>\n// Get the document root in which the editor exists. This will\n// usually be the top-level `document`, but might be a [shadow\n// DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n// root if the editor is inside one.\nprototypeAccessors.root.get = function () {\n    var this$1 = this;\n\n  var cached = this._root;\n  if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {\n    if (search.nodeType == 9 || (search.nodeType == 11 && search.host))\n      { return this$1._root = search }\n  } }\n  return cached || document\n};\n\n// :: ({left: number, top: number}) → ?{pos: number, inside: number}\n// Given a pair of viewport coordinates, return the document\n// position that corresponds to them. May return null if the given\n// coordinates aren't inside of the visible editor. When an object\n// is returned, its `pos` property is the position nearest to the\n// coordinates, and its `inside` property holds the position of the\n// inner node that the position falls inside of, or -1 if it is at\n// the top level, not in any node.\nEditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {\n  var pos = posAtCoords(this, coords);\n  if (this.inDOMChange && pos) {\n    pos.pos = this.inDOMChange.mapping.map(pos.pos);\n    if (pos.inside != -1) { pos.inside = this.inDOMChange.mapping.map(pos.inside); }\n  }\n  return pos\n};\n\n// :: (number) → {left: number, right: number, top: number, bottom: number}\n// Returns the viewport rectangle at a given document position. `left`\n// and `right` will be the same number, as this returns a flat\n// cursor-ish rectangle.\nEditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos) {\n  if (this.inDOMChange)\n    { pos = this.inDOMChange.mapping.invert().map(pos); }\n  return coordsAtPos(this, pos)\n};\n\n// :: (number) → {node: dom.Node, offset: number}\n// Find the DOM position that corresponds to the given document\n// position. Note that you should **not** mutate the editor's\n// internal DOM, only inspect it (and even that is usually not\n// necessary).\nEditorView.prototype.domAtPos = function domAtPos (pos) {\n  if (this.inDOMChange)\n    { pos = this.inDOMChange.mapping.invert().map(pos); }\n  return this.docView.domFromPos(pos)\n};\n\n// :: (number) → ?dom.Node\n// Find the DOM node that represents the document node after the\n// given position. May return `null` when the position doesn't point\n// in front of a node or if the node is inside an opaque node view.\n//\n// This is intended to be able to call things like\n// `getBoundingClientRect` on that DOM node. Do **not** mutate the\n// editor DOM directly, or add styling this way, since that will be\n// immediately overriden by the editor as it redraws the node.\nEditorView.prototype.nodeDOM = function nodeDOM (pos) {\n  if (this.inDOMChange)\n    { pos = this.inDOMChange.mapping.invert().map(pos); }\n  var desc = this.docView.descAt(pos);\n  return desc ? desc.nodeDOM : null\n};\n\n// :: (dom.Node, number, ?number) → number\n// Find the document position that corresponds to a given DOM\n// position. (Whenever possible, it is preferable to inspect the\n// document structure directly, rather than poking around in the\n// DOM, but sometimes—for example when interpreting an event\n// target—you don't have a choice.)\n//\n// The `bias` parameter can be used to influence which side of a DOM\n// node to use when the position is inside a leaf node.\nEditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {\n    if ( bias === void 0 ) bias = -1;\n\n  var pos = this.docView.posFromDOM(node, offset, bias);\n  if (pos == null) { throw new RangeError(\"DOM position not inside the editor\") }\n  if (this.inDOMChange)\n    { pos = this.inDOMChange.mapping.map(pos); }\n  return pos\n};\n\n// :: (union<\"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\">, ?EditorState) → bool\n// Find out whether the selection is at the end of a textblock when\n// moving in a given direction. When, for example, given `\"left\"`,\n// it will return true if moving left from the current cursor\n// position would leave that position's parent textblock. Will apply\n// to the view's current state by default, but it is possible to\n// pass a different state.\nEditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {\n  return endOfTextblock(this, state || this.state, dir)\n};\n\n// :: ()\n// Removes the editor from the DOM and destroys all [node\n// views](#view.NodeView).\nEditorView.prototype.destroy = function destroy () {\n  if (!this.docView) { return }\n  destroyInput(this);\n  this.destroyPluginViews();\n  this.selectionReader.destroy();\n  if (this.mounted) {\n    this.docView.update(this.state.doc, [], viewDecorations(this), this);\n    this.dom.textContent = \"\";\n  } else if (this.dom.parentNode) {\n    this.dom.parentNode.removeChild(this.dom);\n  }\n  this.docView.destroy();\n  this.docView = null;\n};\n\n// Used for testing.\nEditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {\n  return dispatchEvent(this, event)\n};\n\n// :: (Transaction)\n// Dispatch a transaction. Will call\n// [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)\n// when given, and otherwise defaults to applying the transaction to\n// the current state and calling\n// [`updateState`](#view.EditorView.updateState) with the result.\n// This method is bound to the view instance, so that it can be\n// easily passed around.\nEditorView.prototype.dispatch = function dispatch (tr) {\n  var dispatchTransaction = this._props.dispatchTransaction;\n  if (dispatchTransaction) { dispatchTransaction.call(this, tr); }\n  else { this.updateState(this.state.apply(tr)); }\n};\n\nObject.defineProperties( EditorView.prototype, prototypeAccessors );\n\nfunction computeDocDeco(view) {\n  var attrs = Object.create(null);\n  attrs.class = \"ProseMirror\" + (view.focused ? \" ProseMirror-focused\" : \"\");\n  attrs.contenteditable = String(view.editable);\n\n  view.someProp(\"attributes\", function (value) {\n    if (typeof value == \"function\") { value = value(view.state); }\n    if (value) { for (var attr in value) {\n      if (attr == \"class\")\n        { attrs.class += \" \" + value[attr]; }\n      else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n        { attrs[attr] = String(value[attr]); }\n    } }\n  });\n\n  return [Decoration.node(0, view.state.doc.content.size, attrs)]\n}\n\nfunction cursorWrapperDOM(visible) {\n  var span = document.createElement(\"span\");\n  span.textContent = \"\\ufeff\"; // zero-width non-breaking space\n  if (!visible) {\n    span.style.position = \"absolute\";\n    span.style.left = \"-100000px\";\n  }\n  return span\n}\n\nfunction updateCursorWrapper(view) {\n  var $pos = needsCursorWrapper(view.state);\n  // On IE/Edge, moving the DOM selection will abort a mouse drag, so\n  // there we delay the creation of the wrapper when the mouse is down.\n  if ($pos && !(result.ie && view.mouseDown)) {\n    var visible = view.state.selection.visible;\n    // Needs a cursor wrapper\n    var marks = view.state.storedMarks || $pos.marks(), dom;\n    if (!view.cursorWrapper || !prosemirrorModel.Mark.sameSet(view.cursorWrapper.deco.spec.marks, marks) ||\n        view.cursorWrapper.dom.textContent != \"\\ufeff\" ||\n        view.cursorWrapper.deco.spec.visible != visible)\n      { dom = cursorWrapperDOM(visible); }\n    else if (view.cursorWrapper.deco.pos != $pos.pos)\n      { dom = view.cursorWrapper.dom; }\n    if (dom)\n      { view.cursorWrapper = {dom: dom, deco: Decoration.widget($pos.pos, dom, {isCursorWrapper: true, marks: marks, raw: true, visible: visible})}; }\n  } else {\n    view.cursorWrapper = null;\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", function (value) { return value(view.state) === false; })\n}\n\nfunction selectionContext(root) {\n  var ref = root.getSelection();\n  var offset = ref.focusOffset;\n  var node = ref.focusNode;\n  if (!node || node.nodeType == 3) { return null }\n  return [node, offset,\n          node.nodeType == 1 ? node.childNodes[offset - 1] : null,\n          node.nodeType == 1 ? node.childNodes[offset] : null]\n}\n\nfunction needChromeSelectionForce(context, root) {\n  var newContext = selectionContext(root);\n  if (!newContext || newContext[0].nodeType == 3) { return false }\n  for (var i = 0; i < context.length; i++) { if (newContext[i] != context[i]) { return true } }\n  return false\n}\n\nfunction buildNodeViews(view) {\n  var result$$1 = {};\n  view.someProp(\"nodeViews\", function (obj) {\n    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result$$1, prop))\n      { result$$1[prop] = obj[prop]; } }\n  });\n  return result$$1\n}\n\nfunction changedNodeViews(a, b) {\n  var nA = 0, nB = 0;\n  for (var prop in a) {\n    if (a[prop] != b[prop]) { return true }\n    nA++;\n  }\n  for (var _ in b) { nB++; }\n  return nA != nB\n}\n\n// EditorProps:: interface\n//\n// Props are configuration values that can be passed to an editor view\n// or included in a plugin. This interface lists the supported props.\n//\n// The various event-handling functions may all return `true` to\n// indicate that they handled the given event. The view will then take\n// care to call `preventDefault` on the event, except with\n// `handleDOMEvents`, where the handler itself is responsible for that.\n//\n// How a prop is resolved depends on the prop. Handler functions are\n// called one at a time, starting with the base props and then\n// searching through the plugins (in order of appearance) until one of\n// them returns true. For some props, the first plugin that yields a\n// value gets precedence.\n//\n//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>\n//   Can be an object mapping DOM event type names to functions that\n//   handle them. Such functions will be called before any handling\n//   ProseMirror does of events fired on the editable DOM element.\n//   Contrary to the other event handling props, when returning true\n//   from such a function, you are responsible for calling\n//   `preventDefault` yourself (or not, if you want to allow the\n//   default behavior).\n//\n//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Called when the editor receives a `keydown` event.\n//\n//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool\n//   Handler for `keypress` events.\n//\n//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool\n//   Whenever the user directly input text, this handler is called\n//   before the input is applied. If it returns `true`, the default\n//   behavior of actually inserting the text is suppressed.\n//\n//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a click, from the inside out. The\n//   `direct` flag will be true for the inner node.\n//\n//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is clicked, after `handleClickOn` handlers\n//   have been called.\n//\n//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a double click.\n//\n//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is double-clicked, after `handleDoubleClickOn`.\n//\n//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool\n//   Called for each node around a triple click.\n//\n//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool\n//   Called when the editor is triple-clicked, after `handleTripleClickOn`.\n//\n//   handlePaste:: ?(view: EditorView, event: dom.Event, slice: Slice) → bool\n//   Can be used to override the behavior of pasting. `slice` is the\n//   pasted content parsed by the editor, but you can directly access\n//   the event to get at the raw content.\n//\n//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool\n//   Called when something is dropped on the editor. `moved` will be\n//   true if this drop moves from the current selection (which should\n//   thus be deleted).\n//\n//   handleScrollToSelection:: ?(view: EditorView) → bool\n//   Called when the view, after updating its state, tries to scroll\n//   the selection into view. A handler function may return false to\n//   indicate that it did not handle the scrolling and further\n//   handlers or the default behavior should be tried.\n//\n//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection\n//   Can be used to override the way a selection is created when\n//   reading a DOM selection between the given anchor and head.\n//\n//   domParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading editor changes\n//   from the DOM. Defaults to calling\n//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the\n//   editor's schema.\n//\n//   transformPastedHTML:: ?(html: string) → string\n//   Can be used to transform pasted HTML text, _before_ it is parsed,\n//   for example to clean it up.\n//\n//   clipboardParser:: ?DOMParser\n//   The [parser](#model.DOMParser) to use when reading content from\n//   the clipboard. When not given, the value of the\n//   [`domParser`](#view.EditorProps.domParser) prop is used.\n//\n//   transformPastedText:: ?(text: string) → string\n//   Transform pasted plain text.\n//\n//   clipboardTextParser:: ?(text: string, $context: ResolvedPos) → Slice\n//   A function to parse text from the clipboard into a document\n//   slice. Called after\n//   [`transformPastedText`](#view.EditorProps.transformPastedText).\n//   The default behavior is to split the text into lines, wrap them\n//   in `<p>` tags, and call\n//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.\n//\n//   transformPasted:: ?(Slice) → Slice\n//   Can be used to transform pasted content before it is applied to\n//   the document.\n//\n//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration]) → NodeView>\n//   Allows you to pass custom rendering and behavior logic for nodes\n//   and marks. Should map node and mark names to constructor\n//   functions that produce a [`NodeView`](#view.NodeView) object\n//   implementing the node's display behavior. For nodes, the third\n//   argument `getPos` is a function that can be called to get the\n//   node's current position, which can be useful when creating\n//   transactions to update it. For marks, the third argument is a\n//   boolean that indicates whether the mark's content is inline.\n//\n//   `decorations` is an array of node or inline decorations that are\n//   active around the node. They are automatically drawn in the\n//   normal way, and you will usually just want to ignore this, but\n//   they can also be used as a way to provide context information to\n//   the node view without adding it to the document itself.\n//\n//   clipboardSerializer:: ?DOMSerializer\n//   The DOM serializer to use when putting content onto the\n//   clipboard. If not given, the result of\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)\n//   will be used.\n//\n//   clipboardTextSerializer:: ?(Slice) → string\n//   A function that will be called to get the text for the current\n//   selection when copying text to the clipboard. By default, the\n//   editor will use [`textBetween`](#model.Node.textBetween) on the\n//   selected range.\n//\n//   decorations:: ?(state: EditorState) → ?DecorationSet\n//   A set of [document decorations](#view.Decoration) to show in the\n//   view.\n//\n//   editable:: ?(state: EditorState) → bool\n//   When this returns false, the content of the view is not directly\n//   editable.\n//\n//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>\n//   Control the DOM attributes of the editable element. May be either\n//   an object or a function going from an editor state to an object.\n//   By default, the element will get a class `\"ProseMirror\"`, and\n//   will have its `contentEditable` attribute determined by the\n//   [`editable` prop](#view.EditorProps.editable). Additional classes\n//   provided here will be added to the class. For other attributes,\n//   the value provided first (as in\n//   [`someProp`](#view.EditorView.someProp)) will be used.\n//\n//   scrollThreshold:: ?number | {top: number, right: number, bottom: number, left: number}\n//   Determines the distance (in pixels) between the cursor and the\n//   end of the visible viewport at which point, when scrolling the\n//   cursor into view, scrolling takes place. Defaults to 0.\n//\n//   scrollMargin:: ?number | {top: number, right: number, bottom: number, left: number}\n//   Determines the extra space (in pixels) that is left above or\n//   below the cursor when it is scrolled into view. Defaults to 5.\n\n// DirectEditorProps:: interface extends EditorProps\n//\n// The props object given directly to the editor view supports two\n// fields that can't be used in plugins:\n//\n//   state:: EditorState\n//   The current state of the editor.\n//\n//   dispatchTransaction:: ?(tr: Transaction)\n//   The callback over which to send transactions (state updates)\n//   produced by the view. If you specify this, you probably want to\n//   make sure this ends up calling the view's\n//   [`updateState`](#view.EditorView.updateState) method with a new\n//   state that has the transaction\n//   [applied](#state.EditorState.apply). The callback will be bound to have\n//   the view instance as its `this` binding.\n\nexports.EditorView = EditorView;\nexports.Decoration = Decoration;\nexports.DecorationSet = DecorationSet;\nexports.__serializeForClipboard = serializeForClipboard;\nexports.__parseFromClipboard = parseFromClipboard;\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/rope-sequence/dist/index.js":
/*!****************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/rope-sequence/dist/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var GOOD_LEAF_SIZE = 200\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other)\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0) }\n  else\n    { this.forEachInvertedInner(f, from, to, 0) }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = []\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to)\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = (function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this)\n    this.values = values\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: {},depth: {} };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var this$1 = this;\n\n    for (var i = from; i < to; i++)\n      { if (f(this$1.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var this$1 = this;\n\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this$1.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([])\n\nvar Append = (function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this)\n    this.left = left\n    this.right = right\n    this.length = left.length + right.length\n    this.depth = Math.max(left.depth, right.depth) + 1\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other)\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other)\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nmodule.exports = RopeSequence\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/rope-sequence/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cc/regex.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cc/regex.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=/[\\0-\\x1F\\x7F-\\x9F]/\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cc/regex.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cf/regex.js":
/*!********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cf/regex.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cf/regex.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/P/regex.js":
/*!*******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/P/regex.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=/[!-#%-\\*,-/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E49\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/P/regex.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Z/regex.js":
/*!*******************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Z/regex.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Z/regex.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/index.js":
/*!******************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.Any = __webpack_require__(/*! ./properties/Any/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/properties/Any/regex.js\");\nexports.Cc  = __webpack_require__(/*! ./categories/Cc/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cc/regex.js\");\nexports.Cf  = __webpack_require__(/*! ./categories/Cf/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Cf/regex.js\");\nexports.P   = __webpack_require__(/*! ./categories/P/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/P/regex.js\");\nexports.Z   = __webpack_require__(/*! ./categories/Z/regex */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/categories/Z/regex.js\");\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/properties/Any/regex.js":
/*!*********************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/properties/Any/regex.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/uc.micro/properties/Any/regex.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/w3c-keyname/index.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/w3c-keyname/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \";\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    safari && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n\nmodule.exports = keyName\nkeyName.base = base\nkeyName.shift = shift\n\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/w3c-keyname/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/config.js":
/*!**********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/config.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {var config = {\n    // Default options\n    defaults: {},\n    // Error type\n    errorType: null,\n    // Polyfills\n    polyfills: {\n        fetch: null,\n        FormData: null,\n        URLSearchParams: null,\n        performance: null,\n        PerformanceObserver: null,\n        AbortController: null\n    },\n    polyfill: function (p, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.doThrow, doThrow = _c === void 0 ? true : _c, _d = _b.instance, instance = _d === void 0 ? false : _d;\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var res = this.polyfills[p] ||\n            (typeof self !== \"undefined\" ? self[p] : null) ||\n            (typeof global !== \"undefined\" ? global[p] : null);\n        if (doThrow && !res)\n            throw new Error(p + \" is not defined\");\n        return instance && res ? new (res.bind.apply(res, [void 0].concat(args)))() : res;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n//# sourceMappingURL=config.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../nyeholt/silverstripe-frontend-livingdoc/app/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/config.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js ***!
  \*********************************************************************************************/
/*! exports provided: Wretcher, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wretcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wretcher */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/wretcher.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Wretcher\", function() { return _wretcher__WEBPACK_IMPORTED_MODULE_0__[\"Wretcher\"]; });\n\n\nvar factory = _wretcher__WEBPACK_IMPORTED_MODULE_0__[\"Wretcher\"].factory;\nfactory[\"default\"] = _wretcher__WEBPACK_IMPORTED_MODULE_0__[\"Wretcher\"].factory;\n/* Export typescript types */\n\n/**\n * Return a fresh Wretcher instance.\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (factory);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/middleware.js":
/*!**************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/middleware.js ***!
  \**************************************************************************************************/
/*! exports provided: middlewareHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"middlewareHelper\", function() { return middlewareHelper; });\nvar middlewareHelper = function (middlewares) { return function (fetchFunction) {\n    return (middlewares.length === 0 ?\n        fetchFunction :\n        middlewares.length === 1 ?\n            middlewares[0](fetchFunction) :\n            middlewares.reduceRight(function (acc, curr, idx) {\n                return (idx === middlewares.length - 2) ? curr(acc(fetchFunction)) : curr(acc);\n            }));\n}; };\n//# sourceMappingURL=middleware.js.map\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/middleware.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/mix.js":
/*!*******************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/mix.js ***!
  \*******************************************************************************************/
/*! exports provided: mix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mix\", function() { return mix; });\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar mix = function (one, two, mergeArrays) {\n    if (mergeArrays === void 0) { mergeArrays = false; }\n    if (!one || !two || typeof one !== \"object\" || typeof two !== \"object\")\n        return one;\n    var clone = __assign({}, one);\n    for (var prop in two) {\n        if (two.hasOwnProperty(prop)) {\n            if (two[prop] instanceof Array && one[prop] instanceof Array) {\n                clone[prop] = mergeArrays ? one[prop].concat(two[prop]) : two[prop];\n            }\n            else if (typeof two[prop] === \"object\" && typeof one[prop] === \"object\") {\n                clone[prop] = mix(one[prop], two[prop], mergeArrays);\n            }\n            else {\n                clone[prop] = two[prop];\n            }\n        }\n    }\n    return clone;\n};\n//# sourceMappingURL=mix.js.map\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/mix.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/perfs.js":
/*!*********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/perfs.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/config.js\");\n\nvar onMatch = function (entries, name, callback, _performance) {\n    if (!entries.getEntriesByName)\n        return false;\n    var matches = entries.getEntriesByName(name);\n    if (matches && matches.length > 0) {\n        callback(matches.reverse()[0]);\n        if (_performance.clearMeasures)\n            _performance.clearMeasures(name);\n        perfs.callbacks.delete(name);\n        if (perfs.callbacks.size < 1) {\n            perfs.observer.disconnect();\n            if (_performance.clearResourceTimings) {\n                _performance.clearResourceTimings();\n            }\n        }\n        return true;\n    }\n    return false;\n};\nvar lazyObserver = function (_performance, _observer) {\n    if (!perfs.observer && _performance && _observer) {\n        perfs.observer = new _observer(function (entries) {\n            perfs.callbacks.forEach(function (callback, name) {\n                onMatch(entries, name, callback, _performance);\n            });\n        });\n        if (_performance.clearResourceTimings)\n            _performance.clearResourceTimings();\n    }\n    return perfs.observer;\n};\nvar perfs = {\n    callbacks: new Map(),\n    observer: null,\n    observe: function (name, callback) {\n        if (!name || !callback)\n            return;\n        var _performance = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].polyfill(\"performance\", { doThrow: false });\n        var _observer = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].polyfill(\"PerformanceObserver\", { doThrow: false });\n        if (!lazyObserver(_performance, _observer))\n            return;\n        if (!onMatch(_performance, name, callback, _performance)) {\n            if (perfs.callbacks.size < 1)\n                perfs.observer.observe({ entryTypes: [\"resource\", \"measure\"] });\n            perfs.callbacks.set(name, callback);\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (perfs);\n//# sourceMappingURL=perfs.js.map\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/perfs.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/resolver.js":
/*!************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/resolver.js ***!
  \************************************************************************************************/
/*! exports provided: resolver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolver\", function() { return resolver; });\n/* harmony import */ var _mix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mix */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/mix.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/config.js\");\n/* harmony import */ var _perfs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./perfs */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/perfs.js\");\n/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./middleware */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/middleware.js\");\n\n\n\n\nvar resolver = function (wretcher) {\n    var url = wretcher._url, catchers = wretcher._catchers, resolvers = wretcher._resolvers, middlewares = wretcher._middlewares, opts = wretcher._options;\n    var finalOptions = Object(_mix__WEBPACK_IMPORTED_MODULE_0__[\"mix\"])(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaults, opts);\n    var fetchController = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].polyfill(\"AbortController\", { doThrow: false, instance: true });\n    if (!finalOptions[\"signal\"] && fetchController) {\n        finalOptions[\"signal\"] = fetchController.signal;\n    }\n    // The generated fetch request\n    var fetchRequest = Object(_middleware__WEBPACK_IMPORTED_MODULE_3__[\"middlewareHelper\"])(middlewares)(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].polyfill(\"fetch\"))(url, finalOptions);\n    // Throws on an http error\n    var throwingPromise = fetchRequest.then(function (response) {\n        if (!response.ok) {\n            return response[_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].errorType || \"text\"]().then(function (msg) {\n                // Enhances the error object\n                var err = new Error(msg);\n                err[_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].errorType || \"text\"] = msg;\n                err[\"status\"] = response.status;\n                err[\"response\"] = response;\n                throw err;\n            });\n        }\n        return response;\n    });\n    // Wraps the Promise in order to dispatch the error to a matching catcher\n    var catchersWrapper = function (promise) {\n        return promise.catch(function (err) {\n            if (catchers.has(err.status))\n                return catchers.get(err.status)(err, wretcher);\n            else if (catchers.has(err.name))\n                return catchers.get(err.name)(err, wretcher);\n            else\n                throw err;\n        });\n    };\n    var bodyParser = function (funName) { return function (cb) { return funName ?\n        // If a callback is provided, then callback with the body result otherwise return the parsed body itself.\n        catchersWrapper(throwingPromise.then(function (_) { return _ && _[funName](); }).then(function (_) { return _ && cb && cb(_) || _; })) :\n        // No body parsing method - return the response\n        catchersWrapper(throwingPromise.then(function (_) { return _ && cb && cb(_) || _; })); }; };\n    var responseChain = {\n        /**\n         * Retrieves the raw result as a promise.\n         */\n        res: bodyParser(null),\n        /**\n         * Retrieves the result as a parsed JSON object.\n         */\n        json: bodyParser(\"json\"),\n        /**\n         * Retrieves the result as a Blob object.\n         */\n        blob: bodyParser(\"blob\"),\n        /**\n         * Retrieves the result as a FormData object.\n         */\n        formData: bodyParser(\"formData\"),\n        /**\n         * Retrieves the result as an ArrayBuffer object.\n         */\n        arrayBuffer: bodyParser(\"arrayBuffer\"),\n        /**\n         * Retrieves the result as a string.\n         */\n        text: bodyParser(\"text\"),\n        /**\n         * Performs a callback on the API performance timings of the request.\n         *\n         * Warning: Still experimental on browsers and node.js\n         */\n        perfs: function (cb) {\n            fetchRequest.then(function (res) { return _perfs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].observe(res.url, cb); });\n            return responseChain;\n        },\n        /**\n         * Aborts the request after a fixed time.\n         *\n         * @param time Time in milliseconds\n         * @param controller A custom controller\n         */\n        setTimeout: function (time, controller) {\n            if (controller === void 0) { controller = fetchController; }\n            setTimeout(function () { return controller.abort(); }, time);\n            return responseChain;\n        },\n        /**\n         * Returns the automatically generated AbortController alongside the current wretch response as a pair.\n         */\n        controller: function () { return [fetchController, responseChain]; },\n        /**\n         * Catches an http response with a specific error code or name and performs a callback.\n         */\n        error: function (errorId, cb) {\n            catchers.set(errorId, cb);\n            return responseChain;\n        },\n        /**\n         * Catches a bad request (http code 400) and performs a callback.\n         */\n        badRequest: function (cb) { return responseChain.error(400, cb); },\n        /**\n         * Catches an unauthorized request (http code 401) and performs a callback.\n         */\n        unauthorized: function (cb) { return responseChain.error(401, cb); },\n        /**\n         * Catches a forbidden request (http code 403) and performs a callback.\n         */\n        forbidden: function (cb) { return responseChain.error(403, cb); },\n        /**\n         * Catches a \"not found\" request (http code 404) and performs a callback.\n         */\n        notFound: function (cb) { return responseChain.error(404, cb); },\n        /**\n         * Catches a timeout (http code 408) and performs a callback.\n         */\n        timeout: function (cb) { return responseChain.error(408, cb); },\n        /**\n         * Catches an internal server error (http code 500) and performs a callback.\n         */\n        internalError: function (cb) { return responseChain.error(500, cb); },\n        /**\n         * Catches an AbortError and performs a callback.\n         */\n        onAbort: function (cb) { return responseChain.error(\"AbortError\", cb); }\n    };\n    return resolvers.reduce(function (chain, r) { return r(chain, wretcher); }, responseChain);\n};\n//# sourceMappingURL=resolver.js.map\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/resolver.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/wretcher.js":
/*!************************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/wretcher.js ***!
  \************************************************************************************************/
/*! exports provided: Wretcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Wretcher\", function() { return Wretcher; });\n/* harmony import */ var _mix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mix */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/mix.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/config.js\");\n/* harmony import */ var _resolver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolver */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/resolver.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n/**\n * The Wretcher class used to perform easy fetch requests.\n *\n * Immutability : almost every method of this class return a fresh Wretcher object.\n */\nvar Wretcher = /** @class */ (function () {\n    function Wretcher(_url, _options, _catchers, _resolvers, _middlewares, _deferredChain) {\n        if (_catchers === void 0) { _catchers = new Map(); }\n        if (_resolvers === void 0) { _resolvers = []; }\n        if (_middlewares === void 0) { _middlewares = []; }\n        if (_deferredChain === void 0) { _deferredChain = []; }\n        this._url = _url;\n        this._options = _options;\n        this._catchers = _catchers;\n        this._resolvers = _resolvers;\n        this._middlewares = _middlewares;\n        this._deferredChain = _deferredChain;\n    }\n    Wretcher.factory = function (url, options) {\n        if (url === void 0) { url = \"\"; }\n        if (options === void 0) { options = {}; }\n        return new Wretcher(url, options);\n    };\n    Wretcher.prototype.selfFactory = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.url, url = _c === void 0 ? this._url : _c, _d = _b.options, options = _d === void 0 ? this._options : _d, _e = _b.catchers, catchers = _e === void 0 ? this._catchers : _e, _f = _b.resolvers, resolvers = _f === void 0 ? this._resolvers : _f, _g = _b.middlewares, middlewares = _g === void 0 ? this._middlewares : _g, _h = _b.deferredChain, deferredChain = _h === void 0 ? this._deferredChain : _h;\n        return new Wretcher(url, options, catchers, resolvers, middlewares, deferredChain);\n    };\n    /**\n     * Sets the default fetch options used for every subsequent fetch call.\n     * @param options New default options\n     * @param mixin If true, mixes in instead of replacing the existing options\n     */\n    Wretcher.prototype.defaults = function (options, mixin) {\n        if (mixin === void 0) { mixin = false; }\n        _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaults = mixin ? Object(_mix__WEBPACK_IMPORTED_MODULE_0__[\"mix\"])(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaults, options) : options;\n        return this;\n    };\n    /**\n     * Sets the method (text, json ...) used to parse the data contained in the response body in case of an HTTP error.\n     *\n     * Persists for every subsequent requests.\n     *\n     * Default is \"text\".\n     */\n    Wretcher.prototype.errorType = function (method) {\n        _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].errorType = method;\n        return this;\n    };\n    /**\n     * Sets the non-global polyfills which will be used for every subsequent calls.\n     *\n     * Needed for libraries like [fetch-ponyfill](https://github.com/qubyte/fetch-ponyfill).\n     *\n     * @param polyfills An object containing the polyfills.\n     */\n    Wretcher.prototype.polyfills = function (polyfills) {\n        _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].polyfills = __assign({}, _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].polyfills, polyfills);\n        return this;\n    };\n    /**\n     * Returns a new Wretcher object with the argument url appended and the same options.\n     * @param url String url\n     * @param replace Boolean If true, replaces the current url instead of appending\n     */\n    Wretcher.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = false; }\n        if (replace)\n            return this.selfFactory({ url: url });\n        var split = this._url.split(\"?\");\n        return this.selfFactory({\n            url: split.length > 1 ?\n                split[0] + url + \"?\" + split[1] :\n                this._url + url\n        });\n    };\n    /**\n     * Returns a new Wretcher object with the same url and new options.\n     * @param options New options\n     * @param mixin If true, mixes in instead of replacing the existing options\n     */\n    Wretcher.prototype.options = function (options, mixin) {\n        if (mixin === void 0) { mixin = true; }\n        return this.selfFactory({ options: mixin ? Object(_mix__WEBPACK_IMPORTED_MODULE_0__[\"mix\"])(this._options, options) : options });\n    };\n    /**\n     * Converts a javascript object to query parameters,\n     * then appends this query string to the current url.\n     *\n     * If given a string, use the string as the query verbatim.\n     *\n     * ```\n     * let w = wretch(\"http://example.com\") // url is http://example.com\n     *\n     * // Chain query calls\n     * w = w.query({ a: 1, b : 2 }) // url is now http://example.com?a=1&b=2\n     * w = w.query(\"foo-bar-baz-woz\") // url is now http://example.com?a=1&b=2&foo-bar-baz-woz\n     *\n     * // Pass true as the second argument to replace existing query parameters\n     * w = w.query(\"c=3&d=4\", true) // url is now http://example.com?c=3&d=4\n     * ```\n     *\n     * @param qp An object which will be converted, or a string which will be used verbatim.\n     */\n    Wretcher.prototype.query = function (qp, replace) {\n        if (replace === void 0) { replace = false; }\n        return this.selfFactory({ url: appendQueryParams(this._url, qp, replace) });\n    };\n    /**\n     * Set request headers.\n     * @param headerValues An object containing header keys and values\n     */\n    Wretcher.prototype.headers = function (headerValues) {\n        return this.selfFactory({ options: Object(_mix__WEBPACK_IMPORTED_MODULE_0__[\"mix\"])(this._options, { headers: headerValues }) });\n    };\n    /**\n     * Shortcut to set the \"Accept\" header.\n     * @param headerValue Header value\n     */\n    Wretcher.prototype.accept = function (headerValue) {\n        return this.headers({ Accept: headerValue });\n    };\n    /**\n     * Shortcut to set the \"Content-Type\" header.\n     * @param headerValue Header value\n     */\n    Wretcher.prototype.content = function (headerValue) {\n        return this.headers({ \"Content-Type\": headerValue });\n    };\n    /**\n     * Shortcut to set the \"Authorization\" header.\n     * @param headerValue Header value\n     */\n    Wretcher.prototype.auth = function (headerValue) {\n        return this.headers({ Authorization: headerValue });\n    };\n    /**\n     * Adds a default catcher which will be called on every subsequent request error when the error code matches.\n     * @param errorId Error code or name\n     * @param catcher: The catcher method\n     */\n    Wretcher.prototype.catcher = function (errorId, catcher) {\n        var newMap = new Map(this._catchers);\n        newMap.set(errorId, catcher);\n        return this.selfFactory({ catchers: newMap });\n    };\n    /**\n     * Associates a custom signal with the request.\n     * @param controller : An AbortController\n     */\n    Wretcher.prototype.signal = function (controller) {\n        return this.selfFactory({ options: __assign({}, this._options, { signal: controller.signal }) });\n    };\n    /**\n     * Program a resolver to perform response chain tasks automatically.\n     * @param doResolve : Resolver callback\n     */\n    Wretcher.prototype.resolve = function (doResolve, clear) {\n        if (clear === void 0) { clear = false; }\n        return this.selfFactory({ resolvers: clear ? [doResolve] : this._resolvers.concat([doResolve]) });\n    };\n    /**\n     * Defer wretcher methods that will be chained and called just before the request is performed.\n     */\n    Wretcher.prototype.defer = function (callback, clear) {\n        if (clear === void 0) { clear = false; }\n        return this.selfFactory({\n            deferredChain: clear ? [callback] : this._deferredChain.concat([callback])\n        });\n    };\n    /**\n     * Add middlewares to intercept a request before being sent.\n     */\n    Wretcher.prototype.middlewares = function (middlewares, clear) {\n        if (clear === void 0) { clear = false; }\n        return this.selfFactory({\n            middlewares: clear ? middlewares : this._middlewares.concat(middlewares)\n        });\n    };\n    Wretcher.prototype.method = function (method, options, body) {\n        if (options === void 0) { options = {}; }\n        if (body === void 0) { body = null; }\n        var baseWretcher = !body ? this :\n            typeof body === \"object\" ? this.json(body) :\n                this.body(body);\n        var deferredWretcher = baseWretcher._deferredChain.reduce(function (acc, curr) { return curr(acc, acc._url, acc._options); }, baseWretcher);\n        return Object(_resolver__WEBPACK_IMPORTED_MODULE_2__[\"resolver\"])(deferredWretcher.options(__assign({}, options, { method: method })));\n    };\n    /**\n     * Performs a get request.\n     */\n    Wretcher.prototype.get = function (options) {\n        return this.method(\"GET\", options);\n    };\n    /**\n     * Performs a delete request.\n     */\n    Wretcher.prototype.delete = function (options) {\n        return this.method(\"DELETE\", options);\n    };\n    /**\n     * Performs a put request.\n     */\n    Wretcher.prototype.put = function (body, options) {\n        return this.method(\"PUT\", options, body);\n    };\n    /**\n     * Performs a post request.\n     */\n    Wretcher.prototype.post = function (body, options) {\n        return this.method(\"POST\", options, body);\n    };\n    /**\n     * Performs a patch request.\n     */\n    Wretcher.prototype.patch = function (body, options) {\n        return this.method(\"PATCH\", options, body);\n    };\n    /**\n     * Performs a head request.\n     */\n    Wretcher.prototype.head = function (options) {\n        return this.method(\"HEAD\", options);\n    };\n    /**\n     * Performs an options request\n     */\n    Wretcher.prototype.opts = function (options) {\n        return this.method(\"OPTIONS\", options);\n    };\n    /**\n     * Sets the request body with any content.\n     * @param contents The body contents\n     */\n    Wretcher.prototype.body = function (contents) {\n        return this.selfFactory({ options: __assign({}, this._options, { body: contents }) });\n    };\n    /**\n     * Sets the content type header, stringifies an object and sets the request body.\n     * @param jsObject An object which will be serialized into a JSON\n     */\n    Wretcher.prototype.json = function (jsObject) {\n        return this.content(\"application/json\").body(JSON.stringify(jsObject));\n    };\n    /**\n     * Converts the javascript object to a FormData and sets the request body.\n     * @param formObject An object which will be converted to a FormData\n     */\n    Wretcher.prototype.formData = function (formObject) {\n        return this.body(convertFormData(formObject));\n    };\n    /**\n     * Converts the input to an url encoded string and sets the content-type header and body.\n     * If the input argument is already a string, skips the conversion part.\n     *\n     * @param input An object to convert into an url encoded string or an already encoded string\n     */\n    Wretcher.prototype.formUrl = function (input) {\n        return this\n            .body(typeof input === \"string\" ? input : convertFormUrl(input))\n            .content(\"application/x-www-form-urlencoded\");\n    };\n    return Wretcher;\n}());\n\n// Internal helpers\nvar appendQueryParams = function (url, qp, replace) {\n    var queryString;\n    if (typeof qp === \"string\") {\n        queryString = qp;\n    }\n    else {\n        var usp = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].polyfill(\"URLSearchParams\", { instance: true });\n        for (var key in qp) {\n            if (qp[key] instanceof Array) {\n                for (var _i = 0, _a = qp[key]; _i < _a.length; _i++) {\n                    var val = _a[_i];\n                    usp.append(key, val);\n                }\n            }\n            else {\n                usp.append(key, qp[key]);\n            }\n        }\n        queryString = usp.toString();\n    }\n    var split = url.split(\"?\");\n    if (replace || split.length < 2)\n        return split[0] + \"?\" + queryString;\n    return url + \"&\" + queryString;\n};\nfunction convertFormData(formObject) {\n    var formData = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].polyfill(\"FormData\", { instance: true });\n    for (var key in formObject) {\n        if (formObject[key] instanceof Array) {\n            for (var _i = 0, _a = formObject[key]; _i < _a.length; _i++) {\n                var item = _a[_i];\n                formData.append(key + \"[]\", item);\n            }\n        }\n        else {\n            formData.append(key, formObject[key]);\n        }\n    }\n    return formData;\n}\nfunction encodeQueryValue(key, value) {\n    return encodeURIComponent(key) +\n        \"=\" +\n        encodeURIComponent(typeof value === \"object\" ?\n            JSON.stringify(value) :\n            \"\" + value);\n}\nfunction convertFormUrl(formObject) {\n    return Object.keys(formObject)\n        .map(function (key) {\n        var value = formObject[key];\n        if (value instanceof Array) {\n            return value.map(function (v) { return encodeQueryValue(key, v); }).join(\"&\");\n        }\n        return encodeQueryValue(key, value);\n    })\n        .join(\"&\");\n}\n//# sourceMappingURL=wretcher.js.map\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/wretcher.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/data/mockup-pages.js":
/*!************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/data/mockup-pages.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar mockupPages = [{\n  \"title\": \"Home\",\n  \"link\": \"/home\"\n}, {\n  \"title\": \"About Us\",\n  \"link\": \"/about\"\n}, {\n  \"title\": \"Team\",\n  \"link\": \"/team\"\n}, {\n  \"title\": \"Company History\",\n  \"link\": \"/history\"\n}, {\n  \"title\": \"Contact Us\",\n  \"link\": \"/contact\"\n}];\n/* harmony default export */ __webpack_exports__[\"default\"] = (mockupPages);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/data/mockup-pages.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js":
/*!*******************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/Field.js ***!
  \*******************************************************************************/
/*! exports provided: Field */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Field\", function() { return Field; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Field =\n/*#__PURE__*/\nfunction () {\n  function Field(options) {\n    _classCallCheck(this, Field);\n\n    this.options = options;\n  }\n\n  _createClass(Field, [{\n    key: \"read\",\n    value: function read(dom) {\n      return dom.value;\n    }\n  }, {\n    key: \"validateType\",\n    value: function validateType(_value) {}\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (!value && this.options.required) {\n        return \"Required field\";\n      }\n\n      return this.validateType(value) || this.options.validate && this.options.validate(value);\n    }\n  }, {\n    key: \"clean\",\n    value: function clean(value) {\n      return this.options.clean ? this.options.clean(value) : value;\n    }\n  }]);\n\n  return Field;\n}();\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/Field.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/FieldGroup.js":
/*!************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/FieldGroup.js ***!
  \************************************************************************************/
/*! exports provided: FieldGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FieldGroup\", function() { return FieldGroup; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar FieldGroup =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(FieldGroup, _Field);\n\n  /**\n   *\n   * @param {string} name\n   * @param {object} fields\n   *              The list of fields in { name: new Field() } format\n   */\n  function FieldGroup(options) {\n    var _this;\n\n    _classCallCheck(this, FieldGroup);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FieldGroup).call(this, options));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updateCallback\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"fields\", []);\n\n    _this.fields = options.fields;\n    return _this;\n  }\n\n  _createClass(FieldGroup, [{\n    key: \"render\",\n    value: function render() {\n      var container = document.createElement('fieldset');\n      container.classList.add(\"fieldgroup\");\n      container.classList.add(\"fieldgroup-\" + this.options.name);\n      this.renderFields(container, this.updateCallback);\n      return container;\n    }\n  }, {\n    key: \"renderFields\",\n    value: function renderFields(container) {\n      var _this2 = this;\n\n      var domFields = [];\n      var prefix = this.options.name || '';\n\n      for (var name in this.fields) {\n        var field = this.fields[name];\n\n        if (!field.options.name) {\n          field.options.name = name;\n        }\n\n        if (field instanceof FieldGroup) {\n          field.updateCallback = this.updateCallback;\n        }\n\n        var formField = field.render();\n        formField.setAttribute('data-label', field.options.label || field.options.name);\n        formField.setAttribute('data-name', field.options.name);\n        domFields.push(formField);\n        field.dom = formField;\n      }\n\n      var fieldNumber = 1;\n      domFields.forEach(function (domfield) {\n        // wrap in a div with a form label\n        var formFieldId = prefix + '-field-' + fieldNumber;\n        domfield.id = formFieldId;\n        var fieldWrapper = document.createElement(\"div\");\n        fieldWrapper.className = prefix + '-fieldwrapper fieldgroup-fieldwrapper field-' + domfield.getAttribute('data-name');\n        var fieldLabel = document.createElement(\"label\");\n        fieldLabel.innerHTML = domfield.getAttribute('data-label');\n        fieldLabel.setAttribute('for', formFieldId);\n        fieldWrapper.appendChild(fieldLabel);\n        fieldWrapper.appendChild(domfield);\n        container.appendChild(fieldWrapper);\n\n        if (_this2.updateCallback) {\n          domfield.addEventListener('change', function (e) {\n            _this2.updateCallback(domfield.name, _this2.fields[domfield.name].read(domfield));\n          });\n          domfield.addEventListener('keyup', function (e) {\n            _this2.updateCallback(domfield.name, _this2.fields[domfield.name].read(domfield));\n          });\n        }\n\n        fieldNumber++;\n      });\n    }\n  }, {\n    key: \"getValues\",\n    value: function getValues() {\n      var result = Object.create(null),\n          i = 0;\n\n      for (var name in this.fields) {\n        var field = this.fields[name];\n\n        if (field instanceof FieldGroup) {\n          var subfields = field.getValues();\n          result = _objectSpread2({}, result, {}, subfields);\n        } else {\n          var dom = field.dom;\n          var value = field.read(dom),\n              bad = field.validate(value);\n\n          if (bad) {\n            this.reportInvalid(dom, bad);\n            return null;\n          }\n\n          result[name] = field.clean(value);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"reportInvalid\",\n    value: function reportInvalid(dom, message) {\n      // FIXME this is awful and needs a lot more work\n      var parent = dom.parentNode;\n      var msg = parent.appendChild(document.createElement(\"div\"));\n      msg.style.left = dom.offsetLeft + dom.offsetWidth + 2 + \"px\";\n      msg.style.top = dom.offsetTop - 5 + \"px\";\n      msg.className = \"ProseMirror-invalid\";\n      msg.textContent = message;\n      setTimeout(function () {\n        return parent.removeChild(msg);\n      }, 1500);\n    }\n  }]);\n\n  return FieldGroup;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/FieldGroup.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.js":
/*!*****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.js ***!
  \*****************************************************************************************/
/*! exports provided: FileUploadField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FileUploadField\", function() { return FileUploadField; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! filepond */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/filepond/dist/filepond.js\");\n/* harmony import */ var filepond__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(filepond__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _FileUploadField_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FileUploadField.scss */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.scss\");\n/* harmony import */ var _FileUploadField_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_FileUploadField_scss__WEBPACK_IMPORTED_MODULE_2__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar FileUploadField =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(FileUploadField, _Field);\n\n  function FileUploadField(options) {\n    var _this;\n\n    _classCallCheck(this, FileUploadField);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FileUploadField).call(this, options));\n\n    if (!_this.options.type) {\n      _this.options.type = 'page';\n    }\n\n    if (!_this.options.url) {\n      _this.options.url = '__prose';\n    }\n\n    return _this;\n  }\n\n  _createClass(FileUploadField, [{\n    key: \"read\",\n    value: function read(dom) {\n      if (this.hiddenField) {\n        return {\n          type: this.options.type,\n          id: this.hiddenField.value\n        };\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      this.hiddenField = document.createElement('hidden');\n      this.hiddenField.type = \"text\";\n      this.hiddenField.value = this.options.value || \"\";\n      var div = document.createElement('div');\n      div.className = 'FileUploadField';\n      var inputDiv = document.createElement('div');\n      inputDiv.className = 'FileUploadField__Input';\n      var input = document.createElement('input');\n      input.name = this.options.name ? this.options.name : this.options.label;\n      input.type = \"file\";\n      inputDiv.appendChild(input);\n      div.appendChild(inputDiv);\n      div.appendChild(this.hiddenField);\n      var pond = filepond__WEBPACK_IMPORTED_MODULE_1__[\"create\"](input, {\n        multiple: true,\n        name: this.options.name\n      }); // pond.onaddfile = function (e, file) {\n      //     if (file) {\n      //         file.setMetadata(\"path\", location.pathname);\n      //     }\n      // };\n\n      pond.onprocessfile = function (err, file) {\n        if (file && _this2.options.onupload) {\n          _this2.options.onupload(file);\n        }\n      };\n\n      filepond__WEBPACK_IMPORTED_MODULE_1__[\"setOptions\"]({\n        server: this.options.uploadurl\n      });\n      return div;\n    }\n  }]);\n\n  return FileUploadField;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.scss":
/*!*******************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.scss ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.scss?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.js":
/*!*****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.js ***!
  \*****************************************************************************************/
/*! exports provided: ItemFilterField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemFilterField\", function() { return ItemFilterField; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\n/* harmony import */ var html5_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html5-tag */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/html5-tag/lib/index.js\");\n/* harmony import */ var html5_tag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(html5_tag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var escape_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! escape-html */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js\");\n/* harmony import */ var escape_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(escape_html__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var wretch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wretch */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js\");\n/* harmony import */ var _ItemFilterField_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ItemFilterField.scss */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.scss\");\n/* harmony import */ var _ItemFilterField_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ItemFilterField_scss__WEBPACK_IMPORTED_MODULE_4__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _readOnlyError(name) { throw new Error(\"\\\"\" + name + \"\\\" is read-only\"); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar ItemFilterField =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(ItemFilterField, _Field);\n\n  function ItemFilterField(options) {\n    var _this;\n\n    _classCallCheck(this, ItemFilterField);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ItemFilterField).call(this, options));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"items\", []);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"lookIn\", 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"loading\", false);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"lookupItems\", function () {});\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"shortcodes\", {\n      'image': 'image',\n      'file': 'file_link',\n      'page': 'sitetree_link'\n    });\n\n    if (!_this.options.type) {\n      _this.options.type = 'page';\n    }\n\n    if (!_this.options.url) {\n      _this.options.url = '__prose';\n    }\n\n    return _this;\n  }\n\n  _createClass(ItemFilterField, [{\n    key: \"read\",\n    value: function read(dom) {\n      if (this.hiddenField) {\n        var shortcode = this.shortcodes[this.options.type] || 'file_link';\n        return {\n          type: this.options.type,\n          shortcode: shortcode,\n          id: this.hiddenField.value\n        };\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      this.hiddenField = document.createElement('hidden');\n      this.hiddenField.type = \"text\";\n      this.hiddenField.value = this.options.value || \"\";\n      var div = document.createElement('div');\n      div.className = 'ItemFilterField';\n      var inputDiv = document.createElement('div');\n      inputDiv.className = 'ItemFilterField__Input';\n      var displayDiv = document.createElement('div');\n      displayDiv.className = 'ItemFilterField__Display';\n      var input = document.createElement('input');\n      input.name = this.options.name ? this.options.name : this.options.label;\n      input.type = \"text\";\n      inputDiv.appendChild(input);\n      div.appendChild(inputDiv);\n      div.appendChild(displayDiv);\n      div.appendChild(this.hiddenField);\n      var w = Object(wretch__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n      var treeType = this.options.type || 'page';\n      var apiUrl = this.options.url + '/search/' + treeType;\n      var secId = document.querySelector('input[name=SecurityID]').value;\n      var isStage = location.href.indexOf('stage=Stage') > 0;\n      this.lookupItems = debounce(function (value, extraOpts) {\n        var reqUrl = \"\".concat(apiUrl);\n        var queryOpts = {\n          term: value,\n          SecurityID: secId\n        };\n\n        if (extraOpts) {\n          queryOpts = (_readOnlyError(\"queryOpts\"), _objectSpread2({}, queryOpts, {}, extraOpts));\n        }\n\n        if (isStage) {\n          queryOpts.stage = 'Stage';\n        }\n\n        _this2.loading = true;\n\n        _this2.renderItems(displayDiv);\n\n        w.url(reqUrl).query(queryOpts).get().json(function (data) {\n          if (data && data.results) {\n            _this2.items = data.results;\n          }\n\n          _this2.loading = false;\n\n          _this2.renderItems(displayDiv);\n        }).catch(function (e) {\n          console.log(e);\n          _this2.loading = false;\n\n          _this2.renderItems(displayDiv);\n        });\n      }, 500);\n\n      if (this.value) {\n        this.lookupItems('', {\n          initial: this.value\n        });\n      } else if (this.options.folderId) {\n        this.lookupItems('', {\n          folderId: this.options.folderId\n        });\n      }\n\n      input.addEventListener('keyup', function (e) {\n        _this2.lookupItems(e.target.value);\n      });\n      document.addEventListener('click', function (e) {\n        if (e.target && e.target.className === 'ItemFilterField__Item__Image') {\n          document.querySelectorAll('.ItemFilterField__Item__Image').forEach(function (elem) {\n            elem.classList.remove('ItemFilterField__Item__Image--Selected');\n          });\n          e.target.classList.add('ItemFilterField__Item__Image--Selected');\n          var imageId = e.target.getAttribute('data-id');\n          var imageLink = e.target.getAttribute('data-url');\n          var imageTitle = e.target.getAttribute('data-title');\n\n          if (imageId && imageLink) {\n            _this2.hiddenField.value = imageId;\n\n            if (_this2.options.linkField) {\n              document.getElementsByName(_this2.options.linkField).forEach(function (elem) {\n                elem.value = imageLink;\n              });\n            }\n\n            if (_this2.options.titleField) {\n              document.getElementsByName(_this2.options.titleField).forEach(function (elem) {\n                elem.value = imageTitle;\n              });\n            }\n          } else if (imageId) {\n            _this2.lookupItems(imageId);\n          }\n        }\n      });\n      return div;\n    }\n    /**\n     *\n     * @param {HTMLDivElement} displayDiv\n     */\n\n  }, {\n    key: \"renderItems\",\n    value: function renderItems(displayDiv) {\n      while (displayDiv.firstChild) {\n        displayDiv.removeChild(displayDiv.firstChild);\n      }\n\n      if (this.loading) {\n        displayDiv.innerHTML = \"<div class='ItemFilterField__Loading'>Loading ... </div>\";\n        return;\n      }\n\n      var newItems = this.items.map(function (item) {\n        var title = item.text;\n\n        if (title.length > 20) {\n          title = title.substring(0, 18) + '...';\n        }\n\n        var img = html5_tag__WEBPACK_IMPORTED_MODULE_1___default()('img', {\n          'class': 'ItemFilterField__Item__Image',\n          'src': item.icon,\n          'data-id': \"\" + item.id,\n          'data-title': item.text,\n          'data-url': item.data && item.data.link ? item.data.link : '',\n          'title': escape_html__WEBPACK_IMPORTED_MODULE_2___default()(item.location + ' / ' + item.text)\n        });\n        var cap = html5_tag__WEBPACK_IMPORTED_MODULE_1___default()('span', {\n          'class': 'ItemFilterField__Item__Caption'\n        }, escape_html__WEBPACK_IMPORTED_MODULE_2___default()(title));\n        var itemDiv = html5_tag__WEBPACK_IMPORTED_MODULE_1___default()('div', {\n          'class': 'ItemFilterField__Item'\n        }, img + cap);\n        return itemDiv;\n      });\n\n      if (newItems.length > 0) {\n        displayDiv.innerHTML = newItems.join('');\n      } else {\n        displayDiv.innerHTML = \"<div class='ItemFilterField__Loading'>No results</div>\";\n      }\n    }\n  }]);\n\n  return ItemFilterField;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this,\n        args = arguments;\n\n    var later = function later() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n\n;\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.scss":
/*!*******************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.scss ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.scss?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/SelectField.js":
/*!*************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/SelectField.js ***!
  \*************************************************************************************/
/*! exports provided: SelectField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectField\", function() { return SelectField; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar SelectField =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(SelectField, _Field);\n\n  function SelectField() {\n    _classCallCheck(this, SelectField);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SelectField).apply(this, arguments));\n  }\n\n  _createClass(SelectField, [{\n    key: \"render\",\n    value: function render() {\n      var this$1 = this;\n      var select = document.createElement(\"select\");\n      this.options.options.forEach(function (o) {\n        var opt = select.appendChild(document.createElement(\"option\"));\n        opt.value = o.value;\n        opt.selected = o.value == this$1.options.value;\n        opt.innerHTML = o.label;\n        opt.label = o.label;\n      });\n      return select;\n    }\n  }]);\n\n  return SelectField;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/SelectField.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js":
/*!***********************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js ***!
  \***********************************************************************************/
/*! exports provided: TextField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextField\", function() { return TextField; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar TextField =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(TextField, _Field);\n\n  function TextField() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, TextField);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextField)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"textType\", \"text\");\n\n    return _this;\n  }\n\n  _createClass(TextField, [{\n    key: \"render\",\n    value: function render() {\n      var input = document.createElement(\"input\");\n      input.type = this.textType;\n      input.name = this.options.name ? this.options.name : this.options.label;\n      input.placeholder = this.options.placeholder ? this.options.placeholder : '...';\n      input.value = this.options.value || \"\";\n      input.autocomplete = this.options.autocomplete ? this.options.autocomplete : \"off\";\n      return input;\n    }\n  }]);\n\n  return TextField;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField.js":
/*!***************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField.js ***!
  \***************************************************************************************/
/*! exports provided: TextareaField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextareaField\", function() { return TextareaField; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar TextareaField =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(TextareaField, _Field);\n\n  function TextareaField() {\n    _classCallCheck(this, TextareaField);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TextareaField).apply(this, arguments));\n  }\n\n  _createClass(TextareaField, [{\n    key: \"render\",\n    value: function render() {\n      var input = document.createElement(\"textarea\");\n      input.name = this.options.name;\n      input.rows = 10;\n      input.placeholder = this.options.label;\n      input.value = this.options.value || \"\";\n      return input;\n    }\n  }]);\n\n  return TextareaField;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/fields/TreeField.js":
/*!***********************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/TreeField.js ***!
  \***********************************************************************************/
/*! exports provided: TreeField */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeField\", function() { return TreeField; });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/Field.js\");\n/* harmony import */ var infinite_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! infinite-tree */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/lib/index.js\");\n/* harmony import */ var infinite_tree__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(infinite_tree__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classnames */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var escape_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! escape-html */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/escape-html/index.js\");\n/* harmony import */ var escape_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(escape_html__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var html5_tag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! html5-tag */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/html5-tag/lib/index.js\");\n/* harmony import */ var html5_tag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(html5_tag__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var wretch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! wretch */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js\");\n/* harmony import */ var infinite_tree_dist_infinite_tree_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! infinite-tree/dist/infinite-tree.css */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/infinite-tree/dist/infinite-tree.css\");\n/* harmony import */ var infinite_tree_dist_infinite_tree_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(infinite_tree_dist_infinite_tree_css__WEBPACK_IMPORTED_MODULE_6__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\nvar TreeField =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(TreeField, _Field);\n\n  function TreeField(options) {\n    var _this;\n\n    _classCallCheck(this, TreeField);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TreeField).call(this, options));\n\n    if (!_this.options.type) {\n      _this.options.type = 'page';\n    }\n\n    if (!_this.options.url) {\n      _this.options.url = '__prose';\n    }\n\n    return _this;\n  }\n\n  _createClass(TreeField, [{\n    key: \"read\",\n    value: function read(dom) {\n      if (this.hiddenField) {\n        return this.options.type == 'file' ? {\n          type: 'file',\n          shortcode: 'file_link',\n          id: this.hiddenField.value\n        } : {\n          type: 'page',\n          shortcode: 'sitetree_link',\n          id: this.hiddenField.value // '[file_link,id=' + this.hiddenField.value + ']' :\n          // '[sitetree_link,id=' + this.hiddenField.value + ']';\n\n        };\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var input = document.createElement('input');\n      input.readOnly = true;\n      input.name = this.options.name ? this.options.name : this.options.label;\n      input.type = \"text\";\n      input.value = this.options.text || \"\";\n      this.hiddenField = document.createElement('hidden');\n      this.hiddenField.type = \"text\";\n      this.hiddenField.value = this.options.value || \"\";\n      var div = document.createElement('div');\n      div.className = 'TreeField';\n      var treeDiv = document.createElement('div');\n      div.className = 'TreeField__Tree';\n      div.appendChild(input);\n      div.appendChild(this.hiddenField);\n      div.appendChild(treeDiv);\n      this.tree = treeDiv;\n      var treeUrlBase = this.options.url;\n      var treeType = this.options.type == 'file' ? 'file' : 'page';\n      var isStage = location.href.indexOf('stage=Stage') > 0;\n      var appendage = isStage ? '&stage=Stage' : '';\n      var apiUrl = treeUrlBase + '/childnodes/' + treeType; // + '?id=' + node.id + appendage;\n\n      var secId = document.querySelector('input[name=SecurityID]').value;\n      var tree = new infinite_tree__WEBPACK_IMPORTED_MODULE_1___default.a({\n        el: treeDiv,\n        data: [{\n          id: '#',\n          name: this.options.treeLabel ? this.options.treeLabel : 'Select item',\n          loadOnDemand: true,\n          children: []\n        }],\n        // autoOpen: true,\n        loadNodes: function loadNodes(parentNode, next) {\n          var reqUrl = \"\".concat(apiUrl, \"?id=\").concat(parentNode.id).concat(appendage);\n          var w = Object(wretch__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n          var queryOpts = {\n            id: parentNode.id,\n            SecurityID: secId\n          };\n\n          if (isStage) {\n            queryOpts.stage = 'Stage';\n          }\n\n          w.url(reqUrl).query(queryOpts).get().json(function (data) {\n            var nodes = data.map(function (item) {\n              return {\n                id: \"\" + item.id,\n                name: item.text,\n                loadOnDemand: item.children,\n                children: item.children ? [] : null,\n                icon: item.icon || null,\n                data: item.data\n              };\n            });\n            next(null, nodes, function () {});\n          });\n        },\n        rowRenderer: customRowRenderer\n      });\n      var firstNode = treeDiv.querySelector('div.infinite-tree-item[data-id=\"#\"] a.infinite-tree-toggler');\n\n      if (firstNode) {\n        firstNode.click();\n      }\n\n      tree.on('selectNode', function (node) {\n        if (!node) {\n          return;\n        }\n\n        if (!node.data || !node.data.link) {\n          return;\n        }\n\n        input.value = node.name;\n\n        if (this.options.titleField) {\n          document.getElementsByName(this.options.titleField).forEach(function (elem) {\n            elem.value = node.name;\n          });\n        }\n\n        this.hiddenField.value = node.id;\n\n        if (node.data) {\n          // if there's a linked field, use it\n          if (this.options.linkField && node.data.link) {\n            document.getElementsByName(this.options.linkField).forEach(function (elem) {\n              elem.value = node.data.link;\n            });\n          }\n        }\n      }.bind(this)); // $(treeDiv).on('select_node.jstree', function (e, tree) {\n      //     let node = tree.node;\n      //     if (!node) {\n      //         return;\n      //     }\n      //     input.value = node.text;\n      //     if (this.options.titleField) {\n      //         document.getElementsByName(this.options.titleField).forEach((elem) => {\n      //             elem.value = node.text;\n      //         });\n      //     }\n      //     this.hiddenField.value = node.id;\n      //     if (node.data) {\n      //         // if there's a linked field, use it\n      //         if (this.options.linkField && node.data.link) {\n      //             document.getElementsByName(this.options.linkField).forEach((elem) => {\n      //                 elem.value = node.data.link;\n      //             });\n      //         }\n      //     }\n      // }.bind(this));\n\n      return div;\n    }\n  }]);\n\n  return TreeField;\n}(_Field__WEBPACK_IMPORTED_MODULE_0__[\"Field\"]);\n\nvar customRowRenderer = function customRowRenderer(node, treeOptions) {\n  var id = node.id,\n      name = node.name,\n      _node$loadOnDemand = node.loadOnDemand,\n      loadOnDemand = _node$loadOnDemand === void 0 ? false : _node$loadOnDemand,\n      children = node.children,\n      state = node.state,\n      icon = node.icon;\n  var droppable = treeOptions.droppable;\n  var depth = state.depth,\n      open = state.open,\n      path = state.path,\n      total = state.total,\n      _state$selected = state.selected,\n      selected = _state$selected === void 0 ? false : _state$selected,\n      filtered = state.filtered;\n  var childrenLength = Object.keys(children).length;\n  var more = node.hasChildren();\n\n  if (filtered === false) {\n    return '';\n  }\n\n  var togglerContent = '';\n\n  if (!more && loadOnDemand) {\n    togglerContent = '►';\n  }\n\n  if (more && open) {\n    togglerContent = '▼';\n  }\n\n  if (more && !open) {\n    togglerContent = '►';\n  }\n\n  var toggler = html5_tag__WEBPACK_IMPORTED_MODULE_4___default()('a', {\n    'style': 'min-width: 16px; display: inline-block',\n    'class': function () {\n      if (!more && loadOnDemand) {\n        return classnames__WEBPACK_IMPORTED_MODULE_2___default()(treeOptions.togglerClass, 'infinite-tree-closed');\n      }\n\n      if (more && open) {\n        return classnames__WEBPACK_IMPORTED_MODULE_2___default()(treeOptions.togglerClass);\n      }\n\n      if (more && !open) {\n        return classnames__WEBPACK_IMPORTED_MODULE_2___default()(treeOptions.togglerClass, 'infinite-tree-closed');\n      }\n    }()\n  }, togglerContent);\n  var iconTag = icon ? html5_tag__WEBPACK_IMPORTED_MODULE_4___default()('img', {\n    'src': icon,\n    height: '16',\n    style: 'margin-right: 0.5rem; max-width: 32px;'\n  }) : '';\n  var iconHolder = icon ? html5_tag__WEBPACK_IMPORTED_MODULE_4___default()('span', {\n    'style': 'width: 32px; display: inline-block;'\n  }, iconTag) : '';\n  var title = html5_tag__WEBPACK_IMPORTED_MODULE_4___default()('span', {\n    'class': classnames__WEBPACK_IMPORTED_MODULE_2___default()('infinite-tree-title')\n  }, escape_html__WEBPACK_IMPORTED_MODULE_3___default()(name));\n  var treeNode = html5_tag__WEBPACK_IMPORTED_MODULE_4___default()('div', {\n    'class': 'infinite-tree-node',\n    'style': \"margin-left: \".concat(depth * 18, \"px\")\n  }, toggler + iconHolder + title);\n  return html5_tag__WEBPACK_IMPORTED_MODULE_4___default()('div', {\n    'data-id': \"\" + id,\n    'data-expanded': more && open,\n    'data-depth': \"\" + depth,\n    'data-path': path,\n    'data-selected': selected,\n    'data-children': childrenLength,\n    'data-total': total,\n    'class': classnames__WEBPACK_IMPORTED_MODULE_2___default()('infinite-tree-item', {\n      'infinite-tree-selected': selected\n    }),\n    'droppable': droppable\n  }, treeNode);\n};\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/fields/TreeField.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/clear-marks.js":
/*!**************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/clear-marks.js ***!
  \**************************************************************************************/
/*! exports provided: clearMarks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearMarks\", function() { return clearMarks; });\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_menu__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\n\n\nvar clearicon = {\n  width: 20,\n  height: 20,\n  path: \"M13.774,9.355h-7.36c-0.305,0-0.552,0.247-0.552,0.551s0.247,0.551,0.552,0.551h7.36 c0.304,0,0.551-0.247,0.551-0.551S14.078,9.355,13.774,9.355z M10.094,0.875c-4.988,0-9.031,4.043-9.031,9.031    s4.043,9.031,9.031,9.031s9.031-4.043,9.031-9.031S15.082,0.875,10.094,0.875z M10.094,17.809c-4.365,0-7.902-3.538-7.902-7.902    c0-4.365,3.538-7.902,7.902-7.902c4.364,0,7.902,3.538,7.902,7.902C17.996,14.271,14.458,17.809,10.094,17.809z\"\n};\nfunction clearMarks() {\n  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_0__[\"MenuItem\"]({\n    title: \"Clear formatting, links\",\n    icon: clearicon,\n    enable: function enable(state) {\n      return state.selection != null;\n    },\n    run: function run(state, dispatch, view) {\n      dispatch(state.tr.removeMark(state.selection.$from.pos, state.selection.$to.pos));\n    }\n  });\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/clear-marks.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/image-paste.js":
/*!**************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/image-paste.js ***!
  \**************************************************************************************/
/*! exports provided: imagePaste */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"imagePaste\", function() { return imagePaste; });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var wretch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wretch */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\n\nvar IMAGE_TYPE = /image.*/;\nvar MAX_PASTE_SIZE = 1500000;\nvar PASTING = false;\nvar imagePaste = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__[\"Plugin\"]({\n  state: {\n    init: function init() {\n      return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__[\"DecorationSet\"].empty;\n    },\n    apply: function apply(tr, set) {\n      set = set.map(tr.mapping, tr.doc); // See if the transaction adds or removes any placeholders\n\n      var action = tr.getMeta(this);\n\n      if (action && action.add) {\n        var widget = document.createElement(\"placeholder\"); // let imgNode = document.createElement('img');\n        // imgNode.setAttribute('src', 'resources/symbiote/silverstripe-prose-editor/client/images/paste-loading.png');\n        // widget.appendChild(imgNode);\n\n        var deco = prosemirror_view__WEBPACK_IMPORTED_MODULE_2__[\"Decoration\"].widget(action.add.pos, widget, {\n          id: action.add.id\n        });\n        set = set.add(tr.doc, [deco]);\n      } else if (action && action.remove) {\n        set = set.remove(set.find(null, null, function (spec) {\n          return spec.id == action.remove.id;\n        }));\n      }\n\n      return set;\n    }\n  },\n  props: {\n    decorations: function decorations(state) {\n      return this.getState(state);\n    },\n    handleDOMEvents: {\n      paste: function paste(view, e) {\n        var clipboardData = e.clipboardData || window.clipboardData;\n\n        if (!clipboardData) {\n          return;\n        }\n\n        for (var i = 0; i < clipboardData.types.length; i++) {\n          if (clipboardData.types[i].match(IMAGE_TYPE) || clipboardData.items[i].type.match(IMAGE_TYPE)) {\n            var file;\n            var reader;\n\n            var _ret = function () {\n              var editorParent = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"findEditorFieldNode\"])(view.dom);\n\n              if (!editorParent) {\n                return {\n                  v: void 0\n                };\n              } // by simply returning true, we let the image get pasted as base64 data: urls.\n\n\n              file = clipboardData.items[i].getAsFile();\n\n              if (!file) {\n                // file = clipboardData.items[i].getAsString(function (s) {\n                //     console.log(s);\n                // });\n                alert(\"Could not convert clipboard data to file, please try a smaller image\");\n                return \"continue\";\n              }\n\n              e.stopPropagation();\n              var tr = view.state.tr;\n              var id = new Date().getTime();\n\n              if (!tr.selection.empty) {\n                tr.deleteSelection();\n              } // add a placeholder\n\n\n              tr.setMeta(imagePaste, {\n                add: {\n                  id: id,\n                  pos: tr.selection.from\n                }\n              });\n              view.dispatch(tr);\n              reader = new FileReader();\n\n              reader.onload = function (evt) {\n                if (evt.target.result && evt.target.result.length > 0 && evt.target.result.length < MAX_PASTE_SIZE) {\n                  // declared here, otherwise the paste action can change the focused element before the post responds\n                  PASTING = true;\n                  var secId = document.querySelector('input[name=SecurityID]').value;\n                  var uploadPath = editorParent.getAttribute('data-upload-path');\n                  var uploadEndpoint = editorParent.getAttribute('data-prose-url') + '/pastefile';\n                  var w = Object(wretch__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n                  w.url(uploadEndpoint).formData({\n                    'ajax': 1,\n                    SecurityID: secId,\n                    rawData: evt.target.result,\n                    path: uploadPath\n                  }).post().json(function (response) {\n                    if (response && response.url) {\n                      var imageNodeType = view.state.config.schema.nodes.image;\n                      var pos = findPlaceholder(view.state, id);\n\n                      if (pos == null) {\n                        return;\n                      }\n\n                      view.dispatch(view.state.tr.replaceWith(pos, pos, imageNodeType.create({\n                        src: response.url\n                      })).setMeta(imagePaste, {\n                        remove: {\n                          id: id\n                        }\n                      }));\n                    }\n\n                    PASTING = false;\n                  }).catch(function (d) {\n                    view.dispatch(tr.setMeta(placeholderPlugin, {\n                      remove: {\n                        id: id\n                      }\n                    }));\n                    console.error(error);\n                    alert(\"Upload failed\");\n                  });\n                }\n              };\n\n              reader.readAsDataURL(file);\n            }();\n\n            switch (_ret) {\n              case \"continue\":\n                continue;\n\n              default:\n                if (_typeof(_ret) === \"object\") return _ret.v;\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\nfunction findPlaceholder(state, id) {\n  var decos = imagePaste.getState(state);\n  var found = decos.find(null, null, function (spec) {\n    return spec.id == id;\n  });\n  return found.length ? found[0].from : null;\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/image-paste.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/markdown-editing.js":
/*!*******************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/markdown-editing.js ***!
  \*******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n/* harmony import */ var _proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proseutil/doc-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js\");\n/* harmony import */ var prosemirror_markdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-markdown */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-markdown/dist/index.js\");\n/* harmony import */ var prosemirror_markdown__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_markdown__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fields_TextareaField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fields/TextareaField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(prosemirror_menu__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\nvar icon = {\n  width: 208,\n  height: 128,\n  path: \"M30 98v-68h20l20 25 20-25h20v68h-20v-39l-20 25-20-25v39zM155 98l-30-33h20v-35h20v35h20z\"\n};\n\nfunction editMarkdown() {\n  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_5__[\"MenuItem\"]({\n    title: \"Edit markdown\",\n    label: \"Markdown\",\n    icon: icon,\n    enable: function enable(state) {\n      return state.selection.empty;\n    },\n    run: function run(state, _, view) {\n      // var ref = state.selection;\n      var markdown = prosemirror_markdown__WEBPACK_IMPORTED_MODULE_2__[\"defaultMarkdownSerializer\"].serialize(view.state.doc);\n      Object(_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__[\"openPrompt\"])({\n        title: \"Markdown\",\n        fields: {\n          content: new _fields_TextareaField__WEBPACK_IMPORTED_MODULE_4__[\"TextareaField\"]({\n            label: \"Content\",\n            value: markdown\n          })\n        },\n        callback: function callback(attrs) {\n          var newDoc = prosemirror_markdown__WEBPACK_IMPORTED_MODULE_2__[\"defaultMarkdownParser\"].parse(attrs.content); // we convert the doc to a known-good HTML format before reparsing\n          // otherwise the current editor can't read the markdown text\n\n          newDoc = Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_1__[\"htmlToDoc\"])(Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_1__[\"docToHtml\"])(newDoc));\n          view.dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__[\"AllSelection\"](state.doc)));\n          view.dispatch(view.state.tr.replaceSelectionWith(newDoc));\n          view.focus();\n        }\n      });\n    }\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (editMarkdown);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/markdown-editing.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js":
/*!*************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js ***!
  \*************************************************************************************/
/*! exports provided: InlineShortcodeNodeSpec, BlockShortcodeNodeSpec, ShortcodeViewer, ShortcodeNodeView, insertShortcode, renderProseShortcode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InlineShortcodeNodeSpec\", function() { return InlineShortcodeNodeSpec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockShortcodeNodeSpec\", function() { return BlockShortcodeNodeSpec; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShortcodeViewer\", function() { return ShortcodeViewer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShortcodeNodeView\", function() { return ShortcodeNodeView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"insertShortcode\", function() { return insertShortcode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderProseShortcode\", function() { return renderProseShortcode; });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\n/* harmony import */ var _proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n/* harmony import */ var _fields_TextField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../fields/TextField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js\");\n/* harmony import */ var wretch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wretch */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/wretch/dist/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar INLINE_CONTAINER_ELEM = 'span';\nvar BLOCK_CONTAINER_ELEM = 'div';\nvar PROSE_CLASS = 'prose-shortcode';\nvar SETTINGS_ICON = {\n  width: 20,\n  height: 20,\n  path: \"M17.279,8.257h-0.785c-0.107-0.322-0.237-0.635-0.391-0.938l0.555-0.556c0.208-0.208,0.208-0.544,0-0.751l-2.254-2.257c-0.199-0.2-0.552-0.2-0.752,0l-0.556,0.557c-0.304-0.153-0.617-0.284-0.939-0.392V3.135c0-0.294-0.236-0.532-0.531-0.532H8.435c-0.293,0-0.531,0.237-0.531,0.532v0.784C7.582,4.027,7.269,4.158,6.966,4.311L6.409,3.754c-0.1-0.1-0.234-0.155-0.376-0.155c-0.141,0-0.275,0.055-0.375,0.155L3.403,6.011c-0.208,0.207-0.208,0.543,0,0.751l0.556,0.556C3.804,7.622,3.673,7.935,3.567,8.257H2.782c-0.294,0-0.531,0.238-0.531,0.531v3.19c0,0.295,0.237,0.531,0.531,0.531h0.787c0.105,0.318,0.236,0.631,0.391,0.938l-0.556,0.559c-0.208,0.207-0.208,0.545,0,0.752l2.254,2.254c0.208,0.207,0.544,0.207,0.751,0l0.558-0.559c0.303,0.154,0.616,0.285,0.938,0.391v0.787c0,0.293,0.238,0.531,0.531,0.531h3.191c0.295,0,0.531-0.238,0.531-0.531v-0.787c0.322-0.105,0.636-0.236,0.938-0.391l0.56,0.559c0.208,0.205,0.546,0.207,0.752,0l2.252-2.254c0.208-0.207,0.208-0.545,0.002-0.752l-0.559-0.559c0.153-0.303,0.285-0.615,0.389-0.938h0.789c0.295,0,0.532-0.236,0.532-0.531v-3.19C17.812,8.495,17.574,8.257,17.279,8.257z M16.747,11.447h-0.653c-0.241,0-0.453,0.164-0.514,0.398c-0.129,0.496-0.329,0.977-0.594,1.426c-0.121,0.209-0.089,0.473,0.083,0.645l0.463,0.465l-1.502,1.504l-0.465-0.463c-0.174-0.174-0.438-0.207-0.646-0.082c-0.447,0.262-0.927,0.463-1.427,0.594c-0.234,0.061-0.397,0.271-0.397,0.514V17.1H8.967v-0.652c0-0.242-0.164-0.453-0.397-0.514c-0.5-0.131-0.98-0.332-1.428-0.594c-0.207-0.123-0.472-0.09-0.646,0.082l-0.463,0.463L4.53,14.381l0.461-0.463c0.169-0.172,0.204-0.434,0.083-0.643c-0.266-0.461-0.467-0.939-0.596-1.43c-0.06-0.234-0.272-0.398-0.514-0.398H3.313V9.319h0.652c0.241,0,0.454-0.162,0.514-0.397c0.131-0.498,0.33-0.979,0.595-1.43c0.122-0.208,0.088-0.473-0.083-0.645L4.53,6.386l1.503-1.504l0.46,0.462c0.173,0.172,0.437,0.204,0.646,0.083c0.45-0.265,0.931-0.464,1.433-0.597c0.233-0.062,0.396-0.274,0.396-0.514V3.667h2.128v0.649c0,0.24,0.161,0.452,0.396,0.514c0.502,0.133,0.982,0.333,1.433,0.597c0.211,0.12,0.475,0.089,0.646-0.083l0.459-0.462l1.504,1.504l-0.463,0.463c-0.17,0.171-0.202,0.438-0.081,0.646c0.263,0.448,0.463,0.928,0.594,1.427c0.061,0.235,0.272,0.397,0.514,0.397h0.651V11.447z\"\n};\nvar InlineShortcodeNodeSpec = {\n  attrs: {\n    shortcode: {\n      default: {\n        type: 'inline_placeholder',\n        args: {},\n        attrs: {}\n      }\n    }\n  },\n  inline: true,\n  group: \"inline\",\n  draggable: true,\n  defining: true,\n  // so people can't select the inner content separately\n  atom: true,\n  nodeContainer: INLINE_CONTAINER_ELEM,\n  toDOM: function toDOM(node) {\n    return [INLINE_CONTAINER_ELEM, {\n      \"data-shortcode\": JSON.stringify(node.attrs.shortcode),\n      class: PROSE_CLASS\n    }, nodeToShortcode(node)];\n  },\n  // When parsing, such an image, if its type matches one of the known\n  // types, is converted to a dino node.\n  parseDOM: [{\n    tag: INLINE_CONTAINER_ELEM + \"[class=\" + PROSE_CLASS + \"]\",\n    getAttrs: function getAttrs(dom) {\n      var shortcode = dom.getAttribute(\"data-shortcode\");\n\n      if (shortcode) {\n        var shortcodeData = JSON.parse(shortcode);\n        return {\n          shortcode: shortcodeData\n        };\n      }\n\n      return InlineShortcodeNodeSpec.attrs.shortcode.default;\n    }\n  }]\n  /**\n   * Block shortcodes have content that appears outside <p> tags.\n   */\n\n};\nvar blockParse = [Object.assign({}, InlineShortcodeNodeSpec.parseDOM[0], {\n  tag: BLOCK_CONTAINER_ELEM + \"[class=\" + PROSE_CLASS + \"]\"\n})];\nvar BlockShortcodeNodeSpec = Object.assign({}, InlineShortcodeNodeSpec, {\n  attrs: {\n    shortcode: {\n      default: {\n        type: 'block_placeholder',\n        args: {}\n      }\n    }\n  },\n  nodeContainer: BLOCK_CONTAINER_ELEM,\n  inline: false,\n  group: \"block\",\n  parseDOM: blockParse,\n  toDOM: function toDOM(node) {\n    return [BLOCK_CONTAINER_ELEM, {\n      \"data-shortcode\": JSON.stringify(node.attrs.shortcode),\n      class: PROSE_CLASS\n    }, nodeToShortcode(node)];\n  }\n});\n\nfunction cloneShortcodeAttrs(shortcodeAttrs) {\n  return {\n    type: shortcodeAttrs.type,\n    args: Object.assign({}, shortcodeAttrs.args)\n  };\n}\n\nfunction nodeToShortcode(node) {\n  var attrStr = \"\";\n\n  if (!node.attrs.shortcode) {\n    return \"\";\n  }\n\n  if (node.attrs.shortcode.args) {\n    var argStr = argsToAttrString(node.attrs.shortcode.args);\n\n    if (argStr.length > 0) {\n      attrStr = \",\" + argStr;\n    }\n  }\n\n  return \"[\" + node.attrs.shortcode.type + attrStr + \"]\";\n}\n\nfunction argsToAttrString(args) {\n  var keys = Object.keys(args);\n\n  if (keys.length > 0) {\n    var attrs = keys.map(function (item) {\n      return item + '=\"' + args[item] + '\"';\n    });\n    return attrs.join(' ');\n  }\n\n  return \"\";\n}\n\nvar ShortcodeViewer = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__[\"Plugin\"]({});\nvar ShortcodeNodeView =\n/*#__PURE__*/\nfunction () {\n  function ShortcodeNodeView(node, view, getPos) {\n    _classCallCheck(this, ShortcodeNodeView);\n\n    // We'll need these later\n    this.node = node;\n    this.outerView = view;\n    this.getPos = getPos; // The node's representation in the editor\n\n    this.dom = document.createElement(node.type.spec.nodeContainer);\n    this.dom.className = PROSE_CLASS;\n    this.dom.setAttribute('style', 'position: relative');\n    var contentHolder = document.createElement(node.type.spec.nodeContainer);\n    var settingsButton = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_1__[\"buildSvg\"])(SETTINGS_ICON);\n    this.contentHolder = contentHolder;\n    this.settingsButton = settingsButton;\n    settingsButton.setAttribute('style', 'cursor: pointer; position: absolute; padding: 0px; right: 0px; top: 0px;line-height: 0.8;');\n    contentHolder.setAttribute('style', 'margin-right: 16px');\n    this.dom.appendChild(contentHolder);\n    this.dom.appendChild(settingsButton);\n    settingsButton.addEventListener('click', function (e) {\n      e.preventDefault();\n      var nodeArgs = node.attrs.shortcode.args;\n      var shortcodeAttrs = node.attrs.shortcode.attrs;\n      var fields = {};\n      Object.keys(shortcodeAttrs).forEach(function (key) {\n        var inputField = shortcodeAttrs[key] == 'text' ? new _fields_TextField__WEBPACK_IMPORTED_MODULE_3__[\"TextField\"]({\n          label: key,\n          value: nodeArgs ? nodeArgs[key] : null\n        }) : null;\n\n        if (inputField) {\n          fields[key] = inputField;\n        }\n      });\n      Object(_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_2__[\"openPrompt\"])({\n        title: \"Shortcode attributes\",\n        fields: fields,\n        callback: function callback(attrs) {\n          var newNodeAttrs = JSON.parse(JSON.stringify(node.attrs));\n          newNodeAttrs.shortcode.args = attrs;\n          view.dispatch(view.state.tr.setNodeMarkup(getPos(), null, newNodeAttrs, undefined));\n        }\n      });\n    });\n    var editorParent = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_1__[\"findEditorFieldNode\"])(view.dom);\n\n    if (editorParent && this.node.attrs.shortcode) {\n      var shortcodeUrl = editorParent.getAttribute('data-prose-url') + '/rendershortcode';\n      var shortcodeArgs = this.node.attrs.shortcode.args;\n      shortcodeArgs = shortcodeArgs || {};\n      shortcodeArgs.context_id = editorParent.getAttribute('data-context-id');\n      renderProseShortcode(this.node.attrs.shortcode.type, shortcodeArgs, shortcodeUrl).text(function (res) {\n        contentHolder.innerHTML = res;\n      });\n    }\n\n    contentHolder.innerHTML = 'Loading...';\n  }\n\n  _createClass(ShortcodeNodeView, [{\n    key: \"selectNode\",\n    value: function selectNode() {\n      this.dom.classList.add(\"ProseMirror-selectednode\");\n    }\n  }, {\n    key: \"deselectNode\",\n    value: function deselectNode() {\n      this.dom.classList.remove(\"ProseMirror-selectednode\");\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.contentHolder.remove();\n      this.settingsButton.remove();\n    }\n  }]);\n\n  return ShortcodeNodeView;\n}();\n/**\n * Command for inserting\n */\n\nfunction insertShortcode(shortcode, attributes, shortcodeNodeType) {\n  if (!shortcode) {\n    shortcode = 'inline_placeholder';\n  }\n\n  return function (state, dispatch) {\n    if (Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_1__[\"canInsert\"])(state, shortcodeNodeType)) {\n      if (dispatch) {\n        var newNode = shortcodeNodeType.create({\n          shortcode: {\n            type: shortcode,\n            attrs: attributes\n          }\n        });\n        dispatch(state.tr.replaceSelectionWith(newNode));\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n}\nfunction renderProseShortcode(shortcode, attrs, shortcodeUrl) {\n  var w = Object(wretch__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n  shortcodeUrl = shortcodeUrl || '/__prose/rendershortcode';\n  return w.url(shortcodeUrl).query({\n    shortcode: shortcode,\n    attrs: JSON.stringify(attrs)\n  }).get();\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-image-selector.js":
/*!********************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/ss-image-selector.js ***!
  \********************************************************************************************/
/*! exports provided: imageSelector, imageSelectorDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"imageSelector\", function() { return imageSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"imageSelectorDialog\", function() { return imageSelectorDialog; });\n/* harmony import */ var _proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fields_TextField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fields/TextField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js\");\n/* harmony import */ var _fields_ItemFilterField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../fields/ItemFilterField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/ItemFilterField.js\");\n/* harmony import */ var _fields_FieldGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../fields/FieldGroup */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/FieldGroup.js\");\n/* harmony import */ var _fields_FileUploadField__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../fields/FileUploadField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/FileUploadField.js\");\n\n\n\n\n\n\n\n\nvar imageIcon = {\n  width: 20,\n  height: 20,\n  path: \"M18.555,15.354V4.592c0-0.248-0.202-0.451-0.45-0.451H1.888c-0.248,0-0.451,0.203-0.451,0.451v10.808c0,0.559,0.751,0.451,0.451,0.451h16.217h0.005C18.793,15.851,18.478,14.814,18.555,15.354 M2.8,14.949l4.944-6.464l4.144,5.419c0.003,0.003,0.003,0.003,0.003,0.005l0.797,1.04H2.8z M13.822,14.949l-1.006-1.317l1.689-2.218l2.688,3.535H13.822z M17.654,14.064l-2.791-3.666c-0.181-0.237-0.535-0.237-0.716,0l-1.899,2.493l-4.146-5.42c-0.18-0.237-0.536-0.237-0.716,0l-5.047,6.598V5.042h15.316V14.064z M12.474,6.393c-0.869,0-1.577,0.707-1.577,1.576s0.708,1.576,1.577,1.576s1.577-0.707,1.577-1.576S13.343,6.393,12.474,6.393 M12.474,8.645c-0.371,0-0.676-0.304-0.676-0.676s0.305-0.676,0.676-0.676c0.372,0,0.676,0.304,0.676,0.676S12.846,8.645,12.474,8.645\"\n};\nvar UPLOAD_ENDPOINT = '__prose/uploadfile';\nfunction imageSelector(nodeType) {\n  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__[\"MenuItem\"]({\n    title: \"Add image\",\n    icon: imageIcon,\n    enable: function enable(state) {\n      return Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__[\"canInsert\"])(state, nodeType);\n    },\n    run: function run(state, dispatch, view) {\n      var attrs = null;\n      var node = null;\n      var from = state.selection.from;\n      var to = state.selection.to;\n\n      if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_3__[\"NodeSelection\"] && state.selection.node.type == nodeType) {\n        node = state.selection.node;\n        attrs = node.attrs;\n        attrs.alt = attrs.alt || state.doc.textBetween(from, to, \" \");\n      }\n\n      imageSelectorDialog(attrs, function callback(newAttrs) {\n        if (newAttrs.imageSel) {\n          newAttrs['data-id'] = newAttrs.imageSel.id; // attrs['data-shortcode'] = 'image';\n        }\n\n        view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(newAttrs)));\n        view.focus();\n      });\n    }\n  });\n}\nfunction imageSelectorDialog(attrs, callback, fieldList) {\n  var secId = document.querySelector('input[name=SecurityID]').value;\n  var uploadUrl = UPLOAD_ENDPOINT + '?SecurityID=' + secId + '&path=' + location.pathname;\n  var filterField = new _fields_ItemFilterField__WEBPACK_IMPORTED_MODULE_5__[\"ItemFilterField\"]({\n    name: \"image_selector\",\n    linkField: 'image_location',\n    titleField: 'image_title',\n    label: \"Find an image\",\n    required: false,\n    text: '',\n    type: 'image',\n    value: null\n  });\n  var availableFields = {\n    imageSel: filterField,\n    fileUpload: new _fields_FileUploadField__WEBPACK_IMPORTED_MODULE_7__[\"FileUploadField\"]({\n      name: 'imageUpload',\n      label: 'Upload image',\n      required: false,\n      type: 'image',\n      value: null,\n      uploadurl: uploadUrl,\n      onupload: function onupload(file) {\n        if (file && file.filenameWithoutExtension) {\n          filterField && filterField.lookupItems(file.filenameWithoutExtension);\n        }\n      }\n    }),\n    imageInfo: new _fields_FieldGroup__WEBPACK_IMPORTED_MODULE_6__[\"FieldGroup\"]({\n      name: 'imageInfo',\n      label: \"Details\",\n      fields: {\n        src: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n          label: \"Location\",\n          required: true,\n          value: attrs && attrs.src,\n          name: 'image_location'\n        }),\n        title: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n          label: \"Title\",\n          value: attrs && attrs.title,\n          name: \"image_title\"\n        }),\n        alt: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n          label: \"Description\",\n          value: attrs && attrs.alt\n        })\n      }\n    }),\n    imageProps: new _fields_FieldGroup__WEBPACK_IMPORTED_MODULE_6__[\"FieldGroup\"]({\n      name: 'imageProps',\n      label: \"Properties\",\n      fields: {\n        width: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n          label: \"Width\",\n          value: attrs && attrs.width\n        }),\n        height: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n          label: \"Height\",\n          value: attrs && attrs.height\n        })\n      }\n    })\n  };\n  var usedFields = {};\n\n  if (fieldList) {\n    for (var i = 0; i < fieldList.length; i++) {\n      usedFields[fieldList[i]] = availableFields[fieldList[i]];\n    }\n  } else {\n    usedFields = availableFields;\n  }\n\n  Object(_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__[\"openPrompt\"])({\n    title: \"Select image\",\n    fields: usedFields,\n    callback: callback\n  });\n  filterField.lookupItems('');\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/ss-image-selector.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector.js":
/*!*******************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector.js ***!
  \*******************************************************************************************/
/*! exports provided: linkSelector, linkSelectorDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkSelector\", function() { return linkSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkSelectorDialog\", function() { return linkSelectorDialog; });\n/* harmony import */ var _proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fields_TextField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fields/TextField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js\");\n/* harmony import */ var _fields_SelectField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../fields/SelectField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/SelectField.js\");\n/* harmony import */ var _fields_TreeField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../fields/TreeField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TreeField.js\");\nfunction _objectSpread2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\nfunction linkSelector(markType, options) {\n  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__[\"MenuItem\"]({\n    title: \"Add link\",\n    icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__[\"icons\"].link,\n    active: function active(state) {\n      return Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__[\"markActive\"])(state, markType);\n    },\n    enable: function enable(state) {\n      return Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__[\"markActive\"])(state, markType) || !state.selection.empty;\n    },\n    run: function run(state, dispatch, view) {\n      var attrs = {};\n      var node = null; // if we've got a link already active, we need to select it\n\n      if (Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__[\"markActive\"])(state, markType)) {\n        // position of the cursor or selection start; we don't use\n        // selection.$cursor, because a range selection will have $cursor\n        // as null\n        var pos = state.selection.$anchor.pos;\n        var markPos = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_2__[\"positionAroundMark\"])(state.doc, pos, markType); // and the node at that point\n\n        node = state.doc.nodeAt(pos); // figure out the position of the wrapping text element as applicable\n\n        var textPos = state.doc.resolve(pos);\n        var selection = null;\n\n        if (node.isText) {\n          selection = prosemirror_state__WEBPACK_IMPORTED_MODULE_3__[\"TextSelection\"].create(state.doc, markPos.from, markPos.to);\n        } else {\n          selection = prosemirror_state__WEBPACK_IMPORTED_MODULE_3__[\"NodeSelection\"].create(state.doc, textPos.start());\n        }\n\n        dispatch(state.tr.setSelection(selection));\n\n        if (node && node.marks && node.marks.length > 0) {\n          node.marks.forEach(function (mark) {\n            if (mark.type == markType) {\n              attrs = mark.attrs;\n            }\n          });\n        }\n      }\n\n      var linkAttrs = _objectSpread2({}, attrs, {\n        text: node ? node.text : ''\n      });\n\n      linkSelectorDialog(linkAttrs, options, function callback(newAttrs) {\n        newAttrs.href = newAttrs.externalLink;\n\n        if (newAttrs.href.length === 0) {\n          var pageData = newAttrs.pageLink;\n\n          if (pageData && pageData.id) {\n            newAttrs.href = '[' + pageData.shortcode + ',id=' + pageData.id + ']';\n          }\n        }\n\n        var from = view.state.selection.$anchor.pos;\n        var to = view.state.selection.$head.pos;\n        view.dispatch(view.state.tr.addMark(from, to, markType.create(newAttrs))); // toggleMark(markType, attrs)(view.state, view.dispatch);\n        // const schema = view.state.schema;\n        // const node = schema.text(attrs.text, [schema.marks.link.create(attrs)])\n        // view.dispatch(view.state.tr.replaceSelectionWith(node, false));\n\n        view.focus();\n      });\n    }\n  });\n}\nfunction linkSelectorDialog(attrs, options, _callback, fieldList) {\n  var externalLink = '';\n  var itemId = '';\n  var itemText = attrs.text;\n  var itemType = 'page';\n\n  if (attrs && attrs.href) {\n    var parts = null;\n\n    if (parts = attrs.href.match(/sitetree_link,id=(\\d+)/)) {\n      itemId = parts[1];\n      itemType = 'page';\n    } else if (parts = attrs.href.match(/file_link,id=(\\d+)/)) {\n      itemId = parts[1];\n      itemType = 'file';\n    } else {\n      externalLink = attrs.href;\n    }\n\n    if (itemId) {\n      itemText = itemText + ' - ' + itemType + ' #' + itemId + '';\n    }\n  }\n\n  var formFields = {};\n\n  if (options.internal) {\n    formFields.pageLink = new _fields_TreeField__WEBPACK_IMPORTED_MODULE_6__[\"TreeField\"]({\n      name: \"search-page\",\n      label: \"Select a page (or select external link below)\",\n      required: false,\n      text: itemText,\n      type: itemType,\n      value: itemId\n    });\n  }\n\n  formFields = _objectSpread2({}, formFields, {\n    externalLink: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n      label: \"External URL\",\n      required: false,\n      value: externalLink\n    }),\n    title: new _fields_TextField__WEBPACK_IMPORTED_MODULE_4__[\"TextField\"]({\n      label: \"Description\",\n      required: false,\n      value: attrs && attrs.title\n    }),\n    target: new _fields_SelectField__WEBPACK_IMPORTED_MODULE_5__[\"SelectField\"]({\n      label: \"Open target\",\n      required: false,\n      value: attrs && attrs.target,\n      options: [{\n        value: '',\n        label: 'default'\n      }, {\n        value: '_blank',\n        label: '_blank'\n      }, {\n        value: '_self',\n        label: '_self'\n      }, {\n        value: '_parent',\n        label: '_parent'\n      }, {\n        value: '_top',\n        label: '_top'\n      }]\n    })\n  });\n  var usedFields = {};\n\n  if (fieldList) {\n    for (var i = 0; i < fieldList.length; i++) {\n      usedFields[fieldList[i]] = formFields[fieldList[i]];\n    }\n  } else {\n    usedFields = formFields;\n  }\n\n  Object(_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__[\"openPrompt\"])({\n    title: \"Select link\",\n    fields: usedFields,\n    callback: function callback(newAttrs) {\n      newAttrs.href = newAttrs.externalLink;\n\n      if (newAttrs.href.length === 0) {\n        var pageData = newAttrs.pageLink;\n\n        if (pageData && pageData.id) {\n          newAttrs.href = '[' + pageData.shortcode + ',id=' + pageData.id + ']';\n        }\n      }\n\n      _callback(newAttrs);\n    }\n  });\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/table-tools.js":
/*!**************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/table-tools.js ***!
  \**************************************************************************************/
/*! exports provided: tableTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tableTools\", function() { return tableTools; });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-tables */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-tables/dist/index.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar tableTools = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__[\"Plugin\"]({\n  view: function view(editorView) {\n    return new TableTools(editorView);\n  }\n});\n\nvar TableTools =\n/*#__PURE__*/\nfunction () {\n  function TableTools(view) {\n    _classCallCheck(this, TableTools);\n\n    this.tableTools = document.createElement('div');\n    this.tableTools.className = 'tabletools';\n    view.dom.parentNode.appendChild(this.tableTools);\n    this.update(view, null);\n    this.tableMenu = [];\n\n    function item(label, cmd) {\n      return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__[\"MenuItem\"]({\n        title: label,\n        label: label,\n        // select: cmd,\n        run: cmd\n      });\n    }\n\n    this.tableMenu = [Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"addColumnBefore\"], {\n      title: \"Insert column before\",\n      icon: tableIcons.addColumnBefore\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"addColumnAfter\"], {\n      title: \"Insert column after\",\n      icon: tableIcons.addColumnAfter\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"deleteColumn\"], {\n      title: \"Delete column\",\n      icon: tableIcons.deleteColumn\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"addRowBefore\"], {\n      title: \"Insert row before\",\n      icon: tableIcons.addRowBefore\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"addRowAfter\"], {\n      title: \"Insert row after\",\n      icon: tableIcons.addRowAfter\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"deleteRow\"], {\n      title: \"Delete row\",\n      icon: tableIcons.deleteRow\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"mergeCells\"], {\n      title: \"Merge cells\",\n      icon: tableIcons.mergeCells\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"splitCell\"], {\n      title: \"Split cell\",\n      icon: tableIcons.splitCell\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"toggleHeaderColumn\"], {\n      title: \"Toggle header column\",\n      icon: tableIcons.toggleHeaderColumn\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"toggleHeaderRow\"], {\n      title: \"Toggle header row\",\n      icon: tableIcons.toggleHeaderRow\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"toggleHeaderCell\"], {\n      title: \"Toggle header cells\",\n      icon: tableIcons.toggleHeaderCell\n    }), Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_3__[\"cmdItem\"])(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"deleteTable\"], {\n      title: \"Delete table\",\n      icon: tableIcons.deleteTable\n    })]; // this.tableTools.textContent = to;\n\n    this.renderedMenu = Object(prosemirror_menu__WEBPACK_IMPORTED_MODULE_1__[\"renderGrouped\"])(view, [this.tableMenu]);\n    this.tableTools.appendChild(this.renderedMenu.dom);\n  }\n\n  _createClass(TableTools, [{\n    key: \"update\",\n    value: function update(view, prevState) {\n      var state = view.state; // no change since last time\n\n      if (prevState && prevState.doc.eq(state.doc) && prevState.selection.eq(state.selection)) {\n        return;\n      }\n\n      if (!state.selection || !state.selection.$cursor) {\n        return;\n      }\n\n      if (!state.selection.empty || state.selection.$cursor == null) {\n        this.tableTools.style.display = \"none\";\n        return;\n      }\n\n      if (!Object(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"isInTable\"])(state)) {\n        this.tableTools.style.display = \"none\";\n        return;\n      } // Otherwise, reposition it and update its content\n\n\n      this.tableTools.style.display = \"\"; // These are in screen coordinates\n\n      var _state$selection = state.selection,\n          from = _state$selection.from,\n          to = _state$selection.to; // let start = view.coordsAtPos(lastPos), end = view.coordsAtPos(lastPos)\n\n      var start = view.coordsAtPos(from),\n          end = view.coordsAtPos(to); // The box in which the tooltip is positioned, to use as base\n\n      var box = this.tableTools.offsetParent.getBoundingClientRect(); // Find a center-ish x position from the selection endpoints (when\n      // crossing lines, end may be more to the left)\n\n      this.tableTools.style.left = start.left - 100 + \"px\";\n      this.tableTools.style.bottom = box.bottom - start.top + 20 + \"px\";\n      this.renderedMenu && this.renderedMenu.update(state);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.tableTools.remove();\n    }\n  }]);\n\n  return TableTools;\n}();\n\nvar tableIcons = {\n  addColumnBefore: {\n    width: 14,\n    height: 14,\n    path: \"M 8.6819,1e-4 C 8.3918,1e-4 8.159,0.1689 8.159,0.379 l 0,13.242 c 0,0.21 0.2328,0.3789 0.5229,0.3789 l 4.7928,0 c 0.29,0 0.5252,-0.1689 0.5252,-0.3789 l 0,-13.242 c 0,-0.2101 -0.2352,-0.3789 -0.5252,-0.3789 l -4.7928,0 z m 0.687,1.1582 3.4211,0 0,3.2168 -3.4211,0 0,-3.2168 z m 0,4.2852 3.4211,0 0,3.2148 -3.4211,0 0,-3.2148 z m 0,4.2832 3.4211,0 0,3.2148 -3.4211,0 0,-3.2148 z M 4.0319,3.0001 q 0.264,0 0.4658,0.1915 l 0.3882,0.3882 q 0.1965,0.1966 0.1965,0.4709 0,0.2795 -0.1965,0.4658 l -1.5164,1.5217 3.6436,0 q 0.2691,0 0.4372,0.194 0.1683,0.1941 0.1683,0.4684 l 0,0.6625 q 0,0.2743 -0.1683,0.4684 -0.1681,0.1941 -0.4372,0.1941 l -3.6436,0 1.5164,1.5216 q 0.1965,0.1863 0.1965,0.4658 0,0.2795 -0.1965,0.4658 L 4.4977,10.867 q -0.1967,0.1966 -0.4658,0.1966 -0.2742,0 -0.471,-0.1966 L 0.1917,7.4977 Q 1e-4,7.3165 1e-4,7.0319 1e-4,6.7524 0.1917,6.5609 L 3.5609,3.1916 Q 3.7628,3.0001 4.0319,3.0001 Z\"\n  },\n  addColumnAfter: {\n    width: 14,\n    height: 14,\n    path: \"m 5.3165569,14.0019 c 0.2900213,0 0.5227581,-0.1688 0.5227581,-0.3789 l 0,-13.2422 c 0,-0.21 -0.2327368,-0.3789 -0.5227581,-0.3789 l -4.7914999,0 C 0.235136,0.0019 0,0.1708 0,0.3808 L 0,13.623 c 0,0.2101 0.235136,0.3789 0.525057,0.3789 l 4.7914999,0 z m -0.6868135,-1.1582 -3.4201714,0 0,-3.2168 3.4201714,0 0,3.2168 z m 0,-4.2852 -3.4201714,0 0,-3.2148 3.4201714,0 0,3.2148 z m 0,-4.2832 -3.4201714,0 0,-3.2148 3.4201714,0 0,3.2148 z m 5.3395506,6.7583 q -0.2639283,0 -0.4656736,-0.1915 L 9.1155258,10.4539 Q 8.9190791,10.2573 8.9190791,9.983 q 0,-0.2795 0.1964467,-0.4658 l 1.5159882,-1.5217 -3.642611,0 q -0.269027,0 -0.4370814,-0.194 Q 6.3835673,7.6074 6.3835673,7.3331 l 0,-0.6625 q 0,-0.2743 0.1682543,-0.4684 Q 6.719876,6.0081 6.988903,6.0081 l 3.642611,0 L 9.1155258,4.4865 Q 8.9190791,4.3002 8.9190791,4.0207 q 0,-0.2795 0.1964467,-0.4658 L 9.5036204,3.1667 Q 9.7002671,2.9701 9.969294,2.9701 q 0.274126,0 0.470872,0.1966 L 13.808452,6.536 Q 14,6.7172 14,7.0018 q 0,0.2795 -0.191548,0.471 l -3.368286,3.3693 q -0.201845,0.1915 -0.470872,0.1915 z\"\n  },\n  deleteColumn: {\n    width: 14,\n    height: 14,\n    path: \"m 5.31971,13.9999 c 0.29019,0 0.52307,-0.1688 0.52307,-0.3789 l 0,-13.242 C 5.84278,0.169 5.6099,1e-4 5.31971,1e-4 l -4.79434,0 C 0.23528,1e-4 0,0.169 0,0.379 l 0,13.242 c 0,0.2101 0.23528,0.3789 0.52537,0.3789 l 4.79434,0 z m -0.68722,-1.1582 -3.4222,0 0,-3.2168 3.4222,0 0,3.2168 z m 0,-4.2852 -3.4222,0 0,-3.2148 3.4222,0 0,3.2148 z m 0,-4.2832 -3.4222,0 0,-3.2148 3.4222,0 0,3.2148 z m 1.76757,0.4266 q 0,-0.2558 0.17911,-0.4348 L 7.4492,3.3953 q 0.17912,-0.1791 0.43501,-0.1791 0.2559,0 0.43501,0.1791 l 1.88081,1.8802 1.8808,-1.8802 q 0.17912,-0.1791 0.43501,-0.1791 0.2559,0 0.43501,0.1791 l 0.87003,0.8698 Q 14,4.4441 14,4.6999 14,4.9557 13.82088,5.1348 l -1.8808,1.8802 1.8808,1.8802 Q 14,9.0742 14,9.33 14,9.5858 13.82088,9.7649 l -0.87003,0.8698 q -0.17911,0.179 -0.43501,0.179 -0.25589,0 -0.43501,-0.179 l -1.8808,-1.8802 -1.88081,1.8802 q -0.17911,0.179 -0.43501,0.179 -0.25589,0 -0.43501,-0.179 L 6.57917,9.7649 Q 6.40006,9.5858 6.40006,9.33 q 0,-0.2558 0.17911,-0.4348 L 8.45998,7.015 6.57917,5.1348 Q 6.40006,4.9557 6.40006,4.6999 Z\"\n  },\n  addRowBefore: {\n    width: 14,\n    height: 14,\n    path: \"m 13.9999,8.6819 c 0,-0.2901 -0.1688,-0.5229 -0.3789,-0.5229 l -13.242,0 c -0.21,0 -0.3789,0.2328 -0.3789,0.5229 l 0,4.7928 c 0,0.29 0.1689,0.5252 0.3789,0.5252 l 13.242,0 c 0.2101,0 0.3789,-0.2352 0.3789,-0.5252 l 0,-4.7928 z m -1.1582,0.687 0,3.4211 -3.2168,0 0,-3.4211 3.2168,0 z m -4.2852,0 0,3.4211 -3.2148,0 0,-3.4211 3.2148,0 z m -4.2832,0 0,3.4211 -3.2148,0 0,-3.4211 3.2148,0 z m 6.7266,-5.337 q 0,0.264 -0.1915,0.4658 l -0.3882,0.3882 q -0.1966,0.1965 -0.4709,0.1965 -0.2795,0 -0.4658,-0.1965 l -1.5217,-1.5164 0,3.6436 q 0,0.2691 -0.194,0.4372 -0.1941,0.1683 -0.4684,0.1683 l -0.6625,0 Q 6.3626,7.6186 6.1685,7.4503 5.9744,7.2822 5.9744,7.0131 l 0,-3.6436 -1.5216,1.5164 Q 4.2665,5.0824 3.987,5.0824 3.7075,5.0824 3.5212,4.8859 L 3.133,4.4977 Q 2.9364,4.301 2.9364,4.0319 q 0,-0.2742 0.1966,-0.471 L 6.5023,0.1917 Q 6.6835,1e-4 6.9681,1e-4 q 0.2795,0 0.471,0.1916 l 3.3693,3.3692 q 0.1915,0.2019 0.1915,0.471 z\"\n  },\n  addRowAfter: {\n    width: 14,\n    height: 14,\n    path: \"m 1e-4,5.3181 c 0,0.2901 0.1688,0.5229 0.3789,0.5229 l 13.242,0 c 0.21,0 0.3789,-0.2328 0.3789,-0.5229 l 0,-4.7928 C 13.9999,0.2353 13.831,1e-4 13.621,1e-4 l -13.242,0 C 0.1689,1e-4 1e-4,0.2353 1e-4,0.5253 l 0,4.7928 z m 1.1582,-0.687 0,-3.4211 3.2168,0 0,3.4211 -3.2168,0 z m 4.2852,0 0,-3.4211 3.2148,0 0,3.4211 -3.2148,0 z m 4.2832,0 0,-3.4211 3.2148,0 0,3.4211 -3.2148,0 z m -6.7266,5.337 q 0,-0.264 0.1915,-0.4658 L 3.5798,9.1141 q 0.1966,-0.1965 0.4709,-0.1965 0.2795,0 0.4658,0.1965 l 1.5217,1.5164 0,-3.6436 q 0,-0.2691 0.194,-0.4372 0.1941,-0.1683 0.4684,-0.1683 l 0.6625,0 q 0.2743,0 0.4684,0.1683 0.1941,0.1681 0.1941,0.4372 l 0,3.6436 1.5216,-1.5164 q 0.1863,-0.1965 0.4658,-0.1965 0.2795,0 0.4658,0.1965 l 0.3882,0.3882 q 0.1966,0.1967 0.1966,0.4658 0,0.2742 -0.1966,0.471 l -3.3693,3.3692 q -0.1812,0.1916 -0.4658,0.1916 -0.2795,0 -0.471,-0.1916 L 3.1916,10.4391 Q 3.0001,10.2372 3.0001,9.9681 Z\"\n  },\n  deleteRow: {\n    width: 14,\n    height: 14,\n    path: \"m 13.9999,8.68029 c 0,-0.29019 -0.1688,-0.52307 -0.3789,-0.52307 l -13.242,0 c -0.21,0 -0.3789,0.23288 -0.3789,0.52307 l 0,4.79434 C 1e-4,13.76472 0.169,14 0.379,14 l 13.242,0 c 0.2101,0 0.3789,-0.23528 0.3789,-0.52537 l 0,-4.79434 z m -1.1582,0.68722 0,3.4222 -3.2168,0 0,-3.4222 3.2168,0 z m -4.2852,0 0,3.4222 -3.2148,0 0,-3.4222 3.2148,0 z m -4.2832,0 0,3.4222 -3.2148,0 0,-3.4222 3.2148,0 z M 4.6999,7.59994 q -0.2558,0 -0.4348,-0.17911 L 3.3953,6.5508 Q 3.2162,6.37168 3.2162,6.11579 q 0,-0.2559 0.1791,-0.43501 L 5.2755,3.79997 3.3953,1.91917 Q 3.2162,1.74005 3.2162,1.48416 q 0,-0.2559 0.1791,-0.43501 L 4.2651,0.17912 Q 4.4441,0 4.6999,0 4.9557,0 5.1348,0.17912 L 7.015,2.05992 8.8952,0.17912 Q 9.0742,0 9.33,0 9.5858,0 9.7649,0.17912 l 0.8698,0.87003 q 0.179,0.17911 0.179,0.43501 0,0.25589 -0.179,0.43501 l -1.8802,1.8808 1.8802,1.88081 q 0.179,0.17911 0.179,0.43501 0,0.25589 -0.179,0.43501 L 9.7649,7.42083 Q 9.5858,7.59994 9.33,7.59994 q -0.2558,0 -0.4348,-0.17911 L 7.015,5.54002 5.1348,7.42083 Q 4.9557,7.59994 4.6999,7.59994 Z\"\n  },\n  mergeCells: {\n    width: 14,\n    height: 14,\n    path: \"m 6.491328,7.000195 -3.560223,0 c -0.137727,0 -0.256921,0.0503 -0.357583,0.15109 -0.100662,0.10057 -0.150992,0.21986 -0.150992,0.35759 0,0.13772 0.05033,0.25692 0.150992,0.35758 l 1.144344,1.14424 -2.63837,2.63847 c -0.05306,0.053 -0.0795,0.11393 -0.0795,0.18269 0,0.069 0.02643,0.12993 0.0795,0.18289 l 0.905858,0.90576 c 0.05306,0.053 0.113927,0.0794 0.18279,0.0794 0.06886,0 0.129827,-0.0264 0.182791,-0.0794 l 2.638369,-2.63837 1.144344,1.14435 c 0.100661,0.10056 0.219856,0.15099 0.357582,0.15099 0.137825,0 0.257019,-0.0504 0.357681,-0.15099 0.100662,-0.10057 0.150992,-0.21986 0.150992,-0.35759 l 0,-3.56022 c 0,-0.13773 -0.05033,-0.25702 -0.150894,-0.35748 -0.100662,-0.10067 -0.219856,-0.151 -0.357681,-0.151 z m 6.508673,-4.83185 c 0,-0.0689 -0.02653,-0.12973 -0.07959,-0.18279 l -0.905955,-0.90596 c -0.05296,-0.0531 -0.113829,-0.0795 -0.182693,-0.0795 -0.06896,0 -0.129826,0.0265 -0.18279,0.0795 L 9.010408,3.717965 7.86626,2.573625 c -0.100564,-0.10067 -0.219954,-0.151 -0.357681,-0.151 -0.137727,0 -0.256921,0.0503 -0.357583,0.151 -0.100661,0.10066 -0.150992,0.21985 -0.150992,0.35758 l 0,3.56022 c 0,0.13783 0.05033,0.25702 0.150992,0.35768 0.100662,0.10066 0.219856,0.151 0.357583,0.151 l 3.560223,0 c 0.137727,0 0.257117,-0.0503 0.357681,-0.151 0.100662,-0.10066 0.15109,-0.21985 0.15109,-0.35768 0,-0.13772 -0.05043,-0.25692 -0.15109,-0.35758 l -1.144344,-1.14434 2.638565,-2.63837 c 0.05277,-0.053 0.0793,-0.11393 0.0793,-0.18279 z\"\n  },\n  splitCell: {\n    width: 14,\n    height: 14,\n    path: \"M 12.851703,1.14844 C 12.752843,1.04944 12.635563,1 12.500164,1 L 9.0001119,1 c -0.135399,0 -0.252483,0.0495 -0.35154,0.14844 -0.09886,0.099 -0.148344,0.21614 -0.148344,0.35154 0,0.1354 0.04948,0.25268 0.148344,0.35154 l 1.124908,1.125 -2.593779,2.59378 c -0.05207,0.0522 -0.07815,0.112 -0.07815,0.1797 0,0.0677 0.02608,0.12763 0.07815,0.1797 l 0.890644,0.89065 c 0.05207,0.0521 0.111905,0.0781 0.179701,0.0781 0.0677,0 0.127536,-0.026 0.179605,-0.0781 l 2.5938751,-2.59378 1.124811,1.12491 c 0.09906,0.099 0.216332,0.14853 0.351731,0.14853 0.135399,0 0.252579,-0.0496 0.351539,-0.14853 0.09887,-0.0989 0.148345,-0.21614 0.148345,-0.35154 l 0,-3.50006 c 9.6e-5,-0.13549 -0.0491,-0.25248 -0.148249,-0.35144 z M 5.9298469,7.17956 c -0.05207,-0.0521 -0.112001,-0.0781 -0.179701,-0.0781 -0.0677,0 -0.127632,0.026 -0.179701,0.0781 l -2.593779,2.59378 -1.125003,-1.1251 c -0.09896,-0.0988 -0.216044,-0.14835 -0.351539,-0.14835 -0.135495,0 -0.252675,0.0496 -0.351635,0.14835 -0.09896,0.099 -0.148441,0.21633 -0.148441,0.35173 l 0,3.50005 c 0,0.1354 0.04948,0.25258 0.148441,0.35154 C 1.2475489,12.95046 1.3647249,13 1.5001239,13 l 3.500052,0 c 0.135399,0 0.252579,-0.0496 0.351539,-0.14844 0.09896,-0.099 0.148441,-0.21614 0.148441,-0.35154 0,-0.1354 -0.04948,-0.25268 -0.148441,-0.35173 L 4.2267119,11.02348 6.8204909,8.4296 c 0.05207,-0.0521 0.07805,-0.1119 0.07805,-0.1797 0,-0.0677 -0.02608,-0.12753 -0.07805,-0.1797 L 5.9298469,7.17956 Z\"\n  },\n  toggleHeaderColumn: {\n    width: 14,\n    height: 14,\n    path: \"m 4.42857,9.785715 v 1.28571 q 0,0.26786 -0.1875,0.45536 -0.1875,0.1875 -0.45536,0.1875 H 1.642857 q -0.267857,0 -0.455357,-0.1875 Q 1,11.339285 1,11.071425 v -1.28571 q 0,-0.26786 0.1875,-0.45536 0.1875,-0.1875 0.455357,-0.1875 H 3.78571 q 0.26786,0 0.45536,0.1875 0.1875,0.1875 0.1875,0.45536 z m 0,-3.42857 v 1.28571 q 0,0.26786 -0.1875,0.45536 -0.1875,0.1875 -0.45536,0.1875 H 1.642857 Q 1.375,8.285715 1.1875,8.098215 1,7.910715 1,7.642855 v -1.28571 q 0,-0.26786 0.1875,-0.45536 0.1875,-0.1875 0.455357,-0.1875 H 3.78571 q 0.26786,0 0.45536,0.1875 0.1875,0.1875 0.1875,0.45536 z M 13,9.785715 v 1.28571 q 0,0.26786 -0.1875,0.45536 -0.1875,0.1875 -0.45536,0.1875 H 5.92857 q -0.26786,0 -0.45536,-0.1875 -0.1875,-0.1875 -0.1875,-0.45536 v -1.28571 q 0,-0.26786 0.1875,-0.45536 0.1875,-0.1875 0.45536,-0.1875 h 6.42857 q 0.26786,0 0.45536,0.1875 Q 13,9.517855 13,9.785715 z M 4.42857,2.928575 v 1.28571 q 0,0.26786 -0.1875,0.45536 -0.1875,0.1875 -0.45536,0.1875 H 1.642857 Q 1.375,4.857145 1.1875,4.669645 1,4.482145 1,4.214285 v -1.28571 q 0,-0.26786 0.1875,-0.45536 0.1875,-0.1875 0.455357,-0.1875 H 3.78571 q 0.26786,0 0.45536,0.1875 0.1875,0.1875 0.1875,0.45536 z M 13,6.357145 v 1.28571 q 0,0.26786 -0.1875,0.45536 -0.1875,0.1875 -0.45536,0.1875 H 5.92857 q -0.26786,0 -0.45536,-0.1875 -0.1875,-0.1875 -0.1875,-0.45536 v -1.28571 q 0,-0.26786 0.1875,-0.45536 0.1875,-0.1875 0.45536,-0.1875 h 6.42857 q 0.26786,0 0.45536,0.1875 Q 13,6.089285 13,6.357145 z m 0,-3.42857 v 1.28571 q 0,0.26786 -0.1875,0.45536 -0.1875,0.1875 -0.45536,0.1875 H 5.92857 q -0.26786,0 -0.45536,-0.1875 -0.1875,-0.1875 -0.1875,-0.45536 v -1.28571 q 0,-0.26786 0.1875,-0.45536 0.1875,-0.1875 0.45536,-0.1875 h 6.42857 q 0.26786,0 0.45536,0.1875 Q 13,2.660715 13,2.928575 z\"\n  },\n  toggleHeaderRow: {\n    width: 14,\n    height: 14,\n    path: \"m 6.53846,8.384615 v 2.76923 q 0,0.375 -0.27404,0.64904 -0.27404,0.27404 -0.64904,0.27404 H 1.923077 q -0.375,0 -0.649039,-0.27404 Q 1,11.528845 1,11.153845 v -2.76923 q 0,-0.375 0.274038,-0.64904 0.274039,-0.27403 0.649039,-0.27403 H 5.61538 q 0.375,0 0.64904,0.27403 0.27404,0.27404 0.27404,0.64904 z m 0,-5.53846 v 2.76923 q 0,0.375 -0.27404,0.64904 -0.27404,0.27404 -0.64904,0.27404 H 1.923077 q -0.375,0 -0.649039,-0.27404 Q 1,5.990385 1,5.615385 v -2.76923 q 0,-0.375 0.274038,-0.64904 0.274039,-0.27404 0.649039,-0.27404 H 5.61538 q 0.375,0 0.64904,0.27404 0.27404,0.27404 0.27404,0.64904 z M 13,8.384615 v 2.76923 q 0,0.375 -0.27404,0.64904 -0.27404,0.27404 -0.64904,0.27404 h -3.6923 q -0.375,0 -0.64904,-0.27404 -0.27404,-0.27404 -0.27404,-0.64904 v -2.76923 q 0,-0.375 0.27404,-0.64904 0.27404,-0.27403 0.64904,-0.27403 h 3.6923 q 0.375,0 0.64904,0.27403 Q 13,8.009615 13,8.384615 z m 0,-5.53846 v 2.76923 q 0,0.375 -0.27404,0.64904 -0.27404,0.27404 -0.64904,0.27404 h -3.6923 q -0.375,0 -0.64904,-0.27404 -0.27404,-0.27404 -0.27404,-0.64904 v -2.76923 q 0,-0.375 0.27404,-0.64904 0.27404,-0.27404 0.64904,-0.27404 h 3.6923 q 0.375,0 0.64904,0.27404 Q 13,2.471155 13,2.846155 z\"\n  },\n  toggleHeaderCell: {\n    width: 14,\n    height: 14,\n    path: \"m 9.4146827,3.4683 0,-1.7198 -8.41468995,0 0,1.7198 3.19389995,0 0,8.7832 2.02689,0 0,-8.7832 3.1939,0 m 3.2817903,7.048 c 0.14907,0 0.24394,0.042 0.28459,0.1254 0.0407,0.084 0.0158,0.1841 -0.0745,0.3015 l -0.8538,1.0978 c -0.0904,0.1174 -0.20102,0.1761 -0.33203,0.1761 -0.131,0 -0.24168,-0.059 -0.33203,-0.1761 l -0.85379,-1.0978 c -0.0904,-0.1174 -0.1152,-0.2179 -0.0745,-0.3015 0.0407,-0.084 0.13552,-0.1254 0.2846,-0.1254 l 0.54209,0 0,-6.9387 -0.54209,0 c -0.14908,0 -0.24394,-0.042 -0.2846,-0.1254 -0.0407,-0.084 -0.0158,-0.1841 0.0745,-0.3015 l 0.85379,-1.0978 c 0.0904,-0.1174 0.20103,-0.1761 0.33203,-0.1761 0.13101,0 0.24168,0.059 0.33203,0.1761 l 0.8538,1.0978 c 0.0903,0.1174 0.11519,0.2179 0.0745,0.3015 -0.0406,0.084 -0.13552,0.1254 -0.28459,0.1254 l -0.54209,0 0,6.9387 z\"\n  },\n  deleteTable: {\n    width: 14,\n    height: 14,\n    path: \"m 5.4999377,5.7501979 v 4.5001871 q 0,0.109505 -0.070503,0.179508 -0.070503,0.07 -0.1795074,0.0705 H 4.7499064 q -0.1095045,0 -0.1795075,-0.0705 -0.070003,-0.0705 -0.070503,-0.179508 V 5.7501979 q 0,-0.1095045 0.070503,-0.1795075 0.070503,-0.070003 0.1795075,-0.070503 h 0.5000209 q 0.1095045,0 0.1795074,0.070503 0.070003,0.070503 0.070503,0.1795075 z m 2.0000833,0 v 4.5001871 q 0,0.109505 -0.070503,0.179508 -0.070503,0.07 -0.1795075,0.0705 H 6.7499898 q -0.1095046,0 -0.1795075,-0.0705 -0.070003,-0.0705 -0.070503,-0.179508 V 5.7501979 q 0,-0.1095045 0.070503,-0.1795075 0.070503,-0.070003 0.1795075,-0.070503 h 0.5000208 q 0.1095046,0 0.1795075,0.070503 0.070003,0.070503 0.070503,0.1795075 z m 2.0000833,0 v 4.5001871 q 0,0.109505 -0.070503,0.179508 -0.070503,0.07 -0.1795075,0.0705 H 8.7500731 q -0.1095046,0 -0.1795075,-0.0705 -0.070003,-0.0705 -0.070503,-0.179508 V 5.7501979 q 0,-0.1095045 0.070503,-0.1795075 0.070503,-0.070003 0.1795075,-0.070503 H 9.250094 q 0.1095046,0 0.1795075,0.070503 0.070003,0.070503 0.070503,0.1795075 z M 10.500146,11.406934 V 4.000625 H 3.4998543 v 7.406309 q 0,0.172007 0.054502,0.316513 0.054502,0.144506 0.1135047,0.211009 0.059003,0.0665 0.082004,0.0665 h 6.500271 q 0.0235,0 0.082,-0.0665 0.0585,-0.0665 0.113504,-0.211009 0.055,-0.144506 0.0545,-0.316513 z M 5.2499273,3.0000833 H 8.7500731 L 8.3750575,2.0860453 Q 8.3205552,2.0155423 8.2420519,2.0000417 H 5.7654487 q -0.078003,0.015501 -0.1330055,0.086004 z m 7.2503017,0.2500105 v 0.5000208 q 0,0.1095046 -0.0705,0.1795075 -0.0705,0.070003 -0.179507,0.070503 h -0.750031 v 7.4063089 q 0,0.648527 -0.367016,1.121046 Q 10.766157,13 10.250136,13 H 3.7498648 Q 3.2343433,13 2.866828,12.542981 2.4993126,12.085962 2.4998127,11.437435 V 3.999625 H 1.7497814 q -0.1095046,0 -0.1795075,-0.070503 Q 1.500271,3.8586191 1.499771,3.7496146 V 3.2495937 q 0,-0.1095045 0.070503,-0.1795074 0.070503,-0.070003 0.1795075,-0.070503 H 4.163882 L 4.7109048,1.695029 Q 4.8279097,1.4060169 5.1329224,1.2030085 5.4379351,1 5.7499481,1 H 8.2500523 Q 8.5625653,1 8.867078,1.2030085 9.1715907,1.4060169 9.2890956,1.695029 l 0.5470227,1.3045543 h 2.4141007 q 0.109504,0 0.179507,0.070503 0.07,0.070503 0.0705,0.1795074 z\"\n  }\n};\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/table-tools.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/plugins/view-source.js":
/*!**************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/view-source.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n/* harmony import */ var _proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proseutil/doc-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _fields_TextareaField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../fields/TextareaField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField.js\");\n\n\n\n\n\nvar prosemirrorMenu = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\"); // var prosemirrorState = require('prosemirror-state');\n\n\nfunction viewSource() {\n  return new prosemirrorMenu.MenuItem({\n    title: \"View source\",\n    label: \"Source\",\n    icon: prosemirrorMenu.icons.code,\n    enable: function enable(state) {\n      return state.selection.empty;\n    },\n    run: function run(state, _, view) {\n      // var ref = state.selection;\n      Object(_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__[\"openPrompt\"])({\n        title: \"View Source\",\n        fields: {\n          content: new _fields_TextareaField__WEBPACK_IMPORTED_MODULE_3__[\"TextareaField\"]({\n            label: \"Content\",\n            value: Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_1__[\"docToHtml\"])(state.doc)\n          })\n        },\n        callback: function callback(attrs) {\n          var newDoc = Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_1__[\"htmlToDoc\"])(attrs.content);\n          view.dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__[\"AllSelection\"](state.doc)));\n          view.dispatch(view.state.tr.replaceSelectionWith(newDoc));\n          view.focus();\n        }\n      });\n    }\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (viewSource);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/plugins/view-source.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js":
/*!**************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js ***!
  \**************************************************************************************/
/*! exports provided: setSchema, domToDoc, htmlToDoc, docToHtml */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setSchema\", function() { return setSchema; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"domToDoc\", function() { return domToDoc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"htmlToDoc\", function() { return htmlToDoc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"docToHtml\", function() { return docToHtml; });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__);\n\nvar serializer = null;\nvar schema = null;\nvar container = document.createElement('div');\nfunction setSchema(v) {\n  schema = v;\n  serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__[\"DOMSerializer\"].fromSchema(schema);\n}\nfunction domToDoc(domNode) {\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__[\"DOMParser\"].fromSchema(schema).parse(domNode);\n}\nfunction htmlToDoc(html) {\n  container.innerHTML = html;\n  var doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__[\"DOMParser\"].fromSchema(schema).parse(container);\n  container.innerHTML = '';\n  return doc;\n}\nfunction docToHtml(doc) {\n  container.appendChild(serializer.serializeFragment(doc.content));\n  var html = container.innerHTML;\n  container.innerHTML = '';\n  return html;\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js":
/*!*****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js ***!
  \*****************************************************************************************/
/*! exports provided: markActive, canInsert, cmdItem, markItem, wrapListItem, markWrappingInputRule, positionAroundMark, findEditorFieldNode, buildSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markActive\", function() { return markActive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canInsert\", function() { return canInsert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cmdItem\", function() { return cmdItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markItem\", function() { return markItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrapListItem\", function() { return wrapListItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"markWrappingInputRule\", function() { return markWrappingInputRule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"positionAroundMark\", function() { return positionAroundMark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findEditorFieldNode\", function() { return findEditorFieldNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildSvg\", function() { return buildSvg; });\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_menu__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-commands */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-commands/dist/commands.js\");\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-schema-list */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-list/dist/schema-list.js\");\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-inputrules */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-inputrules/dist/index.js\");\n/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nfunction markActive(state, type) {\n  var ref = state.selection;\n  var from = ref.from;\n  var $from = ref.$from;\n  var to = ref.to;\n  var empty = ref.empty;\n\n  if (empty) {\n    return type.isInSet(state.storedMarks || $from.marks());\n  } else {\n    return state.doc.rangeHasMark(from, to, type);\n  }\n}\nfunction canInsert(state, nodeType) {\n  var $from = state.selection.$from;\n\n  for (var d = $from.depth; d >= 0; d--) {\n    var index = $from.index(d);\n\n    if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction cmdItem(cmd, options) {\n  var passedOptions = {\n    label: options.title,\n    run: cmd\n  };\n\n  for (var prop in options) {\n    passedOptions[prop] = options[prop];\n  }\n\n  if ((!options.enable || options.enable === true) && !options.select) {\n    passedOptions[options.enable ? \"enable\" : \"select\"] = function (state) {\n      return cmd(state);\n    };\n  }\n\n  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_0__[\"MenuItem\"](passedOptions);\n}\nfunction markItem(markType, options) {\n  var passedOptions = {\n    active: function active(state) {\n      return markActive(state, markType);\n    },\n    enable: true\n  };\n\n  for (var prop in options) {\n    passedOptions[prop] = options[prop];\n  }\n\n  return cmdItem(Object(prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__[\"toggleMark\"])(markType), passedOptions);\n}\nfunction wrapListItem(nodeType, options) {\n  return cmdItem(Object(prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_2__[\"wrapInList\"])(nodeType, options.attrs), options);\n}\nfunction markWrappingInputRule(regexp, markType, getAttrs) {\n  return new prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_3__[\"InputRule\"](regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : null;\n    var tr = state.tr;\n    tr = tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_4__[\"TextSelection\"].create(tr.doc, start, end));\n    var replacementText = match.length > 1 ? match[1] : match[0];\n    tr = tr.insertText(replacementText + ' ');\n    tr = tr.addMark(start, start + replacementText.length, markType.create(attrs));\n    var $pos = tr.doc.resolve(start + replacementText.length + 1);\n\n    if ($pos) {\n      tr = tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_4__[\"Selection\"].near($pos));\n    } // tr = tr.replaceSel\n\n\n    return tr;\n  });\n}\n/**\n * Adapted from https://discuss.prosemirror.net/t/expanding-the-selection-to-the-active-mark/478/6\n *\n * @param {*} doc\n * @param {*} pos\n */\n\nfunction positionAroundMark(doc, pos, markType) {\n  var $pos = doc.resolve(pos);\n  var start = $pos.parent.childAfter($pos.parentOffset);\n\n  if (!start.node) {\n    return;\n  }\n\n  var link = start.node.marks.find(function (mark) {\n    return mark.type === markType;\n  });\n\n  if (!link) {\n    return;\n  }\n\n  var startIndex = $pos.index();\n  var startPos = $pos.start() + start.offset;\n\n  while (startIndex > 0 && link.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  } // let endIndex = $pos.indexAfter();\n\n\n  var endPos = startPos + start.node.nodeSize;\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n/**\n * Finds the editor DOM field wrapping around the given HTML Element\n * @param {HTMLElement} node\n */\n\nfunction findEditorFieldNode(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node.getAttribute('data-prose-url')) {\n    return node;\n  }\n\n  return findEditorFieldNode(node.parentElement);\n}\nvar SVG = \"http://www.w3.org/2000/svg\";\nvar XLINK = \"http://www.w3.org/1999/xlink\";\nvar prefix$1 = \"ProseMirror-icon\";\n\nfunction hashPath(path) {\n  var hash = 0;\n\n  for (var i = 0; i < path.length; i++) {\n    hash = (hash << 5) - hash + path.charCodeAt(i) | 0;\n  }\n\n  return hash;\n}\n\nfunction buildSvg(icon) {\n  var node = document.createElement(\"div\");\n  node.className = prefix$1;\n\n  if (icon.path) {\n    var name = \"pm-icon-\" + hashPath(icon.path).toString(16);\n\n    if (!document.getElementById(name)) {\n      buildSVG(name, icon);\n    }\n\n    var svg = node.appendChild(document.createElementNS(SVG, \"svg\"));\n    svg.style.width = icon.width / icon.height + \"em\";\n    var use = svg.appendChild(document.createElementNS(SVG, \"use\"));\n    use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(document.location)[1] + \"#\" + name);\n  } else if (icon.dom) {\n    node.appendChild(icon.dom.cloneNode(true));\n  } else {\n    node.appendChild(document.createElement(\"span\")).textContent = icon.text || '';\n\n    if (icon.css) {\n      node.firstChild.style.cssText = icon.css;\n    }\n  }\n\n  return node;\n}\n\nfunction buildSVG(name, data) {\n  var collection = document.getElementById(prefix$1 + \"-collection\");\n\n  if (!collection) {\n    collection = document.createElementNS(SVG, \"svg\");\n    collection.id = prefix$1 + \"-collection\";\n    collection.style.display = \"none\";\n    document.body.insertBefore(collection, document.body.firstChild);\n  }\n\n  var sym = document.createElementNS(SVG, \"symbol\");\n  sym.id = name;\n  sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height);\n  var path = sym.appendChild(document.createElementNS(SVG, \"path\"));\n  path.setAttribute(\"d\", data.path);\n  collection.appendChild(sym);\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js":
/*!*****************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js ***!
  \*****************************************************************************************/
/*! exports provided: openPrompt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openPrompt\", function() { return openPrompt; });\n/* harmony import */ var _fields_FieldGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../fields/FieldGroup */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/FieldGroup.js\");\n\nvar prefix = \"ProseMirror-prompt\";\n/**\n * Options is\n *\n * {\n *  update: function() called when a field is updated\n *  forceRemainOpen: stays open even if clicked outside\n *  cancel: function() called on cancel\n *  title: title of the dialog\n *  fields: object of key :=> field object\n *  showButtons: boolean whether to show action buttons\n *  callback: called when the 'ok' button is clicked\n * }\n *\n * @param {object} options\n * @param {string} createIn\n */\n\nfunction openPrompt(options, createIn) {\n  var form;\n  var wrapper = document.body.appendChild(document.createElement(\"div\"));\n  wrapper.style.width = '65%';\n  wrapper.style.maxHeight = '90%';\n  wrapper.style.overflow = 'auto';\n  wrapper.style.paddingBottom = '20px';\n  wrapper.className = prefix;\n\n  var mouseOutside = function mouseOutside(e) {\n    if (!wrapper.contains(e.target)) {\n      close();\n    }\n  }; // handle clicks outside the dialog\n\n\n  if (!options.forceRemainOpen) {\n    setTimeout(function () {\n      return window.addEventListener(\"mousedown\", mouseOutside);\n    }, 50);\n  }\n\n  var close = function close() {\n    window.removeEventListener(\"mousedown\", mouseOutside);\n\n    if (wrapper.parentNode) {\n      wrapper.parentNode.removeChild(wrapper);\n    }\n  };\n\n  var submitButton = document.createElement(\"button\");\n  submitButton.type = \"submit\";\n  submitButton.className = prefix + \"-submit\";\n  submitButton.textContent = \"OK\";\n  var cancelButton = document.createElement(\"button\");\n  cancelButton.type = \"button\";\n  cancelButton.className = prefix + \"-cancel\";\n  cancelButton.textContent = \"Cancel\";\n  cancelButton.addEventListener(\"click\", function () {\n    if (options.cancel) {\n      options.cancel();\n    }\n\n    close();\n  });\n  form = wrapper.appendChild(document.createElement(\"form\"));\n\n  if (options.title) {\n    form.appendChild(document.createElement(\"h5\")).textContent = options.title;\n  }\n\n  var rootGroup = new _fields_FieldGroup__WEBPACK_IMPORTED_MODULE_0__[\"FieldGroup\"]({\n    name: \"root\",\n    fields: options.fields\n  });\n\n  if (options.update) {\n    rootGroup.updateCallback = options.update;\n  }\n\n  rootGroup.renderFields(form);\n  var buttons = form.appendChild(document.createElement(\"div\"));\n  buttons.className = prefix + \"-buttons\";\n\n  if (!options.hideButtons) {\n    buttons.appendChild(submitButton);\n    buttons.appendChild(document.createTextNode(\" \"));\n    buttons.appendChild(cancelButton);\n  }\n\n  if (createIn) {\n    wrapper.style.position = 'static';\n    wrapper.style.width = '100%';\n    wrapper.style.border = 'none';\n    createIn.prepend(wrapper);\n  } else {\n    var box = wrapper.getBoundingClientRect();\n    var top = (window.innerHeight - box.height) / 2 - 100;\n    top = top < 0 ? 0 : top;\n    wrapper.style.top = top + \"px\";\n    wrapper.style.left = (window.innerWidth - box.width) / 2 + \"px\";\n  }\n\n  var submit = function submit() {\n    var params = rootGroup.getValues();\n\n    if (params) {\n      close();\n      options.callback(params);\n    }\n  };\n\n  form.addEventListener(\"submit\", function (e) {\n    e.preventDefault();\n    submit();\n  });\n  form.addEventListener(\"keydown\", function (e) {\n    // ESC\n    if (e.keyCode == 27) {\n      e.preventDefault();\n      close(); // Enter\n    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {// e.preventDefault();\n      // submit();\n      // Tab\n    } else if (e.keyCode == 9) {\n      window.setTimeout(function () {\n        if (!wrapper.contains(document.activeElement)) {\n          close();\n        }\n      }, 500);\n    }\n  });\n  var input = form.elements[0];\n\n  if (input) {\n    input.focus();\n  }\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/schema.js":
/*!*************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/schema.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-list/dist/schema-list.js\");\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-schema-basic */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-basic/dist/schema-basic.js\");\n/* harmony import */ var prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proseutil/doc-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-tables */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-tables/dist/index.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prosemirror_tables__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _plugins_shortcodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/shortcodes */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js\");\n\n\n\n\n\n\nvar schemaNodes = Object(prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__[\"addListNodes\"])(prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_2__[\"schema\"].spec.nodes, \"paragraph block*\", \"block\");\nvar tNodes = Object(prosemirror_tables__WEBPACK_IMPORTED_MODULE_4__[\"tableNodes\"])({\n  tableGroup: \"block\",\n  cellContent: \"block+\",\n  cellAttributes: {\n    background: {\n      default: null,\n      getFromDOM: function getFromDOM(dom) {\n        return dom.style.backgroundColor || null;\n      },\n      setDOMAttr: function setDOMAttr(value, attrs) {\n        if (value) attrs.style = (attrs.style || \"\") + \"background-color: \".concat(value, \";\");\n      }\n    }\n  }\n});\nschemaNodes = schemaNodes.append(tNodes);\nschemaNodes = schemaNodes.append({\n  inline_shortcode: _plugins_shortcodes__WEBPACK_IMPORTED_MODULE_5__[\"InlineShortcodeNodeSpec\"],\n  block_shortcode: _plugins_shortcodes__WEBPACK_IMPORTED_MODULE_5__[\"BlockShortcodeNodeSpec\"],\n  image: {\n    inline: true,\n    attrs: {\n      src: {},\n      alt: {\n        default: null\n      },\n      title: {\n        default: null\n      },\n      width: {\n        default: null\n      },\n      height: {\n        default: null\n      },\n      // support for silverstripe specific attrs\n      'data-id': {\n        default: null\n      },\n      'data-shortcode': {\n        default: null\n      }\n    },\n    group: \"inline\",\n    draggable: true,\n    parseDOM: [{\n      tag: \"img[src]\",\n      getAttrs: function getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\"),\n          width: dom.getAttribute('width'),\n          height: dom.getAttribute('height'),\n          'data-id': dom.getAttribute('data-id'),\n          'data-shortcode': dom.getAttribute('data-shortcode')\n        };\n      }\n    }],\n    toDOM: function toDOM(node) {\n      return [\"img\", node.attrs];\n    }\n  }\n}); // custom link insert thing.\n\nvar schemaMarks = prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_2__[\"schema\"].spec.marks.append({\n  strike: {\n    parseDOM: [{\n      tag: \"s\"\n    }, {\n      tag: \"strike\"\n    }],\n    toDOM: function toDOM() {\n      return [\"s\"];\n    }\n  },\n  link: {\n    attrs: {\n      href: {},\n      title: {\n        default: null\n      },\n      target: {\n        default: '_self'\n      }\n    },\n    inclusive: false,\n    parseDOM: [{\n      tag: \"a[href]\",\n      getAttrs: function getAttrs(dom) {\n        return {\n          href: dom.getAttribute(\"href\"),\n          title: dom.getAttribute(\"title\"),\n          target: dom.getAttribute(\"target\")\n        };\n      }\n    }],\n    toDOM: function toDOM(node) {\n      return [\"a\", node.attrs];\n    }\n  }\n}); // Mix the nodes from prosemirror-schema-list into the basic schema to\n// create a schema with list support.\n\nvar mySchema = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__[\"Schema\"]({\n  nodes: schemaNodes,\n  marks: schemaMarks\n});\nObject(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_3__[\"setSchema\"])(mySchema);\n/* harmony default export */ __webpack_exports__[\"default\"] = (mySchema);\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/schema.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/setup.js":
/*!************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/setup.js ***!
  \************************************************************************/
/*! exports provided: buildMenuItems, buildKeymap, buildInputRules, setupEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildMenuItems\", function() { return buildMenuItems; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildKeymap\", function() { return buildKeymap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildInputRules\", function() { return buildInputRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupEditor\", function() { return setupEditor; });\n/* harmony import */ var _proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n/* harmony import */ var _plugins_view_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/view-source */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/view-source.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-tables */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-tables/dist/index.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proseutil/doc-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/doc-utils.js\");\n/* harmony import */ var _plugins_ss_link_selector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/ss-link-selector */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector.js\");\n/* harmony import */ var _proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proseutil/editor-utils */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/editor-utils.js\");\n/* harmony import */ var _fields_TextField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fields/TextField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js\");\n/* harmony import */ var _fields_SelectField__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fields/SelectField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/SelectField.js\");\n/* harmony import */ var _plugins_clear_marks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/clear-marks */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/clear-marks.js\");\n/* harmony import */ var _plugins_ss_image_selector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugins/ss-image-selector */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-image-selector.js\");\n/* harmony import */ var _plugins_image_paste__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/image-paste */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/image-paste.js\");\n/* harmony import */ var _plugins_shortcodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/shortcodes */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prosemirror-view */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(prosemirror_view__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(prosemirror_state__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./schema */ \"../../../symbiote/silverstripe-prose-editor/editor/src/schema.js\");\n/* harmony import */ var _plugins_markdown_editing__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/markdown-editing */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/markdown-editing.js\");\n/* harmony import */ var _plugins_table_tools__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/table-tools */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/table-tools.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-keymap/dist/keymap.js\");\n\nvar prosemirrorHistory = __webpack_require__(/*! prosemirror-history */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-history/dist/history.js\");\n\nvar prosemirrorCommands = __webpack_require__(/*! prosemirror-commands */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-commands/dist/commands.js\");\n\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-state/dist/index.js\");\n\nvar prosemirrorDropcursor = __webpack_require__(/*! prosemirror-dropcursor */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-dropcursor/dist/dropcursor.js\");\n\nvar prosemirrorGapcursor = __webpack_require__(/*! prosemirror-gapcursor */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-gapcursor/dist/index.js\");\n\nvar prosemirrorMenu = __webpack_require__(/*! prosemirror-menu */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-menu/dist/index.js\");\n\nvar prosemirrorSchemaList = __webpack_require__(/*! prosemirror-schema-list */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-schema-list/dist/schema-list.js\");\n\nvar prosemirrorInputrules = __webpack_require__(/*! prosemirror-inputrules */ \"../../../symbiote/silverstripe-prose-editor/editor/node_modules/prosemirror-inputrules/dist/index.js\");\n\nvar autoComplete = __webpack_require__(/*! ./vendor/auto-complete */ \"../../../symbiote/silverstripe-prose-editor/editor/src/vendor/auto-complete.js\");\n\nvar mockupPages = __webpack_require__(/*! ./data/mockup-pages */ \"../../../symbiote/silverstripe-prose-editor/editor/src/data/mockup-pages.js\"); // table plugin support in FF\n\n\ndocument.execCommand(\"enableObjectResizing\", false, \"false\");\ndocument.execCommand(\"enableInlineTableEditing\", false, \"false\");\n\nfunction injectAutoComplete(name) {\n  var pages = mockupPages.default;\n  var options = [];\n  var hasPages = pages && pages.length > 0;\n\n  if (hasPages) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = pages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var page = _step.value;\n        options.push({\n          value: page.link,\n          label: page.title\n        });\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    ;\n  }\n\n  var ac = new autoComplete({\n    selector: \"input[name=\\\"\".concat(name, \"\\\"]\"),\n    minChars: 2,\n    source: function source(term, suggest) {\n      term = term.toLowerCase();\n      var choices = options;\n      var matches = [];\n\n      for (var i = 0; i < choices.length; i++) {\n        if (~choices[i].label.toLowerCase().indexOf(term)) matches.push(choices[i]);\n      }\n\n      suggest(matches);\n    },\n    renderItem: function renderItem(item) {\n      return \"\\n            <div class=\\\"autocomplete-suggestion\\\" data-link=\\\"\".concat(item.value, \"\\\" data-val=\\\"\").concat(item.label, \"\\\">\\n                <b>\").concat(item.label, \"</b>\\n            </div>\\n            \");\n    },\n    onSelect: function onSelect(e, term, item) {\n      e.preventDefault(); // TODO add the value\n\n      e.stopPropagation();\n      var acField = document.querySelector(\"input[name=\\\"\".concat(name, \"\\\"]\"));\n\n      if (!acField) {\n        return;\n      }\n\n      acField.value = item.getAttribute('data-link');\n    }\n  });\n} // Helpers to create specific types of items\n\n\nfunction insertLink(nodeType) {\n  return new prosemirrorMenu.MenuItem({\n    title: \"Insert link\",\n    label: \"Page Link\",\n    // enable: function enable() { return hasPages },\n    run: function run(state, _, view) {\n      var attrs = null;\n\n      if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.type == nodeType) {\n        attrs = state.selection.node.attrs;\n      }\n\n      Object(_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_0__[\"openPrompt\"])({\n        title: \"Insert page\",\n        fields: {\n          pageLink: new _fields_TextField__WEBPACK_IMPORTED_MODULE_6__[\"TextField\"]({\n            name: \"search-page\",\n            label: \"Search page\",\n            required: false,\n            autocomplete: true,\n            value: attrs && attrs.href\n          }),\n          externalLink: new _fields_TextField__WEBPACK_IMPORTED_MODULE_6__[\"TextField\"]({\n            label: \"External URL\",\n            required: false,\n            value: attrs && attrs.href\n          }),\n          text: new _fields_TextField__WEBPACK_IMPORTED_MODULE_6__[\"TextField\"]({\n            label: \"Text\",\n            required: false,\n            value: attrs && attrs.text\n          }),\n          title: new _fields_TextField__WEBPACK_IMPORTED_MODULE_6__[\"TextField\"]({\n            label: \"Description\",\n            required: false,\n            value: attrs && attrs.title\n          }),\n          target: new _fields_SelectField__WEBPACK_IMPORTED_MODULE_7__[\"SelectField\"]({\n            label: \"Open target\",\n            required: false,\n            options: [{\n              value: '',\n              label: 'default'\n            }, {\n              value: '_blank',\n              label: '_blank'\n            }, {\n              value: '_self',\n              label: '_self'\n            }, {\n              value: '_parent',\n              label: '_parent'\n            }, {\n              value: '_top',\n              label: '_top'\n            }]\n          })\n        },\n        callback: function callback(attrs) {\n          var schema = view.state.schema;\n          attrs.href = attrs.externalLink ? attrs.externalLink : attrs.pageLink;\n          var node = schema.text(attrs.text, [schema.marks.link.create(attrs)]);\n          view.dispatch(view.state.tr.replaceSelectionWith(node, false));\n          view.focus();\n        }\n      });\n    }\n  });\n} // :: (Schema) → Object\n// Given a schema, look for default mark and node types in it and\n// return an object with relevant menu items relating to those marks:\n//\n// **`toggleStrong`**`: MenuItem`\n//   : A menu item to toggle the [strong mark](#schema-basic.StrongMark).\n//\n// **`toggleEm`**`: MenuItem`\n//   : A menu item to toggle the [emphasis mark](#schema-basic.EmMark).\n//\n// **`toggleCode`**`: MenuItem`\n//   : A menu item to toggle the [code font mark](#schema-basic.CodeMark).\n//\n// **`toggleLink`**`: MenuItem`\n//   : A menu item to toggle the [link mark](#schema-basic.LinkMark).\n//\n// **`insertImage`**`: MenuItem`\n//   : A menu item to insert an [image](#schema-basic.Image).\n//\n// **`wrapBulletList`**`: MenuItem`\n//   : A menu item to wrap the selection in a [bullet list](#schema-list.BulletList).\n//\n// **`wrapOrderedList`**`: MenuItem`\n//   : A menu item to wrap the selection in an [ordered list](#schema-list.OrderedList).\n//\n// **`wrapBlockQuote`**`: MenuItem`\n//   : A menu item to wrap the selection in a [block quote](#schema-basic.BlockQuote).\n//\n// **`makeParagraph`**`: MenuItem`\n//   : A menu item to set the current textblock to be a normal\n//     [paragraph](#schema-basic.Paragraph).\n//\n// **`makeCodeBlock`**`: MenuItem`\n//   : A menu item to set the current textblock to be a\n//     [code block](#schema-basic.CodeBlock).\n//\n// **`makeHead[N]`**`: MenuItem`\n//   : Where _N_ is 1 to 6. Menu items to set the current textblock to\n//     be a [heading](#schema-basic.Heading) of level _N_.\n//\n// **`insertHorizontalRule`**`: MenuItem`\n//   : A menu item to insert a horizontal rule.\n//\n// The return value also contains some prefabricated menu elements and\n// menus, that you can use instead of composing your own menu from\n// scratch:\n//\n// **`insertMenu`**`: Dropdown`\n//   : A dropdown containing the `insertImage` and\n//     `insertHorizontalRule` items.\n//\n// **`typeMenu`**`: Dropdown`\n//   : A dropdown containing the items for making the current\n//     textblock a paragraph, code block, or heading.\n//\n// **`fullMenu`**`: [[MenuElement]]`\n//   : An array of arrays of menu elements for use as the full menu\n//     for, for example the [menu bar](https://github.com/prosemirror/prosemirror-menu#user-content-menubar).\n\n\nfunction buildMenuItems(schema, settings) {\n  var r = {},\n      type;\n  var menuConfig = settings.menu;\n\n  if (type = schema.marks.strong) {\n    r.toggleStrong = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"markItem\"])(type, {\n      title: \"Toggle strong style\",\n      icon: prosemirrorMenu.icons.strong\n    });\n  }\n\n  if (type = schema.marks.em) {\n    r.toggleEm = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"markItem\"])(type, {\n      title: \"Toggle emphasis\",\n      icon: prosemirrorMenu.icons.em\n    });\n  } // if (type = schema.marks.code) { r.toggleCode = markItem(type, { title: \"Toggle code font\", icon: prosemirrorMenu.icons.code }); }\n\n\n  r.clearMarks = Object(_plugins_clear_marks__WEBPACK_IMPORTED_MODULE_8__[\"clearMarks\"])();\n\n  if (type = schema.marks.link) {\n    r.toggleLink = Object(_plugins_ss_link_selector__WEBPACK_IMPORTED_MODULE_4__[\"linkSelector\"])(type, settings.linkSelector);\n  }\n\n  if (type = schema.nodes.image) {\n    r.insertImage = Object(_plugins_ss_image_selector__WEBPACK_IMPORTED_MODULE_9__[\"imageSelector\"])(type);\n  }\n\n  if (type = schema.nodes.bullet_list) {\n    r.wrapBulletList = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"wrapListItem\"])(type, {\n      title: \"Wrap in bullet list\",\n      icon: prosemirrorMenu.icons.bulletList\n    });\n  }\n\n  if (type = schema.nodes.ordered_list) {\n    r.wrapOrderedList = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"wrapListItem\"])(type, {\n      title: \"Wrap in ordered list\",\n      icon: prosemirrorMenu.icons.orderedList\n    });\n  }\n\n  if (type = schema.nodes.blockquote) {\n    r.wrapBlockQuote = prosemirrorMenu.wrapItem(type, {\n      title: \"Wrap in block quote\",\n      icon: prosemirrorMenu.icons.blockquote\n    });\n  }\n\n  if (type = schema.nodes.paragraph) {\n    r.makeParagraph = prosemirrorMenu.blockTypeItem(type, {\n      title: \"Change to paragraph\",\n      label: \"Plain\"\n    });\n  }\n\n  if (type = schema.nodes.code_block) {\n    r.makeCodeBlock = prosemirrorMenu.blockTypeItem(type, {\n      title: \"Change to code block\",\n      label: \"Code\"\n    });\n  }\n\n  if (type = schema.nodes.heading) {\n    for (var i = 1; i <= 10; i++) {\n      r[\"makeHead\" + i] = prosemirrorMenu.blockTypeItem(type, {\n        title: \"Change to heading \" + i,\n        label: \"Heading \" + i,\n        attrs: {\n          level: i\n        }\n      });\n    }\n  }\n\n  if (type = schema.nodes.horizontal_rule) {\n    var hr = type;\n    r.insertHorizontalRule = new prosemirrorMenu.MenuItem({\n      title: \"Insert horizontal rule\",\n      label: \"Horizontal rule\",\n      icon: {\n        width: 8,\n        height: 8,\n        path: \"M0 3v2h8v-2h-8z\"\n      },\n      enable: function enable(state) {\n        return Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"canInsert\"])(state, hr);\n      },\n      run: function run(state, dispatch) {\n        dispatch(state.tr.replaceSelectionWith(hr.create()));\n      }\n    });\n  } // insertlink\n  // insertimage\n  // bulletlist\n  // orderedlist\n  // quote\n  // paragraph\n  // pre\n  // hr\n  // table\n  // shortcode\n  // viewsource\n\n\n  if (type = schema.nodes.table) {\n    r.insertTable = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"cmdItem\"])(function (state, dispatch, view) {\n      var node = Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_3__[\"htmlToDoc\"])('<table><tr><td></td><td></td></tr></table>');\n\n      if (dispatch) {\n        dispatch(state.tr.replaceSelectionWith(node, false));\n        view.focus();\n      }\n\n      return true;\n    }, {\n      label: \"Table\",\n      title: \"Insert table\",\n      icon: {\n        width: 8,\n        height: 8,\n        path: \"M0 0v2h2v-2h-2zm3 0v2h2v-2h-2zm3 0v2h2v-2h-2zm-6 3v2h2v-2h-2zm3 0v2h2v-2h-2zm3 0v2h2v-2h-2zm-6 3v2h2v-2h-2zm3 0v2h2v-2h-2zm3 0v2h2v-2h-2z\"\n      }\n    });\n  }\n\n  if (type = schema.nodes.inline_shortcode) {\n    var showFieldArgs = {\n      'field': 'text',\n      'id': 'text'\n    };\n    var listingArgs = {\n      'id': 'text',\n      'source_id': 'text'\n    };\n    r.insertInlineShortcode = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"cmdItem\"])(Object(_plugins_shortcodes__WEBPACK_IMPORTED_MODULE_11__[\"insertShortcode\"])('show_field', showFieldArgs, schema.nodes.inline_shortcode), {\n      title: \"Page field\"\n    });\n    r.insertBlockShortcode = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"cmdItem\"])(Object(_plugins_shortcodes__WEBPACK_IMPORTED_MODULE_11__[\"insertShortcode\"])('listing', listingArgs, schema.nodes.block_shortcode), {\n      title: \"Content list\"\n    });\n    r.insertEmbed = Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"cmdItem\"])(Object(_plugins_shortcodes__WEBPACK_IMPORTED_MODULE_11__[\"insertShortcode\"])('embed', {\n      'url': 'text',\n      'width': 'text',\n      'height': 'text'\n    }, schema.nodes.block_shortcode), {\n      title: \"Embed\"\n    });\n  }\n\n  r.viewSource = Object(_plugins_view_source__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n  r.editMarkdown = Object(_plugins_markdown_editing__WEBPACK_IMPORTED_MODULE_15__[\"default\"])();\n  var shortcodeDropdown = [r.insertEmbed, r.insertInlineShortcode, r.insertBlockShortcode];\n\n  var cut = function cut(arr) {\n    return arr.filter(function (x) {\n      return x;\n    });\n  };\n\n  r.shortcodeMenu = new prosemirrorMenu.Dropdown(cut(shortcodeDropdown), {\n    label: \"Shortcodes\"\n  });\n  var typeItems = [r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6, r.makeParagraph];\n\n  if (menuConfig.pre) {\n    typeItems.push(r.makeCodeBlock);\n  } // typeItems.push(r.makeHead1 && new prosemirrorMenu.DropdownSubmenu(cut([\n  //     r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6\n  // ]), { label: \"Heading\" }));\n\n\n  r.typeMenu = new prosemirrorMenu.Dropdown(cut(typeItems), {\n    label: \"Format...\"\n  });\n  var inlineItems = [r.clearMarks, r.toggleStrong, r.toggleEm];\n\n  if (menuConfig.insertlink) {\n    inlineItems.push(r.toggleLink);\n  }\n\n  if (menuConfig.insertimage) {\n    inlineItems.push(r.insertImage);\n  }\n\n  r.inlineMenu = [cut(inlineItems)];\n  var blockItems = [r.insertHorizontalRule];\n\n  if (menuConfig.table) {\n    blockItems.push(r.insertTable);\n  }\n\n  if (menuConfig.bulletlist) {\n    blockItems.push(r.wrapBulletList);\n  }\n\n  if (menuConfig.orderedlist) {\n    blockItems.push(r.wrapOrderedList);\n  }\n\n  blockItems.push(r.wrapBlockQuote);\n  blockItems.push(prosemirrorMenu.joinUpItem);\n  blockItems.push(prosemirrorMenu.liftItem);\n  blockItems.push(prosemirrorMenu.selectParentNodeItem);\n\n  if (menuConfig.shortcode) {\n    blockItems.push(r.shortcodeMenu);\n  }\n\n  if (menuConfig.viewsource) {\n    blockItems.push(r.viewSource);\n  }\n\n  r.blockMenu = [cut(blockItems)];\n  r.fullMenu = r.inlineMenu.concat([[r.typeMenu]], [[prosemirrorMenu.undoItem, prosemirrorMenu.redoItem]], r.blockMenu);\n  return r;\n}\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : false; // :: (Schema, ?Object) → Object\n// Inspect the given schema looking for marks and nodes from the\n// basic schema, and if found, add key bindings related to them.\n// This will add:\n//\n// * **Mod-b** for toggling [strong](#schema-basic.StrongMark)\n// * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)\n// * **Mod-`** for toggling [code font](#schema-basic.CodeMark)\n// * **Ctrl-Shift-0** for making the current textblock a paragraph\n// * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current\n//   textblock a heading of the corresponding level\n// * **Ctrl-Shift-Backslash** to make the current textblock a code block\n// * **Ctrl-Shift-8** to wrap the selection in an ordered list\n// * **Ctrl-Shift-9** to wrap the selection in a bullet list\n// * **Ctrl->** to wrap the selection in a block quote\n// * **Enter** to split a non-empty textblock in a list item while at\n//   the same time splitting the list item\n// * **Mod-Enter** to insert a hard break\n// * **Mod-_** to insert a horizontal rule\n// * **Backspace** to undo an input rule\n// * **Alt-ArrowUp** to `joinUp`\n// * **Alt-ArrowDown** to `joinDown`\n// * **Mod-BracketLeft** to `lift`\n// * **Escape** to `selectParentNode`\n//\n// You can suppress or map these bindings by passing a `mapKeys`\n// argument, which maps key names (say `\"Mod-B\"` to either `false`, to\n// remove the binding, or a new key name string.\n\nfunction buildKeymap(schema, mapKeys) {\n  var keys = {},\n      type;\n\n  function bind(key, cmd) {\n    if (mapKeys) {\n      var mapped = mapKeys[key];\n\n      if (mapped === false) {\n        return;\n      }\n\n      if (mapped) {\n        key = mapped;\n      }\n    }\n\n    keys[key] = cmd;\n  }\n\n  bind(\"Mod-z\", prosemirrorHistory.undo);\n  bind(\"Shift-Mod-z\", prosemirrorHistory.redo);\n  bind(\"Backspace\", prosemirrorInputrules.undoInputRule);\n\n  if (!mac) {\n    bind(\"Mod-y\", prosemirrorHistory.redo);\n  }\n\n  bind(\"Alt-ArrowUp\", prosemirrorCommands.joinUp);\n  bind(\"Alt-ArrowDown\", prosemirrorCommands.joinDown);\n  bind(\"Mod-BracketLeft\", prosemirrorCommands.lift);\n  bind(\"Escape\", prosemirrorCommands.selectParentNode);\n\n  if (type = schema.marks.strong) {\n    bind(\"Mod-b\", prosemirrorCommands.toggleMark(type));\n  }\n\n  if (type = schema.marks.em) {\n    bind(\"Mod-i\", prosemirrorCommands.toggleMark(type));\n  }\n\n  if (type = schema.marks.code) {\n    bind(\"Mod-`\", prosemirrorCommands.toggleMark(type));\n  }\n\n  if (type = schema.nodes.bullet_list) {\n    bind(\"Shift-Ctrl-8\", prosemirrorSchemaList.wrapInList(type));\n  }\n\n  if (type = schema.nodes.ordered_list) {\n    bind(\"Shift-Ctrl-9\", prosemirrorSchemaList.wrapInList(type));\n  }\n\n  if (type = schema.nodes.blockquote) {\n    bind(\"Ctrl->\", prosemirrorCommands.wrapIn(type));\n  }\n\n  if (type = schema.nodes.hard_break) {\n    var br = type,\n        cmd = prosemirrorCommands.chainCommands(prosemirrorCommands.exitCode, function (state, dispatch) {\n      dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());\n      return true;\n    });\n    bind(\"Mod-Enter\", cmd);\n    bind(\"Shift-Enter\", cmd);\n\n    if (mac) {\n      bind(\"Ctrl-Enter\", cmd);\n    }\n  }\n\n  if (type = schema.nodes.list_item) {\n    bind(\"Enter\", prosemirrorSchemaList.splitListItem(type));\n    bind(\"Mod-[\", prosemirrorSchemaList.liftListItem(type));\n    bind(\"Mod-]\", prosemirrorSchemaList.sinkListItem(type));\n  }\n\n  if (type = schema.nodes.paragraph) {\n    bind(\"Shift-Ctrl-0\", prosemirrorCommands.setBlockType(type));\n  }\n\n  if (type = schema.nodes.code_block) {\n    bind(\"Shift-Ctrl-\\\\\", prosemirrorCommands.setBlockType(type));\n  }\n\n  if (type = schema.nodes.heading) {\n    for (var i = 1; i <= 6; i++) {\n      bind(\"Shift-Ctrl-\" + i, prosemirrorCommands.setBlockType(type, {\n        level: i\n      }));\n    }\n  }\n\n  if (type = schema.nodes.horizontal_rule) {\n    var hr = type;\n    bind(\"Mod-_\", function (state, dispatch) {\n      dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());\n      return true;\n    });\n  }\n\n  return keys;\n} // : (NodeType) → InputRule\n// Given a blockquote node type, returns an input rule that turns `\"> \"`\n// at the start of a textblock into a blockquote.\n\nfunction blockQuoteRule(nodeType) {\n  return prosemirrorInputrules.wrappingInputRule(/^\\s*>\\s$/, nodeType);\n} // : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a number\n// followed by a dot at the start of a textblock into an ordered list.\n\n\nfunction orderedListRule(nodeType) {\n  return prosemirrorInputrules.wrappingInputRule(/^(\\d+)\\.\\s$/, nodeType, function (match) {\n    return {\n      order: +match[1]\n    };\n  }, function (match, node) {\n    return node.childCount + node.attrs.order == +match[1];\n  });\n} // : (NodeType) → InputRule\n// Given a list node type, returns an input rule that turns a bullet\n// (dash, plush, or asterisk) at the start of a textblock into a\n// bullet list.\n\n\nfunction bulletListRule(nodeType) {\n  return prosemirrorInputrules.wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType);\n} // : (NodeType) → InputRule\n// Given a code block node type, returns an input rule that turns a\n// textblock starting with three backticks into a code block.\n\n\nfunction codeBlockRule(nodeType) {\n  return prosemirrorInputrules.textblockTypeInputRule(/^```$/, nodeType);\n} // : (NodeType, number) → InputRule\n// Given a node type and a maximum level, creates an input rule that\n// turns up to that number of `#` characters followed by a space at\n// the start of a textblock into a heading whose level corresponds to\n// the number of `#` signs.\n\n\nfunction headingRule(nodeType, maxLevel) {\n  return prosemirrorInputrules.textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"})\\\\s$\"), nodeType, function (match) {\n    return {\n      level: match[1].length\n    };\n  });\n} // : (Schema) → Plugin\n// A set of input rules for creating the basic block quotes, lists,\n// code blocks, and heading.\n\n\nfunction buildInputRules(schema) {\n  var rules = [prosemirrorInputrules.ellipsis, prosemirrorInputrules.emDash],\n      type; // prosemirrorInputrules.smartQuotes.concat(prosemirrorInputrules.ellipsis, prosemirrorInputrules.emDash), type;\n\n  if (type = schema.nodes.blockquote) {\n    rules.push(blockQuoteRule(type));\n  }\n\n  if (type = schema.nodes.ordered_list) {\n    rules.push(orderedListRule(type));\n  }\n\n  if (type = schema.nodes.bullet_list) {\n    rules.push(bulletListRule(type));\n  }\n\n  if (type = schema.nodes.code_block) {\n    rules.push(codeBlockRule(type));\n  }\n\n  if (type = schema.nodes.heading) {\n    rules.push(headingRule(type, 6));\n  }\n\n  if (type = schema.marks.code) {\n    rules.push(Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"markWrappingInputRule\"])(/`([^`\\\\]+)` /, type));\n  }\n\n  if (type = schema.marks.strike) {\n    rules.push(Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"markWrappingInputRule\"])(/~([^~\\\\]+)~ /, type));\n  }\n\n  if (type = schema.marks.em) {\n    rules.push(Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"markWrappingInputRule\"])(/_([^_\\\\]+)_ /, type));\n  }\n\n  if (type = schema.marks.strong) {\n    rules.push(Object(_proseutil_editor_utils__WEBPACK_IMPORTED_MODULE_5__[\"markWrappingInputRule\"])(/\\*\\*([^\\*\\\\]+)\\*\\* /, type));\n  }\n\n  return prosemirrorInputrules.inputRules({\n    rules: rules\n  });\n} // !! This module exports helper functions for deriving a set of basic\n// menu items, input rules, or key bindings from a schema. These\n// values need to know about the schema for two reasons—they need\n// access to specific instances of node and mark types, and they need\n// to know which of the node and mark types that they know about are\n// actually present in the schema.\n//\n// The `exampleSetup` plugin ties these together into a plugin that\n// will automatically enable this basic functionality in an editor.\n// :: (Object) → [Plugin]\n// A convenience plugin that bundles together a simple menu with basic\n// key bindings, input rules, and styling for the example schema.\n// Probably only useful for quickly setting up a passable\n// editor—you'll need more control over your settings in most\n// real-world situations.\n//\n//   options::- The following options are recognized:\n//\n//     schema:: Schema\n//     The schema to generate key bindings and menu items for.\n//\n//     mapKeys:: ?Object\n//     Can be used to [adjust](#example-setup.buildKeymap) the key bindings created.\n//\n//     menuBar:: ?bool\n//     Set to false to disable the menu bar.\n//\n//     history:: ?bool\n//     Set to false to disable the history plugin.\n//\n//     floatingMenu:: ?bool\n//     Set to false to make the menu bar non-floating.\n//\n//     menuContent:: [[MenuItem]]\n//     Can be used to override the menu content.\n\nfunction setupPlugins(options) {\n  var plugins = [buildInputRules(options.schema), prosemirrorKeymap.keymap(buildKeymap(options.schema, options.mapKeys)), prosemirrorKeymap.keymap(prosemirrorCommands.baseKeymap), prosemirrorDropcursor.dropCursor(), prosemirrorGapcursor.gapCursor(), _plugins_image_paste__WEBPACK_IMPORTED_MODULE_10__[\"imagePaste\"], _plugins_table_tools__WEBPACK_IMPORTED_MODULE_16__[\"tableTools\"], Object(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"columnResizing\"])(), Object(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"tableEditing\"])(), prosemirrorKeymap.keymap({\n    \"Tab\": Object(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"goToNextCell\"])(1),\n    \"Shift-Tab\": Object(prosemirror_tables__WEBPACK_IMPORTED_MODULE_2__[\"goToNextCell\"])(-1)\n  })];\n\n  if (options.menuBar !== false) {\n    plugins.push(prosemirrorMenu.menuBar({\n      floating: options.floatingMenu !== false,\n      content: buildMenuItems(options.schema, options.settings).fullMenu\n    }));\n  }\n\n  if (options.history !== false) {\n    plugins.push(prosemirrorHistory.history());\n  }\n\n  return plugins.concat(new prosemirrorState.Plugin({\n    props: {\n      attributes: {\n        class: \"ProseMirror-example-setup-style\"\n      }\n    }\n  }));\n}\n\nfunction setupEditor(editorNode, valueNode, storageNode) {\n  var configStr = editorNode.parentNode.getAttribute('data-prose-config');\n  var config = {\n    menu: {\n      'insertlink': true,\n      'insertimage': true,\n      'bulletlist': true,\n      'orderedlist': true,\n      'quote': true,\n      'paragraph': true,\n      'pre': true,\n      'hr': true,\n      'table': true,\n      'shortcode': true,\n      'viewsource': true\n    },\n    linkSelector: {\n      internal: true\n    }\n  };\n\n  if (configStr && configStr.length > 2) {\n    config = JSON.parse(configStr);\n  }\n\n  var editorView = new prosemirror_view__WEBPACK_IMPORTED_MODULE_12__[\"EditorView\"](editorNode, {\n    state: prosemirror_state__WEBPACK_IMPORTED_MODULE_13__[\"EditorState\"].create({\n      doc: Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_3__[\"domToDoc\"])(valueNode),\n      plugins: setupPlugins({\n        schema: _schema__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n        menuBar: true,\n        settings: config || {\n          menu: {},\n          linkSelector: {}\n        },\n        history: true\n      })\n    }),\n    nodeViews: {\n      inline_shortcode: function inline_shortcode(node, view, getPos) {\n        return new _plugins_shortcodes__WEBPACK_IMPORTED_MODULE_11__[\"ShortcodeNodeView\"](node, view, getPos);\n      },\n      block_shortcode: function block_shortcode(node, view, getPos) {\n        return new _plugins_shortcodes__WEBPACK_IMPORTED_MODULE_11__[\"ShortcodeNodeView\"](node, view, getPos);\n      }\n    },\n    dispatchTransaction: function dispatchTransaction(tr) {\n      this.updateState(this.state.apply(tr));\n      var newValue = Object(_proseutil_doc_utils__WEBPACK_IMPORTED_MODULE_3__[\"docToHtml\"])(this.state.doc);\n\n      if (newValue != storageNode.value) {\n        storageNode.value = newValue;\n        var event = document.createEvent('Event');\n        event.initEvent('change', true, true); //can bubble, and is cancellable\n\n        storageNode.dispatchEvent(event);\n      }\n    }\n  });\n  return editorView;\n}\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/setup.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/src/vendor/auto-complete.js":
/*!***************************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/src/vendor/auto-complete.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n    JavaScript autoComplete v1.0.4\n    Copyright (c) 2014 Simon Steinberger / Pixabay\n    GitHub: https://github.com/Pixabay/JavaScript-autoComplete\n    License: http://www.opensource.org/licenses/mit-license.php\n*/\nvar autoComplete = function () {\n  // \"use strict\";\n  function autoComplete(options) {\n    if (!document.querySelector) return; // helpers\n\n    function hasClass(el, className) {\n      return el.classList ? el.classList.contains(className) : new RegExp('\\\\b' + className + '\\\\b').test(el.className);\n    }\n\n    function addEvent(el, type, handler) {\n      if (el.attachEvent) el.attachEvent('on' + type, handler);else el.addEventListener(type, handler);\n    }\n\n    function removeEvent(el, type, handler) {\n      // if (el.removeEventListener) not working in IE11\n      if (el.detachEvent) el.detachEvent('on' + type, handler);else el.removeEventListener(type, handler);\n    }\n\n    function live(elClass, event, cb, context) {\n      addEvent(context || document, event, function (e) {\n        var found,\n            el = e.target || e.srcElement;\n\n        while (el && !(found = hasClass(el, elClass))) {\n          el = el.parentElement;\n        }\n\n        if (found) cb.call(el, e);\n      });\n    }\n\n    var o = {\n      selector: 0,\n      source: 0,\n      minChars: 3,\n      delay: 150,\n      offsetLeft: 0,\n      offsetTop: 1,\n      cache: 1,\n      menuClass: '',\n      renderItem: function renderItem(item, search) {\n        // escape special characters\n        search = search.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n        var re = new RegExp(\"(\" + search.split(' ').join('|') + \")\", \"gi\");\n        return '<div class=\"autocomplete-suggestion\" data-val=\"' + item + '\">' + item.replace(re, \"<b>$1</b>\") + '</div>';\n      },\n      onSelect: function onSelect(e, term, item) {}\n    };\n\n    for (var k in options) {\n      if (options.hasOwnProperty(k)) o[k] = options[k];\n    } // init\n\n\n    var elems = _typeof(o.selector) == 'object' ? [o.selector] : document.querySelectorAll(o.selector);\n\n    for (var i = 0; i < elems.length; i++) {\n      var that = elems[i]; // create suggestions container \"sc\"\n\n      that.sc = document.createElement('div');\n      that.sc.className = 'autocomplete-suggestions ' + o.menuClass;\n      that.autocompleteAttr = that.getAttribute('autocomplete');\n      that.setAttribute('autocomplete', 'off');\n      that.cache = {};\n      that.last_val = '';\n\n      that.updateSC = function (resize, next) {\n        var rect = that.getBoundingClientRect();\n        that.sc.style.left = Math.round(rect.left + (window.pageXOffset || document.documentElement.scrollLeft) + o.offsetLeft) + 'px';\n        that.sc.style.top = Math.round(rect.bottom + (window.pageYOffset || document.documentElement.scrollTop) + o.offsetTop) + 'px';\n        that.sc.style.width = Math.round(rect.right - rect.left) + 'px'; // outerWidth\n\n        if (!resize) {\n          that.sc.style.display = 'block';\n\n          if (!that.sc.maxHeight) {\n            that.sc.maxHeight = parseInt((window.getComputedStyle ? getComputedStyle(that.sc, null) : that.sc.currentStyle).maxHeight);\n          }\n\n          if (!that.sc.suggestionHeight) that.sc.suggestionHeight = that.sc.querySelector('.autocomplete-suggestion').offsetHeight;\n          if (that.sc.suggestionHeight) if (!next) that.sc.scrollTop = 0;else {\n            var scrTop = that.sc.scrollTop,\n                selTop = next.getBoundingClientRect().top - that.sc.getBoundingClientRect().top;\n            if (selTop + that.sc.suggestionHeight - that.sc.maxHeight > 0) that.sc.scrollTop = selTop + that.sc.suggestionHeight + scrTop - that.sc.maxHeight;else if (selTop < 0) that.sc.scrollTop = selTop + scrTop;\n          }\n        }\n      };\n\n      addEvent(window, 'resize', that.updateSC);\n      document.body.appendChild(that.sc);\n      live('autocomplete-suggestion', 'mouseleave', function (e) {\n        var sel = that.sc.querySelector('.autocomplete-suggestion.selected');\n        if (sel) setTimeout(function () {\n          sel.className = sel.className.replace('selected', '');\n        }, 20);\n      }, that.sc);\n      live('autocomplete-suggestion', 'mouseover', function (e) {\n        var sel = that.sc.querySelector('.autocomplete-suggestion.selected');\n        if (sel) sel.className = sel.className.replace('selected', '');\n        this.className += ' selected';\n      }, that.sc);\n      live('autocomplete-suggestion', 'mousedown', function (e) {\n        if (hasClass(this, 'autocomplete-suggestion')) {\n          // else outside click\n          var v = this.getAttribute('data-val');\n          that.value = v;\n          o.onSelect(e, v, this);\n          that.sc.style.display = 'none';\n        }\n      }, that.sc);\n\n      that.blurHandler = function () {\n        try {\n          var over_sb = document.querySelector('.autocomplete-suggestions:hover');\n        } catch (e) {\n          var over_sb = 0;\n        }\n\n        if (!over_sb) {\n          that.last_val = that.value;\n          that.sc.style.display = 'none';\n          setTimeout(function () {\n            that.sc.style.display = 'none';\n          }, 350); // hide suggestions on fast input\n        } else if (that !== document.activeElement) setTimeout(function () {\n          that.focus();\n        }, 20);\n      };\n\n      addEvent(that, 'blur', that.blurHandler);\n\n      var suggest = function suggest(data) {\n        var val = that.value;\n        that.cache[val] = data;\n\n        if (data.length && val.length >= o.minChars) {\n          var s = '';\n\n          for (var i = 0; i < data.length; i++) {\n            s += o.renderItem(data[i], val);\n          }\n\n          that.sc.innerHTML = s;\n          that.updateSC(0);\n        } else that.sc.style.display = 'none';\n      };\n\n      that.keydownHandler = function (e) {\n        var key = window.event ? e.keyCode : e.which; // down (40), up (38)\n\n        if ((key == 40 || key == 38) && that.sc.innerHTML) {\n          var next,\n              sel = that.sc.querySelector('.autocomplete-suggestion.selected');\n\n          if (!sel) {\n            next = key == 40 ? that.sc.querySelector('.autocomplete-suggestion') : that.sc.childNodes[that.sc.childNodes.length - 1]; // first : last\n\n            next.className += ' selected';\n            that.value = next.getAttribute('data-val');\n          } else {\n            next = key == 40 ? sel.nextSibling : sel.previousSibling;\n\n            if (next) {\n              sel.className = sel.className.replace('selected', '');\n              next.className += ' selected';\n              that.value = next.getAttribute('data-val');\n            } else {\n              sel.className = sel.className.replace('selected', '');\n              that.value = that.last_val;\n              next = 0;\n            }\n          }\n\n          that.updateSC(0, next);\n          return false;\n        } // esc\n        else if (key == 27) {\n            that.value = that.last_val;\n            that.sc.style.display = 'none';\n          } // enter\n          else if (key == 13 || key == 9) {\n              var sel = that.sc.querySelector('.autocomplete-suggestion.selected');\n\n              if (sel && that.sc.style.display != 'none') {\n                o.onSelect(e, sel.getAttribute('data-val'), sel);\n                setTimeout(function () {\n                  that.sc.style.display = 'none';\n                }, 20);\n              }\n            }\n      };\n\n      addEvent(that, 'keydown', that.keydownHandler);\n\n      that.keyupHandler = function (e) {\n        var key = window.event ? e.keyCode : e.which;\n\n        if (!key || (key < 35 || key > 40) && key != 13 && key != 27) {\n          var val = that.value;\n\n          if (val.length >= o.minChars) {\n            if (val != that.last_val) {\n              that.last_val = val;\n              clearTimeout(that.timer);\n\n              if (o.cache) {\n                if (val in that.cache) {\n                  suggest(that.cache[val]);\n                  return;\n                } // no requests if previous suggestions were empty\n\n\n                for (var i = 1; i < val.length - o.minChars; i++) {\n                  var part = val.slice(0, val.length - i);\n\n                  if (part in that.cache && !that.cache[part].length) {\n                    suggest([]);\n                    return;\n                  }\n                }\n              }\n\n              that.timer = setTimeout(function () {\n                o.source(val, suggest);\n              }, o.delay);\n            }\n          } else {\n            that.last_val = val;\n            that.sc.style.display = 'none';\n          }\n        }\n      };\n\n      addEvent(that, 'keyup', that.keyupHandler);\n\n      that.focusHandler = function (e) {\n        that.last_val = '\\n';\n        that.keyupHandler(e);\n      };\n\n      if (!o.minChars) addEvent(that, 'focus', that.focusHandler);\n    } // public destroy method\n\n\n    this.destroy = function () {\n      for (var i = 0; i < elems.length; i++) {\n        var that = elems[i];\n        removeEvent(window, 'resize', that.updateSC);\n        removeEvent(that, 'blur', that.blurHandler);\n        removeEvent(that, 'focus', that.focusHandler);\n        removeEvent(that, 'keydown', that.keydownHandler);\n        removeEvent(that, 'keyup', that.keyupHandler);\n        if (that.autocompleteAttr) that.setAttribute('autocomplete', that.autocompleteAttr);else that.removeAttribute('autocomplete');\n        document.body.removeChild(that.sc);\n        that = null;\n      }\n    };\n  }\n\n  return autoComplete;\n}();\n\n(function () {\n  if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return autoComplete;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})();\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/src/vendor/auto-complete.js?");

/***/ }),

/***/ "../../../symbiote/silverstripe-prose-editor/editor/style/index.scss":
/*!****************************************************************************!*\
  !*** /tmp/work/symbiote/silverstripe-prose-editor/editor/style/index.scss ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:////tmp/work/symbiote/silverstripe-prose-editor/editor/style/index.scss?");

/***/ }),

/***/ "./node_modules/ace-builds/src-noconflict/ace.js":
/*!*******************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/ace.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {/* ***** BEGIN LICENSE BLOCK *****\n * Distributed under the BSD license:\n *\n * Copyright (c) 2010, Ajax.org B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of Ajax.org B.V. nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/**\n * Define a module along with a payload\n * @param module a name for the payload\n * @param payload a function to call with (require, exports, module) params\n */\n\n(function() {\n\nvar ACE_NAMESPACE = \"ace\";\n\nvar global = (function() { return this; })();\nif (!global && typeof window != \"undefined\") global = window; // strict mode\n\n\nif (!ACE_NAMESPACE && typeof requirejs !== \"undefined\")\n    return;\n\n\nvar define = function(module, deps, payload) {\n    if (typeof module !== \"string\") {\n        if (define.original)\n            define.original.apply(this, arguments);\n        else {\n            console.error(\"dropping module because define wasn\\'t a string.\");\n            console.trace();\n        }\n        return;\n    }\n    if (arguments.length == 2)\n        payload = deps;\n    if (!define.modules[module]) {\n        define.payloads[module] = payload;\n        define.modules[module] = null;\n    }\n};\n\ndefine.modules = {};\ndefine.payloads = {};\n\n/**\n * Get at functionality define()ed using the function above\n */\nvar _require = function(parentId, module, callback) {\n    if (typeof module === \"string\") {\n        var payload = lookup(parentId, module);\n        if (payload != undefined) {\n            callback && callback();\n            return payload;\n        }\n    } else if (Object.prototype.toString.call(module) === \"[object Array]\") {\n        var params = [];\n        for (var i = 0, l = module.length; i < l; ++i) {\n            var dep = lookup(parentId, module[i]);\n            if (dep == undefined && require.original)\n                return;\n            params.push(dep);\n        }\n        return callback && callback.apply(null, params) || true;\n    }\n};\n\nvar require = function(module, callback) {\n    var packagedModule = _require(\"\", module, callback);\n    if (packagedModule == undefined && require.original)\n        return require.original.apply(this, arguments);\n    return packagedModule;\n};\n\nvar normalizeModule = function(parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n        var chunks = moduleName.split(\"!\");\n        return normalizeModule(parentId, chunks[0]) + \"!\" + normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n        moduleName = base + \"/\" + moduleName;\n\n        while(moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n            var previous = moduleName;\n            moduleName = moduleName.replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n        }\n    }\n    return moduleName;\n};\n\n/**\n * Internal function to lookup moduleNames and resolve them by calling the\n * definition function if needed.\n */\nvar lookup = function(parentId, moduleName) {\n    moduleName = normalizeModule(parentId, moduleName);\n\n    var module = define.modules[moduleName];\n    if (!module) {\n        module = define.payloads[moduleName];\n        if (typeof module === 'function') {\n            var exports = {};\n            var mod = {\n                id: moduleName,\n                uri: '',\n                exports: exports,\n                packaged: true\n            };\n\n            var req = function(module, callback) {\n                return _require(moduleName, module, callback);\n            };\n\n            var returnValue = module(req, exports, mod);\n            exports = returnValue || mod.exports;\n            define.modules[moduleName] = exports;\n            delete define.payloads[moduleName];\n        }\n        module = define.modules[moduleName] = exports || module;\n    }\n    return module;\n};\n\nfunction exportAce(ns) {\n    var root = global;\n    if (ns) {\n        if (!global[ns])\n            global[ns] = {};\n        root = global[ns];\n    }\n\n    if (!root.define || !root.define.packaged) {\n        define.original = root.define;\n        root.define = define;\n        root.define.packaged = true;\n    }\n\n    if (!root.require || !root.require.packaged) {\n        require.original = root.require;\n        root.require = require;\n        root.require.packaged = true;\n    }\n}\n\nexportAce(ACE_NAMESPACE);\n\n})();\n\nace.define(\"ace/lib/regexp\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\n    var real = {\n            exec: RegExp.prototype.exec,\n            test: RegExp.prototype.test,\n            match: String.prototype.match,\n            replace: String.prototype.replace,\n            split: String.prototype.split\n        },\n        compliantExecNpcg = real.exec.call(/()??/, \"\")[1] === undefined, // check `exec` handling of nonparticipating capturing groups\n        compliantLastIndexIncrement = function () {\n            var x = /^/g;\n            real.test.call(x, \"\");\n            return !x.lastIndex;\n        }();\n\n    if (compliantLastIndexIncrement && compliantExecNpcg)\n        return;\n    RegExp.prototype.exec = function (str) {\n        var match = real.exec.apply(this, arguments),\n            name, r2;\n        if ( typeof(str) == 'string' && match) {\n            if (!compliantExecNpcg && match.length > 1 && indexOf(match, \"\") > -1) {\n                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), \"g\", \"\"));\n                real.replace.call(str.slice(match.index), r2, function () {\n                    for (var i = 1; i < arguments.length - 2; i++) {\n                        if (arguments[i] === undefined)\n                            match[i] = undefined;\n                    }\n                });\n            }\n            if (this._xregexp && this._xregexp.captureNames) {\n                for (var i = 1; i < match.length; i++) {\n                    name = this._xregexp.captureNames[i - 1];\n                    if (name)\n                       match[name] = match[i];\n                }\n            }\n            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))\n                this.lastIndex--;\n        }\n        return match;\n    };\n    if (!compliantLastIndexIncrement) {\n        RegExp.prototype.test = function (str) {\n            var match = real.exec.call(this, str);\n            if (match && this.global && !match[0].length && (this.lastIndex > match.index))\n                this.lastIndex--;\n            return !!match;\n        };\n    }\n\n    function getNativeFlags (regex) {\n        return (regex.global     ? \"g\" : \"\") +\n               (regex.ignoreCase ? \"i\" : \"\") +\n               (regex.multiline  ? \"m\" : \"\") +\n               (regex.extended   ? \"x\" : \"\") + // Proposed for ES4; included in AS3\n               (regex.sticky     ? \"y\" : \"\");\n    }\n\n    function indexOf (array, item, from) {\n        if (Array.prototype.indexOf) // Use the native array method if available\n            return array.indexOf(item, from);\n        for (var i = from || 0; i < array.length; i++) {\n            if (array[i] === item)\n                return i;\n        }\n        return -1;\n    }\n\n});\n\nace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\nfunction Empty() {}\n\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function bind(that) { // .length is 1\n        var target = this;\n        if (typeof target != \"function\") {\n            throw new TypeError(\"Function.prototype.bind called on incompatible \" + target);\n        }\n        var args = slice.call(arguments, 1); // for normal call\n        var bound = function () {\n\n            if (this instanceof bound) {\n\n                var result = target.apply(\n                    this,\n                    args.concat(slice.call(arguments))\n                );\n                if (Object(result) === result) {\n                    return result;\n                }\n                return this;\n\n            } else {\n                return target.apply(\n                    that,\n                    args.concat(slice.call(arguments))\n                );\n\n            }\n\n        };\n        if(target.prototype) {\n            Empty.prototype = target.prototype;\n            bound.prototype = new Empty();\n            Empty.prototype = null;\n        }\n        return bound;\n    };\n}\nvar call = Function.prototype.call;\nvar prototypeOfArray = Array.prototype;\nvar prototypeOfObject = Object.prototype;\nvar slice = prototypeOfArray.slice;\nvar _toString = call.bind(prototypeOfObject.toString);\nvar owns = call.bind(prototypeOfObject.hasOwnProperty);\nvar defineGetter;\nvar defineSetter;\nvar lookupGetter;\nvar lookupSetter;\nvar supportsAccessors;\nif ((supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\"))) {\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n}\nif ([1,2].splice(0).length != 2) {\n    if(function() { // test IE < 9 to splice bug - see issue #138\n        function makeArray(l) {\n            var a = new Array(l+2);\n            a[0] = a[1] = 0;\n            return a;\n        }\n        var array = [], lengthBefore;\n        \n        array.splice.apply(array, makeArray(20));\n        array.splice.apply(array, makeArray(26));\n\n        lengthBefore = array.length; //46\n        array.splice(5, 0, \"XXX\"); // add one element\n\n        lengthBefore + 1 == array.length\n\n        if (lengthBefore + 1 == array.length) {\n            return true;// has right splice implementation without bugs\n        }\n    }()) {//IE 6/7\n        var array_splice = Array.prototype.splice;\n        Array.prototype.splice = function(start, deleteCount) {\n            if (!arguments.length) {\n                return [];\n            } else {\n                return array_splice.apply(this, [\n                    start === void 0 ? 0 : start,\n                    deleteCount === void 0 ? (this.length - start) : deleteCount\n                ].concat(slice.call(arguments, 2)))\n            }\n        };\n    } else {//IE8\n        Array.prototype.splice = function(pos, removeCount){\n            var length = this.length;\n            if (pos > 0) {\n                if (pos > length)\n                    pos = length;\n            } else if (pos == void 0) {\n                pos = 0;\n            } else if (pos < 0) {\n                pos = Math.max(length + pos, 0);\n            }\n\n            if (!(pos+removeCount < length))\n                removeCount = length - pos;\n\n            var removed = this.slice(pos, pos+removeCount);\n            var insert = slice.call(arguments, 2);\n            var add = insert.length;            \n            if (pos === length) {\n                if (add) {\n                    this.push.apply(this, insert);\n                }\n            } else {\n                var remove = Math.min(removeCount, length - pos);\n                var tailOldPos = pos + remove;\n                var tailNewPos = tailOldPos + add - remove;\n                var tailCount = length - tailOldPos;\n                var lengthAfterRemove = length - remove;\n\n                if (tailNewPos < tailOldPos) { // case A\n                    for (var i = 0; i < tailCount; ++i) {\n                        this[tailNewPos+i] = this[tailOldPos+i];\n                    }\n                } else if (tailNewPos > tailOldPos) { // case B\n                    for (i = tailCount; i--; ) {\n                        this[tailNewPos+i] = this[tailOldPos+i];\n                    }\n                } // else, add == remove (nothing to do)\n\n                if (add && pos === lengthAfterRemove) {\n                    this.length = lengthAfterRemove; // truncate array\n                    this.push.apply(this, insert);\n                } else {\n                    this.length = lengthAfterRemove + add; // reserves space\n                    for (i = 0; i < add; ++i) {\n                        this[pos+i] = insert[i];\n                    }\n                }\n            }\n            return removed;\n        };\n    }\n}\nif (!Array.isArray) {\n    Array.isArray = function isArray(obj) {\n        return _toString(obj) == \"[object Array]\";\n    };\n}\nvar boxedString = Object(\"a\"),\n    splitString = boxedString[0] != \"a\" || !(0 in boxedString);\n\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(); // TODO message\n        }\n\n        while (++i < length) {\n            if (i in self) {\n                fun.call(thisp, self[i], i, object);\n            }\n        }\n    };\n}\nif (!Array.prototype.map) {\n    Array.prototype.map = function map(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            result = Array(length),\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self)\n                result[i] = fun.call(thisp, self[i], i, object);\n        }\n        return result;\n    };\n}\nif (!Array.prototype.filter) {\n    Array.prototype.filter = function filter(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                    object,\n            length = self.length >>> 0,\n            result = [],\n            value,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self) {\n                value = self[i];\n                if (fun.call(thisp, value, i, object)) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    };\n}\nif (!Array.prototype.every) {\n    Array.prototype.every = function every(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && !fun.call(thisp, self[i], i, object)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nif (!Array.prototype.some) {\n    Array.prototype.some = function some(fun /*, thisp */) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0,\n            thisp = arguments[1];\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && fun.call(thisp, self[i], i, object)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nif (!Array.prototype.reduce) {\n    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n        if (!length && arguments.length == 1) {\n            throw new TypeError(\"reduce of empty array with no initial value\");\n        }\n\n        var i = 0;\n        var result;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i++];\n                    break;\n                }\n                if (++i >= length) {\n                    throw new TypeError(\"reduce of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        for (; i < length; i++) {\n            if (i in self) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        }\n\n        return result;\n    };\n}\nif (!Array.prototype.reduceRight) {\n    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n        var object = toObject(this),\n            self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                object,\n            length = self.length >>> 0;\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n        if (!length && arguments.length == 1) {\n            throw new TypeError(\"reduceRight of empty array with no initial value\");\n        }\n\n        var result, i = length - 1;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i--];\n                    break;\n                }\n                if (--i < 0) {\n                    throw new TypeError(\"reduceRight of empty array with no initial value\");\n                }\n            } while (true);\n        }\n\n        do {\n            if (i in this) {\n                result = fun.call(void 0, result, self[i], i, object);\n            }\n        } while (i--);\n\n        return result;\n    };\n}\nif (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {\n    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n        var self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        var i = 0;\n        if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n        }\n        i = i >= 0 ? i : Math.max(0, length + i);\n        for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {\n    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n        var self = splitString && _toString(this) == \"[object String]\" ?\n                this.split(\"\") :\n                toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n        var i = length - 1;\n        if (arguments.length > 1) {\n            i = Math.min(i, toInteger(arguments[1]));\n        }\n        i = i >= 0 ? i : length - Math.abs(i);\n        for (; i >= 0; i--) {\n            if (i in self && sought === self[i]) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\nif (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function getPrototypeOf(object) {\n        return object.__proto__ || (\n            object.constructor ?\n            object.constructor.prototype :\n            prototypeOfObject\n        );\n    };\n}\nif (!Object.getOwnPropertyDescriptor) {\n    var ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a \" +\n                         \"non-object: \";\n    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n            throw new TypeError(ERR_NON_OBJECT + object);\n        if (!owns(object, property))\n            return;\n\n        var descriptor, getter, setter;\n        descriptor =  { enumerable: true, configurable: true };\n        if (supportsAccessors) {\n            var prototype = object.__proto__;\n            object.__proto__ = prototypeOfObject;\n\n            var getter = lookupGetter(object, property);\n            var setter = lookupSetter(object, property);\n            object.__proto__ = prototype;\n\n            if (getter || setter) {\n                if (getter) descriptor.get = getter;\n                if (setter) descriptor.set = setter;\n                return descriptor;\n            }\n        }\n        descriptor.value = object[property];\n        return descriptor;\n    };\n}\nif (!Object.getOwnPropertyNames) {\n    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {\n        return Object.keys(object);\n    };\n}\nif (!Object.create) {\n    var createEmpty;\n    if (Object.prototype.__proto__ === null) {\n        createEmpty = function () {\n            return { \"__proto__\": null };\n        };\n    } else {\n        createEmpty = function () {\n            var empty = {};\n            for (var i in empty)\n                empty[i] = null;\n            empty.constructor =\n            empty.hasOwnProperty =\n            empty.propertyIsEnumerable =\n            empty.isPrototypeOf =\n            empty.toLocaleString =\n            empty.toString =\n            empty.valueOf =\n            empty.__proto__ = null;\n            return empty;\n        }\n    }\n\n    Object.create = function create(prototype, properties) {\n        var object;\n        if (prototype === null) {\n            object = createEmpty();\n        } else {\n            if (typeof prototype != \"object\")\n                throw new TypeError(\"typeof prototype[\"+(typeof prototype)+\"] != 'object'\");\n            var Type = function () {};\n            Type.prototype = prototype;\n            object = new Type();\n            object.__proto__ = prototype;\n        }\n        if (properties !== void 0)\n            Object.defineProperties(object, properties);\n        return object;\n    };\n}\n\nfunction doesDefinePropertyWork(object) {\n    try {\n        Object.defineProperty(object, \"sentinel\", {});\n        return \"sentinel\" in object;\n    } catch (exception) {\n    }\n}\nif (Object.defineProperty) {\n    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n    var definePropertyWorksOnDom = typeof document == \"undefined\" ||\n        doesDefinePropertyWork(document.createElement(\"div\"));\n    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n        var definePropertyFallback = Object.defineProperty;\n    }\n}\n\nif (!Object.defineProperty || definePropertyFallback) {\n    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\n    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \"\n    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined \" +\n                                      \"on this javascript engine\";\n\n    Object.defineProperty = function defineProperty(object, property, descriptor) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n        if ((typeof descriptor != \"object\" && typeof descriptor != \"function\") || descriptor === null)\n            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n        if (definePropertyFallback) {\n            try {\n                return definePropertyFallback.call(Object, object, property, descriptor);\n            } catch (exception) {\n            }\n        }\n        if (owns(descriptor, \"value\")) {\n\n            if (supportsAccessors && (lookupGetter(object, property) ||\n                                      lookupSetter(object, property)))\n            {\n                var prototype = object.__proto__;\n                object.__proto__ = prototypeOfObject;\n                delete object[property];\n                object[property] = descriptor.value;\n                object.__proto__ = prototype;\n            } else {\n                object[property] = descriptor.value;\n            }\n        } else {\n            if (!supportsAccessors)\n                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n            if (owns(descriptor, \"get\"))\n                defineGetter(object, property, descriptor.get);\n            if (owns(descriptor, \"set\"))\n                defineSetter(object, property, descriptor.set);\n        }\n\n        return object;\n    };\n}\nif (!Object.defineProperties) {\n    Object.defineProperties = function defineProperties(object, properties) {\n        for (var property in properties) {\n            if (owns(properties, property))\n                Object.defineProperty(object, property, properties[property]);\n        }\n        return object;\n    };\n}\nif (!Object.seal) {\n    Object.seal = function seal(object) {\n        return object;\n    };\n}\nif (!Object.freeze) {\n    Object.freeze = function freeze(object) {\n        return object;\n    };\n}\ntry {\n    Object.freeze(function () {});\n} catch (exception) {\n    Object.freeze = (function freeze(freezeObject) {\n        return function freeze(object) {\n            if (typeof object == \"function\") {\n                return object;\n            } else {\n                return freezeObject(object);\n            }\n        };\n    })(Object.freeze);\n}\nif (!Object.preventExtensions) {\n    Object.preventExtensions = function preventExtensions(object) {\n        return object;\n    };\n}\nif (!Object.isSealed) {\n    Object.isSealed = function isSealed(object) {\n        return false;\n    };\n}\nif (!Object.isFrozen) {\n    Object.isFrozen = function isFrozen(object) {\n        return false;\n    };\n}\nif (!Object.isExtensible) {\n    Object.isExtensible = function isExtensible(object) {\n        if (Object(object) === object) {\n            throw new TypeError(); // TODO message\n        }\n        var name = '';\n        while (owns(object, name)) {\n            name += '?';\n        }\n        object[name] = true;\n        var returnValue = owns(object, name);\n        delete object[name];\n        return returnValue;\n    };\n}\nif (!Object.keys) {\n    var hasDontEnumBug = true,\n        dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    for (var key in {\"toString\": null}) {\n        hasDontEnumBug = false;\n    }\n\n    Object.keys = function keys(object) {\n\n        if (\n            (typeof object != \"object\" && typeof object != \"function\") ||\n            object === null\n        ) {\n            throw new TypeError(\"Object.keys called on a non-object\");\n        }\n\n        var keys = [];\n        for (var name in object) {\n            if (owns(object, name)) {\n                keys.push(name);\n            }\n        }\n\n        if (hasDontEnumBug) {\n            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {\n                var dontEnum = dontEnums[i];\n                if (owns(object, dontEnum)) {\n                    keys.push(dontEnum);\n                }\n            }\n        }\n        return keys;\n    };\n\n}\nif (!Date.now) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\nvar ws = \"\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u2000\\u2001\\u2002\\u2003\" +\n    \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\" +\n    \"\\u2029\\uFEFF\";\nif (!String.prototype.trim) {\n    ws = \"[\" + ws + \"]\";\n    var trimBeginRegexp = new RegExp(\"^\" + ws + ws + \"*\"),\n        trimEndRegexp = new RegExp(ws + ws + \"*$\");\n    String.prototype.trim = function trim() {\n        return String(this).replace(trimBeginRegexp, \"\").replace(trimEndRegexp, \"\");\n    };\n}\n\nfunction toInteger(n) {\n    n = +n;\n    if (n !== n) { // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n}\n\nfunction isPrimitive(input) {\n    var type = typeof input;\n    return (\n        input === null ||\n        type === \"undefined\" ||\n        type === \"boolean\" ||\n        type === \"number\" ||\n        type === \"string\"\n    );\n}\n\nfunction toPrimitive(input) {\n    var val, valueOf, toString;\n    if (isPrimitive(input)) {\n        return input;\n    }\n    valueOf = input.valueOf;\n    if (typeof valueOf === \"function\") {\n        val = valueOf.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    toString = input.toString;\n    if (typeof toString === \"function\") {\n        val = toString.call(input);\n        if (isPrimitive(val)) {\n            return val;\n        }\n    }\n    throw new TypeError();\n}\nvar toObject = function (o) {\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can't convert \"+o+\" to object\");\n    }\n    return Object(o);\n};\n\n});\n\nace.define(\"ace/lib/fixoldbrowsers\",[\"require\",\"exports\",\"module\",\"ace/lib/regexp\",\"ace/lib/es5-shim\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./regexp\");\nrequire(\"./es5-shim\");\nif (typeof Element != \"undefined\" && !Element.prototype.remove) {\n    Object.defineProperty(Element.prototype, \"remove\", {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: function() { this.parentNode && this.parentNode.removeChild(this); }\n    });\n}\n\n\n});\n\nace.define(\"ace/lib/useragent\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nexports.OS = {\n    LINUX: \"LINUX\",\n    MAC: \"MAC\",\n    WINDOWS: \"WINDOWS\"\n};\nexports.getOS = function() {\n    if (exports.isMac) {\n        return exports.OS.MAC;\n    } else if (exports.isLinux) {\n        return exports.OS.LINUX;\n    } else {\n        return exports.OS.WINDOWS;\n    }\n};\nvar _navigator = typeof navigator == \"object\" ? navigator : {};\n\nvar os = (/mac|win|linux/i.exec(_navigator.platform) || [\"other\"])[0].toLowerCase();\nvar ua = _navigator.userAgent || \"\";\nvar appName = _navigator.appName || \"\";\nexports.isWin = (os == \"win\");\nexports.isMac = (os == \"mac\");\nexports.isLinux = (os == \"linux\");\nexports.isIE = \n    (appName == \"Microsoft Internet Explorer\" || appName.indexOf(\"MSAppHost\") >= 0)\n    ? parseFloat((ua.match(/(?:MSIE |Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1])\n    : parseFloat((ua.match(/(?:Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1]); // for ie\n    \nexports.isOldIE = exports.isIE && exports.isIE < 9;\nexports.isGecko = exports.isMozilla = ua.match(/ Gecko\\/\\d+/);\nexports.isOpera = typeof opera == \"object\" && Object.prototype.toString.call(window.opera) == \"[object Opera]\";\nexports.isWebKit = parseFloat(ua.split(\"WebKit/\")[1]) || undefined;\n\nexports.isChrome = parseFloat(ua.split(\" Chrome/\")[1]) || undefined;\n\nexports.isEdge = parseFloat(ua.split(\" Edge/\")[1]) || undefined;\n\nexports.isAIR = ua.indexOf(\"AdobeAIR\") >= 0;\n\nexports.isAndroid = ua.indexOf(\"Android\") >= 0;\n\nexports.isChromeOS = ua.indexOf(\" CrOS \") >= 0;\n\nexports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;\n\nif (exports.isIOS) exports.isMac = true;\n\nexports.isMobile = exports.isIOS || exports.isAndroid;\n\n});\n\nace.define(\"ace/lib/dom\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar useragent = require(\"./useragent\"); \nvar XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n\nexports.buildDom = function buildDom(arr, parent, refs) {\n    if (typeof arr == \"string\" && arr) {\n        var txt = document.createTextNode(arr);\n        if (parent)\n            parent.appendChild(txt);\n        return txt;\n    }\n    \n    if (!Array.isArray(arr))\n        return arr;\n    if (typeof arr[0] != \"string\" || !arr[0]) {\n        var els = [];\n        for (var i = 0; i < arr.length; i++) {\n            var ch = buildDom(arr[i], parent, refs);\n            ch && els.push(ch);\n        }\n        return els;\n    }\n    \n    var el = document.createElement(arr[0]);\n    var options = arr[1];\n    var childIndex = 1;\n    if (options && typeof options == \"object\" && !Array.isArray(options))\n        childIndex = 2;\n    for (var i = childIndex; i < arr.length; i++)\n        buildDom(arr[i], el, refs);\n    if (childIndex == 2) {\n        Object.keys(options).forEach(function(n) {\n            var val = options[n];\n            if (n === \"class\") {\n                el.className = Array.isArray(val) ? val.join(\" \") : val;\n            } else if (typeof val == \"function\" || n == \"value\") {\n                el[n] = val;\n            } else if (n === \"ref\") {\n                if (refs) refs[val] = el;\n            } else if (val != null) {\n                el.setAttribute(n, val);\n            }\n        });\n    }\n    if (parent)\n        parent.appendChild(el);\n    return el;\n};\n\nexports.getDocumentHead = function(doc) {\n    if (!doc)\n        doc = document;\n    return doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement;\n};\n\nexports.createElement = function(tag, ns) {\n    return document.createElementNS ?\n           document.createElementNS(ns || XHTML_NS, tag) :\n           document.createElement(tag);\n};\n\nexports.removeChildren = function(element) {\n    element.innerHTML = \"\";\n};\n\nexports.createTextNode = function(textContent, element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createTextNode(textContent);\n};\n\nexports.createFragment = function(element) {\n    var doc = element ? element.ownerDocument : document;\n    return doc.createDocumentFragment();\n};\n\nexports.hasCssClass = function(el, name) {\n    var classes = (el.className + \"\").split(/\\s+/g);\n    return classes.indexOf(name) !== -1;\n};\nexports.addCssClass = function(el, name) {\n    if (!exports.hasCssClass(el, name)) {\n        el.className += \" \" + name;\n    }\n};\nexports.removeCssClass = function(el, name) {\n    var classes = el.className.split(/\\s+/g);\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        classes.splice(index, 1);\n    }\n    el.className = classes.join(\" \");\n};\n\nexports.toggleCssClass = function(el, name) {\n    var classes = el.className.split(/\\s+/g), add = true;\n    while (true) {\n        var index = classes.indexOf(name);\n        if (index == -1) {\n            break;\n        }\n        add = false;\n        classes.splice(index, 1);\n    }\n    if (add)\n        classes.push(name);\n\n    el.className = classes.join(\" \");\n    return add;\n};\nexports.setCssClass = function(node, className, include) {\n    if (include) {\n        exports.addCssClass(node, className);\n    } else {\n        exports.removeCssClass(node, className);\n    }\n};\n\nexports.hasCssString = function(id, doc) {\n    var index = 0, sheets;\n    doc = doc || document;\n    if ((sheets = doc.querySelectorAll(\"style\"))) {\n        while (index < sheets.length)\n            if (sheets[index++].id === id)\n                return true;\n    }\n};\n\nexports.importCssString = function importCssString(cssText, id, target) {\n    var container = target;\n    if (!target || !target.getRootNode) {\n        container = document;\n    } else {\n        container = target.getRootNode();\n        if (!container || container == target)\n            container = document;\n    }\n    \n    var doc = container.ownerDocument || container;\n    if (id && exports.hasCssString(id, container))\n        return null;\n    \n    if (id)\n        cssText += \"\\n/*# sourceURL=ace/css/\" + id + \" */\";\n    \n    var style = exports.createElement(\"style\");\n    style.appendChild(doc.createTextNode(cssText));\n    if (id)\n        style.id = id;\n\n    if (container == doc)\n        container = exports.getDocumentHead(doc);\n    container.insertBefore(style, container.firstChild);\n};\n\nexports.importCssStylsheet = function(uri, doc) {\n    exports.buildDom([\"link\", {rel: \"stylesheet\", href: uri}], exports.getDocumentHead(doc));\n};\nexports.scrollbarWidth = function(document) {\n    var inner = exports.createElement(\"ace_inner\");\n    inner.style.width = \"100%\";\n    inner.style.minWidth = \"0px\";\n    inner.style.height = \"200px\";\n    inner.style.display = \"block\";\n\n    var outer = exports.createElement(\"ace_outer\");\n    var style = outer.style;\n\n    style.position = \"absolute\";\n    style.left = \"-10000px\";\n    style.overflow = \"hidden\";\n    style.width = \"200px\";\n    style.minWidth = \"0px\";\n    style.height = \"150px\";\n    style.display = \"block\";\n\n    outer.appendChild(inner);\n\n    var body = document.documentElement;\n    body.appendChild(outer);\n\n    var noScrollbar = inner.offsetWidth;\n\n    style.overflow = \"scroll\";\n    var withScrollbar = inner.offsetWidth;\n\n    if (noScrollbar == withScrollbar) {\n        withScrollbar = outer.clientWidth;\n    }\n\n    body.removeChild(outer);\n\n    return noScrollbar-withScrollbar;\n};\n\nif (typeof document == \"undefined\") {\n    exports.importCssString = function() {};\n}\n\nexports.computedStyle = function(element, style) {\n    return window.getComputedStyle(element, \"\") || {};\n};\n\nexports.setStyle = function(styles, property, value) {\n    if (styles[property] !== value) {\n        styles[property] = value;\n    }\n};\n\nexports.HAS_CSS_ANIMATION = false;\nexports.HAS_CSS_TRANSFORMS = false;\nexports.HI_DPI = useragent.isWin\n    ? typeof window !== \"undefined\" && window.devicePixelRatio >= 1.5\n    : true;\n\nif (typeof document !== \"undefined\") {\n    var div = document.createElement(\"div\");\n    if (exports.HI_DPI && div.style.transform  !== undefined)\n        exports.HAS_CSS_TRANSFORMS = true;\n    if (!useragent.isEdge && typeof div.style.animationName !== \"undefined\")\n        exports.HAS_CSS_ANIMATION = true;\n    div = null;\n}\n\nif (exports.HAS_CSS_TRANSFORMS) {\n    exports.translate = function(element, tx, ty) {\n        element.style.transform = \"translate(\" + Math.round(tx) + \"px, \" + Math.round(ty) +\"px)\";\n    };\n} else {\n    exports.translate = function(element, tx, ty) {\n        element.style.top = Math.round(ty) + \"px\";\n        element.style.left = Math.round(tx) + \"px\";\n    };\n}\n\n});\n\nace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.inherits = function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n};\n\nexports.mixin = function(obj, mixin) {\n    for (var key in mixin) {\n        obj[key] = mixin[key];\n    }\n    return obj;\n};\n\nexports.implement = function(proto, mixin) {\n    exports.mixin(proto, mixin);\n};\n\n});\n\nace.define(\"ace/lib/keys\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./oop\");\nvar Keys = (function() {\n    var ret = {\n        MODIFIER_KEYS: {\n            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta',\n            91: 'MetaLeft', 92: 'MetaRight', 93: 'ContextMenu'\n        },\n\n        KEY_MODS: {\n            \"ctrl\": 1, \"alt\": 2, \"option\" : 2, \"shift\": 4,\n            \"super\": 8, \"meta\": 8, \"command\": 8, \"cmd\": 8\n        },\n\n        FUNCTION_KEYS : {\n            8  : \"Backspace\",\n            9  : \"Tab\",\n            13 : \"Return\",\n            19 : \"Pause\",\n            27 : \"Esc\",\n            32 : \"Space\",\n            33 : \"PageUp\",\n            34 : \"PageDown\",\n            35 : \"End\",\n            36 : \"Home\",\n            37 : \"Left\",\n            38 : \"Up\",\n            39 : \"Right\",\n            40 : \"Down\",\n            44 : \"Print\",\n            45 : \"Insert\",\n            46 : \"Delete\",\n            96 : \"Numpad0\",\n            97 : \"Numpad1\",\n            98 : \"Numpad2\",\n            99 : \"Numpad3\",\n            100: \"Numpad4\",\n            101: \"Numpad5\",\n            102: \"Numpad6\",\n            103: \"Numpad7\",\n            104: \"Numpad8\",\n            105: \"Numpad9\",\n            '-13': \"NumpadEnter\",\n            112: \"F1\",\n            113: \"F2\",\n            114: \"F3\",\n            115: \"F4\",\n            116: \"F5\",\n            117: \"F6\",\n            118: \"F7\",\n            119: \"F8\",\n            120: \"F9\",\n            121: \"F10\",\n            122: \"F11\",\n            123: \"F12\",\n            144: \"Numlock\",\n            145: \"Scrolllock\"\n        },\n\n        PRINTABLE_KEYS: {\n           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',\n           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',\n           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',\n           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',\n           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',\n           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',\n          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',\n          219: '[', 220: '\\\\',221: ']', 222: \"'\", 111: '/', 106: '*'\n        }\n    };\n    var name, i;\n    for (i in ret.FUNCTION_KEYS) {\n        name = ret.FUNCTION_KEYS[i].toLowerCase();\n        ret[name] = parseInt(i, 10);\n    }\n    for (i in ret.PRINTABLE_KEYS) {\n        name = ret.PRINTABLE_KEYS[i].toLowerCase();\n        ret[name] = parseInt(i, 10);\n    }\n    oop.mixin(ret, ret.MODIFIER_KEYS);\n    oop.mixin(ret, ret.PRINTABLE_KEYS);\n    oop.mixin(ret, ret.FUNCTION_KEYS);\n    ret.enter = ret[\"return\"];\n    ret.escape = ret.esc;\n    ret.del = ret[\"delete\"];\n    ret[173] = '-';\n    \n    (function() {\n        var mods = [\"cmd\", \"ctrl\", \"alt\", \"shift\"];\n        for (var i = Math.pow(2, mods.length); i--;) {            \n            ret.KEY_MODS[i] = mods.filter(function(x) {\n                return i & ret.KEY_MODS[x];\n            }).join(\"-\") + \"-\";\n        }\n    })();\n\n    ret.KEY_MODS[0] = \"\";\n    ret.KEY_MODS[-1] = \"input-\";\n\n    return ret;\n})();\noop.mixin(exports, Keys);\n\nexports.keyCodeToString = function(keyCode) {\n    var keyString = Keys[keyCode];\n    if (typeof keyString != \"string\")\n        keyString = String.fromCharCode(keyCode);\n    return keyString.toLowerCase();\n};\n\n});\n\nace.define(\"ace/lib/event\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar keys = require(\"./keys\");\nvar useragent = require(\"./useragent\");\n\nvar pressedKeys = null;\nvar ts = 0;\n\nvar activeListenerOptions;\nfunction detectListenerOptionsSupport() {\n    activeListenerOptions = false;\n    try {\n        document.createComment(\"\").addEventListener(\"test\", function() {}, { \n            get passive() { \n                activeListenerOptions = {passive: false};\n            }\n        });\n    } catch(e) {}\n}\n\nfunction getListenerOptions() {\n    if (activeListenerOptions == undefined)\n        detectListenerOptionsSupport();\n    return activeListenerOptions;\n}\n\nexports.addListener = function(elem, type, callback) {\n    return elem.addEventListener(type, callback, getListenerOptions());\n};\n\nexports.removeListener = function(elem, type, callback) {\n    return elem.removeEventListener(type, callback, getListenerOptions());\n};\nexports.stopEvent = function(e) {\n    exports.stopPropagation(e);\n    exports.preventDefault(e);\n    return false;\n};\n\nexports.stopPropagation = function(e) {\n    if (e.stopPropagation)\n        e.stopPropagation();\n};\n\nexports.preventDefault = function(e) {\n    if (e.preventDefault)\n        e.preventDefault();\n};\nexports.getButton = function(e) {\n    if (e.type == \"dblclick\")\n        return 0;\n    if (e.type == \"contextmenu\" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))\n        return 2;\n    return e.button;\n};\n\nexports.capture = function(el, eventHandler, releaseCaptureHandler) {\n    function onMouseUp(e) {\n        eventHandler && eventHandler(e);\n        releaseCaptureHandler && releaseCaptureHandler(e);\n\n        exports.removeListener(document, \"mousemove\", eventHandler, true);\n        exports.removeListener(document, \"mouseup\", onMouseUp, true);\n        exports.removeListener(document, \"dragstart\", onMouseUp, true);\n    }\n\n    exports.addListener(document, \"mousemove\", eventHandler, true);\n    exports.addListener(document, \"mouseup\", onMouseUp, true);\n    exports.addListener(document, \"dragstart\", onMouseUp, true);\n    \n    return onMouseUp;\n};\n\nexports.addMouseWheelListener = function(el, callback) {\n    if (\"onmousewheel\" in el) {\n        exports.addListener(el, \"mousewheel\", function(e) {\n            var factor = 8;\n            if (e.wheelDeltaX !== undefined) {\n                e.wheelX = -e.wheelDeltaX / factor;\n                e.wheelY = -e.wheelDeltaY / factor;\n            } else {\n                e.wheelX = 0;\n                e.wheelY = -e.wheelDelta / factor;\n            }\n            callback(e);\n        });\n    } else if (\"onwheel\" in el) {\n        exports.addListener(el, \"wheel\",  function(e) {\n            var factor = 0.35;\n            switch (e.deltaMode) {\n                case e.DOM_DELTA_PIXEL:\n                    e.wheelX = e.deltaX * factor || 0;\n                    e.wheelY = e.deltaY * factor || 0;\n                    break;\n                case e.DOM_DELTA_LINE:\n                case e.DOM_DELTA_PAGE:\n                    e.wheelX = (e.deltaX || 0) * 5;\n                    e.wheelY = (e.deltaY || 0) * 5;\n                    break;\n            }\n            \n            callback(e);\n        });\n    } else {\n        exports.addListener(el, \"DOMMouseScroll\", function(e) {\n            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {\n                e.wheelX = (e.detail || 0) * 5;\n                e.wheelY = 0;\n            } else {\n                e.wheelX = 0;\n                e.wheelY = (e.detail || 0) * 5;\n            }\n            callback(e);\n        });\n    }\n};\n\nexports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {\n    var clicks = 0;\n    var startX, startY, timer; \n    var eventNames = {\n        2: \"dblclick\",\n        3: \"tripleclick\",\n        4: \"quadclick\"\n    };\n\n    function onMousedown(e) {\n        if (exports.getButton(e) !== 0) {\n            clicks = 0;\n        } else if (e.detail > 1) {\n            clicks++;\n            if (clicks > 4)\n                clicks = 1;\n        } else {\n            clicks = 1;\n        }\n        if (useragent.isIE) {\n            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;\n            if (!timer || isNewClick)\n                clicks = 1;\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);\n\n            if (clicks == 1) {\n                startX = e.clientX;\n                startY = e.clientY;\n            }\n        }\n        \n        e._clicks = clicks;\n\n        eventHandler[callbackName](\"mousedown\", e);\n\n        if (clicks > 4)\n            clicks = 0;\n        else if (clicks > 1)\n            return eventHandler[callbackName](eventNames[clicks], e);\n    }\n    if (!Array.isArray(elements))\n        elements = [elements];\n    elements.forEach(function(el) {\n        exports.addListener(el, \"mousedown\", onMousedown);\n    });\n};\n\nvar getModifierHash = function(e) {\n    return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n};\n\nexports.getModifierString = function(e) {\n    return keys.KEY_MODS[getModifierHash(e)];\n};\n\nfunction normalizeCommandKeys(callback, e, keyCode) {\n    var hashId = getModifierHash(e);\n\n    if (!useragent.isMac && pressedKeys) {\n        if (e.getModifierState && (e.getModifierState(\"OS\") || e.getModifierState(\"Win\")))\n            hashId |= 8;\n        if (pressedKeys.altGr) {\n            if ((3 & hashId) != 3)\n                pressedKeys.altGr = 0;\n            else\n                return;\n        }\n        if (keyCode === 18 || keyCode === 17) {\n            var location = \"location\" in e ? e.location : e.keyLocation;\n            if (keyCode === 17 && location === 1) {\n                if (pressedKeys[keyCode] == 1)\n                    ts = e.timeStamp;\n            } else if (keyCode === 18 && hashId === 3 && location === 2) {\n                var dt = e.timeStamp - ts;\n                if (dt < 50)\n                    pressedKeys.altGr = true;\n            }\n        }\n    }\n    \n    if (keyCode in keys.MODIFIER_KEYS) {\n        keyCode = -1;\n    }\n    \n    if (!hashId && keyCode === 13) {\n        var location = \"location\" in e ? e.location : e.keyLocation;\n        if (location === 3) {\n            callback(e, hashId, -keyCode);\n            if (e.defaultPrevented)\n                return;\n        }\n    }\n    \n    if (useragent.isChromeOS && hashId & 8) {\n        callback(e, hashId, keyCode);\n        if (e.defaultPrevented)\n            return;\n        else\n            hashId &= ~8;\n    }\n    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {\n        return false;\n    }\n    \n    return callback(e, hashId, keyCode);\n}\n\n\nexports.addCommandKeyListener = function(el, callback) {\n    var addListener = exports.addListener;\n    if (useragent.isOldGecko || (useragent.isOpera && !(\"KeyboardEvent\" in window))) {\n        var lastKeyDownKeyCode = null;\n        addListener(el, \"keydown\", function(e) {\n            lastKeyDownKeyCode = e.keyCode;\n        });\n        addListener(el, \"keypress\", function(e) {\n            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);\n        });\n    } else {\n        var lastDefaultPrevented = null;\n\n        addListener(el, \"keydown\", function(e) {\n            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;\n            var result = normalizeCommandKeys(callback, e, e.keyCode);\n            lastDefaultPrevented = e.defaultPrevented;\n            return result;\n        });\n\n        addListener(el, \"keypress\", function(e) {\n            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {\n                exports.stopEvent(e);\n                lastDefaultPrevented = null;\n            }\n        });\n\n        addListener(el, \"keyup\", function(e) {\n            pressedKeys[e.keyCode] = null;\n        });\n\n        if (!pressedKeys) {\n            resetPressedKeys();\n            addListener(window, \"focus\", resetPressedKeys);\n        }\n    }\n};\nfunction resetPressedKeys() {\n    pressedKeys = Object.create(null);\n}\n\nif (typeof window == \"object\" && window.postMessage && !useragent.isOldIE) {\n    var postMessageId = 1;\n    exports.nextTick = function(callback, win) {\n        win = win || window;\n        var messageName = \"zero-timeout-message-\" + (postMessageId++);\n        \n        var listener = function(e) {\n            if (e.data == messageName) {\n                exports.stopPropagation(e);\n                exports.removeListener(win, \"message\", listener);\n                callback();\n            }\n        };\n        \n        exports.addListener(win, \"message\", listener);\n        win.postMessage(messageName, \"*\");\n    };\n}\n\nexports.$idleBlocked = false;\nexports.onIdle = function(cb, timeout) {\n    return setTimeout(function handler() {\n        if (!exports.$idleBlocked) {\n            cb();\n        } else {\n            setTimeout(handler, 100);\n        }\n    }, timeout);\n};\n\nexports.$idleBlockId = null;\nexports.blockIdle = function(delay) {\n    if (exports.$idleBlockId)\n        clearTimeout(exports.$idleBlockId);\n        \n    exports.$idleBlocked = true;\n    exports.$idleBlockId = setTimeout(function() {\n        exports.$idleBlocked = false;\n    }, delay || 100);\n};\n\nexports.nextFrame = typeof window == \"object\" && (window.requestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || window.oRequestAnimationFrame);\n\nif (exports.nextFrame)\n    exports.nextFrame = exports.nextFrame.bind(window);\nelse\n    exports.nextFrame = function(callback) {\n        setTimeout(callback, 17);\n    };\n});\n\nace.define(\"ace/range\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nvar comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\nvar Range = function(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n        row: startRow,\n        column: startColumn\n    };\n\n    this.end = {\n        row: endRow,\n        column: endColumn\n    };\n};\n\n(function() {\n    this.isEqual = function(range) {\n        return this.start.row === range.start.row &&\n            this.end.row === range.end.row &&\n            this.start.column === range.start.column &&\n            this.end.column === range.end.column;\n    };\n    this.toString = function() {\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n    };\n\n    this.contains = function(row, column) {\n        return this.compare(row, column) == 0;\n    };\n    this.compareRange = function(range) {\n        var cmp,\n            end = range.end,\n            start = range.start;\n\n        cmp = this.compare(end.row, end.column);\n        if (cmp == 1) {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == 1) {\n                return 2;\n            } else if (cmp == 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else if (cmp == -1) {\n            return -2;\n        } else {\n            cmp = this.compare(start.row, start.column);\n            if (cmp == -1) {\n                return -1;\n            } else if (cmp == 1) {\n                return 42;\n            } else {\n                return 0;\n            }\n        }\n    };\n    this.comparePoint = function(p) {\n        return this.compare(p.row, p.column);\n    };\n    this.containsRange = function(range) {\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function(range) {\n        var cmp = this.compareRange(range);\n        return (cmp == -1 || cmp == 0 || cmp == 1);\n    };\n    this.isEnd = function(row, column) {\n        return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function(row, column) {\n        return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function(row, column) {\n        if (typeof row == \"object\") {\n            this.start.column = row.column;\n            this.start.row = row.row;\n        } else {\n            this.start.row = row;\n            this.start.column = column;\n        }\n    };\n    this.setEnd = function(row, column) {\n        if (typeof row == \"object\") {\n            this.end.column = row.column;\n            this.end.row = row.row;\n        } else {\n            this.end.row = row;\n            this.end.column = column;\n        }\n    };\n    this.inside = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideStart = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isEnd(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.insideEnd = function(row, column) {\n        if (this.compare(row, column) == 0) {\n            if (this.isStart(row, column)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    };\n    this.compare = function(row, column) {\n        if (!this.isMultiLine()) {\n            if (row === this.start.row) {\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n            }\n        }\n\n        if (row < this.start.row)\n            return -1;\n\n        if (row > this.end.row)\n            return 1;\n\n        if (this.start.row === row)\n            return column >= this.start.column ? 0 : -1;\n\n        if (this.end.row === row)\n            return column <= this.end.column ? 0 : 1;\n\n        return 0;\n    };\n    this.compareStart = function(row, column) {\n        if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareEnd = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.compareInside = function(row, column) {\n        if (this.end.row == row && this.end.column == column) {\n            return 1;\n        } else if (this.start.row == row && this.start.column == column) {\n            return -1;\n        } else {\n            return this.compare(row, column);\n        }\n    };\n    this.clipRows = function(firstRow, lastRow) {\n        if (this.end.row > lastRow)\n            var end = {row: lastRow + 1, column: 0};\n        else if (this.end.row < firstRow)\n            var end = {row: firstRow, column: 0};\n\n        if (this.start.row > lastRow)\n            var start = {row: lastRow + 1, column: 0};\n        else if (this.start.row < firstRow)\n            var start = {row: firstRow, column: 0};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function(row, column) {\n        var cmp = this.compare(row, column);\n\n        if (cmp == 0)\n            return this;\n        else if (cmp == -1)\n            var start = {row: row, column: column};\n        else\n            var end = {row: row, column: column};\n\n        return Range.fromPoints(start || this.start, end || this.end);\n    };\n\n    this.isEmpty = function() {\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\n    };\n    this.isMultiLine = function() {\n        return (this.start.row !== this.end.row);\n    };\n    this.clone = function() {\n        return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function() {\n        if (this.end.column == 0)\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);\n        else\n            return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function(session) {\n        var screenPosStart = session.documentToScreenPosition(this.start);\n        var screenPosEnd = session.documentToScreenPosition(this.end);\n\n        return new Range(\n            screenPosStart.row, screenPosStart.column,\n            screenPosEnd.row, screenPosEnd.column\n        );\n    };\n    this.moveBy = function(row, column) {\n        this.start.row += row;\n        this.start.column += column;\n        this.end.row += row;\n        this.end.column += column;\n    };\n\n}).call(Range.prototype);\nRange.fromPoints = function(start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n};\nRange.comparePoints = comparePoints;\n\nRange.comparePoints = function(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n};\n\n\nexports.Range = Range;\n});\n\nace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.last = function(a) {\n    return a[a.length - 1];\n};\n\nexports.stringReverse = function(string) {\n    return string.split(\"\").reverse().join(\"\");\n};\n\nexports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n        if (count & 1)\n            result += string;\n\n        if (count >>= 1)\n            string += string;\n    }\n    return result;\n};\n\nvar trimBeginRegexp = /^\\s\\s*/;\nvar trimEndRegexp = /\\s\\s*$/;\n\nexports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n};\n\nexports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n};\n\nexports.copyObject = function(obj) {\n    var copy = {};\n    for (var key in obj) {\n        copy[key] = obj[key];\n    }\n    return copy;\n};\n\nexports.copyArray = function(array){\n    var copy = [];\n    for (var i=0, l=array.length; i<l; i++) {\n        if (array[i] && typeof array[i] == \"object\")\n            copy[i] = this.copyObject(array[i]);\n        else \n            copy[i] = array[i];\n    }\n    return copy;\n};\n\nexports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj)\n        return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n        copy = [];\n        for (var key = 0; key < obj.length; key++) {\n            copy[key] = deepCopy(obj[key]);\n        }\n        return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\")\n        return obj;\n    \n    copy = {};\n    for (var key in obj)\n        copy[key] = deepCopy(obj[key]);\n    return copy;\n};\n\nexports.arrayToMap = function(arr) {\n    var map = {};\n    for (var i=0; i<arr.length; i++) {\n        map[arr[i]] = 1;\n    }\n    return map;\n\n};\n\nexports.createMap = function(props) {\n    var map = Object.create(null);\n    for (var i in props) {\n        map[i] = props[i];\n    }\n    return map;\n};\nexports.arrayRemove = function(array, value) {\n  for (var i = 0; i <= array.length; i++) {\n    if (value === array[i]) {\n      array.splice(i, 1);\n    }\n  }\n};\n\nexports.escapeRegExp = function(str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n};\n\nexports.escapeHTML = function(str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n};\n\nexports.getMatchOffsets = function(string, regExp) {\n    var matches = [];\n\n    string.replace(regExp, function(str) {\n        matches.push({\n            offset: arguments[arguments.length-2],\n            length: str.length\n        });\n    });\n\n    return matches;\n};\nexports.deferredCall = function(fcn) {\n    var timer = null;\n    var callback = function() {\n        timer = null;\n        fcn();\n    };\n\n    var deferred = function(timeout) {\n        deferred.cancel();\n        timer = setTimeout(callback, timeout || 0);\n        return deferred;\n    };\n\n    deferred.schedule = deferred;\n\n    deferred.call = function() {\n        this.cancel();\n        fcn();\n        return deferred;\n    };\n\n    deferred.cancel = function() {\n        clearTimeout(timer);\n        timer = null;\n        return deferred;\n    };\n    \n    deferred.isPending = function() {\n        return timer;\n    };\n\n    return deferred;\n};\n\n\nexports.delayedCall = function(fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function() {\n        timer = null;\n        fcn();\n    };\n\n    var _self = function(timeout) {\n        if (timer == null)\n            timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n\n    _self.delay = function(timeout) {\n        timer && clearTimeout(timer);\n        timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n\n    _self.call = function() {\n        this.cancel();\n        fcn();\n    };\n\n    _self.cancel = function() {\n        timer && clearTimeout(timer);\n        timer = null;\n    };\n\n    _self.isPending = function() {\n        return timer;\n    };\n\n    return _self;\n};\n});\n\nace.define(\"ace/clipboard\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar $cancelT;\nmodule.exports = { \n    lineMode: false,\n    pasteCancelled: function() {\n        if ($cancelT && $cancelT > Date.now() - 50)\n            return true;\n        return $cancelT = false;\n    },\n    cancel: function() {\n        $cancelT = Date.now();\n    }\n};\n\n});\n\nace.define(\"ace/keyboard/textinput\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/clipboard\",\"ace/lib/keys\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar clipboard = require(\"../clipboard\");\nvar BROKEN_SETDATA = useragent.isChrome < 18;\nvar USE_IE_MIME_TYPE =  useragent.isIE;\nvar HAS_FOCUS_ARGS = useragent.isChrome > 63;\nvar MAX_LINE_LENGTH = 400;\n\nvar KEYS = require(\"../lib/keys\");\nvar MODS = KEYS.KEY_MODS;\nvar isIOS = useragent.isIOS;\nvar valueResetRegex = isIOS ? /\\s/ : /\\n/;\n\nvar TextInput = function(parentNode, host) {\n    var text = dom.createElement(\"textarea\");\n    text.className = \"ace_text-input\";\n\n    text.setAttribute(\"wrap\", \"off\");\n    text.setAttribute(\"autocorrect\", \"off\");\n    text.setAttribute(\"autocapitalize\", \"off\");\n    text.setAttribute(\"spellcheck\", false);\n\n    text.style.opacity = \"0\";\n    parentNode.insertBefore(text, parentNode.firstChild);\n\n    var copied = false;\n    var pasted = false;\n    var inComposition = false;\n    var sendingText = false;\n    var tempStyle = '';\n    \n    if (!useragent.isMobile)\n        text.style.fontSize = \"1px\";\n\n    var commandMode = false;\n    var ignoreFocusEvents = false;\n    \n    var lastValue = \"\";\n    var lastSelectionStart = 0;\n    var lastSelectionEnd = 0;\n    var lastRestoreEnd = 0;\n    try { var isFocused = document.activeElement === text; } catch(e) {}\n    \n    event.addListener(text, \"blur\", function(e) {\n        if (ignoreFocusEvents) return;\n        host.onBlur(e);\n        isFocused = false;\n    });\n    event.addListener(text, \"focus\", function(e) {\n        if (ignoreFocusEvents) return;\n        isFocused = true;\n        if (useragent.isEdge) {\n            try {\n                if (!document.hasFocus())\n                    return;\n            } catch(e) {}\n        }\n        host.onFocus(e);\n        if (useragent.isEdge)\n            setTimeout(resetSelection);\n        else\n            resetSelection();\n    });\n    this.$focusScroll = false;\n    this.focus = function() {\n        if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == \"browser\")\n            return text.focus({ preventScroll: true });\n\n        var top = text.style.top;\n        text.style.position = \"fixed\";\n        text.style.top = \"0px\";\n        try {\n            var isTransformed = text.getBoundingClientRect().top != 0;\n        } catch(e) {\n            return;\n        }\n        var ancestors = [];\n        if (isTransformed) {\n            var t = text.parentElement;\n            while (t && t.nodeType == 1) {\n                ancestors.push(t);\n                t.setAttribute(\"ace_nocontext\", true);\n                if (!t.parentElement && t.getRootNode)\n                    t = t.getRootNode().host;\n                else\n                    t = t.parentElement;\n            }\n        }\n        text.focus({ preventScroll: true });\n        if (isTransformed) {\n            ancestors.forEach(function(p) {\n                p.removeAttribute(\"ace_nocontext\");\n            });\n        }\n        setTimeout(function() {\n            text.style.position = \"\";\n            if (text.style.top == \"0px\")\n                text.style.top = top;\n        }, 0);\n    };\n    this.blur = function() {\n        text.blur();\n    };\n    this.isFocused = function() {\n        return isFocused;\n    };\n    \n    host.on(\"beforeEndOperation\", function() {\n        if (host.curOp && host.curOp.command.name == \"insertstring\")\n            return;\n        if (inComposition) {\n            lastValue = text.value = \"\";\n            onCompositionEnd();\n        }\n        resetSelection();\n    });\n    \n    var resetSelection = isIOS\n    ? function(value) {\n        if (!isFocused || (copied && !value) || sendingText) return;\n        if (!value) \n            value = \"\";\n        var newValue = \"\\n ab\" + value + \"cde fg\\n\";\n        if (newValue != text.value)\n            text.value = lastValue = newValue;\n        \n        var selectionStart = 4;\n        var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));\n\n        if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {\n            text.setSelectionRange(selectionStart, selectionEnd);\n        }\n        lastSelectionStart = selectionStart;\n        lastSelectionEnd = selectionEnd;\n    }\n    : function() {\n        if (inComposition || sendingText)\n            return;\n        if (!isFocused && !afterContextMenu)\n            return;\n        inComposition = true;\n        \n        var selection = host.selection;\n        var range = selection.getRange();\n        var row = selection.cursor.row;\n        var selectionStart = range.start.column;\n        var selectionEnd = range.end.column;\n        var line = host.session.getLine(row);\n\n        if (range.start.row != row) {\n            var prevLine = host.session.getLine(row - 1);\n            selectionStart = range.start.row < row - 1 ? 0 : selectionStart;\n            selectionEnd += prevLine.length + 1;\n            line = prevLine + \"\\n\" + line;\n        }\n        else if (range.end.row != row) {\n            var nextLine = host.session.getLine(row + 1);\n            selectionEnd = range.end.row > row  + 1 ? nextLine.length : selectionEnd;\n            selectionEnd += line.length + 1;\n            line = line + \"\\n\" + nextLine;\n        }\n\n        if (line.length > MAX_LINE_LENGTH) {\n            if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {\n                line = line.slice(0, MAX_LINE_LENGTH);\n            } else {\n                line = \"\\n\";\n                selectionStart = 0;\n                selectionEnd = 1;\n            }\n        }\n\n        var newValue = line + \"\\n\\n\";\n        if (newValue != lastValue) {\n            text.value = lastValue = newValue;\n            lastSelectionStart = lastSelectionEnd = newValue.length;\n        }\n        if (afterContextMenu) {\n            lastSelectionStart = text.selectionStart;\n            lastSelectionEnd = text.selectionEnd;\n        }\n        if (\n            lastSelectionEnd != selectionEnd \n            || lastSelectionStart != selectionStart \n            || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization\n        ) {\n            try {\n                text.setSelectionRange(selectionStart, selectionEnd);\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n            } catch(e){}\n        }\n        inComposition = false;\n    };\n\n    if (isFocused)\n        host.onFocus();\n\n\n    var isAllSelected = function(text) {\n        return text.selectionStart === 0 && text.selectionEnd >= lastValue.length\n            && text.value === lastValue && lastValue\n            && text.selectionEnd !== lastSelectionEnd;\n    };\n\n    var onSelect = function(e) {\n        if (inComposition)\n            return;\n        if (copied) {\n            copied = false;\n        } else if (isAllSelected(text)) {\n            host.selectAll();\n            resetSelection();\n        }\n    };\n\n    var inputHandler = null;\n    this.setInputHandler = function(cb) {inputHandler = cb;};\n    this.getInputHandler = function() {return inputHandler;};\n    var afterContextMenu = false;\n    \n    var sendText = function(value, fromInput) {\n        if (afterContextMenu)\n            afterContextMenu = false;\n        if (pasted) {\n            resetSelection();\n            if (value)\n                host.onPaste(value);\n            pasted = false;\n            return \"\";\n        } else {\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n        \n            var extendLeft = lastSelectionStart;\n            var extendRight = lastValue.length - lastSelectionEnd;\n            \n            var inserted = value;\n            var restoreStart = value.length - selectionStart;\n            var restoreEnd = value.length - selectionEnd;\n        \n            var i = 0;\n            while (extendLeft > 0 && lastValue[i] == value[i]) {\n                i++;\n                extendLeft--;\n            }\n            inserted = inserted.slice(i);\n            i = 1;\n            while (extendRight > 0 && lastValue.length - i > lastSelectionStart - 1  && lastValue[lastValue.length - i] == value[value.length - i]) {\n                i++;\n                extendRight--;\n            }\n            restoreStart -= i-1;\n            restoreEnd -= i-1;\n            var endIndex = inserted.length - i + 1;\n            if (endIndex < 0) {\n                extendLeft = -endIndex;\n                endIndex = 0;\n            } \n            inserted = inserted.slice(0, endIndex);\n            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)\n                return \"\";\n            sendingText = true;\n            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {\n                host.onTextInput(inserted);\n            } else {\n                host.onTextInput(inserted, {\n                    extendLeft: extendLeft,\n                    extendRight: extendRight,\n                    restoreStart: restoreStart,\n                    restoreEnd: restoreEnd\n                });\n            }\n            sendingText = false;\n            \n            lastValue = value;\n            lastSelectionStart = selectionStart;\n            lastSelectionEnd = selectionEnd;\n            lastRestoreEnd = restoreEnd;\n            return inserted;\n        }\n    };\n    var onInput = function(e) {\n        if (inComposition)\n            return onCompositionUpdate();\n        if (e && e.inputType) {\n            if (e.inputType == \"historyUndo\") return host.execCommand(\"undo\");\n            if (e.inputType == \"historyRedo\") return host.execCommand(\"redo\");\n        }\n        var data = text.value;\n        var inserted = sendText(data, true);\n        if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted))\n            resetSelection();\n    };\n    \n    var handleClipboardData = function(e, data, forceIEMime) {\n        var clipboardData = e.clipboardData || window.clipboardData;\n        if (!clipboardData || BROKEN_SETDATA)\n            return;\n        var mime = USE_IE_MIME_TYPE || forceIEMime ? \"Text\" : \"text/plain\";\n        try {\n            if (data) {\n                return clipboardData.setData(mime, data) !== false;\n            } else {\n                return clipboardData.getData(mime);\n            }\n        } catch(e) {\n            if (!forceIEMime)\n                return handleClipboardData(e, data, true);\n        }\n    };\n\n    var doCopy = function(e, isCut) {\n        var data = host.getCopyText();\n        if (!data)\n            return event.preventDefault(e);\n\n        if (handleClipboardData(e, data)) {\n            if (isIOS) {\n                resetSelection(data);\n                copied = data;\n                setTimeout(function () {\n                    copied = false;\n                }, 10);\n            }\n            isCut ? host.onCut() : host.onCopy();\n            event.preventDefault(e);\n        } else {\n            copied = true;\n            text.value = data;\n            text.select();\n            setTimeout(function(){\n                copied = false;\n                resetSelection();\n                isCut ? host.onCut() : host.onCopy();\n            });\n        }\n    };\n    \n    var onCut = function(e) {\n        doCopy(e, true);\n    };\n    \n    var onCopy = function(e) {\n        doCopy(e, false);\n    };\n    \n    var onPaste = function(e) {\n        var data = handleClipboardData(e);\n        if (clipboard.pasteCancelled())\n            return;\n        if (typeof data == \"string\") {\n            if (data)\n                host.onPaste(data, e);\n            if (useragent.isIE)\n                setTimeout(resetSelection);\n            event.preventDefault(e);\n        }\n        else {\n            text.value = \"\";\n            pasted = true;\n        }\n    };\n\n    event.addCommandKeyListener(text, host.onCommandKey.bind(host));\n\n    event.addListener(text, \"select\", onSelect);\n    event.addListener(text, \"input\", onInput);\n\n    event.addListener(text, \"cut\", onCut);\n    event.addListener(text, \"copy\", onCopy);\n    event.addListener(text, \"paste\", onPaste);\n    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {\n        event.addListener(parentNode, \"keydown\", function(e) {\n            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)\n                return;\n\n            switch (e.keyCode) {\n                case 67:\n                    onCopy(e);\n                    break;\n                case 86:\n                    onPaste(e);\n                    break;\n                case 88:\n                    onCut(e);\n                    break;\n            }\n        });\n    }\n    var onCompositionStart = function(e) {\n        if (inComposition || !host.onCompositionStart || host.$readOnly) \n            return;\n        \n        inComposition = {};\n\n        if (commandMode)\n            return;\n        \n        setTimeout(onCompositionUpdate, 0);\n        host.on(\"mousedown\", cancelComposition);\n        \n        var range = host.getSelectionRange();\n        range.end.row = range.start.row;\n        range.end.column = range.start.column;\n        inComposition.markerRange = range;\n        inComposition.selectionStart = lastSelectionStart;\n        host.onCompositionStart(inComposition);\n        \n        if (inComposition.useTextareaForIME) {\n            text.value = \"\";\n            lastValue = \"\";\n            lastSelectionStart = 0;\n            lastSelectionEnd = 0;\n        }\n        else {\n            if (text.msGetInputContext)\n                inComposition.context = text.msGetInputContext();\n            if (text.getInputContext)\n                inComposition.context = text.getInputContext();\n        }\n    };\n\n    var onCompositionUpdate = function() {\n        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)\n            return;\n        if (commandMode)\n            return cancelComposition();\n        \n        if (inComposition.useTextareaForIME) {\n            host.onCompositionUpdate(text.value);\n        }\n        else {\n            var data = text.value;\n            sendText(data);\n            if (inComposition.markerRange) {\n                if (inComposition.context) {\n                    inComposition.markerRange.start.column = inComposition.selectionStart\n                        = inComposition.context.compositionStartOffset;\n                }\n                inComposition.markerRange.end.column = inComposition.markerRange.start.column\n                    + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;\n            }\n        }\n    };\n\n    var onCompositionEnd = function(e) {\n        if (!host.onCompositionEnd || host.$readOnly) return;\n        inComposition = false;\n        host.onCompositionEnd();\n        host.off(\"mousedown\", cancelComposition);\n        if (e) onInput();\n    };\n    \n\n    function cancelComposition() {\n        ignoreFocusEvents = true;\n        text.blur();\n        text.focus();\n        ignoreFocusEvents = false;\n    }\n\n    var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);\n    \n    function onKeyup(e) {\n        if (e.keyCode == 27 && text.value.length < text.selectionStart) {\n            if (!inComposition)\n                lastValue = text.value;\n            lastSelectionStart = lastSelectionEnd = -1;\n            resetSelection();\n        }\n        syncComposition();\n    }\n\n    event.addListener(text, \"compositionstart\", onCompositionStart);\n    event.addListener(text, \"compositionupdate\", onCompositionUpdate);\n    event.addListener(text, \"keyup\", onKeyup);\n    event.addListener(text, \"keydown\", syncComposition);\n    event.addListener(text, \"compositionend\", onCompositionEnd);\n\n    this.getElement = function() {\n        return text;\n    };\n    this.setCommandMode = function(value) {\n       commandMode = value;\n       text.readOnly = false;\n    };\n    \n    this.setReadOnly = function(readOnly) {\n        if (!commandMode)\n            text.readOnly = readOnly;\n    };\n\n    this.setCopyWithEmptySelection = function(value) {\n    };\n\n    this.onContextMenu = function(e) {\n        afterContextMenu = true;\n        resetSelection();\n        host._emit(\"nativecontextmenu\", {target: host, domEvent: e});\n        this.moveToMouse(e, true);\n    };\n    \n    this.moveToMouse = function(e, bringToFront) {\n        if (!tempStyle)\n            tempStyle = text.style.cssText;\n        text.style.cssText = (bringToFront ? \"z-index:100000;\" : \"\")\n            + (useragent.isIE ? \"opacity:0.1;\" : \"\")\n            + \"text-indent: -\" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + \"px;\";\n\n        var rect = host.container.getBoundingClientRect();\n        var style = dom.computedStyle(host.container);\n        var top = rect.top + (parseInt(style.borderTopWidth) || 0);\n        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);\n        var maxTop = rect.bottom - top - text.clientHeight -2;\n        var move = function(e) {\n            dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));\n        }; \n        move(e);\n\n        if (e.type != \"mousedown\")\n            return;\n\n        host.renderer.$isMousePressed = true;\n\n        clearTimeout(closeTimeout);\n        if (useragent.isWin)\n            event.capture(host.container, move, onContextMenuClose);\n    };\n\n    this.onContextMenuClose = onContextMenuClose;\n    var closeTimeout;\n    function onContextMenuClose() {\n        clearTimeout(closeTimeout);\n        closeTimeout = setTimeout(function () {\n            if (tempStyle) {\n                text.style.cssText = tempStyle;\n                tempStyle = '';\n            }\n            host.renderer.$isMousePressed = false;\n            if (host.renderer.$keepTextAreaAtCursor)\n                host.renderer.$moveTextAreaToCursor();\n        }, 0);\n    }\n\n    var onContextMenu = function(e) {\n        host.textInput.onContextMenu(e);\n        onContextMenuClose();\n    };\n    event.addListener(text, \"mouseup\", onContextMenu);\n    event.addListener(text, \"mousedown\", function(e) {\n        e.preventDefault();\n        onContextMenuClose();\n    });\n    event.addListener(host.renderer.scroller, \"contextmenu\", onContextMenu);\n    event.addListener(text, \"contextmenu\", onContextMenu);\n    \n    if (isIOS)\n        addIosSelectionHandler(parentNode, host, text);\n\n    function addIosSelectionHandler(parentNode, host, text) {\n        var typingResetTimeout = null;\n        var typing = false;\n \n        text.addEventListener(\"keydown\", function (e) {\n            if (typingResetTimeout) clearTimeout(typingResetTimeout);\n            typing = true;\n        }, true);\n\n        text.addEventListener(\"keyup\", function (e) {\n            typingResetTimeout = setTimeout(function () {\n                typing = false;\n            }, 100);\n        }, true);\n        var detectArrowKeys = function(e) {\n            if (document.activeElement !== text) return;\n            if (typing || inComposition || host.$mouseHandler.isMousePressed) return;\n\n            if (copied) {\n                return;\n            }\n            var selectionStart = text.selectionStart;\n            var selectionEnd = text.selectionEnd;\n            \n            var key = null;\n            var modifier = 0;\n            if (selectionStart == 0) {\n                key = KEYS.up;\n            } else if (selectionStart == 1) {\n                key = KEYS.home;\n            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == \"\\n\") {\n                key = KEYS.end;\n            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == \" \") {\n                key = KEYS.left;\n                modifier = MODS.option;\n            } else if (\n                selectionStart < lastSelectionStart\n                || (\n                    selectionStart == lastSelectionStart \n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd\n                )\n            ) {\n                key = KEYS.left;\n            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split(\"\\n\").length > 2) {\n                key = KEYS.down;\n            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == \" \") {\n                key = KEYS.right;\n                modifier = MODS.option;\n            } else if (\n                selectionEnd > lastSelectionEnd\n                || (\n                    selectionEnd == lastSelectionEnd \n                    && lastSelectionEnd != lastSelectionStart\n                    && selectionStart == selectionEnd\n                )\n            ) {\n                key = KEYS.right;\n            }\n            \n            if (selectionStart !== selectionEnd)\n                modifier |= MODS.shift;\n\n            if (key) {\n                var result = host.onCommandKey({}, modifier, key);\n                if (!result && host.commands) {\n                    key = KEYS.keyCodeToString(key);\n                    var command = host.commands.findKeyCommand(modifier, key);\n                    if (command)\n                        host.execCommand(command);\n                }\n                lastSelectionStart = selectionStart;\n                lastSelectionEnd = selectionEnd;\n                resetSelection(\"\");\n            }\n        };\n        document.addEventListener(\"selectionchange\", detectArrowKeys);\n        host.on(\"destroy\", function() {\n            document.removeEventListener(\"selectionchange\", detectArrowKeys);\n        });\n    }\n\n};\n\nexports.TextInput = TextInput;\n});\n\nace.define(\"ace/mouse/default_handlers\",[\"require\",\"exports\",\"module\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar useragent = require(\"../lib/useragent\");\n\nvar DRAG_OFFSET = 0; // pixels\nvar SCROLL_COOLDOWN_T = 550; // milliseconds\n\nfunction DefaultHandlers(mouseHandler) {\n    mouseHandler.$clickSelection = null;\n\n    var editor = mouseHandler.editor;\n    editor.setDefaultHandler(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n    editor.setDefaultHandler(\"dblclick\", this.onDoubleClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"tripleclick\", this.onTripleClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"quadclick\", this.onQuadClick.bind(mouseHandler));\n    editor.setDefaultHandler(\"mousewheel\", this.onMouseWheel.bind(mouseHandler));\n\n    var exports = [\"select\", \"startSelect\", \"selectEnd\", \"selectAllEnd\", \"selectByWordsEnd\",\n        \"selectByLinesEnd\", \"dragWait\", \"dragWaitEnd\", \"focusWait\"];\n\n    exports.forEach(function(x) {\n        mouseHandler[x] = this[x];\n    }, this);\n\n    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, \"getLineRange\");\n    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, \"getWordRange\");\n}\n\n(function() {\n\n    this.onMouseDown = function(ev) {\n        var inSelection = ev.inSelection();\n        var pos = ev.getDocumentPosition();\n        this.mousedownEvent = ev;\n        var editor = this.editor;\n\n        var button = ev.getButton();\n        if (button !== 0) {\n            var selectionRange = editor.getSelectionRange();\n            var selectionEmpty = selectionRange.isEmpty();\n            if (selectionEmpty || button == 1)\n                editor.selection.moveToPosition(pos);\n            if (button == 2) {\n                editor.textInput.onContextMenu(ev.domEvent);\n                if (!useragent.isMozilla)\n                    ev.preventDefault();\n            }\n            return;\n        }\n\n        this.mousedownEvent.time = Date.now();\n        if (inSelection && !editor.isFocused()) {\n            editor.focus();\n            if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {\n                this.setState(\"focusWait\");\n                this.captureMouse(ev);\n                return;\n            }\n        }\n\n        this.captureMouse(ev);\n        this.startSelect(pos, ev.domEvent._clicks > 1);\n        return ev.preventDefault();\n    };\n\n    this.startSelect = function(pos, waitForClickSelection) {\n        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var editor = this.editor;\n        if (!this.mousedownEvent) return;\n        if (this.mousedownEvent.getShiftKey())\n            editor.selection.selectToPosition(pos);\n        else if (!waitForClickSelection)\n            editor.selection.moveToPosition(pos);\n        if (!waitForClickSelection)\n            this.select();\n        if (editor.renderer.scroller.setCapture) {\n            editor.renderer.scroller.setCapture();\n        }\n        editor.setStyle(\"ace_selecting\");\n        this.setState(\"select\");\n    };\n\n    this.select = function() {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        if (this.$clickSelection) {\n            var cmp = this.$clickSelection.comparePoint(cursor);\n\n            if (cmp == -1) {\n                anchor = this.$clickSelection.end;\n            } else if (cmp == 1) {\n                anchor = this.$clickSelection.start;\n            } else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n\n    this.extendSelectionBy = function(unitName) {\n        var anchor, editor = this.editor;\n        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n        var range = editor.selection[unitName](cursor.row, cursor.column);\n        if (this.$clickSelection) {\n            var cmpStart = this.$clickSelection.comparePoint(range.start);\n            var cmpEnd = this.$clickSelection.comparePoint(range.end);\n\n            if (cmpStart == -1 && cmpEnd <= 0) {\n                anchor = this.$clickSelection.end;\n                if (range.end.row != cursor.row || range.end.column != cursor.column)\n                    cursor = range.start;\n            } else if (cmpEnd == 1 && cmpStart >= 0) {\n                anchor = this.$clickSelection.start;\n                if (range.start.row != cursor.row || range.start.column != cursor.column)\n                    cursor = range.end;\n            } else if (cmpStart == -1 && cmpEnd == 1) {\n                cursor = range.end;\n                anchor = range.start;\n            } else {\n                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n                cursor = orientedRange.cursor;\n                anchor = orientedRange.anchor;\n            }\n            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n        }\n        editor.selection.selectToPosition(cursor);\n        editor.renderer.scrollCursorIntoView();\n    };\n\n    this.selectEnd =\n    this.selectAllEnd =\n    this.selectByWordsEnd =\n    this.selectByLinesEnd = function() {\n        this.$clickSelection = null;\n        this.editor.unsetStyle(\"ace_selecting\");\n        if (this.editor.renderer.scroller.releaseCapture) {\n            this.editor.renderer.scroller.releaseCapture();\n        }\n    };\n\n    this.focusWait = function() {\n        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n        var time = Date.now();\n\n        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)\n            this.startSelect(this.mousedownEvent.getDocumentPosition());\n    };\n\n    this.onDoubleClick = function(ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n        var session = editor.session;\n\n        var range = session.getBracketRange(pos);\n        if (range) {\n            if (range.isEmpty()) {\n                range.start.column--;\n                range.end.column++;\n            }\n            this.setState(\"select\");\n        } else {\n            range = editor.selection.getWordRange(pos.row, pos.column);\n            this.setState(\"selectByWords\");\n        }\n        this.$clickSelection = range;\n        this.select();\n    };\n\n    this.onTripleClick = function(ev) {\n        var pos = ev.getDocumentPosition();\n        var editor = this.editor;\n\n        this.setState(\"selectByLines\");\n        var range = editor.getSelectionRange();\n        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {\n            this.$clickSelection = editor.selection.getLineRange(range.start.row);\n            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;\n        } else {\n            this.$clickSelection = editor.selection.getLineRange(pos.row);\n        }\n        this.select();\n    };\n\n    this.onQuadClick = function(ev) {\n        var editor = this.editor;\n\n        editor.selectAll();\n        this.$clickSelection = editor.getSelectionRange();\n        this.setState(\"selectAll\");\n    };\n\n    this.onMouseWheel = function(ev) {\n        if (ev.getAccelKey())\n            return;\n        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n            ev.wheelX = ev.wheelY;\n            ev.wheelY = 0;\n        }\n        \n        var editor = this.editor;\n        \n        if (!this.$lastScroll)\n            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };\n        \n        var prevScroll = this.$lastScroll;\n        var t = ev.domEvent.timeStamp;\n        var dt = t - prevScroll.t;\n        var vx = dt ? ev.wheelX / dt : prevScroll.vx;\n        var vy = dt ? ev.wheelY / dt : prevScroll.vy;\n        if (dt < SCROLL_COOLDOWN_T) {\n            vx = (vx + prevScroll.vx) / 2;\n            vy = (vy + prevScroll.vy) / 2;\n        }\n        \n        var direction = Math.abs(vx / vy);\n        \n        var canScroll = false;\n        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))\n            canScroll = true;\n        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))\n            canScroll = true;\n            \n        if (canScroll) {\n            prevScroll.allowed = t;\n        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {\n            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx)\n                && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);\n            if (isSlower) {\n                canScroll = true;\n                prevScroll.allowed = t;\n            }\n            else {\n                prevScroll.allowed = 0;\n            }\n        }\n        \n        prevScroll.t = t;\n        prevScroll.vx = vx;\n        prevScroll.vy = vy;\n\n        if (canScroll) {\n            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n            return ev.stop();\n        }\n    };\n\n}).call(DefaultHandlers.prototype);\n\nexports.DefaultHandlers = DefaultHandlers;\n\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\n\nfunction calcRangeOrientation(range, cursor) {\n    if (range.start.row == range.end.row)\n        var cmp = 2 * cursor.column - range.start.column - range.end.column;\n    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)\n        var cmp = cursor.column - 4;\n    else\n        var cmp = 2 * cursor.row - range.start.row - range.end.row;\n\n    if (cmp < 0)\n        return {cursor: range.start, anchor: range.end};\n    else\n        return {cursor: range.end, anchor: range.start};\n}\n\n});\n\nace.define(\"ace/tooltip\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nfunction Tooltip (parentNode) {\n    this.isOpen = false;\n    this.$element = null;\n    this.$parentNode = parentNode;\n}\n\n(function() {\n    this.$init = function() {\n        this.$element = dom.createElement(\"div\");\n        this.$element.className = \"ace_tooltip\";\n        this.$element.style.display = \"none\";\n        this.$parentNode.appendChild(this.$element);\n        return this.$element;\n    };\n    this.getElement = function() {\n        return this.$element || this.$init();\n    };\n    this.setText = function(text) {\n        this.getElement().textContent = text;\n    };\n    this.setHtml = function(html) {\n        this.getElement().innerHTML = html;\n    };\n    this.setPosition = function(x, y) {\n        this.getElement().style.left = x + \"px\";\n        this.getElement().style.top = y + \"px\";\n    };\n    this.setClassName = function(className) {\n        dom.addCssClass(this.getElement(), className);\n    };\n    this.show = function(text, x, y) {\n        if (text != null)\n            this.setText(text);\n        if (x != null && y != null)\n            this.setPosition(x, y);\n        if (!this.isOpen) {\n            this.getElement().style.display = \"block\";\n            this.isOpen = true;\n        }\n    };\n\n    this.hide = function() {\n        if (this.isOpen) {\n            this.getElement().style.display = \"none\";\n            this.isOpen = false;\n        }\n    };\n    this.getHeight = function() {\n        return this.getElement().offsetHeight;\n    };\n    this.getWidth = function() {\n        return this.getElement().offsetWidth;\n    };\n    \n    this.destroy = function() {\n        this.isOpen = false;\n        if (this.$element && this.$element.parentNode) {\n            this.$element.parentNode.removeChild(this.$element);\n        }\n    };\n\n}).call(Tooltip.prototype);\n\nexports.Tooltip = Tooltip;\n});\n\nace.define(\"ace/mouse/default_gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event\",\"ace/tooltip\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar event = require(\"../lib/event\");\nvar Tooltip = require(\"../tooltip\").Tooltip;\n\nfunction GutterHandler(mouseHandler) {\n    var editor = mouseHandler.editor;\n    var gutter = editor.renderer.$gutterLayer;\n    var tooltip = new GutterTooltip(editor.container);\n\n    mouseHandler.editor.setDefaultHandler(\"guttermousedown\", function(e) {\n        if (!editor.isFocused() || e.getButton() != 0)\n            return;\n        var gutterRegion = gutter.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\")\n            return;\n\n        var row = e.getDocumentPosition().row;\n        var selection = editor.session.selection;\n\n        if (e.getShiftKey())\n            selection.selectTo(row, 0);\n        else {\n            if (e.domEvent.detail == 2) {\n                editor.selectAll();\n                return e.preventDefault();\n            }\n            mouseHandler.$clickSelection = editor.selection.getLineRange(row);\n        }\n        mouseHandler.setState(\"selectByLines\");\n        mouseHandler.captureMouse(e);\n        return e.preventDefault();\n    });\n\n\n    var tooltipTimeout, mouseEvent, tooltipAnnotation;\n\n    function showTooltip() {\n        var row = mouseEvent.getDocumentPosition().row;\n        var annotation = gutter.$annotations[row];\n        if (!annotation)\n            return hideTooltip();\n\n        var maxRow = editor.session.getLength();\n        if (row == maxRow) {\n            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;\n            var pos = mouseEvent.$pos;\n            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))\n                return hideTooltip();\n        }\n\n        if (tooltipAnnotation == annotation)\n            return;\n        tooltipAnnotation = annotation.text.join(\"<br/>\");\n\n        tooltip.setHtml(tooltipAnnotation);\n        tooltip.show();\n        editor._signal(\"showGutterTooltip\", tooltip);\n        editor.on(\"mousewheel\", hideTooltip);\n\n        if (mouseHandler.$tooltipFollowsMouse) {\n            moveTooltip(mouseEvent);\n        } else {\n            var gutterElement = mouseEvent.domEvent.target;\n            var rect = gutterElement.getBoundingClientRect();\n            var style = tooltip.getElement().style;\n            style.left = rect.right + \"px\";\n            style.top = rect.bottom + \"px\";\n        }\n    }\n\n    function hideTooltip() {\n        if (tooltipTimeout)\n            tooltipTimeout = clearTimeout(tooltipTimeout);\n        if (tooltipAnnotation) {\n            tooltip.hide();\n            tooltipAnnotation = null;\n            editor._signal(\"hideGutterTooltip\", tooltip);\n            editor.removeEventListener(\"mousewheel\", hideTooltip);\n        }\n    }\n\n    function moveTooltip(e) {\n        tooltip.setPosition(e.x, e.y);\n    }\n\n    mouseHandler.editor.setDefaultHandler(\"guttermousemove\", function(e) {\n        var target = e.domEvent.target || e.domEvent.srcElement;\n        if (dom.hasCssClass(target, \"ace_fold-widget\"))\n            return hideTooltip();\n\n        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)\n            moveTooltip(e);\n\n        mouseEvent = e;\n        if (tooltipTimeout)\n            return;\n        tooltipTimeout = setTimeout(function() {\n            tooltipTimeout = null;\n            if (mouseEvent && !mouseHandler.isMousePressed)\n                showTooltip();\n            else\n                hideTooltip();\n        }, 50);\n    });\n\n    event.addListener(editor.renderer.$gutter, \"mouseout\", function(e) {\n        mouseEvent = null;\n        if (!tooltipAnnotation || tooltipTimeout)\n            return;\n\n        tooltipTimeout = setTimeout(function() {\n            tooltipTimeout = null;\n            hideTooltip();\n        }, 50);\n    });\n    \n    editor.on(\"changeSession\", hideTooltip);\n}\n\nfunction GutterTooltip(parentNode) {\n    Tooltip.call(this, parentNode);\n}\n\noop.inherits(GutterTooltip, Tooltip);\n\n(function(){\n    this.setPosition = function(x, y) {\n        var windowWidth = window.innerWidth || document.documentElement.clientWidth;\n        var windowHeight = window.innerHeight || document.documentElement.clientHeight;\n        var width = this.getWidth();\n        var height = this.getHeight();\n        x += 15;\n        y += 15;\n        if (x + width > windowWidth) {\n            x -= (x + width) - windowWidth;\n        }\n        if (y + height > windowHeight) {\n            y -= 20 + height;\n        }\n        Tooltip.prototype.setPosition.call(this, x, y);\n    };\n\n}).call(GutterTooltip.prototype);\n\n\n\nexports.GutterHandler = GutterHandler;\n\n});\n\nace.define(\"ace/mouse/mouse_event\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar MouseEvent = exports.MouseEvent = function(domEvent, editor) {\n    this.domEvent = domEvent;\n    this.editor = editor;\n    \n    this.x = this.clientX = domEvent.clientX;\n    this.y = this.clientY = domEvent.clientY;\n\n    this.$pos = null;\n    this.$inSelection = null;\n    \n    this.propagationStopped = false;\n    this.defaultPrevented = false;\n};\n\n(function() {  \n    \n    this.stopPropagation = function() {\n        event.stopPropagation(this.domEvent);\n        this.propagationStopped = true;\n    };\n    \n    this.preventDefault = function() {\n        event.preventDefault(this.domEvent);\n        this.defaultPrevented = true;\n    };\n    \n    this.stop = function() {\n        this.stopPropagation();\n        this.preventDefault();\n    };\n    this.getDocumentPosition = function() {\n        if (this.$pos)\n            return this.$pos;\n        \n        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);\n        return this.$pos;\n    };\n    this.inSelection = function() {\n        if (this.$inSelection !== null)\n            return this.$inSelection;\n            \n        var editor = this.editor;\n        \n\n        var selectionRange = editor.getSelectionRange();\n        if (selectionRange.isEmpty())\n            this.$inSelection = false;\n        else {\n            var pos = this.getDocumentPosition();\n            this.$inSelection = selectionRange.contains(pos.row, pos.column);\n        }\n\n        return this.$inSelection;\n    };\n    this.getButton = function() {\n        return event.getButton(this.domEvent);\n    };\n    this.getShiftKey = function() {\n        return this.domEvent.shiftKey;\n    };\n    \n    this.getAccelKey = useragent.isMac\n        ? function() { return this.domEvent.metaKey; }\n        : function() { return this.domEvent.ctrlKey; };\n    \n}).call(MouseEvent.prototype);\n\n});\n\nace.define(\"ace/mouse/dragdrop_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\n\nvar AUTOSCROLL_DELAY = 200;\nvar SCROLL_CURSOR_DELAY = 200;\nvar SCROLL_CURSOR_HYSTERESIS = 5;\n\nfunction DragdropHandler(mouseHandler) {\n\n    var editor = mouseHandler.editor;\n\n    var blankImage = dom.createElement(\"img\");\n    blankImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (useragent.isOpera)\n        blankImage.style.cssText = \"width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;\";\n\n    var exports = [\"dragWait\", \"dragWaitEnd\", \"startDrag\", \"dragReadyEnd\", \"onMouseDrag\"];\n\n     exports.forEach(function(x) {\n         mouseHandler[x] = this[x];\n    }, this);\n    editor.addEventListener(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n\n\n    var mouseTarget = editor.container;\n    var dragSelectionMarker, x, y;\n    var timerId, range;\n    var dragCursor, counter = 0;\n    var dragOperation;\n    var isInternal;\n    var autoScrollStartTime;\n    var cursorMovedTime;\n    var cursorPointOnCaretMoved;\n\n    this.onDragStart = function(e) {\n        if (this.cancelDrag || !mouseTarget.draggable) {\n            var self = this;\n            setTimeout(function(){\n                self.startSelect();\n                self.captureMouse(e);\n            }, 0);\n            return e.preventDefault();\n        }\n        range = editor.getSelectionRange();\n\n        var dataTransfer = e.dataTransfer;\n        dataTransfer.effectAllowed = editor.getReadOnly() ? \"copy\" : \"copyMove\";\n        if (useragent.isOpera) {\n            editor.container.appendChild(blankImage);\n            blankImage.scrollTop = 0;\n        }\n        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);\n        if (useragent.isOpera) {\n            editor.container.removeChild(blankImage);\n        }\n        dataTransfer.clearData();\n        dataTransfer.setData(\"Text\", editor.session.getTextRange());\n\n        isInternal = true;\n        this.setState(\"drag\");\n    };\n\n    this.onDragEnd = function(e) {\n        mouseTarget.draggable = false;\n        isInternal = false;\n        this.setState(null);\n        if (!editor.getReadOnly()) {\n            var dropEffect = e.dataTransfer.dropEffect;\n            if (!dragOperation && dropEffect == \"move\")\n                editor.session.remove(editor.getSelectionRange());\n            editor.$resetCursorStyle();\n        }\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n    };\n\n    this.onDragEnter = function(e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker)\n            addDragMarker();\n        counter++;\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n\n    this.onDragOver = function(e) {\n        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n            return;\n        x = e.clientX;\n        y = e.clientY;\n        if (!dragSelectionMarker) {\n            addDragMarker();\n            counter++;\n        }\n        if (onMouseMoveTimer !== null)\n            onMouseMoveTimer = null;\n\n        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n        return event.preventDefault(e);\n    };\n\n    this.onDragLeave = function(e) {\n        counter--;\n        if (counter <= 0 && dragSelectionMarker) {\n            clearDragMarker();\n            dragOperation = null;\n            return event.preventDefault(e);\n        }\n    };\n\n    this.onDrop = function(e) {\n        if (!dragCursor)\n            return;\n        var dataTransfer = e.dataTransfer;\n        if (isInternal) {\n            switch (dragOperation) {\n                case \"move\":\n                    if (range.contains(dragCursor.row, dragCursor.column)) {\n                        range = {\n                            start: dragCursor,\n                            end: dragCursor\n                        };\n                    } else {\n                        range = editor.moveText(range, dragCursor);\n                    }\n                    break;\n                case \"copy\":\n                    range = editor.moveText(range, dragCursor, true);\n                    break;\n            }\n        } else {\n            var dropData = dataTransfer.getData('Text');\n            range = {\n                start: dragCursor,\n                end: editor.session.insert(dragCursor, dropData)\n            };\n            editor.focus();\n            dragOperation = null;\n        }\n        clearDragMarker();\n        return event.preventDefault(e);\n    };\n\n    event.addListener(mouseTarget, \"dragstart\", this.onDragStart.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragend\", this.onDragEnd.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragenter\", this.onDragEnter.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragover\", this.onDragOver.bind(mouseHandler));\n    event.addListener(mouseTarget, \"dragleave\", this.onDragLeave.bind(mouseHandler));\n    event.addListener(mouseTarget, \"drop\", this.onDrop.bind(mouseHandler));\n\n    function scrollCursorIntoView(cursor, prevCursor) {\n        var now = Date.now();\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        var hMovement = !prevCursor || cursor.column != prevCursor.column;\n        if (!cursorMovedTime || vMovement || hMovement) {\n            editor.moveCursorToPosition(cursor);\n            cursorMovedTime = now;\n            cursorPointOnCaretMoved = {x: x, y: y};\n        } else {\n            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);\n            if (distance > SCROLL_CURSOR_HYSTERESIS) {\n                cursorMovedTime = null;\n            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {\n                editor.renderer.scrollCursorIntoView();\n                cursorMovedTime = null;\n            }\n        }\n    }\n\n    function autoScroll(cursor, prevCursor) {\n        var now = Date.now();\n        var lineHeight = editor.renderer.layerConfig.lineHeight;\n        var characterWidth = editor.renderer.layerConfig.characterWidth;\n        var editorRect = editor.renderer.scroller.getBoundingClientRect();\n        var offsets = {\n           x: {\n               left: x - editorRect.left,\n               right: editorRect.right - x\n           },\n           y: {\n               top: y - editorRect.top,\n               bottom: editorRect.bottom - y\n           }\n        };\n        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);\n        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);\n        var scrollCursor = {row: cursor.row, column: cursor.column};\n        if (nearestXOffset / characterWidth <= 2) {\n            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);\n        }\n        if (nearestYOffset / lineHeight <= 1) {\n            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);\n        }\n        var vScroll = cursor.row != scrollCursor.row;\n        var hScroll = cursor.column != scrollCursor.column;\n        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n        if (vScroll || (hScroll && !vMovement)) {\n            if (!autoScrollStartTime)\n                autoScrollStartTime = now;\n            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)\n                editor.renderer.scrollCursorIntoView(scrollCursor);\n        } else {\n            autoScrollStartTime = null;\n        }\n    }\n\n    function onDragInterval() {\n        var prevCursor = dragCursor;\n        dragCursor = editor.renderer.screenToTextCoordinates(x, y);\n        scrollCursorIntoView(dragCursor, prevCursor);\n        autoScroll(dragCursor, prevCursor);\n    }\n\n    function addDragMarker() {\n        range = editor.selection.toOrientedRange();\n        dragSelectionMarker = editor.session.addMarker(range, \"ace_selection\", editor.getSelectionStyle());\n        editor.clearSelection();\n        if (editor.isFocused())\n            editor.renderer.$cursorLayer.setBlinking(false);\n        clearInterval(timerId);\n        onDragInterval();\n        timerId = setInterval(onDragInterval, 20);\n        counter = 0;\n        event.addListener(document, \"mousemove\", onMouseMove);\n    }\n\n    function clearDragMarker() {\n        clearInterval(timerId);\n        editor.session.removeMarker(dragSelectionMarker);\n        dragSelectionMarker = null;\n        editor.selection.fromOrientedRange(range);\n        if (editor.isFocused() && !isInternal)\n            editor.$resetCursorStyle();\n        range = null;\n        dragCursor = null;\n        counter = 0;\n        autoScrollStartTime = null;\n        cursorMovedTime = null;\n        event.removeListener(document, \"mousemove\", onMouseMove);\n    }\n    var onMouseMoveTimer = null;\n    function onMouseMove() {\n        if (onMouseMoveTimer == null) {\n            onMouseMoveTimer = setTimeout(function() {\n                if (onMouseMoveTimer != null && dragSelectionMarker)\n                    clearDragMarker();\n            }, 20);\n        }\n    }\n\n    function canAccept(dataTransfer) {\n        var types = dataTransfer.types;\n        return !types || Array.prototype.some.call(types, function(type) {\n            return type == 'text/plain' || type == 'Text';\n        });\n    }\n\n    function getDropEffect(e) {\n        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];\n        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];\n\n        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;\n        var effectAllowed = \"uninitialized\";\n        try {\n            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();\n        } catch (e) {}\n        var dropEffect = \"none\";\n\n        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n        else if (moveAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"move\";\n        else if (copyAllowed.indexOf(effectAllowed) >= 0)\n            dropEffect = \"copy\";\n\n        return dropEffect;\n    }\n}\n\n(function() {\n\n    this.dragWait = function() {\n        var interval = Date.now() - this.mousedownEvent.time;\n        if (interval > this.editor.getDragDelay())\n            this.startDrag();\n    };\n\n    this.dragWaitEnd = function() {\n        var target = this.editor.container;\n        target.draggable = false;\n        this.startSelect(this.mousedownEvent.getDocumentPosition());\n        this.selectEnd();\n    };\n\n    this.dragReadyEnd = function(e) {\n        this.editor.$resetCursorStyle();\n        this.editor.unsetStyle(\"ace_dragging\");\n        this.editor.renderer.setCursorStyle(\"\");\n        this.dragWaitEnd();\n    };\n\n    this.startDrag = function(){\n        this.cancelDrag = false;\n        var editor = this.editor;\n        var target = editor.container;\n        target.draggable = true;\n        editor.renderer.$cursorLayer.setBlinking(false);\n        editor.setStyle(\"ace_dragging\");\n        var cursorStyle = useragent.isWin ? \"default\" : \"move\";\n        editor.renderer.setCursorStyle(cursorStyle);\n        this.setState(\"dragReady\");\n    };\n\n    this.onMouseDrag = function(e) {\n        var target = this.editor.container;\n        if (useragent.isIE && this.state == \"dragReady\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 3)\n                target.dragDrop();\n        }\n        if (this.state === \"dragWait\") {\n            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n            if (distance > 0) {\n                target.draggable = false;\n                this.startSelect(this.mousedownEvent.getDocumentPosition());\n            }\n        }\n    };\n\n    this.onMouseDown = function(e) {\n        if (!this.$dragEnabled)\n            return;\n        this.mousedownEvent = e;\n        var editor = this.editor;\n\n        var inSelection = e.inSelection();\n        var button = e.getButton();\n        var clickCount = e.domEvent.detail || 1;\n        if (clickCount === 1 && button === 0 && inSelection) {\n            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))\n                return;\n            this.mousedownEvent.time = Date.now();\n            var eventTarget = e.domEvent.target || e.domEvent.srcElement;\n            if (\"unselectable\" in eventTarget)\n                eventTarget.unselectable = \"on\";\n            if (editor.getDragDelay()) {\n                if (useragent.isWebKit) {\n                    this.cancelDrag = true;\n                    var mouseTarget = editor.container;\n                    mouseTarget.draggable = true;\n                }\n                this.setState(\"dragWait\");\n            } else {\n                this.startDrag();\n            }\n            this.captureMouse(e, this.onMouseDrag.bind(this));\n            e.defaultPrevented = true;\n        }\n    };\n\n}).call(DragdropHandler.prototype);\n\n\nfunction calcDistance(ax, ay, bx, by) {\n    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n}\n\nexports.DragdropHandler = DragdropHandler;\n\n});\n\nace.define(\"ace/mouse/touch_handler\",[\"require\",\"exports\",\"module\",\"ace/mouse/mouse_event\",\"ace/lib/event\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar event = require(\"../lib/event\");\nvar dom = require(\"../lib/dom\");\n\nexports.addTouchListeners = function(el, editor) {\n    var mode = \"scroll\";\n    var startX;\n    var startY;\n    var touchStartT;\n    var lastT;\n    var longTouchTimer;\n    var animationTimer;\n    var animationSteps = 0;\n    var pos;\n    var clickCount = 0;\n    var vX = 0;\n    var vY = 0;\n    var pressed;\n    var contextMenu;\n    \n    function createContextMenu() {\n        var clipboard = window.navigator && window.navigator.clipboard;\n        var isOpen = false;\n        var updateMenu = function() {\n            var selected = editor.getCopyText();\n            var hasUndo = editor.session.getUndoManager().hasUndo();\n            contextMenu.replaceChild(\n                dom.buildDom(isOpen ? [\"span\",\n                    !selected && [\"span\", { class: \"ace_mobile-button\", action: \"selectall\" }, \"Select All\"],\n                    selected && [\"span\", { class: \"ace_mobile-button\", action: \"copy\" }, \"Copy\"],\n                    selected && [\"span\", { class: \"ace_mobile-button\", action: \"cut\" }, \"Cut\"],\n                    clipboard && [\"span\", { class: \"ace_mobile-button\", action: \"paste\" }, \"Paste\"],\n                    hasUndo && [\"span\", { class: \"ace_mobile-button\", action: \"undo\" }, \"Undo\"],\n                    [\"span\", { class: \"ace_mobile-button\", action: \"find\" }, \"Find\"],\n                    [\"span\", { class: \"ace_mobile-button\", action: \"openCommandPallete\" }, \"Pallete\"]\n                ] : [\"span\"]),\n                contextMenu.firstChild\n            );\n        };\n        var handleClick = function(e) {\n            var action = e.target.getAttribute(\"action\");\n\n            if (action == \"more\" || !isOpen) {\n                isOpen = !isOpen;\n                return updateMenu();\n            }\n            if (action == \"paste\") {\n                clipboard.readText().then(function (text) {\n                    editor.execCommand(action, text);\n                });\n            }\n            else if (action) {\n                if (action == \"cut\" || action == \"copy\") {\n                    if (clipboard)\n                        clipboard.writeText(editor.getCopyText());\n                    else\n                        document.execCommand(\"copy\");\n                }\n                editor.execCommand(action);\n            }\n            contextMenu.firstChild.style.display = \"none\";\n            isOpen = false;\n            if (action != \"openCommandPallete\")\n                editor.focus();\n        };\n        contextMenu = dom.buildDom([\"div\",\n            {\n                class: \"ace_mobile-menu\",\n                ontouchstart: function(e) {\n                    mode = \"menu\";\n                    e.stopPropagation();\n                    e.preventDefault();\n                    editor.textInput.focus();\n                },\n                ontouchend: function(e) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    handleClick(e);\n                },\n                onclick: handleClick\n            },\n            [\"span\"],\n            [\"span\", { class: \"ace_mobile-button\", action: \"more\" }, \"...\"]\n        ], editor.container);\n    }\n    function showContextMenu() {\n        if (!contextMenu) createContextMenu();\n        var cursor = editor.selection.cursor;\n        var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);\n        var rect = editor.container.getBoundingClientRect();\n        contextMenu.style.top = pagePos.pageY - rect.top - 3 + \"px\";\n        contextMenu.style.right = \"10px\";\n        contextMenu.style.display = \"\";\n        contextMenu.firstChild.style.display = \"none\";\n        editor.on(\"input\", hideContextMenu);\n    }\n    function hideContextMenu(e) {\n        if (contextMenu)\n            contextMenu.style.display = \"none\";\n        editor.off(\"input\", hideContextMenu);\n    }\n\n    function handleLongTap() {\n        longTouchTimer = null;\n        clearTimeout(longTouchTimer);\n        var range = editor.selection.getRange();\n        var inSelection = range.contains(pos.row, pos.column);\n        if (range.isEmpty() || !inSelection) {\n            editor.selection.moveToPosition(pos);\n            editor.selection.selectWord();\n        }\n        mode = \"wait\";\n        showContextMenu();\n    }\n    function switchToSelectionMode() {\n        longTouchTimer = null;\n        clearTimeout(longTouchTimer);\n        editor.selection.moveToPosition(pos);\n        var range = clickCount >= 2\n            ? editor.selection.getLineRange(pos.row)\n            : editor.session.getBracketRange(pos);\n        if (range && !range.isEmpty()) {\n            editor.selection.setRange(range);\n        } else {\n            editor.selection.selectWord();\n        }\n        mode = \"wait\";\n    }\n    event.addListener(el, \"contextmenu\", function(e) {\n        if (!pressed) return;\n        var textarea = editor.textInput.getElement();\n        textarea.focus();\n    });\n    event.addListener(el, \"touchstart\", function (e) {\n        var touches = e.touches;\n        if (longTouchTimer || touches.length > 1) {\n            clearTimeout(longTouchTimer);\n            longTouchTimer = null;\n            touchStartT = -1;\n            mode = \"zoom\";\n            return;\n        }\n        \n        pressed = editor.$mouseHandler.isMousePressed = true;\n        var h = editor.renderer.layerConfig.lineHeight;\n        var w = editor.renderer.layerConfig.lineHeight;\n        var t = e.timeStamp;\n        lastT = t;\n        var touchObj = touches[0];\n        var x = touchObj.clientX;\n        var y = touchObj.clientY;\n        if (Math.abs(startX - x) + Math.abs(startY - y) > h)\n            touchStartT = -1;\n        \n        startX = e.clientX = x;\n        startY = e.clientY = y;\n        vX = vY = 0;\n        \n        var ev = new MouseEvent(e, editor);\n        pos = ev.getDocumentPosition();\n\n        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {\n            clickCount++;\n            e.preventDefault();\n            e.button = 0;\n            switchToSelectionMode();\n        } else {\n            clickCount = 0;\n            var cursor = editor.selection.cursor;\n            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;\n            \n            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);\n            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);\n            var rect = editor.renderer.scroller.getBoundingClientRect();\n            var weightedDistance = function(x, y) {\n                x = x / w;\n                y = y / h - 0.75;\n                return x * x + y * y;\n            };\n            \n            if (e.clientX < rect.left) {\n                mode = \"zoom\";\n                return;\n            }\n            \n            var diff1 = weightedDistance(\n                e.clientX - rect.left - cursorPos.left,\n                e.clientY - rect.top - cursorPos.top\n            );\n            var diff2 = weightedDistance(\n                e.clientX - rect.left - anchorPos.left,\n                e.clientY - rect.top - anchorPos.top\n            );\n            if (diff1 < 3.5 && diff2 < 3.5)\n                mode = diff1 > diff2 ? \"cursor\" : \"anchor\";\n                \n            if (diff2 < 3.5)\n                mode = \"anchor\";\n            else if (diff1 < 3.5)\n                mode = \"cursor\";\n            else\n                mode = \"scroll\";\n            longTouchTimer = setTimeout(handleLongTap, 450);\n        }\n        touchStartT = t;\n    });\n\n    event.addListener(el, \"touchend\", function (e) {\n        pressed = editor.$mouseHandler.isMousePressed = false;\n        if (animationTimer) clearInterval(animationTimer);\n        if (mode == \"zoom\") {\n            mode = \"\";\n            animationSteps = 0;\n        } else if (longTouchTimer) {\n            editor.selection.moveToPosition(pos);\n            animationSteps = 0;\n            showContextMenu();\n        } else if (mode == \"scroll\") {\n            animate();\n            e.preventDefault();\n            hideContextMenu();\n        } else {\n            showContextMenu();\n        }\n        clearTimeout(longTouchTimer);\n        longTouchTimer = null;\n    });\n    event.addListener(el, \"touchmove\", function (e) {\n        if (longTouchTimer) {\n            clearTimeout(longTouchTimer);\n            longTouchTimer = null;\n        }\n        var touches = e.touches;\n        if (touches.length > 1 || mode == \"zoom\") return;\n\n        var touchObj = touches[0];\n\n        var wheelX = startX - touchObj.clientX;\n        var wheelY = startY - touchObj.clientY;\n\n        if (mode == \"wait\") {\n            if (wheelX * wheelX + wheelY * wheelY > 4)\n                mode = \"cursor\";\n            else\n                return e.preventDefault();\n        }\n\n        startX = touchObj.clientX;\n        startY = touchObj.clientY;\n\n        e.clientX = touchObj.clientX;\n        e.clientY = touchObj.clientY;\n\n        var t = e.timeStamp;\n        var dt = t - lastT;\n        lastT = t;\n        if (mode == \"scroll\") {\n            var mouseEvent = new MouseEvent(e, editor);\n            mouseEvent.speed = 1;\n            mouseEvent.wheelX = wheelX;\n            mouseEvent.wheelY = wheelY;\n            if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;\n            if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;\n            if (dt != 0) {\n                vX = wheelX / dt;\n                vY = wheelY / dt;\n            }\n            editor._emit(\"mousewheel\", mouseEvent);\n            if (!mouseEvent.propagationStopped) {\n                vX = vY = 0;\n            }\n        }\n        else {\n            var ev = new MouseEvent(e, editor);\n            var pos = ev.getDocumentPosition();\n            if (mode == \"cursor\")\n                editor.selection.moveCursorToPosition(pos);\n            else if (mode == \"anchor\")\n                editor.selection.setSelectionAnchor(pos.row, pos.column);\n            editor.renderer.scrollCursorIntoView(pos);\n            e.preventDefault();\n        }\n    });\n\n    function animate() {\n        animationSteps += 60;\n        animationTimer = setInterval(function() {\n            if (animationSteps-- <= 0) {\n                clearInterval(animationTimer);\n                animationTimer = null;\n            }\n            if (Math.abs(vX) < 0.01) vX = 0;\n            if (Math.abs(vY) < 0.01) vY = 0;\n            if (animationSteps < 20) vX = 0.9 * vX;\n            if (animationSteps < 20) vY = 0.9 * vY;\n            var oldScrollTop = editor.session.getScrollTop();\n            editor.renderer.scrollBy(10 * vX, 10 * vY);\n            if (oldScrollTop == editor.session.getScrollTop())\n                animationSteps = 0;\n        }, 10);\n    }\n};\n\n});\n\nace.define(\"ace/lib/net\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"./dom\");\n\nexports.get = function (url, callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            callback(xhr.responseText);\n        }\n    };\n    xhr.send(null);\n};\n\nexports.loadScript = function(path, callback) {\n    var head = dom.getDocumentHead();\n    var s = document.createElement('script');\n\n    s.src = path;\n    head.appendChild(s);\n\n    s.onload = s.onreadystatechange = function(_, isAbort) {\n        if (isAbort || !s.readyState || s.readyState == \"loaded\" || s.readyState == \"complete\") {\n            s = s.onload = s.onreadystatechange = null;\n            if (!isAbort)\n                callback();\n        }\n    };\n};\nexports.qualifyURL = function(url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.href;\n};\n\n});\n\nace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar EventEmitter = {};\nvar stopPropagation = function() { this.propagationStopped = true; };\nvar preventDefault = function() { this.defaultPrevented = true; };\n\nEventEmitter._emit =\nEventEmitter._dispatchEvent = function(eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler)\n        return;\n\n    if (typeof e != \"object\" || !e)\n        e = {};\n\n    if (!e.type)\n        e.type = eventName;\n    if (!e.stopPropagation)\n        e.stopPropagation = stopPropagation;\n    if (!e.preventDefault)\n        e.preventDefault = preventDefault;\n\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++) {\n        listeners[i](e, this);\n        if (e.propagationStopped)\n            break;\n    }\n    \n    if (defaultHandler && !e.defaultPrevented)\n        return defaultHandler(e, this);\n};\n\n\nEventEmitter._signal = function(eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++)\n        listeners[i](e, this);\n};\n\nEventEmitter.once = function(eventName, callback) {\n    var _self = this;\n    this.addEventListener(eventName, function newCallback() {\n        _self.removeEventListener(eventName, newCallback);\n        callback.apply(null, arguments);\n    });\n    if (!callback) {\n        return new Promise(function(resolve) {\n            callback = resolve;\n        });\n    }\n};\n\n\nEventEmitter.setDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        handlers = this._defaultHandlers = {_disabled_: {}};\n    \n    if (handlers[eventName]) {\n        var old = handlers[eventName];\n        var disabled = handlers._disabled_[eventName];\n        if (!disabled)\n            handlers._disabled_[eventName] = disabled = [];\n        disabled.push(old);\n        var i = disabled.indexOf(callback);\n        if (i != -1) \n            disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n};\nEventEmitter.removeDefaultHandler = function(eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers)\n        return;\n    var disabled = handlers._disabled_[eventName];\n    \n    if (handlers[eventName] == callback) {\n        if (disabled)\n            this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n        var i = disabled.indexOf(callback);\n        if (i != -1)\n            disabled.splice(i, 1);\n    }\n};\n\nEventEmitter.on =\nEventEmitter.addEventListener = function(eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        listeners = this._eventRegistry[eventName] = [];\n\n    if (listeners.indexOf(callback) == -1)\n        listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n};\n\nEventEmitter.off =\nEventEmitter.removeListener =\nEventEmitter.removeEventListener = function(eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners)\n        return;\n\n    var index = listeners.indexOf(callback);\n    if (index !== -1)\n        listeners.splice(index, 1);\n};\n\nEventEmitter.removeAllListeners = function(eventName) {\n    if (this._eventRegistry) this._eventRegistry[eventName] = [];\n};\n\nexports.EventEmitter = EventEmitter;\n\n});\n\nace.define(\"ace/lib/app_config\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"no use strict\";\n\nvar oop = require(\"./oop\");\nvar EventEmitter = require(\"./event_emitter\").EventEmitter;\n\nvar optionsProvider = {\n    setOptions: function(optList) {\n        Object.keys(optList).forEach(function(key) {\n            this.setOption(key, optList[key]);\n        }, this);\n    },\n    getOptions: function(optionNames) {\n        var result = {};\n        if (!optionNames) {\n            var options = this.$options;\n            optionNames = Object.keys(options).filter(function(key) {\n                return !options[key].hidden;\n            });\n        } else if (!Array.isArray(optionNames)) {\n            result = optionNames;\n            optionNames = Object.keys(result);\n        }\n        optionNames.forEach(function(key) {\n            result[key] = this.getOption(key);\n        }, this);\n        return result;\n    },\n    setOption: function(name, value) {\n        if (this[\"$\" + name] === value)\n            return;\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);\n\n        if (!opt.handlesSet)\n            this[\"$\" + name] = value;\n        if (opt && opt.set)\n            opt.set.call(this, value);\n    },\n    getOption: function(name) {\n        var opt = this.$options[name];\n        if (!opt) {\n            return warn('misspelled option \"' + name + '\"');\n        }\n        if (opt.forwardTo)\n            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);\n        return opt && opt.get ? opt.get.call(this) : this[\"$\" + name];\n    }\n};\n\nfunction warn(message) {\n    if (typeof console != \"undefined\" && console.warn)\n        console.warn.apply(console, arguments);\n}\n\nfunction reportError(msg, data) {\n    var e = new Error(msg);\n    e.data = data;\n    if (typeof console == \"object\" && console.error)\n        console.error(e);\n    setTimeout(function() { throw e; });\n}\n\nvar AppConfig = function() {\n    this.$defaultOptions = {};\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n    this.defineOptions = function(obj, path, options) {\n        if (!obj.$options)\n            this.$defaultOptions[path] = obj.$options = {};\n\n        Object.keys(options).forEach(function(key) {\n            var opt = options[key];\n            if (typeof opt == \"string\")\n                opt = {forwardTo: opt};\n\n            opt.name || (opt.name = key);\n            obj.$options[opt.name] = opt;\n            if (\"initialValue\" in opt)\n                obj[\"$\" + opt.name] = opt.initialValue;\n        });\n        oop.implement(obj, optionsProvider);\n\n        return this;\n    };\n\n    this.resetOptions = function(obj) {\n        Object.keys(obj.$options).forEach(function(key) {\n            var opt = obj.$options[key];\n            if (\"value\" in opt)\n                obj.setOption(key, opt.value);\n        });\n    };\n\n    this.setDefaultValue = function(path, name, value) {\n        if (!path) {\n            for (path in this.$defaultOptions)\n                if (this.$defaultOptions[path][name])\n                    break;\n            if (!this.$defaultOptions[path][name])\n                return false;\n        }\n        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});\n        if (opts[name]) {\n            if (opts.forwardTo)\n                this.setDefaultValue(opts.forwardTo, name, value);\n            else\n                opts[name].value = value;\n        }\n    };\n\n    this.setDefaultValues = function(path, optionHash) {\n        Object.keys(optionHash).forEach(function(key) {\n            this.setDefaultValue(path, key, optionHash[key]);\n        }, this);\n    };\n    \n    this.warn = warn;\n    this.reportError = reportError;\n    \n}).call(AppConfig.prototype);\n\nexports.AppConfig = AppConfig;\n\n});\n\nace.define(\"ace/config\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/app_config\"], function(require, exports, module) {\n\"no use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar net = require(\"./lib/net\");\nvar AppConfig = require(\"./lib/app_config\").AppConfig;\n\nmodule.exports = exports = new AppConfig();\n\nvar global = (function() {\n    return this || typeof window != \"undefined\" && window;\n})();\n\nvar options = {\n    packaged: false,\n    workerPath: null,\n    modePath: null,\n    themePath: null,\n    basePath: \"\",\n    suffix: \".js\",\n    $moduleUrls: {},\n    loadWorkerFromBlob: true,\n    sharedPopups: false\n};\n\nexports.get = function(key) {\n    if (!options.hasOwnProperty(key))\n        throw new Error(\"Unknown config key: \" + key);\n\n    return options[key];\n};\n\nexports.set = function(key, value) {\n    if (options.hasOwnProperty(key))\n        options[key] = value;\n    else if (this.setDefaultValue(\"\", key, value) == false)\n        throw new Error(\"Unknown config key: \" + key);\n};\n\nexports.all = function() {\n    return lang.copyObject(options);\n};\n\nexports.$modes = {};\nexports.moduleUrl = function(name, component) {\n    if (options.$moduleUrls[name])\n        return options.$moduleUrls[name];\n\n    var parts = name.split(\"/\");\n    component = component || parts[parts.length - 2] || \"\";\n    var sep = component == \"snippets\" ? \"/\" : \"-\";\n    var base = parts[parts.length - 1];\n    if (component == \"worker\" && sep == \"-\") {\n        var re = new RegExp(\"^\" + component + \"[\\\\-_]|[\\\\-_]\" + component + \"$\", \"g\");\n        base = base.replace(re, \"\");\n    }\n\n    if ((!base || base == component) && parts.length > 1)\n        base = parts[parts.length - 2];\n    var path = options[component + \"Path\"];\n    if (path == null) {\n        path = options.basePath;\n    } else if (sep == \"/\") {\n        component = sep = \"\";\n    }\n    if (path && path.slice(-1) != \"/\")\n        path += \"/\";\n    return path + component + sep + base + this.get(\"suffix\");\n};\n\nexports.setModuleUrl = function(name, subst) {\n    return options.$moduleUrls[name] = subst;\n};\n\nexports.$loading = {};\nexports.loadModule = function(moduleName, onLoad) {\n    var module, moduleType;\n    if (Array.isArray(moduleName)) {\n        moduleType = moduleName[0];\n        moduleName = moduleName[1];\n    }\n\n    try {\n        module = require(moduleName);\n    } catch (e) {}\n    if (module && !exports.$loading[moduleName])\n        return onLoad && onLoad(module);\n\n    if (!exports.$loading[moduleName])\n        exports.$loading[moduleName] = [];\n\n    exports.$loading[moduleName].push(onLoad);\n\n    if (exports.$loading[moduleName].length > 1)\n        return;\n\n    var afterLoad = function() {\n        require([moduleName], function(module) {\n            exports._emit(\"load.module\", {name: moduleName, module: module});\n            var listeners = exports.$loading[moduleName];\n            exports.$loading[moduleName] = null;\n            listeners.forEach(function(onLoad) {\n                onLoad && onLoad(module);\n            });\n        });\n    };\n\n    if (!exports.get(\"packaged\"))\n        return afterLoad();\n    \n    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);\n    reportErrorIfPathIsNotConfigured();\n};\n\nvar reportErrorIfPathIsNotConfigured = function() {\n    if (\n        !options.basePath && !options.workerPath \n        && !options.modePath && !options.themePath\n        && !Object.keys(options.$moduleUrls).length\n    ) {\n        console.error(\n            \"Unable to infer path to ace from script src,\",\n            \"use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes\",\n            \"or with webpack use ace/webpack-resolver\"\n        );\n        reportErrorIfPathIsNotConfigured = function() {};\n    }\n};\ninit(true);function init(packaged) {\n\n    if (!global || !global.document)\n        return;\n    \n    options.packaged = packaged || require.packaged || module.packaged || (global.define && __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\").packaged);\n\n    var scriptOptions = {};\n    var scriptUrl = \"\";\n    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill\n    var currentDocument = currentScript && currentScript.ownerDocument || document;\n    \n    var scripts = currentDocument.getElementsByTagName(\"script\");\n    for (var i=0; i<scripts.length; i++) {\n        var script = scripts[i];\n\n        var src = script.src || script.getAttribute(\"src\");\n        if (!src)\n            continue;\n\n        var attributes = script.attributes;\n        for (var j=0, l=attributes.length; j < l; j++) {\n            var attr = attributes[j];\n            if (attr.name.indexOf(\"data-ace-\") === 0) {\n                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, \"\"))] = attr.value;\n            }\n        }\n\n        var m = src.match(/^(.*)\\/ace(\\-\\w+)?\\.js(\\?|$)/);\n        if (m)\n            scriptUrl = m[1];\n    }\n\n    if (scriptUrl) {\n        scriptOptions.base = scriptOptions.base || scriptUrl;\n        scriptOptions.packaged = true;\n    }\n\n    scriptOptions.basePath = scriptOptions.base;\n    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;\n    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;\n    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;\n    delete scriptOptions.base;\n\n    for (var key in scriptOptions)\n        if (typeof scriptOptions[key] !== \"undefined\")\n            exports.set(key, scriptOptions[key]);\n}\n\nexports.init = init;\n\nfunction deHyphenate(str) {\n    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });\n}\n\nexports.version = \"1.4.8\";\n\n});\n\nace.define(\"ace/mouse/mouse_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/mouse/default_handlers\",\"ace/mouse/default_gutter_handler\",\"ace/mouse/mouse_event\",\"ace/mouse/dragdrop_handler\",\"ace/mouse/touch_handler\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar DefaultHandlers = require(\"./default_handlers\").DefaultHandlers;\nvar DefaultGutterHandler = require(\"./default_gutter_handler\").GutterHandler;\nvar MouseEvent = require(\"./mouse_event\").MouseEvent;\nvar DragdropHandler = require(\"./dragdrop_handler\").DragdropHandler;\nvar addTouchListeners = require(\"./touch_handler\").addTouchListeners;\nvar config = require(\"../config\");\n\nvar MouseHandler = function(editor) {\n    var _self = this;\n    this.editor = editor;\n\n    new DefaultHandlers(this);\n    new DefaultGutterHandler(this);\n    new DragdropHandler(this);\n\n    var focusEditor = function(e) {\n        var windowBlurred = !document.hasFocus || !document.hasFocus()\n            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());\n        if (windowBlurred)\n            window.focus();\n        editor.focus();\n    };\n\n    var mouseTarget = editor.renderer.getMouseEventTarget();\n    event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"));\n    event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"));\n    event.addMultiMouseDownListener([\n        mouseTarget,\n        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,\n        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,\n        editor.textInput && editor.textInput.getElement()\n    ].filter(Boolean), [400, 300, 250], this, \"onMouseEvent\");\n    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, \"mousewheel\"));\n    addTouchListeners(editor.container, editor);\n\n    var gutterEl = editor.renderer.$gutter;\n    event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"));\n    event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"));\n    event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"));\n    event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"));\n\n    event.addListener(mouseTarget, \"mousedown\", focusEditor);\n    event.addListener(gutterEl, \"mousedown\", focusEditor);\n    if (useragent.isIE && editor.renderer.scrollBarV) {\n        event.addListener(editor.renderer.scrollBarV.element, \"mousedown\", focusEditor);\n        event.addListener(editor.renderer.scrollBarH.element, \"mousedown\", focusEditor);\n    }\n\n    editor.on(\"mousemove\", function(e){\n        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)\n            return;\n\n        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);\n        var range = editor.session.selection.getRange();\n        var renderer = editor.renderer;\n\n        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {\n            renderer.setCursorStyle(\"default\");\n        } else {\n            renderer.setCursorStyle(\"\");\n        }\n    });\n};\n\n(function() {\n    this.onMouseEvent = function(name, e) {\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n\n    this.onMouseMove = function(name, e) {\n        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;\n        if (!listeners || !listeners.length)\n            return;\n\n        this.editor._emit(name, new MouseEvent(e, this.editor));\n    };\n\n    this.onMouseWheel = function(name, e) {\n        var mouseEvent = new MouseEvent(e, this.editor);\n        mouseEvent.speed = this.$scrollSpeed * 2;\n        mouseEvent.wheelX = e.wheelX;\n        mouseEvent.wheelY = e.wheelY;\n\n        this.editor._emit(name, mouseEvent);\n    };\n    \n    this.setState = function(state) {\n        this.state = state;\n    };\n\n    this.captureMouse = function(ev, mouseMoveHandler) {\n        this.x = ev.x;\n        this.y = ev.y;\n\n        this.isMousePressed = true;\n        var editor = this.editor;\n        var renderer = this.editor.renderer;\n        renderer.$isMousePressed = true;\n\n        var self = this;\n        var onMouseMove = function(e) {\n            if (!e) return;\n            if (useragent.isWebKit && !e.which && self.releaseMouse)\n                return self.releaseMouse();\n\n            self.x = e.clientX;\n            self.y = e.clientY;\n            mouseMoveHandler && mouseMoveHandler(e);\n            self.mouseEvent = new MouseEvent(e, self.editor);\n            self.$mouseMoved = true;\n        };\n\n        var onCaptureEnd = function(e) {\n            editor.off(\"beforeEndOperation\", onOperationEnd);\n            clearInterval(timerId);\n            onCaptureInterval();\n            self[self.state + \"End\"] && self[self.state + \"End\"](e);\n            self.state = \"\";\n            self.isMousePressed = renderer.$isMousePressed = false;\n            if (renderer.$keepTextAreaAtCursor)\n                renderer.$moveTextAreaToCursor();\n            self.$onCaptureMouseMove = self.releaseMouse = null;\n            e && self.onMouseEvent(\"mouseup\", e);\n            editor.endOperation();\n        };\n\n        var onCaptureInterval = function() {\n            self[self.state] && self[self.state]();\n            self.$mouseMoved = false;\n        };\n\n        if (useragent.isOldIE && ev.domEvent.type == \"dblclick\") {\n            return setTimeout(function() {onCaptureEnd(ev);});\n        }\n\n        var onOperationEnd = function(e) {\n            if (!self.releaseMouse) return;\n            if (editor.curOp.command.name && editor.curOp.selectionChanged) {\n                self[self.state + \"End\"] && self[self.state + \"End\"]();\n                self.state = \"\";\n                self.releaseMouse();\n            }\n        };\n\n        editor.on(\"beforeEndOperation\", onOperationEnd);\n        editor.startOperation({command: {name: \"mouse\"}});\n\n        self.$onCaptureMouseMove = onMouseMove;\n        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);\n        var timerId = setInterval(onCaptureInterval, 20);\n    };\n    this.releaseMouse = null;\n    this.cancelContextMenu = function() {\n        var stop = function(e) {\n            if (e && e.domEvent && e.domEvent.type != \"contextmenu\")\n                return;\n            this.editor.off(\"nativecontextmenu\", stop);\n            if (e && e.domEvent)\n                event.stopEvent(e.domEvent);\n        }.bind(this);\n        setTimeout(stop, 10);\n        this.editor.on(\"nativecontextmenu\", stop);\n    };\n}).call(MouseHandler.prototype);\n\nconfig.defineOptions(MouseHandler.prototype, \"mouseHandler\", {\n    scrollSpeed: {initialValue: 2},\n    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},\n    dragEnabled: {initialValue: true},\n    focusTimeout: {initialValue: 0},\n    tooltipFollowsMouse: {initialValue: true}\n});\n\n\nexports.MouseHandler = MouseHandler;\n});\n\nace.define(\"ace/mouse/fold_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\nvar dom = require(\"../lib/dom\");\n\nfunction FoldHandler(editor) {\n\n    editor.on(\"click\", function(e) {\n        var position = e.getDocumentPosition();\n        var session = editor.session;\n        var fold = session.getFoldAt(position.row, position.column, 1);\n        if (fold) {\n            if (e.getAccelKey())\n                session.removeFold(fold);\n            else\n                session.expandFold(fold);\n\n            e.stop();\n        }\n        \n        var target = e.domEvent && e.domEvent.target;\n        if (target && dom.hasCssClass(target, \"ace_inline_button\")) {\n            if (dom.hasCssClass(target, \"ace_toggle_wrap\")) {\n                session.setOption(\"wrap\", !session.getUseWrapMode());\n                editor.renderer.scrollCursorIntoView();\n            }\n        }\n    });\n\n    editor.on(\"gutterclick\", function(e) {\n        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\") {\n            var row = e.getDocumentPosition().row;\n            var session = editor.session;\n            if (session.foldWidgets && session.foldWidgets[row])\n                editor.session.onFoldWidgetClick(row, e);\n            if (!editor.isFocused())\n                editor.focus();\n            e.stop();\n        }\n    });\n\n    editor.on(\"gutterdblclick\", function(e) {\n        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n        if (gutterRegion == \"foldWidgets\") {\n            var row = e.getDocumentPosition().row;\n            var session = editor.session;\n            var data = session.getParentFoldRangeData(row, true);\n            var range = data.range || data.firstRange;\n\n            if (range) {\n                row = range.start.row;\n                var fold = session.getFoldAt(row, session.getLine(row).length, 1);\n\n                if (fold) {\n                    session.removeFold(fold);\n                } else {\n                    session.addFold(\"...\", range);\n                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});\n                }\n            }\n            e.stop();\n        }\n    });\n}\n\nexports.FoldHandler = FoldHandler;\n\n});\n\nace.define(\"ace/keyboard/keybinding\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/event\"], function(require, exports, module) {\n\"use strict\";\n\nvar keyUtil  = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\n\nvar KeyBinding = function(editor) {\n    this.$editor = editor;\n    this.$data = {editor: editor};\n    this.$handlers = [];\n    this.setDefaultHandler(editor.commands);\n};\n\n(function() {\n    this.setDefaultHandler = function(kb) {\n        this.removeKeyboardHandler(this.$defaultHandler);\n        this.$defaultHandler = kb;\n        this.addKeyboardHandler(kb, 0);\n    };\n\n    this.setKeyboardHandler = function(kb) {\n        var h = this.$handlers;\n        if (h[h.length - 1] == kb)\n            return;\n\n        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)\n            this.removeKeyboardHandler(h[h.length - 1]);\n\n        this.addKeyboardHandler(kb, 1);\n    };\n\n    this.addKeyboardHandler = function(kb, pos) {\n        if (!kb)\n            return;\n        if (typeof kb == \"function\" && !kb.handleKeyboard)\n            kb.handleKeyboard = kb;\n        var i = this.$handlers.indexOf(kb);\n        if (i != -1)\n            this.$handlers.splice(i, 1);\n\n        if (pos == undefined)\n            this.$handlers.push(kb);\n        else\n            this.$handlers.splice(pos, 0, kb);\n\n        if (i == -1 && kb.attach)\n            kb.attach(this.$editor);\n    };\n\n    this.removeKeyboardHandler = function(kb) {\n        var i = this.$handlers.indexOf(kb);\n        if (i == -1)\n            return false;\n        this.$handlers.splice(i, 1);\n        kb.detach && kb.detach(this.$editor);\n        return true;\n    };\n\n    this.getKeyboardHandler = function() {\n        return this.$handlers[this.$handlers.length - 1];\n    };\n    \n    this.getStatusText = function() {\n        var data = this.$data;\n        var editor = data.editor;\n        return this.$handlers.map(function(h) {\n            return h.getStatusText && h.getStatusText(editor, data) || \"\";\n        }).filter(Boolean).join(\" \");\n    };\n\n    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {\n        var toExecute;\n        var success = false;\n        var commands = this.$editor.commands;\n\n        for (var i = this.$handlers.length; i--;) {\n            toExecute = this.$handlers[i].handleKeyboard(\n                this.$data, hashId, keyString, keyCode, e\n            );\n            if (!toExecute || !toExecute.command)\n                continue;\n            if (toExecute.command == \"null\") {\n                success = true;\n            } else {\n                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);\n            }\n            if (success && e && hashId != -1 && \n                toExecute.passEvent != true && toExecute.command.passEvent != true\n            ) {\n                event.stopEvent(e);\n            }\n            if (success)\n                break;\n        }\n        \n        if (!success && hashId == -1) {\n            toExecute = {command: \"insertstring\"};\n            success = commands.exec(\"insertstring\", this.$editor, keyString);\n        }\n        \n        if (success && this.$editor._signal)\n            this.$editor._signal(\"keyboardActivity\", toExecute);\n        \n        return success;\n    };\n\n    this.onCommandKey = function(e, hashId, keyCode) {\n        var keyString = keyUtil.keyCodeToString(keyCode);\n        return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);\n    };\n\n    this.onTextInput = function(text) {\n        return this.$callKeyboardHandlers(-1, text);\n    };\n\n}).call(KeyBinding.prototype);\n\nexports.KeyBinding = KeyBinding;\n});\n\nace.define(\"ace/lib/bidiutil\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar ArabicAlefBetIntervalsBegine = ['\\u0621', '\\u0641'];\nvar ArabicAlefBetIntervalsEnd = ['\\u063A', '\\u064a'];\nvar dir = 0, hiLevel = 0;\nvar lastArabic = false, hasUBAT_AL = false,  hasUBAT_B = false,  hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;\n\nvar impTab_LTR = [\t[\t0,\t\t3,\t\t0,\t\t1,\t\t0,\t\t0,\t\t0\t],\t[\t0,\t\t3,\t\t0,\t\t1,\t\t2,\t\t2,\t\t0\t],\t[\t0,\t\t3,\t\t0,\t\t0x11,\t\t2,\t\t0,\t\t1\t],\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t1,\t\t0\t],\t[\t0,\t\t3,\t\t0x15,\t\t0x15,\t\t4,\t\t0,\t\t1\t],\t[\t0,\t\t3,\t\t5,\t\t5,\t\t4,\t\t2,\t\t0\t]\n];\n\nvar impTab_RTL = [\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t1,\t\t0\t],\t[\t2,\t\t0,\t\t1,\t\t1,\t\t0,\t\t2,\t\t0\t],\t[\t2,\t\t0,\t\t2,\t\t1,\t\t3,\t\t2,\t\t0\t],\t[\t2,\t\t0,\t\t2,\t\t0x21,\t\t3,\t\t1,\t\t1\t]\n];\n\nvar LTR = 0, RTL = 1;\n\nvar L = 0;\nvar R = 1;\nvar EN = 2;\nvar AN = 3;\nvar ON = 4;\nvar B = 5;\nvar S = 6;\nvar AL = 7;\nvar WS = 8;\nvar CS = 9;\nvar ES = 10;\nvar ET = 11;\nvar NSM = 12;\nvar LRE = 13;\nvar RLE = 14;\nvar PDF = 15;\nvar LRO = 16;\nvar RLO = 17;\nvar BN = 18;\n\nvar UnicodeTBL00 = [\nBN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,\nBN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,\nWS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,\nEN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,\nON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,\nL,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,\nON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,\nL,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,\nBN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,\nBN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,\nCS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,\nET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON\n];\n\nvar UnicodeTBL20 = [\nWS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R\t,\nON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,\nET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,\nON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS\n];\n\nfunction _computeLevels(chars, levels, len, charTypes) {\n\tvar impTab = dir ? impTab_RTL : impTab_LTR\n\t\t, prevState = null, newClass = null, newLevel = null, newState = 0\n\t\t, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];\n\n\tif (!charTypes) {\n\t\tfor (i = 0, charTypes = []; i < len; i++) {\n\t\t\tcharTypes[i] = _getCharacterType(chars[i]);\n\t\t}\n\t}\n\thiLevel = dir;\n\tlastArabic = false;\n\thasUBAT_AL = false;\n\thasUBAT_B = false;\n\thasUBAT_S = false;\n\tfor (ix = 0; ix < len; ix++){\n\t\tprevState = newState;\n\t\tclasses[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);\n\t\tnewState = impTab[prevState][newClass];\n\t\taction = newState & 0xF0;\n\t\tnewState &= 0x0F;\n\t\tlevels[ix] = newLevel = impTab[newState][5];\n\t\tif (action > 0){\n\t\t\tif (action == 0x10){\n\t\t\t\tfor(i = condPos; i < ix; i++){\n\t\t\t\t\tlevels[i] = 1;\n\t\t\t\t}\n\t\t\t\tcondPos = -1;\n\t\t\t} else {\n\t\t\t\tcondPos = -1;\n\t\t\t}\n\t\t}\n\t\tcond = impTab[newState][6];\n\t\tif (cond){\n\t\t\tif(condPos == -1){\n\t\t\t\tcondPos = ix;\n\t\t\t}\n\t\t}else{\n\t\t\tif (condPos > -1){\n\t\t\t\tfor(i = condPos; i < ix; i++){\n\t\t\t\t\tlevels[i] = newLevel;\n\t\t\t\t}\n\t\t\t\tcondPos = -1;\n\t\t\t}\n\t\t}\n\t\tif (charTypes[ix] == B){\n\t\t\tlevels[ix] = 0;\n\t\t}\n\t\thiLevel |= newLevel;\n\t}\n\tif (hasUBAT_S){\n\t\tfor(i = 0; i < len; i++){\n\t\t\tif(charTypes[i] == S){\n\t\t\t\tlevels[i] = dir;\n\t\t\t\tfor(var j = i - 1; j >= 0; j--){\n\t\t\t\t\tif(charTypes[j] == WS){\n\t\t\t\t\t\tlevels[j] = dir;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction _invertLevel(lev, levels, _array) {\n\tif (hiLevel < lev){\n\t\treturn;\n\t}\n\tif (lev == 1 && dir == RTL && !hasUBAT_B){\n\t\t_array.reverse();\n\t\treturn;\n\t}\n\tvar len = _array.length, start = 0, end, lo, hi, tmp;\n\twhile(start < len){\n\t\tif (levels[start] >= lev){\n\t\t\tend = start + 1;\n\t\twhile(end < len && levels[end] >= lev){\n\t\t\tend++;\n\t\t}\n\t\tfor(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){\n\t\t\ttmp = _array[lo];\n\t\t\t_array[lo] = _array[hi];\n\t\t\t_array[hi] = tmp;\n\t\t}\n\t\tstart = end;\n\t}\n\tstart++;\n\t}\n}\n\nfunction _getCharClass(chars, types, classes, ix) {\t\t\t\n\tvar cType = types[ix], wType, nType, len, i;\n\tswitch(cType){\n\t\tcase L:\n\t\tcase R:\n\t\t\tlastArabic = false;\n\t\tcase ON:\n\t\tcase AN:\n\t\t\treturn cType;\n\t\tcase EN:\n\t\t\treturn lastArabic ? AN : EN;\n\t\tcase AL:\n\t\t\tlastArabic = true;\n\t\t\thasUBAT_AL = true;\n\t\t\treturn R;\n\t\tcase WS:\n\t\t\treturn ON;\n\t\tcase CS:\n\t\t\tif (ix < 1 || (ix + 1) >= types.length ||\n\t\t\t\t((wType = classes[ix - 1]) != EN && wType != AN) ||\n\t\t\t\t((nType = types[ix + 1]) != EN && nType != AN)){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\tif (lastArabic){nType = AN;}\n\t\t\treturn nType == wType ? nType : ON;\n\t\tcase ES:\n\t\t\twType = ix > 0 ? classes[ix - 1] : B;\n\t\t\tif (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\treturn ON;\n\t\tcase ET:\n\t\t\tif (ix > 0 && classes[ix - 1] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\tif (lastArabic){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\ti = ix + 1;\n\t\t\tlen = types.length;\n\t\t\twhile (i < len && types[i] == ET){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < len && types[i] == EN){\n\t\t\t\treturn EN;\n\t\t\t}\n\t\t\treturn ON;\n\t\tcase NSM:\n\t\t\tlen = types.length;\n\t\t\ti = ix + 1;\n\t\t\twhile (i < len && types[i] == NSM){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < len){\n\t\t\t\tvar c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;\n\t\t\t\t\n\t\t\t\twType = types[i];\n\t\t\t\tif (rtlCandidate && (wType == R || wType == AL)){\n\t\t\t\t\treturn R;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ix < 1 || (wType = types[ix - 1]) == B){\n\t\t\t\treturn ON;\n\t\t\t}\n\t\t\treturn classes[ix - 1];\n\t\tcase B:\n\t\t\tlastArabic = false;\n\t\t\thasUBAT_B = true;\n\t\t\treturn dir;\n\t\tcase S:\n\t\t\thasUBAT_S = true;\n\t\t\treturn ON;\n\t\tcase LRE:\n\t\tcase RLE:\n\t\tcase LRO:\n\t\tcase RLO:\n\t\tcase PDF:\n\t\t\tlastArabic = false;\n\t\tcase BN:\n\t\t\treturn ON;\n\t}\n}\n\nfunction _getCharacterType( ch ) {\t\t\n\tvar uc = ch.charCodeAt(0), hi = uc >> 8;\n\t\n\tif (hi == 0) {\t\t\n\t\treturn ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);\n\t} else if (hi == 5) {\n\t\treturn (/[\\u0591-\\u05f4]/.test(ch) ? R : L);\n\t} else if (hi == 6) {\n\t\tif (/[\\u0610-\\u061a\\u064b-\\u065f\\u06d6-\\u06e4\\u06e7-\\u06ed]/.test(ch))\n\t\t\treturn NSM;\n\t\telse if (/[\\u0660-\\u0669\\u066b-\\u066c]/.test(ch))\n\t\t\treturn AN;\n\t\telse if (uc == 0x066A)\n\t\t\treturn ET;\n\t\telse if (/[\\u06f0-\\u06f9]/.test(ch))\n\t\t\treturn EN;\t\t\t\n\t\telse\n\t\t\treturn AL;\n\t} else if (hi == 0x20 && uc <= 0x205F) {\n\t\treturn UnicodeTBL20[uc & 0xFF];\n\t} else if (hi == 0xFE) {\n\t\treturn (uc >= 0xFE70 ? AL : ON);\n\t}\t\t\n\treturn ON;\t\n}\n\nfunction _isArabicDiacritics( ch ) {\n\treturn (ch >= '\\u064b' && ch <= '\\u0655');\n}\nexports.L = L;\nexports.R = R;\nexports.EN = EN;\nexports.ON_R = 3;\nexports.AN = 4;\nexports.R_H = 5;\nexports.B = 6;\nexports.RLE = 7;\n\nexports.DOT = \"\\xB7\";\nexports.doBidiReorder = function(text, textCharTypes, isRtl) {\n\tif (text.length < 2)\n\t\treturn {};\n\t\t\n\tvar chars = text.split(\"\"), logicalFromVisual = new Array(chars.length),\n\t\tbidiLevels = new Array(chars.length), levels = []; \n\n\tdir = isRtl ? RTL : LTR;\n\n\t_computeLevels(chars, levels, chars.length, textCharTypes);\n\n\tfor (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);\n\n\t_invertLevel(2, levels, logicalFromVisual);\n\t_invertLevel(1, levels, logicalFromVisual);\n\n\tfor (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width\n\t\tif (textCharTypes[i] === AN) {\n\t\t\tlevels[i] = exports.AN;\n\t\t} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE) \n\t\t\t|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {\n\t\t\tlevels[i] = exports.ON_R;\n\t\t} else if ((i > 0 && chars[i - 1] === '\\u0644') && /\\u0622|\\u0623|\\u0625|\\u0627/.test(chars[i])) {\n\t\t\tlevels[i - 1] = levels[i] = exports.R_H;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (chars[chars.length - 1] === exports.DOT)\n\t\tlevels[chars.length - 1] = exports.B;\n\t\t\t\t\n\tif (chars[0] === '\\u202B')\n\t\tlevels[0] = exports.RLE;\n\t\t\t\t\n\tfor (var i = 0; i < logicalFromVisual.length; i++) {\n\t\tbidiLevels[i] = levels[logicalFromVisual[i]];\n\t}\n\n\treturn {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};\n};\nexports.hasBidiCharacters = function(text, textCharTypes){\n\tvar ret = false;\n\tfor (var i = 0; i < text.length; i++){\n\t\ttextCharTypes[i] = _getCharacterType(text.charAt(i));\n\t\tif (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))\n\t\t\tret = true;\n\t}\n\treturn ret;\n};\t\nexports.getVisualFromLogicalIdx = function(logIdx, rowMap) {\n\tfor (var i = 0; i < rowMap.logicalFromVisual.length; i++) {\n\t\tif (rowMap.logicalFromVisual[i] == logIdx)\n\t\t\treturn i;\n\t}\n\treturn 0;\n};\n\n});\n\nace.define(\"ace/bidihandler\",[\"require\",\"exports\",\"module\",\"ace/lib/bidiutil\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar bidiUtil = require(\"./lib/bidiutil\");\nvar lang = require(\"./lib/lang\");\nvar bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\u202B]/;\nvar BidiHandler = function(session) {\n    this.session = session;\n    this.bidiMap = {};\n    this.currentRow = null;\n    this.bidiUtil = bidiUtil;\n    this.charWidths = [];\n    this.EOL = \"\\xAC\";\n    this.showInvisibles = true;\n    this.isRtlDir = false;\n    this.$isRtl = false;\n    this.line = \"\";\n    this.wrapIndent = 0;\n    this.EOF = \"\\xB6\";\n    this.RLE = \"\\u202B\";\n    this.contentWidth = 0;\n    this.fontMetrics = null;\n    this.rtlLineOffset = 0;\n    this.wrapOffset = 0;\n    this.isMoveLeftOperation = false;\n    this.seenBidi = bidiRE.test(session.getValue());\n};\n\n(function() {\n    this.isBidiRow = function(screenRow, docRow, splitIndex) {\n        if (!this.seenBidi)\n            return false;\n        if (screenRow !== this.currentRow) {\n            this.currentRow = screenRow;\n            this.updateRowLine(docRow, splitIndex);\n            this.updateBidiMap();\n        }\n        return this.bidiMap.bidiLevels;\n    };\n\n    this.onChange = function(delta) {\n        if (!this.seenBidi) {\n            if (delta.action == \"insert\" && bidiRE.test(delta.lines.join(\"\\n\"))) {\n                this.seenBidi = true;\n                this.currentRow = null;\n            }\n        } \n        else {\n            this.currentRow = null;\n        }\n    };\n\n    this.getDocumentRow = function() {\n        var docRow = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            if (index >= 0)\n                docRow = this.session.$docRowCache[index];\n        }\n\n        return docRow;\n    };\n\n    this.getSplitIndex = function() {\n        var splitIndex = 0;\n        var rowCache = this.session.$screenRowCache;\n        if (rowCache.length) {\n            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);\n            while (this.currentRow - splitIndex > 0) {\n                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);\n                if (currentIndex !== prevIndex)\n                    break;\n\n                prevIndex = currentIndex;\n                splitIndex++;\n            }\n        } else {\n            splitIndex = this.currentRow;\n        }\n\n        return splitIndex;\n    };\n\n    this.updateRowLine = function(docRow, splitIndex) {\n        if (docRow === undefined)\n            docRow = this.getDocumentRow();\n            \n        var isLastRow = (docRow === this.session.getLength() - 1),\n            endOfLine = isLastRow ? this.EOF : this.EOL;\n\n        this.wrapIndent = 0;\n        this.line = this.session.getLine(docRow);\n        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;\n        if (this.session.$useWrapMode) {\n            var splits = this.session.$wrapData[docRow];\n            if (splits) {\n                if (splitIndex === undefined)\n                    splitIndex = this.getSplitIndex();\n\n                if(splitIndex > 0 && splits.length) {\n                    this.wrapIndent = splits.indent;\n                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];\n                    this.line = (splitIndex < splits.length) ?\n                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :\n                            this.line.substring(splits[splits.length - 1]);\n                } else {\n                    this.line = this.line.substring(0, splits[splitIndex]);\n                }\n            }\n            if (splitIndex == splits.length)\n                this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;\n        } else {\n            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;\n        }\n        var session = this.session, shift = 0, size;\n        this.line = this.line.replace(/\\t|[\\u1100-\\u2029, \\u202F-\\uFFE6]/g, function(ch, i){\n            if (ch === '\\t' || session.isFullWidth(ch.charCodeAt(0))) {\n                size = (ch === '\\t') ? session.getScreenTabSize(i + shift) : 2;\n                shift += size - 1;\n                return lang.stringRepeat(bidiUtil.DOT, size);\n            }\n            return ch;\n        });\n\n        if (this.isRtlDir) {\n            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;\n            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;\n        }\n    };\n    \n    this.updateBidiMap = function() {\n        var textCharTypes = [];\n        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {\n             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);\n        } else {\n            this.bidiMap = {};\n        }\n    };\n    this.markAsDirty = function() {\n        this.currentRow = null;\n    };\n    this.updateCharacterWidths = function(fontMetrics) {\n        if (this.characterWidth === fontMetrics.$characterSize.width)\n            return;\n\n        this.fontMetrics = fontMetrics;\n        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;\n        var bidiCharWidth = fontMetrics.$measureCharWidth(\"\\u05d4\");\n\n        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;\n        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;\n        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;\n        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;\n\n        this.currentRow = null;\n    };\n\n    this.setShowInvisibles = function(showInvisibles) {\n        this.showInvisibles = showInvisibles;\n        this.currentRow = null;\n    };\n\n    this.setEolChar = function(eolChar) {\n        this.EOL = eolChar; \n    };\n\n    this.setContentWidth = function(width) {\n        this.contentWidth = width;\n    };\n\n    this.isRtlLine = function(row) {\n        if (this.$isRtl) return true;\n        if (row != undefined)\n            return (this.session.getLine(row).charAt(0) == this.RLE);\n        else\n            return this.isRtlDir; \n    };\n\n    this.setRtlDirection = function(editor, isRtlDir) {\n        var cursor = editor.getCursorPosition(); \n        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {\n            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)\n                editor.session.doc.removeInLine(row, 0, 1);\n            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)\n                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);\n        }\n    };\n    this.getPosLeft = function(col) {\n        col -= this.wrapIndent;\n        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;\n        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;\n        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),\n            levels = this.bidiMap.bidiLevels, left = 0;\n\n        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)\n            visualIdx++;\n            \n        for (var i = 0; i < visualIdx; i++) {\n            left += this.charWidths[levels[i]];\n        }\n\n        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))\n            left += this.charWidths[levels[visualIdx]];\n\n        if (this.wrapIndent)\n            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n\n        if (this.isRtlDir)\n            left += this.rtlLineOffset;\n\n        return left;\n    };\n    this.getSelections = function(startCol, endCol) {\n        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,\n            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,\n                isSelected = false, isSelectedPrev = false, selectionStart = 0;\n            \n        if (this.wrapIndent)\n            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n\n        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {\n            logIdx = map.logicalFromVisual[visIdx];\n            level = levels[visIdx];\n            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);\n            if (isSelected && !isSelectedPrev) {\n                selectionStart = offset;\n            } else if (!isSelected && isSelectedPrev) {\n                selections.push({left: selectionStart, width: offset - selectionStart});\n            }\n            offset += this.charWidths[level];\n            isSelectedPrev = isSelected;\n        }\n\n        if (isSelected && (visIdx === levels.length)) {\n            selections.push({left: selectionStart, width: offset - selectionStart});\n        }\n\n        if(this.isRtlDir) {\n            for (var i = 0; i < selections.length; i++) {\n                selections[i].left += this.rtlLineOffset;\n            }\n        }\n        return selections;\n    };\n    this.offsetToCol = function(posX) {\n        if(this.isRtlDir)\n            posX -= this.rtlLineOffset;\n\n        var logicalIdx = 0, posX = Math.max(posX, 0),\n            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,\n                charWidth = this.charWidths[levels[visualIdx]];\n\n        if (this.wrapIndent)\n           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\n    \n        while(posX > offset + charWidth/2) {\n            offset += charWidth;\n            if(visualIdx === levels.length - 1) {\n                charWidth = 0;\n                break;\n            }\n            charWidth = this.charWidths[levels[++visualIdx]];\n        }\n    \n        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){\n            if(posX < offset)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n\n        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){\n            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]\n                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);\n\n        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))\n                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){\n            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];\n        } else {\n            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)\n                visualIdx--;\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\n        }\n\n        if (logicalIdx === 0 && this.isRtlDir)\n            logicalIdx++;\n\n        return (logicalIdx + this.wrapIndent);\n    };\n\n}).call(BidiHandler.prototype);\n\nexports.BidiHandler = BidiHandler;\n});\n\nace.define(\"ace/selection\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Selection = function(session) {\n    this.session = session;\n    this.doc = session.getDocument();\n\n    this.clearSelection();\n    this.cursor = this.lead = this.doc.createAnchor(0, 0);\n    this.anchor = this.doc.createAnchor(0, 0);\n    this.$silent = false;\n\n    var self = this;\n    this.cursor.on(\"change\", function(e) {\n        self.$cursorChanged = true;\n        if (!self.$silent)\n            self._emit(\"changeCursor\");\n        if (!self.$isEmpty && !self.$silent)\n            self._emit(\"changeSelection\");\n        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)\n            self.$desiredColumn = null;\n    });\n\n    this.anchor.on(\"change\", function() {\n        self.$anchorChanged = true;\n        if (!self.$isEmpty && !self.$silent)\n            self._emit(\"changeSelection\");\n    });\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.isEmpty = function() {\n        return this.$isEmpty || (\n            this.anchor.row == this.lead.row &&\n            this.anchor.column == this.lead.column\n        );\n    };\n    this.isMultiLine = function() {\n        return !this.$isEmpty && this.anchor.row != this.cursor.row;\n    };\n    this.getCursor = function() {\n        return this.lead.getPosition();\n    };\n    this.setSelectionAnchor = function(row, column) {\n        this.$isEmpty = false;\n        this.anchor.setPosition(row, column);\n    };\n    this.getAnchor = \n    this.getSelectionAnchor = function() {\n        if (this.$isEmpty)\n            return this.getSelectionLead();\n        \n        return this.anchor.getPosition();\n    };\n    this.getSelectionLead = function() {\n        return this.lead.getPosition();\n    };\n    this.isBackwards = function() {\n        var anchor = this.anchor;\n        var lead = this.lead;\n        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));\n    };\n    this.getRange = function() {\n        var anchor = this.anchor;\n        var lead = this.lead;\n\n        if (this.$isEmpty)\n            return Range.fromPoints(lead, lead);\n\n        return this.isBackwards()\n            ? Range.fromPoints(lead, anchor)\n            : Range.fromPoints(anchor, lead);\n    };\n    this.clearSelection = function() {\n        if (!this.$isEmpty) {\n            this.$isEmpty = true;\n            this._emit(\"changeSelection\");\n        }\n    };\n    this.selectAll = function() {\n        this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);\n    };\n    this.setRange =\n    this.setSelectionRange = function(range, reverse) {\n        var start = reverse ? range.end : range.start;\n        var end = reverse ? range.start : range.end;\n        this.$setSelection(start.row, start.column, end.row, end.column);\n    };\n\n    this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {\n        if (this.$silent)\n            return;\n        var wasEmpty = this.$isEmpty;\n        var wasMultiselect = this.inMultiSelectMode;\n        this.$silent = true;\n        this.$cursorChanged = this.$anchorChanged = false;\n        this.anchor.setPosition(anchorRow, anchorColumn);\n        this.cursor.setPosition(cursorRow, cursorColumn);\n        this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);\n        this.$silent = false;\n        if (this.$cursorChanged)\n            this._emit(\"changeCursor\");\n        if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)\n            this._emit(\"changeSelection\");\n    };\n\n    this.$moveSelection = function(mover) {\n        var lead = this.lead;\n        if (this.$isEmpty)\n            this.setSelectionAnchor(lead.row, lead.column);\n\n        mover.call(this);\n    };\n    this.selectTo = function(row, column) {\n        this.$moveSelection(function() {\n            this.moveCursorTo(row, column);\n        });\n    };\n    this.selectToPosition = function(pos) {\n        this.$moveSelection(function() {\n            this.moveCursorToPosition(pos);\n        });\n    };\n    this.moveTo = function(row, column) {\n        this.clearSelection();\n        this.moveCursorTo(row, column);\n    };\n    this.moveToPosition = function(pos) {\n        this.clearSelection();\n        this.moveCursorToPosition(pos);\n    };\n    this.selectUp = function() {\n        this.$moveSelection(this.moveCursorUp);\n    };\n    this.selectDown = function() {\n        this.$moveSelection(this.moveCursorDown);\n    };\n    this.selectRight = function() {\n        this.$moveSelection(this.moveCursorRight);\n    };\n    this.selectLeft = function() {\n        this.$moveSelection(this.moveCursorLeft);\n    };\n    this.selectLineStart = function() {\n        this.$moveSelection(this.moveCursorLineStart);\n    };\n    this.selectLineEnd = function() {\n        this.$moveSelection(this.moveCursorLineEnd);\n    };\n    this.selectFileEnd = function() {\n        this.$moveSelection(this.moveCursorFileEnd);\n    };\n    this.selectFileStart = function() {\n        this.$moveSelection(this.moveCursorFileStart);\n    };\n    this.selectWordRight = function() {\n        this.$moveSelection(this.moveCursorWordRight);\n    };\n    this.selectWordLeft = function() {\n        this.$moveSelection(this.moveCursorWordLeft);\n    };\n    this.getWordRange = function(row, column) {\n        if (typeof column == \"undefined\") {\n            var cursor = row || this.lead;\n            row = cursor.row;\n            column = cursor.column;\n        }\n        return this.session.getWordRange(row, column);\n    };\n    this.selectWord = function() {\n        this.setSelectionRange(this.getWordRange());\n    };\n    this.selectAWord = function() {\n        var cursor = this.getCursor();\n        var range = this.session.getAWordRange(cursor.row, cursor.column);\n        this.setSelectionRange(range);\n    };\n\n    this.getLineRange = function(row, excludeLastChar) {\n        var rowStart = typeof row == \"number\" ? row : this.lead.row;\n        var rowEnd;\n\n        var foldLine = this.session.getFoldLine(rowStart);\n        if (foldLine) {\n            rowStart = foldLine.start.row;\n            rowEnd = foldLine.end.row;\n        } else {\n            rowEnd = rowStart;\n        }\n        if (excludeLastChar === true)\n            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);\n        else\n            return new Range(rowStart, 0, rowEnd + 1, 0);\n    };\n    this.selectLine = function() {\n        this.setSelectionRange(this.getLineRange());\n    };\n    this.moveCursorUp = function() {\n        this.moveCursorBy(-1, 0);\n    };\n    this.moveCursorDown = function() {\n        this.moveCursorBy(1, 0);\n    };\n    this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {\n        var start = cursor.column;\n        var end = cursor.column + tabSize;\n\n        if (direction < 0) {\n            start = cursor.column - tabSize;\n            end = cursor.column;\n        }\n        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(\" \").length-1 == tabSize;\n    };\n    this.moveCursorLeft = function() {\n        var cursor = this.lead.getPosition(),\n            fold;\n\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n        } else if (cursor.column === 0) {\n            if (cursor.row > 0) {\n                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, -tabSize);\n            } else {\n                this.moveCursorBy(0, -1);\n            }\n        }\n    };\n    this.moveCursorRight = function() {\n        var cursor = this.lead.getPosition(),\n            fold;\n        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n        }\n        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {\n            if (this.lead.row < this.doc.getLength() - 1) {\n                this.moveCursorTo(this.lead.row + 1, 0);\n            }\n        }\n        else {\n            var tabSize = this.session.getTabSize();\n            var cursor = this.lead;\n            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {\n                this.moveCursorBy(0, tabSize);\n            } else {\n                this.moveCursorBy(0, 1);\n            }\n        }\n    };\n    this.moveCursorLineStart = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var screenRow = this.session.documentToScreenRow(row, column);\n        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);\n        var beforeCursor = this.session.getDisplayLine(\n            row, null, firstColumnPosition.row,\n            firstColumnPosition.column\n        );\n\n        var leadingSpace = beforeCursor.match(/^\\s*/);\n        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)\n            firstColumnPosition.column += leadingSpace[0].length;\n        this.moveCursorToPosition(firstColumnPosition);\n    };\n    this.moveCursorLineEnd = function() {\n        var lead = this.lead;\n        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);\n        if (this.lead.column == lineEnd.column) {\n            var line = this.session.getLine(lineEnd.row);\n            if (lineEnd.column == line.length) {\n                var textEnd = line.search(/\\s+$/);\n                if (textEnd > 0)\n                    lineEnd.column = textEnd;\n            }\n        }\n\n        this.moveCursorTo(lineEnd.row, lineEnd.column);\n    };\n    this.moveCursorFileEnd = function() {\n        var row = this.doc.getLength() - 1;\n        var column = this.doc.getLine(row).length;\n        this.moveCursorTo(row, column);\n    };\n    this.moveCursorFileStart = function() {\n        this.moveCursorTo(0, 0);\n    };\n    this.moveCursorLongWordRight = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            this.moveCursorTo(fold.end.row, fold.end.column);\n            return;\n        }\n        if (this.session.nonTokenRe.exec(rightOfCursor)) {\n            column += this.session.nonTokenRe.lastIndex;\n            this.session.nonTokenRe.lastIndex = 0;\n            rightOfCursor = line.substring(column);\n        }\n        if (column >= line.length) {\n            this.moveCursorTo(row, line.length);\n            this.moveCursorRight();\n            if (row < this.doc.getLength() - 1)\n                this.moveCursorWordRight();\n            return;\n        }\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            column += this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n\n        this.moveCursorTo(row, column);\n    };\n    this.moveCursorLongWordLeft = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1)) {\n            this.moveCursorTo(fold.start.row, fold.start.column);\n            return;\n        }\n\n        var str = this.session.getFoldStringAt(row, column, -1);\n        if (str == null) {\n            str = this.doc.getLine(row).substring(0, column);\n        }\n\n        var leftOfCursor = lang.stringReverse(str);\n        this.session.nonTokenRe.lastIndex = 0;\n        this.session.tokenRe.lastIndex = 0;\n        if (this.session.nonTokenRe.exec(leftOfCursor)) {\n            column -= this.session.nonTokenRe.lastIndex;\n            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);\n            this.session.nonTokenRe.lastIndex = 0;\n        }\n        if (column <= 0) {\n            this.moveCursorTo(row, 0);\n            this.moveCursorLeft();\n            if (row > 0)\n                this.moveCursorWordLeft();\n            return;\n        }\n        if (this.session.tokenRe.exec(leftOfCursor)) {\n            column -= this.session.tokenRe.lastIndex;\n            this.session.tokenRe.lastIndex = 0;\n        }\n\n        this.moveCursorTo(row, column);\n    };\n\n    this.$shortWordEndIndex = function(rightOfCursor) {\n        var index = 0, ch;\n        var whitespaceRe = /\\s/;\n        var tokenRe = this.session.tokenRe;\n\n        tokenRe.lastIndex = 0;\n        if (this.session.tokenRe.exec(rightOfCursor)) {\n            index = this.session.tokenRe.lastIndex;\n        } else {\n            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                index ++;\n\n            if (index < 1) {\n                tokenRe.lastIndex = 0;\n                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {\n                    tokenRe.lastIndex = 0;\n                    index ++;\n                    if (whitespaceRe.test(ch)) {\n                        if (index > 2) {\n                            index--;\n                            break;\n                        } else {\n                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n                                index ++;\n                            if (index > 2)\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        tokenRe.lastIndex = 0;\n\n        return index;\n    };\n\n    this.moveCursorShortWordRight = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n        var line = this.doc.getLine(row);\n        var rightOfCursor = line.substring(column);\n\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold)\n            return this.moveCursorTo(fold.end.row, fold.end.column);\n\n        if (column == line.length) {\n            var l = this.doc.getLength();\n            do {\n                row++;\n                rightOfCursor = this.doc.getLine(row);\n            } while (row < l && /^\\s*$/.test(rightOfCursor));\n\n            if (!/^\\s+/.test(rightOfCursor))\n                rightOfCursor = \"\";\n            column = 0;\n        }\n\n        var index = this.$shortWordEndIndex(rightOfCursor);\n\n        this.moveCursorTo(row, column + index);\n    };\n\n    this.moveCursorShortWordLeft = function() {\n        var row = this.lead.row;\n        var column = this.lead.column;\n\n        var fold;\n        if (fold = this.session.getFoldAt(row, column, -1))\n            return this.moveCursorTo(fold.start.row, fold.start.column);\n\n        var line = this.session.getLine(row).substring(0, column);\n        if (column === 0) {\n            do {\n                row--;\n                line = this.doc.getLine(row);\n            } while (row > 0 && /^\\s*$/.test(line));\n\n            column = line.length;\n            if (!/\\s+$/.test(line))\n                line = \"\";\n        }\n\n        var leftOfCursor = lang.stringReverse(line);\n        var index = this.$shortWordEndIndex(leftOfCursor);\n\n        return this.moveCursorTo(row, column - index);\n    };\n\n    this.moveCursorWordRight = function() {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordRight();\n        else\n            this.moveCursorShortWordRight();\n    };\n\n    this.moveCursorWordLeft = function() {\n        if (this.session.$selectLongWords)\n            this.moveCursorLongWordLeft();\n        else\n            this.moveCursorShortWordLeft();\n    };\n    this.moveCursorBy = function(rows, chars) {\n        var screenPos = this.session.documentToScreenPosition(\n            this.lead.row,\n            this.lead.column\n        );\n\n        var offsetX;\n\n        if (chars === 0) {\n            if (rows !== 0) {\n                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {\n                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);\n                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);\n                } else {\n                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];\n                }\n            }\n\n            if (this.$desiredColumn)\n                screenPos.column = this.$desiredColumn;\n            else\n                this.$desiredColumn = screenPos.column;\n        }\n        \n        if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {\n            var widget = this.session.lineWidgets[this.lead.row];\n            if (rows < 0)\n                rows -= widget.rowsAbove || 0;\n            else if (rows > 0)\n                rows += widget.rowCount - (widget.rowsAbove || 0);\n        }\n        \n        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);\n        \n        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {\n            \n        }\n        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);\n    };\n    this.moveCursorToPosition = function(position) {\n        this.moveCursorTo(position.row, position.column);\n    };\n    this.moveCursorTo = function(row, column, keepDesiredColumn) {\n        var fold = this.session.getFoldAt(row, column, 1);\n        if (fold) {\n            row = fold.start.row;\n            column = fold.start.column;\n        }\n\n        this.$keepDesiredColumnOnChange = true;\n        var line = this.session.getLine(row);\n        if (/[\\uDC00-\\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {\n            if (this.lead.row == row && this.lead.column == column + 1)\n                column = column - 1;\n            else\n                column = column + 1;\n        }\n        this.lead.setPosition(row, column);\n        this.$keepDesiredColumnOnChange = false;\n\n        if (!keepDesiredColumn)\n            this.$desiredColumn = null;\n    };\n    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {\n        var pos = this.session.screenToDocumentPosition(row, column);\n        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);\n    };\n    this.detach = function() {\n        this.lead.detach();\n        this.anchor.detach();\n        this.session = this.doc = null;\n    };\n\n    this.fromOrientedRange = function(range) {\n        this.setSelectionRange(range, range.cursor == range.start);\n        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;\n    };\n\n    this.toOrientedRange = function(range) {\n        var r = this.getRange();\n        if (range) {\n            range.start.column = r.start.column;\n            range.start.row = r.start.row;\n            range.end.column = r.end.column;\n            range.end.row = r.end.row;\n        } else {\n            range = r;\n        }\n\n        range.cursor = this.isBackwards() ? range.start : range.end;\n        range.desiredColumn = this.$desiredColumn;\n        return range;\n    };\n    this.getRangeOfMovements = function(func) {\n        var start = this.getCursor();\n        try {\n            func(this);\n            var end = this.getCursor();\n            return Range.fromPoints(start, end);\n        } catch(e) {\n            return Range.fromPoints(start, start);\n        } finally {\n            this.moveCursorToPosition(start);\n        }\n    };\n\n    this.toJSON = function() {\n        if (this.rangeCount) {\n            var data = this.ranges.map(function(r) {\n                var r1 = r.clone();\n                r1.isBackwards = r.cursor == r.start;\n                return r1;\n            });\n        } else {\n            var data = this.getRange();\n            data.isBackwards = this.isBackwards();\n        }\n        return data;\n    };\n\n    this.fromJSON = function(data) {\n        if (data.start == undefined) {\n            if (this.rangeList && data.length > 1) {\n                this.toSingleRange(data[0]);\n                for (var i = data.length; i--; ) {\n                    var r = Range.fromPoints(data[i].start, data[i].end);\n                    if (data[i].isBackwards)\n                        r.cursor = r.start;\n                    this.addRange(r, true);\n                }\n                return;\n            } else {\n                data = data[0];\n            }\n        }\n        if (this.rangeList)\n            this.toSingleRange(data);\n        this.setSelectionRange(data, data.isBackwards);\n    };\n\n    this.isEqual = function(data) {\n        if ((data.length || this.rangeCount) && data.length != this.rangeCount)\n            return false;\n        if (!data.length || !this.ranges)\n            return this.getRange().isEqual(data);\n\n        for (var i = this.ranges.length; i--; ) {\n            if (!this.ranges[i].isEqual(data[i]))\n                return false;\n        }\n        return true;\n    };\n\n}).call(Selection.prototype);\n\nexports.Selection = Selection;\n});\n\nace.define(\"ace/tokenizer\",[\"require\",\"exports\",\"module\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar config = require(\"./config\");\nvar MAX_TOKEN_COUNT = 2000;\nvar Tokenizer = function(rules) {\n    this.states = rules;\n\n    this.regExps = {};\n    this.matchMappings = {};\n    for (var key in this.states) {\n        var state = this.states[key];\n        var ruleRegExps = [];\n        var matchTotal = 0;\n        var mapping = this.matchMappings[key] = {defaultToken: \"text\"};\n        var flag = \"g\";\n\n        var splitterRurles = [];\n        for (var i = 0; i < state.length; i++) {\n            var rule = state[i];\n            if (rule.defaultToken)\n                mapping.defaultToken = rule.defaultToken;\n            if (rule.caseInsensitive)\n                flag = \"gi\";\n            if (rule.regex == null)\n                continue;\n\n            if (rule.regex instanceof RegExp)\n                rule.regex = rule.regex.toString().slice(1, -1);\n            var adjustedregex = rule.regex;\n            var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n            if (Array.isArray(rule.token)) {\n                if (rule.token.length == 1 || matchcount == 1) {\n                    rule.token = rule.token[0];\n                } else if (matchcount - 1 != rule.token.length) {\n                    this.reportError(\"number of classes and regexp groups doesn't match\", { \n                        rule: rule,\n                        groupCount: matchcount - 1\n                    });\n                    rule.token = rule.token[0];\n                } else {\n                    rule.tokenArray = rule.token;\n                    rule.token = null;\n                    rule.onMatch = this.$arrayTokens;\n                }\n            } else if (typeof rule.token == \"function\" && !rule.onMatch) {\n                if (matchcount > 1)\n                    rule.onMatch = this.$applyToken;\n                else\n                    rule.onMatch = rule.token;\n            }\n\n            if (matchcount > 1) {\n                if (/\\\\\\d/.test(rule.regex)) {\n                    adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function(match, digit) {\n                        return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n                    });\n                } else {\n                    matchcount = 1;\n                    adjustedregex = this.removeCapturingGroups(rule.regex);\n                }\n                if (!rule.splitRegex && typeof rule.token != \"string\")\n                    splitterRurles.push(rule); // flag will be known only at the very end\n            }\n\n            mapping[matchTotal] = i;\n            matchTotal += matchcount;\n\n            ruleRegExps.push(adjustedregex);\n            if (!rule.onMatch)\n                rule.onMatch = null;\n        }\n        \n        if (!ruleRegExps.length) {\n            mapping[0] = 0;\n            ruleRegExps.push(\"$\");\n        }\n        \n        splitterRurles.forEach(function(rule) {\n            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n        }, this);\n\n        this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n    }\n};\n\n(function() {\n    this.$setMaxTokenCount = function(m) {\n        MAX_TOKEN_COUNT = m | 0;\n    };\n    \n    this.$applyToken = function(str) {\n        var values = this.splitRegex.exec(str).slice(1);\n        var types = this.token.apply(this, values);\n        if (typeof types === \"string\")\n            return [{type: types, value: str}];\n\n        var tokens = [];\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i]\n                };\n        }\n        return tokens;\n    };\n\n    this.$arrayTokens = function(str) {\n        if (!str)\n            return [];\n        var values = this.splitRegex.exec(str);\n        if (!values)\n            return \"text\";\n        var tokens = [];\n        var types = this.tokenArray;\n        for (var i = 0, l = types.length; i < l; i++) {\n            if (values[i + 1])\n                tokens[tokens.length] = {\n                    type: types[i],\n                    value: values[i + 1]\n                };\n        }\n        return tokens;\n    };\n\n    this.removeCapturingGroups = function(src) {\n        var r = src.replace(\n            /\\\\.|\\[(?:\\\\.|[^\\\\\\]])*|\\(\\?[:=!]|(\\()/g,\n            function(x, y) {return y ? \"(?:\" : x;}\n        );\n        return r;\n    };\n\n    this.createSplitterRegexp = function(src, flag) {\n        if (src.indexOf(\"(?=\") != -1) {\n            var stack = 0;\n            var inChClass = false;\n            var lastCapture = {};\n            src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function(\n                m, esc, parenOpen, parenClose, square, index\n            ) {\n                if (inChClass) {\n                    inChClass = square != \"]\";\n                } else if (square) {\n                    inChClass = true;\n                } else if (parenClose) {\n                    if (stack == lastCapture.stack) {\n                        lastCapture.end = index+1;\n                        lastCapture.stack = -1;\n                    }\n                    stack--;\n                } else if (parenOpen) {\n                    stack++;\n                    if (parenOpen.length != 1) {\n                        lastCapture.stack = stack;\n                        lastCapture.start = index;\n                    }\n                }\n                return m;\n            });\n\n            if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n        }\n        if (src.charAt(0) != \"^\") src = \"^\" + src;\n        if (src.charAt(src.length - 1) != \"$\") src += \"$\";\n        \n        return new RegExp(src, (flag||\"\").replace(\"g\", \"\"));\n    };\n    this.getLineTokens = function(line, startState) {\n        if (startState && typeof startState != \"string\") {\n            var stack = startState.slice(0);\n            startState = stack[0];\n            if (startState === \"#tmp\") {\n                stack.shift();\n                startState = stack.shift();\n            }\n        } else\n            var stack = [];\n\n        var currentState = startState || \"start\";\n        var state = this.states[currentState];\n        if (!state) {\n            currentState = \"start\";\n            state = this.states[currentState];\n        }\n        var mapping = this.matchMappings[currentState];\n        var re = this.regExps[currentState];\n        re.lastIndex = 0;\n\n        var match, tokens = [];\n        var lastIndex = 0;\n        var matchAttempts = 0;\n\n        var token = {type: null, value: \"\"};\n\n        while (match = re.exec(line)) {\n            var type = mapping.defaultToken;\n            var rule = null;\n            var value = match[0];\n            var index = re.lastIndex;\n\n            if (index - value.length > lastIndex) {\n                var skipped = line.substring(lastIndex, index - value.length);\n                if (token.type == type) {\n                    token.value += skipped;\n                } else {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {type: type, value: skipped};\n                }\n            }\n\n            for (var i = 0; i < match.length-2; i++) {\n                if (match[i + 1] === undefined)\n                    continue;\n\n                rule = state[mapping[i]];\n\n                if (rule.onMatch)\n                    type = rule.onMatch(value, currentState, stack, line);\n                else\n                    type = rule.token;\n\n                if (rule.next) {\n                    if (typeof rule.next == \"string\") {\n                        currentState = rule.next;\n                    } else {\n                        currentState = rule.next(currentState, stack);\n                    }\n                    \n                    state = this.states[currentState];\n                    if (!state) {\n                        this.reportError(\"state doesn't exist\", currentState);\n                        currentState = \"start\";\n                        state = this.states[currentState];\n                    }\n                    mapping = this.matchMappings[currentState];\n                    lastIndex = index;\n                    re = this.regExps[currentState];\n                    re.lastIndex = index;\n                }\n                if (rule.consumeLineEnd)\n                    lastIndex = index;\n                break;\n            }\n\n            if (value) {\n                if (typeof type === \"string\") {\n                    if ((!rule || rule.merge !== false) && token.type === type) {\n                        token.value += value;\n                    } else {\n                        if (token.type)\n                            tokens.push(token);\n                        token = {type: type, value: value};\n                    }\n                } else if (type) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {type: null, value: \"\"};\n                    for (var i = 0; i < type.length; i++)\n                        tokens.push(type[i]);\n                }\n            }\n\n            if (lastIndex == line.length)\n                break;\n\n            lastIndex = index;\n\n            if (matchAttempts++ > MAX_TOKEN_COUNT) {\n                if (matchAttempts > 2 * line.length) {\n                    this.reportError(\"infinite loop with in ace tokenizer\", {\n                        startState: startState,\n                        line: line\n                    });\n                }\n                while (lastIndex < line.length) {\n                    if (token.type)\n                        tokens.push(token);\n                    token = {\n                        value: line.substring(lastIndex, lastIndex += 500),\n                        type: \"overflow\"\n                    };\n                }\n                currentState = \"start\";\n                stack = [];\n                break;\n            }\n        }\n\n        if (token.type)\n            tokens.push(token);\n        \n        if (stack.length > 1) {\n            if (stack[0] !== currentState)\n                stack.unshift(\"#tmp\", currentState);\n        }\n        return {\n            tokens : tokens,\n            state : stack.length ? stack : currentState\n        };\n    };\n    \n    this.reportError = config.reportError;\n    \n}).call(Tokenizer.prototype);\n\nexports.Tokenizer = Tokenizer;\n});\n\nace.define(\"ace/mode/text_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"../lib/lang\");\n\nvar TextHighlightRules = function() {\n\n    this.$rules = {\n        \"start\" : [{\n            token : \"empty_line\",\n            regex : '^$'\n        }, {\n            defaultToken : \"text\"\n        }]\n    };\n};\n\n(function() {\n\n    this.addRules = function(rules, prefix) {\n        if (!prefix) {\n            for (var key in rules)\n                this.$rules[key] = rules[key];\n            return;\n        }\n        for (var key in rules) {\n            var state = rules[key];\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                if (rule.next || rule.onMatch) {\n                    if (typeof rule.next == \"string\") {\n                        if (rule.next.indexOf(prefix) !== 0)\n                            rule.next = prefix + rule.next;\n                    }\n                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\n                        rule.nextState = prefix + rule.nextState;\n                }\n            }\n            this.$rules[prefix + key] = state;\n        }\n    };\n\n    this.getRules = function() {\n        return this.$rules;\n    };\n\n    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\n        var embedRules = typeof HighlightRules == \"function\"\n            ? new HighlightRules().getRules()\n            : HighlightRules;\n        if (states) {\n            for (var i = 0; i < states.length; i++)\n                states[i] = prefix + states[i];\n        } else {\n            states = [];\n            for (var key in embedRules)\n                states.push(prefix + key);\n        }\n\n        this.addRules(embedRules, prefix);\n\n        if (escapeRules) {\n            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\n            for (var i = 0; i < states.length; i++)\n                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));\n        }\n\n        if (!this.$embeds)\n            this.$embeds = [];\n        this.$embeds.push(prefix);\n    };\n\n    this.getEmbeds = function() {\n        return this.$embeds;\n    };\n\n    var pushState = function(currentState, stack) {\n        if (currentState != \"start\" || stack.length)\n            stack.unshift(this.nextState, currentState);\n        return this.nextState;\n    };\n    var popState = function(currentState, stack) {\n        stack.shift();\n        return stack.shift() || \"start\";\n    };\n\n    this.normalizeRules = function() {\n        var id = 0;\n        var rules = this.$rules;\n        function processState(key) {\n            var state = rules[key];\n            state.processed = true;\n            for (var i = 0; i < state.length; i++) {\n                var rule = state[i];\n                var toInsert = null;\n                if (Array.isArray(rule)) {\n                    toInsert = rule;\n                    rule = {};\n                }\n                if (!rule.regex && rule.start) {\n                    rule.regex = rule.start;\n                    if (!rule.next)\n                        rule.next = [];\n                    rule.next.push({\n                        defaultToken: rule.token\n                    }, {\n                        token: rule.token + \".end\",\n                        regex: rule.end || rule.start,\n                        next: \"pop\"\n                    });\n                    rule.token = rule.token + \".start\";\n                    rule.push = true;\n                }\n                var next = rule.next || rule.push;\n                if (next && Array.isArray(next)) {\n                    var stateName = rule.stateName;\n                    if (!stateName)  {\n                        stateName = rule.token;\n                        if (typeof stateName != \"string\")\n                            stateName = stateName[0] || \"\";\n                        if (rules[stateName])\n                            stateName += id++;\n                    }\n                    rules[stateName] = next;\n                    rule.next = stateName;\n                    processState(stateName);\n                } else if (next == \"pop\") {\n                    rule.next = popState;\n                }\n\n                if (rule.push) {\n                    rule.nextState = rule.next || rule.push;\n                    rule.next = pushState;\n                    delete rule.push;\n                }\n\n                if (rule.rules) {\n                    for (var r in rule.rules) {\n                        if (rules[r]) {\n                            if (rules[r].push)\n                                rules[r].push.apply(rules[r], rule.rules[r]);\n                        } else {\n                            rules[r] = rule.rules[r];\n                        }\n                    }\n                }\n                var includeName = typeof rule == \"string\" ? rule : rule.include;\n                if (includeName) {\n                    if (Array.isArray(includeName))\n                        toInsert = includeName.map(function(x) { return rules[x]; });\n                    else\n                        toInsert = rules[includeName];\n                }\n\n                if (toInsert) {\n                    var args = [i, 1].concat(toInsert);\n                    if (rule.noEscape)\n                        args = args.filter(function(x) {return !x.next;});\n                    state.splice.apply(state, args);\n                    i--;\n                }\n                \n                if (rule.keywordMap) {\n                    rule.token = this.createKeywordMapper(\n                        rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive\n                    );\n                    delete rule.defaultToken;\n                }\n            }\n        }\n        Object.keys(rules).forEach(processState, this);\n    };\n\n    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {\n        var keywords = Object.create(null);\n        Object.keys(map).forEach(function(className) {\n            var a = map[className];\n            if (ignoreCase)\n                a = a.toLowerCase();\n            var list = a.split(splitChar || \"|\");\n            for (var i = list.length; i--; )\n                keywords[list[i]] = className;\n        });\n        if (Object.getPrototypeOf(keywords)) {\n            keywords.__proto__ = null;\n        }\n        this.$keywordList = Object.keys(keywords);\n        map = null;\n        return ignoreCase\n            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }\n            : function(value) {return keywords[value] || defaultToken; };\n    };\n\n    this.getKeywords = function() {\n        return this.$keywords;\n    };\n\n}).call(TextHighlightRules.prototype);\n\nexports.TextHighlightRules = TextHighlightRules;\n});\n\nace.define(\"ace/mode/behaviour\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar Behaviour = function() {\n   this.$behaviours = {};\n};\n\n(function () {\n\n    this.add = function (name, action, callback) {\n        switch (undefined) {\n          case this.$behaviours:\n              this.$behaviours = {};\n          case this.$behaviours[name]:\n              this.$behaviours[name] = {};\n        }\n        this.$behaviours[name][action] = callback;\n    };\n    \n    this.addBehaviours = function (behaviours) {\n        for (var key in behaviours) {\n            for (var action in behaviours[key]) {\n                this.add(key, action, behaviours[key][action]);\n            }\n        }\n    };\n    \n    this.remove = function (name) {\n        if (this.$behaviours && this.$behaviours[name]) {\n            delete this.$behaviours[name];\n        }\n    };\n    \n    this.inherit = function (mode, filter) {\n        if (typeof mode === \"function\") {\n            var behaviours = new mode().getBehaviours(filter);\n        } else {\n            var behaviours = mode.getBehaviours(filter);\n        }\n        this.addBehaviours(behaviours);\n    };\n    \n    this.getBehaviours = function (filter) {\n        if (!filter) {\n            return this.$behaviours;\n        } else {\n            var ret = {};\n            for (var i = 0; i < filter.length; i++) {\n                if (this.$behaviours[filter[i]]) {\n                    ret[filter[i]] = this.$behaviours[filter[i]];\n                }\n            }\n            return ret;\n        }\n    };\n\n}).call(Behaviour.prototype);\n\nexports.Behaviour = Behaviour;\n});\n\nace.define(\"ace/token_iterator\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"./range\").Range;\nvar TokenIterator = function(session, initialRow, initialColumn) {\n    this.$session = session;\n    this.$row = initialRow;\n    this.$rowTokens = session.getTokens(initialRow);\n\n    var token = session.getTokenAt(initialRow, initialColumn);\n    this.$tokenIndex = token ? token.index : -1;\n};\n\n(function() { \n    this.stepBackward = function() {\n        this.$tokenIndex -= 1;\n        \n        while (this.$tokenIndex < 0) {\n            this.$row -= 1;\n            if (this.$row < 0) {\n                this.$row = 0;\n                return null;\n            }\n                \n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = this.$rowTokens.length - 1;\n        }\n            \n        return this.$rowTokens[this.$tokenIndex];\n    };   \n    this.stepForward = function() {\n        this.$tokenIndex += 1;\n        var rowCount;\n        while (this.$tokenIndex >= this.$rowTokens.length) {\n            this.$row += 1;\n            if (!rowCount)\n                rowCount = this.$session.getLength();\n            if (this.$row >= rowCount) {\n                this.$row = rowCount - 1;\n                return null;\n            }\n\n            this.$rowTokens = this.$session.getTokens(this.$row);\n            this.$tokenIndex = 0;\n        }\n            \n        return this.$rowTokens[this.$tokenIndex];\n    };      \n    this.getCurrentToken = function () {\n        return this.$rowTokens[this.$tokenIndex];\n    };      \n    this.getCurrentTokenRow = function () {\n        return this.$row;\n    };     \n    this.getCurrentTokenColumn = function() {\n        var rowTokens = this.$rowTokens;\n        var tokenIndex = this.$tokenIndex;\n        var column = rowTokens[tokenIndex].start;\n        if (column !== undefined)\n            return column;\n            \n        column = 0;\n        while (tokenIndex > 0) {\n            tokenIndex -= 1;\n            column += rowTokens[tokenIndex].value.length;\n        }\n        \n        return column;  \n    };\n    this.getCurrentTokenPosition = function() {\n        return {row: this.$row, column: this.getCurrentTokenColumn()};\n    };\n    this.getCurrentTokenRange = function() {\n        var token = this.$rowTokens[this.$tokenIndex];\n        var column = this.getCurrentTokenColumn();\n        return new Range(this.$row, column, this.$row, column + token.value.length);\n    };\n    \n}).call(TokenIterator.prototype);\n\nexports.TokenIterator = TokenIterator;\n});\n\nace.define(\"ace/mode/behaviour/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\n\nvar SAFE_INSERT_IN_TOKENS =\n    [\"text\", \"paren.rparen\", \"rparen\", \"paren\", \"punctuation.operator\"];\nvar SAFE_INSERT_BEFORE_TOKENS =\n    [\"text\", \"paren.rparen\", \"rparen\", \"paren\", \"punctuation.operator\", \"comment\"];\n\nvar context;\nvar contextCache = {};\nvar defaultQuotes = {'\"' : '\"', \"'\" : \"'\"};\n\nvar initContext = function(editor) {\n    var id = -1;\n    if (editor.multiSelect) {\n        id = editor.selection.index;\n        if (contextCache.rangeCount != editor.multiSelect.rangeCount)\n            contextCache = {rangeCount: editor.multiSelect.rangeCount};\n    }\n    if (contextCache[id])\n        return context = contextCache[id];\n    context = contextCache[id] = {\n        autoInsertedBrackets: 0,\n        autoInsertedRow: -1,\n        autoInsertedLineEnd: \"\",\n        maybeInsertedBrackets: 0,\n        maybeInsertedRow: -1,\n        maybeInsertedLineStart: \"\",\n        maybeInsertedLineEnd: \"\"\n    };\n};\n\nvar getWrapped = function(selection, selected, opening, closing) {\n    var rowDiff = selection.end.row - selection.start.row;\n    return {\n        text: opening + selected + closing,\n        selection: [\n                0,\n                selection.start.column + 1,\n                rowDiff,\n                selection.end.column + (rowDiff ? 0 : 1)\n            ]\n    };\n};\n\nvar CstyleBehaviour = function(options) {\n    this.add(\"braces\", \"insertion\", function(state, action, editor, session, text) {\n        var cursor = editor.getCursorPosition();\n        var line = session.doc.getLine(cursor.row);\n        if (text == '{') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && selected !== \"{\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '{', '}');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                if (/[\\]\\}\\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {\n                    CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n                    return {\n                        text: '{}',\n                        selection: [1, 1]\n                    };\n                } else {\n                    CstyleBehaviour.recordMaybeInsert(editor, session, \"{\");\n                    return {\n                        text: '{',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        } else if (text == '}') {\n            initContext(editor);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == '}') {\n                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        } else if (text == \"\\n\" || text == \"\\r\\n\") {\n            initContext(editor);\n            var closing = \"\";\n            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {\n                closing = lang.stringRepeat(\"}\", context.maybeInsertedBrackets);\n                CstyleBehaviour.clearMaybeInsertedClosing();\n            }\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === '}') {\n                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');\n                if (!openBracePos)\n                     return null;\n                var next_indent = this.$getIndent(session.getLine(openBracePos.row));\n            } else if (closing) {\n                var next_indent = this.$getIndent(line);\n            } else {\n                CstyleBehaviour.clearMaybeInsertedClosing();\n                return;\n            }\n            var indent = next_indent + session.getTabString();\n\n            return {\n                text: '\\n' + indent + '\\n' + next_indent + closing,\n                selection: [1, indent.length, 1, indent.length]\n            };\n        } else {\n            CstyleBehaviour.clearMaybeInsertedClosing();\n        }\n    });\n\n    this.add(\"braces\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '{') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.end.column, range.end.column + 1);\n            if (rightChar == '}') {\n                range.end.column++;\n                return range;\n            } else {\n                context.maybeInsertedBrackets--;\n            }\n        }\n    });\n\n    this.add(\"parens\", \"insertion\", function(state, action, editor, session, text) {\n        if (text == '(') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '(', ')');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \")\");\n                return {\n                    text: '()',\n                    selection: [1, 1]\n                };\n            }\n        } else if (text == ')') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ')') {\n                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"parens\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '(') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ')') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"brackets\", \"insertion\", function(state, action, editor, session, text) {\n        if (text == '[') {\n            initContext(editor);\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, '[', ']');\n            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n                CstyleBehaviour.recordAutoInsert(editor, session, \"]\");\n                return {\n                    text: '[]',\n                    selection: [1, 1]\n                };\n            }\n        } else if (text == ']') {\n            initContext(editor);\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar == ']') {\n                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});\n                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n                    CstyleBehaviour.popAutoInsertedClosing();\n                    return {\n                        text: '',\n                        selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"brackets\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected == '[') {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == ']') {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"insertion\", function(state, action, editor, session, text) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n        if (text.length == 1 && quotes[text]) {\n            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) \n                return;\n            initContext(editor);\n            var quote = text;\n            var selection = editor.getSelectionRange();\n            var selected = session.doc.getTextRange(selection);\n            if (selected !== \"\" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {\n                return getWrapped(selection, selected, quote, quote);\n            } else if (!selected) {\n                var cursor = editor.getCursorPosition();\n                var line = session.doc.getLine(cursor.row);\n                var leftChar = line.substring(cursor.column-1, cursor.column);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                \n                var token = session.getTokenAt(cursor.row, cursor.column);\n                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);\n                if (leftChar == \"\\\\\" && token && /escape/.test(token.type))\n                    return null;\n                \n                var stringBefore = token && /string|escape/.test(token.type);\n                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);\n                \n                var pair;\n                if (rightChar == quote) {\n                    pair = stringBefore !== stringAfter;\n                    if (pair && /string\\.end/.test(rightToken.type))\n                        pair = false;\n                } else {\n                    if (stringBefore && !stringAfter)\n                        return null; // wrap string with different quote\n                    if (stringBefore && stringAfter)\n                        return null; // do not pair quotes inside strings\n                    var wordRe = session.$mode.tokenRe;\n                    wordRe.lastIndex = 0;\n                    var isWordBefore = wordRe.test(leftChar);\n                    wordRe.lastIndex = 0;\n                    var isWordAfter = wordRe.test(leftChar);\n                    if (isWordBefore || isWordAfter)\n                        return null; // before or after alphanumeric\n                    if (rightChar && !/[\\s;,.})\\]\\\\]/.test(rightChar))\n                        return null; // there is rightChar and it isn't closing\n                    var charBefore = line[cursor.column - 2];\n                    if (leftChar == quote &&  (charBefore == quote || wordRe.test(charBefore)))\n                        return null;\n                    pair = true;\n                }\n                return {\n                    text: pair ? quote + quote : \"\",\n                    selection: [1,1]\n                };\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\n        var quotes = session.$mode.$quotes || defaultQuotes;\n\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {\n            initContext(editor);\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n};\n\n    \nCstyleBehaviour.isSaneInsertion = function(editor, session) {\n    var cursor = editor.getCursorPosition();\n    var iterator = new TokenIterator(session, cursor.row, cursor.column);\n    if (!this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS)) {\n        if (/[)}\\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))\n            return true;\n        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);\n        if (!this.$matchTokenType(iterator2.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS))\n            return false;\n    }\n    iterator.stepForward();\n    return iterator.getCurrentTokenRow() !== cursor.row ||\n        this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_BEFORE_TOKENS);\n};\n\nCstyleBehaviour.$matchTokenType = function(token, types) {\n    return types.indexOf(token.type || token) > -1;\n};\n\nCstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))\n        context.autoInsertedBrackets = 0;\n    context.autoInsertedRow = cursor.row;\n    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);\n    context.autoInsertedBrackets++;\n};\n\nCstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {\n    var cursor = editor.getCursorPosition();\n    var line = session.doc.getLine(cursor.row);\n    if (!this.isMaybeInsertedClosing(cursor, line))\n        context.maybeInsertedBrackets = 0;\n    context.maybeInsertedRow = cursor.row;\n    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;\n    context.maybeInsertedLineEnd = line.substr(cursor.column);\n    context.maybeInsertedBrackets++;\n};\n\nCstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {\n    return context.autoInsertedBrackets > 0 &&\n        cursor.row === context.autoInsertedRow &&\n        bracket === context.autoInsertedLineEnd[0] &&\n        line.substr(cursor.column) === context.autoInsertedLineEnd;\n};\n\nCstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {\n    return context.maybeInsertedBrackets > 0 &&\n        cursor.row === context.maybeInsertedRow &&\n        line.substr(cursor.column) === context.maybeInsertedLineEnd &&\n        line.substr(0, cursor.column) == context.maybeInsertedLineStart;\n};\n\nCstyleBehaviour.popAutoInsertedClosing = function() {\n    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);\n    context.autoInsertedBrackets--;\n};\n\nCstyleBehaviour.clearMaybeInsertedClosing = function() {\n    if (context) {\n        context.maybeInsertedBrackets = 0;\n        context.maybeInsertedRow = -1;\n    }\n};\n\n\n\noop.inherits(CstyleBehaviour, Behaviour);\n\nexports.CstyleBehaviour = CstyleBehaviour;\n});\n\nace.define(\"ace/unicode\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\nvar wordChars = [48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2];\n\nvar code = 0;\nvar str = [];\nfor (var i = 0; i < wordChars.length; i += 2) {\n    str.push(code += wordChars[i]);\n    if (wordChars[i + 1])\n        str.push(45, code += wordChars[i + 1]);\n}\n\nexports.wordChars = String.fromCharCode.apply(null, str);\n\n});\n\nace.define(\"ace/mode/text\",[\"require\",\"exports\",\"module\",\"ace/config\",\"ace/tokenizer\",\"ace/mode/text_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/unicode\",\"ace/lib/lang\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar config = require(\"../config\");\n\nvar Tokenizer = require(\"../tokenizer\").Tokenizer;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar unicode = require(\"../unicode\");\nvar lang = require(\"../lib/lang\");\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\n\nvar Mode = function() {\n    this.HighlightRules = TextHighlightRules;\n};\n\n(function() {\n    this.$defaultBehaviour = new CstyleBehaviour();\n\n    this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"\\\\$_]+\", \"g\");\n\n    this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"\\\\$_]|\\\\s])+\", \"g\");\n\n    this.getTokenizer = function() {\n        if (!this.$tokenizer) {\n            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);\n            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\n        }\n        return this.$tokenizer;\n    };\n\n    this.lineCommentStart = \"\";\n    this.blockComment = \"\";\n\n    this.toggleCommentLines = function(state, session, startRow, endRow) {\n        var doc = session.doc;\n\n        var ignoreBlankLines = true;\n        var shouldRemove = true;\n        var minIndent = Infinity;\n        var tabSize = session.getTabSize();\n        var insertAtTabStop = false;\n\n        if (!this.lineCommentStart) {\n            if (!this.blockComment)\n                return false;\n            var lineCommentStart = this.blockComment.start;\n            var lineCommentEnd = this.blockComment.end;\n            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\n            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\n\n            var comment = function(line, i) {\n                if (testRemove(line, i))\n                    return;\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);\n                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n                }\n            };\n\n            var uncomment = function(line, i) {\n                var m;\n                if (m = line.match(regexpEnd))\n                    doc.removeInLine(i, line.length - m[0].length, line.length);\n                if (m = line.match(regexpStart))\n                    doc.removeInLine(i, m[1].length, m[0].length);\n            };\n\n            var testRemove = function(line, row) {\n                if (regexpStart.test(line))\n                    return true;\n                var tokens = session.getTokens(row);\n                for (var i = 0; i < tokens.length; i++) {\n                    if (tokens[i].type === \"comment\")\n                        return true;\n                }\n            };\n        } else {\n            if (Array.isArray(this.lineCommentStart)) {\n                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\n                var lineCommentStart = this.lineCommentStart[0];\n            } else {\n                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\n                var lineCommentStart = this.lineCommentStart;\n            }\n            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\n            \n            insertAtTabStop = session.getUseSoftTabs();\n\n            var uncomment = function(line, i) {\n                var m = line.match(regexpStart);\n                if (!m) return;\n                var start = m[1].length, end = m[0].length;\n                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\n                    end--;\n                doc.removeInLine(i, start, end);\n            };\n            var commentWithSpace = lineCommentStart + \" \";\n            var comment = function(line, i) {\n                if (!ignoreBlankLines || /\\S/.test(line)) {\n                    if (shouldInsertSpace(line, minIndent, minIndent))\n                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);\n                    else\n                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n                }\n            };\n            var testRemove = function(line, i) {\n                return regexpStart.test(line);\n            };\n            \n            var shouldInsertSpace = function(line, before, after) {\n                var spaces = 0;\n                while (before-- && line.charAt(before) == \" \")\n                    spaces++;\n                if (spaces % tabSize != 0)\n                    return false;\n                var spaces = 0;\n                while (line.charAt(after++) == \" \")\n                    spaces++;\n                if (tabSize > 2)\n                    return spaces % tabSize != tabSize - 1;\n                else\n                    return spaces % tabSize == 0;\n            };\n        }\n\n        function iter(fun) {\n            for (var i = startRow; i <= endRow; i++)\n                fun(doc.getLine(i), i);\n        }\n\n\n        var minEmptyLength = Infinity;\n        iter(function(line, i) {\n            var indent = line.search(/\\S/);\n            if (indent !== -1) {\n                if (indent < minIndent)\n                    minIndent = indent;\n                if (shouldRemove && !testRemove(line, i))\n                    shouldRemove = false;\n            } else if (minEmptyLength > line.length) {\n                minEmptyLength = line.length;\n            }\n        });\n\n        if (minIndent == Infinity) {\n            minIndent = minEmptyLength;\n            ignoreBlankLines = false;\n            shouldRemove = false;\n        }\n\n        if (insertAtTabStop && minIndent % tabSize != 0)\n            minIndent = Math.floor(minIndent / tabSize) * tabSize;\n\n        iter(shouldRemove ? uncomment : comment);\n    };\n\n    this.toggleBlockComment = function(state, session, range, cursor) {\n        var comment = this.blockComment;\n        if (!comment)\n            return;\n        if (!comment.start && comment[0])\n            comment = comment[0];\n\n        var iterator = new TokenIterator(session, cursor.row, cursor.column);\n        var token = iterator.getCurrentToken();\n\n        var sel = session.selection;\n        var initialRange = session.selection.toOrientedRange();\n        var startRow, colDiff;\n\n        if (token && /comment/.test(token.type)) {\n            var startRange, endRange;\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.start);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    startRange = new Range(row, column, row, column + comment.start.length);\n                    break;\n                }\n                token = iterator.stepBackward();\n            }\n\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            while (token && /comment/.test(token.type)) {\n                var i = token.value.indexOf(comment.end);\n                if (i != -1) {\n                    var row = iterator.getCurrentTokenRow();\n                    var column = iterator.getCurrentTokenColumn() + i;\n                    endRange = new Range(row, column, row, column + comment.end.length);\n                    break;\n                }\n                token = iterator.stepForward();\n            }\n            if (endRange)\n                session.remove(endRange);\n            if (startRange) {\n                session.remove(startRange);\n                startRow = startRange.start.row;\n                colDiff = -comment.start.length;\n            }\n        } else {\n            colDiff = comment.start.length;\n            startRow = range.start.row;\n            session.insert(range.end, comment.end);\n            session.insert(range.start, comment.start);\n        }\n        if (initialRange.start.row == startRow)\n            initialRange.start.column += colDiff;\n        if (initialRange.end.row == startRow)\n            initialRange.end.column += colDiff;\n        session.selection.fromOrientedRange(initialRange);\n    };\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$getIndent(line);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return false;\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n    this.createWorker = function(session) {\n        return null;\n    };\n\n    this.createModeDelegates = function (mapping) {\n        this.$embeds = [];\n        this.$modes = {};\n        for (var i in mapping) {\n            if (mapping[i]) {\n                var Mode = mapping[i];\n                var id = Mode.prototype.$id;\n                var mode = config.$modes[id];\n                if (!mode)\n                    config.$modes[id] = mode = new Mode();\n                if (!config.$modes[i])\n                    config.$modes[i] = mode;\n                this.$embeds.push(i);\n                this.$modes[i] = mode;\n            }\n        }\n\n        var delegations = [\"toggleBlockComment\", \"toggleCommentLines\", \"getNextLineIndent\", \n            \"checkOutdent\", \"autoOutdent\", \"transformAction\", \"getCompletions\"];\n\n        for (var i = 0; i < delegations.length; i++) {\n            (function(scope) {\n              var functionName = delegations[i];\n              var defaultHandler = scope[functionName];\n              scope[delegations[i]] = function() {\n                  return this.$delegator(functionName, arguments, defaultHandler);\n              };\n            }(this));\n        }\n    };\n\n    this.$delegator = function(method, args, defaultHandler) {\n        var state = args[0] || \"start\";\n        if (typeof state != \"string\") {\n            if (Array.isArray(state[2])) {\n                var language = state[2][state[2].length - 1];\n                var mode = this.$modes[language];\n                if (mode)\n                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));\n            }\n            state = state[0] || \"start\";\n        }\n            \n        for (var i = 0; i < this.$embeds.length; i++) {\n            if (!this.$modes[this.$embeds[i]]) continue;\n\n            var split = state.split(this.$embeds[i]);\n            if (!split[0] && split[1]) {\n                args[0] = split[1];\n                var mode = this.$modes[this.$embeds[i]];\n                return mode[method].apply(mode, args);\n            }\n        }\n        var ret = defaultHandler.apply(this, args);\n        return defaultHandler ? ret : undefined;\n    };\n\n    this.transformAction = function(state, action, editor, session, param) {\n        if (this.$behaviour) {\n            var behaviours = this.$behaviour.getBehaviours();\n            for (var key in behaviours) {\n                if (behaviours[key][action]) {\n                    var ret = behaviours[key][action].apply(this, arguments);\n                    if (ret) {\n                        return ret;\n                    }\n                }\n            }\n        }\n    };\n    \n    this.getKeywords = function(append) {\n        if (!this.completionKeywords) {\n            var rules = this.$tokenizer.rules;\n            var completionKeywords = [];\n            for (var rule in rules) {\n                var ruleItr = rules[rule];\n                for (var r = 0, l = ruleItr.length; r < l; r++) {\n                    if (typeof ruleItr[r].token === \"string\") {\n                        if (/keyword|support|storage/.test(ruleItr[r].token))\n                            completionKeywords.push(ruleItr[r].regex);\n                    }\n                    else if (typeof ruleItr[r].token === \"object\") {\n                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    \n                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\n                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\n                                completionKeywords.push(rule.substr(1, rule.length - 2));\n                            }\n                        }\n                    }\n                }\n            }\n            this.completionKeywords = completionKeywords;\n        }\n        if (!append)\n            return this.$keywordList;\n        return completionKeywords.concat(this.$keywordList || []);\n    };\n    \n    this.$createKeywordList = function() {\n        if (!this.$highlightRules)\n            this.getTokenizer();\n        return this.$keywordList = this.$highlightRules.$keywordList || [];\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        var keywords = this.$keywordList || this.$createKeywordList();\n        return keywords.map(function(word) {\n            return {\n                name: word,\n                value: word,\n                score: 0,\n                meta: \"keyword\"\n            };\n        });\n    };\n\n    this.$id = \"ace/mode/text\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/apply_delta\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nfunction throwDeltaError(delta, errorText){\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n}\n\nfunction positionInDocument(docLines, position) {\n    return position.row    >= 0 && position.row    <  docLines.length &&\n           position.column >= 0 && position.column <= docLines[position.row].length;\n}\n\nfunction validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\")\n        throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array))\n        throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end)\n       throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start))\n        throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end))\n        throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)\n        throwDeltaError(delta, \"delta.range must match delta lines\");\n}\n\nexports.applyDelta = function(docLines, delta, doNotValidate) {\n    \n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            var lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            } else {\n                var args = [row, 1].concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            var endColumn = delta.end.column;\n            var endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            } else {\n                docLines.splice(\n                    row, endRow - row + 1,\n                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)\n                );\n            }\n            break;\n    }\n};\n});\n\nace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\nvar Anchor = exports.Anchor = function(doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    \n    if (typeof column == \"undefined\")\n        this.setPosition(row.row, row.column);\n    else\n        this.setPosition(row, column);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.getPosition = function() {\n        return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function() {\n        return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function(delta) {\n        if (delta.start.row == delta.end.row && delta.start.row != this.row)\n            return;\n\n        if (delta.start.row > this.row)\n            return;\n            \n        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);\n        this.setPosition(point.row, point.column, true);\n    };\n    \n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);\n    }\n            \n    function $getTransformedPoint(delta, point, moveIfEqual) {\n        var deltaIsInsert = delta.action == \"insert\";\n        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);\n        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n        var deltaStart = delta.start;\n        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n            return {\n                row: point.row,\n                column: point.column\n            };\n        }\n        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n            return {\n                row: point.row + deltaRowShift,\n                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n            };\n        }\n        \n        return {\n            row: deltaStart.row,\n            column: deltaStart.column\n        };\n    }\n    this.setPosition = function(row, column, noClip) {\n        var pos;\n        if (noClip) {\n            pos = {\n                row: row,\n                column: column\n            };\n        } else {\n            pos = this.$clipPositionToDocument(row, column);\n        }\n\n        if (this.row == pos.row && this.column == pos.column)\n            return;\n\n        var old = {\n            row: this.row,\n            column: this.column\n        };\n\n        this.row = pos.row;\n        this.column = pos.column;\n        this._signal(\"change\", {\n            old: old,\n            value: pos\n        });\n    };\n    this.detach = function() {\n        this.document.removeEventListener(\"change\", this.$onChange);\n    };\n    this.attach = function(doc) {\n        this.document = doc || this.document;\n        this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function(row, column) {\n        var pos = {};\n\n        if (row >= this.document.getLength()) {\n            pos.row = Math.max(0, this.document.getLength() - 1);\n            pos.column = this.document.getLine(pos.row).length;\n        }\n        else if (row < 0) {\n            pos.row = 0;\n            pos.column = 0;\n        }\n        else {\n            pos.row = row;\n            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n        }\n\n        if (column < 0)\n            pos.column = 0;\n\n        return pos;\n    };\n\n}).call(Anchor.prototype);\n\n});\n\nace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/apply_delta\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar applyDelta = require(\"./apply_delta\").applyDelta;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Range = require(\"./range\").Range;\nvar Anchor = require(\"./anchor\").Anchor;\n\nvar Document = function(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n        this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n        this.insertMergedLines({row: 0, column: 0}, textOrLines);\n    } else {\n        this.insert({row: 0, column:0}, textOrLines);\n    }\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setValue = function(text) {\n        var len = this.getLength() - 1;\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\n        this.insert({row: 0, column: 0}, text);\n    };\n    this.getValue = function() {\n        return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function(row, column) {\n        return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n        this.$split = function(text) {\n            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n        };\n    } else {\n        this.$split = function(text) {\n            return text.split(/\\r\\n|\\r|\\n/);\n        };\n    }\n\n\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this.$autoNewLine = match ? match[1] : \"\\n\";\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function() {\n        switch (this.$newLineMode) {\n          case \"windows\":\n            return \"\\r\\n\";\n          case \"unix\":\n            return \"\\n\";\n          default:\n            return this.$autoNewLine || \"\\n\";\n        }\n    };\n\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function(newLineMode) {\n        if (this.$newLineMode === newLineMode)\n            return;\n\n        this.$newLineMode = newLineMode;\n        this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function() {\n        return this.$newLineMode;\n    };\n    this.isNewLine = function(text) {\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n    };\n    this.getLine = function(row) {\n        return this.$lines[row] || \"\";\n    };\n    this.getLines = function(firstRow, lastRow) {\n        return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function() {\n        return this.getLines(0, this.getLength());\n    };\n    this.getLength = function() {\n        return this.$lines.length;\n    };\n    this.getTextRange = function(range) {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function(range) {\n        var lines;\n        if (range.start.row === range.end.row) {\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        } else {\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            var l = lines.length - 1;\n            if (range.end.row - range.start.row == l)\n                lines[l] = lines[l].substring(0, range.end.column);\n        }\n        return lines;\n    };\n    this.insertLines = function(row, lines) {\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n        return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function(firstRow, lastRow) {\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n        return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function(position) {\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n        return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function(position, text) {\n        if (this.getLength() <= 1)\n            this.$detectNewLine(text);\n        \n        return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function(position, text) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = this.pos(position.row, position.column + text.length);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n        \n        return this.clonePos(end);\n    };\n    \n    this.clippedPos = function(row, column) {\n        var length = this.getLength();\n        if (row === undefined) {\n            row = length;\n        } else if (row < 0) {\n            row = 0;\n        } else if (row >= length) {\n            row = length - 1;\n            column = undefined;\n        }\n        var line = this.getLine(row);\n        if (column == undefined)\n            column = line.length;\n        column = Math.min(Math.max(column, 0), line.length);\n        return {row: row, column: column};\n    };\n    \n    this.clonePos = function(pos) {\n        return {row: pos.row, column: pos.column};\n    };\n    \n    this.pos = function(row, column) {\n        return {row: row, column: column};\n    };\n    \n    this.$clipPosition = function(position) {\n        var length = this.getLength();\n        if (position.row >= length) {\n            position.row = Math.max(0, length - 1);\n            position.column = this.getLine(length - 1).length;\n        } else {\n            position.row = Math.max(0, position.row);\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n        }\n        return position;\n    };\n    this.insertFullLines = function(row, lines) {\n        row = Math.min(Math.max(row, 0), this.getLength());\n        var column = 0;\n        if (row < this.getLength()) {\n            lines = lines.concat([\"\"]);\n            column = 0;\n        } else {\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this.$lines[row].length;\n        }\n        this.insertMergedLines({row: row, column: column}, lines);\n    };    \n    this.insertMergedLines = function(position, lines) {\n        var start = this.clippedPos(position.row, position.column);\n        var end = {\n            row: start.row + lines.length - 1,\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n        \n        return this.clonePos(end);\n    };\n    this.remove = function(range) {\n        var start = this.clippedPos(range.start.row, range.start.column);\n        var end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        });\n        return this.clonePos(start);\n    };\n    this.removeInLine = function(row, startColumn, endColumn) {\n        var start = this.clippedPos(row, startColumn);\n        var end = this.clippedPos(row, endColumn);\n        \n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({start: start, end: end})\n        }, true);\n        \n        return this.clonePos(start);\n    };\n    this.removeFullLines = function(firstRow, lastRow) {\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n        var deleteLastNewLine  = lastRow  < this.getLength() - 1;\n        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );\n        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );\n        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );\n        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); \n        var range = new Range(startRow, startCol, endRow, endCol);\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n        \n        this.applyDelta({\n            start: range.start,\n            end: range.end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range)\n        });\n        return deletedLines;\n    };\n    this.removeNewLine = function(row) {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: this.pos(row, this.getLine(row).length),\n                end: this.pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    };\n    this.replace = function(range, text) {\n        if (!(range instanceof Range))\n            range = Range.fromPoints(range.start, range.end);\n        if (text.length === 0 && range.isEmpty())\n            return range.start;\n        if (text == this.getTextRange(range))\n            return range.end;\n\n        this.remove(range);\n        var end;\n        if (text) {\n            end = this.insert(range.start, text);\n        }\n        else {\n            end = range.start;\n        }\n        \n        return end;\n    };\n    this.applyDeltas = function(deltas) {\n        for (var i=0; i<deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    };\n    this.revertDeltas = function(deltas) {\n        for (var i=deltas.length-1; i>=0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    };\n    this.applyDelta = function(delta, doNotValidate) {\n        var isInsert = delta.action == \"insert\";\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\n            : !Range.comparePoints(delta.start, delta.end)) {\n            return;\n        }\n        \n        if (isInsert && delta.lines.length > 20000) {\n            this.$splitAndapplyLargeDelta(delta, 20000);\n        }\n        else {\n            applyDelta(this.$lines, delta, doNotValidate);\n            this._signal(\"change\", delta);\n        }\n    };\n    \n    this.$splitAndapplyLargeDelta = function(delta, MAX) {\n        var lines = delta.lines;\n        var l = lines.length - MAX + 1;\n        var row = delta.start.row; \n        var column = delta.start.column;\n        for (var from = 0, to = 0; from < l; from = to) {\n            to += MAX - 1;\n            var chunk = lines.slice(from, to);\n            chunk.push(\"\");\n            this.applyDelta({\n                start: this.pos(row + from, column),\n                end: this.pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        }\n        delta.lines = lines.slice(from);\n        delta.start.row = row + from;\n        delta.start.column = column;\n        this.applyDelta(delta, true);\n    };\n    this.revertDelta = function(delta) {\n        this.applyDelta({\n            start: this.clonePos(delta.start),\n            end: this.clonePos(delta.end),\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    };\n    this.indexToPosition = function(index, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return {row: i, column: index + lines[i].length + newlineLength};\n        }\n        return {row: l-1, column: index + lines[l-1].length + newlineLength};\n    };\n    this.positionToIndex = function(pos, startRow) {\n        var lines = this.$lines || this.getAllLines();\n        var newlineLength = this.getNewLineCharacter().length;\n        var index = 0;\n        var row = Math.min(pos.row, lines.length);\n        for (var i = startRow || 0; i < row; ++i)\n            index += lines[i].length + newlineLength;\n\n        return index + pos.column;\n    };\n\n}).call(Document.prototype);\n\nexports.Document = Document;\n});\n\nace.define(\"ace/background_tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n\nvar BackgroundTokenizer = function(tokenizer, editor) {\n    this.running = false;\n    this.lines = [];\n    this.states = [];\n    this.currentLine = 0;\n    this.tokenizer = tokenizer;\n\n    var self = this;\n\n    this.$worker = function() {\n        if (!self.running) { return; }\n\n        var workerStart = new Date();\n        var currentLine = self.currentLine;\n        var endLine = -1;\n        var doc = self.doc;\n\n        var startLine = currentLine;\n        while (self.lines[currentLine])\n            currentLine++;\n        \n        var len = doc.getLength();\n        var processedLines = 0;\n        self.running = false;\n        while (currentLine < len) {\n            self.$tokenizeRow(currentLine);\n            endLine = currentLine;\n            do {\n                currentLine++;\n            } while (self.lines[currentLine]);\n            processedLines ++;\n            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {\n                self.running = setTimeout(self.$worker, 20);\n                break;\n            }\n        }\n        self.currentLine = currentLine;\n        \n        if (endLine == -1)\n            endLine = currentLine;\n        \n        if (startLine <= endLine)\n            self.fireUpdateEvent(startLine, endLine);\n    };\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n    this.setTokenizer = function(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.lines = [];\n        this.states = [];\n\n        this.start(0);\n    };\n    this.setDocument = function(doc) {\n        this.doc = doc;\n        this.lines = [];\n        this.states = [];\n\n        this.stop();\n    };\n    this.fireUpdateEvent = function(firstRow, lastRow) {\n        var data = {\n            first: firstRow,\n            last: lastRow\n        };\n        this._signal(\"update\", {data: data});\n    };\n    this.start = function(startRow) {\n        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\n        this.lines.splice(this.currentLine, this.lines.length);\n        this.states.splice(this.currentLine, this.states.length);\n\n        this.stop();\n        this.running = setTimeout(this.$worker, 700);\n    };\n    \n    this.scheduleStart = function() {\n        if (!this.running)\n            this.running = setTimeout(this.$worker, 700);\n    };\n\n    this.$updateOnChange = function(delta) {\n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n\n        if (len === 0) {\n            this.lines[startRow] = null;\n        } else if (delta.action == \"remove\") {\n            this.lines.splice(startRow, len + 1, null);\n            this.states.splice(startRow, len + 1, null);\n        } else {\n            var args = Array(len + 1);\n            args.unshift(startRow, 1);\n            this.lines.splice.apply(this.lines, args);\n            this.states.splice.apply(this.states, args);\n        }\n\n        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\n\n        this.stop();\n    };\n    this.stop = function() {\n        if (this.running)\n            clearTimeout(this.running);\n        this.running = false;\n    };\n    this.getTokens = function(row) {\n        return this.lines[row] || this.$tokenizeRow(row);\n    };\n    this.getState = function(row) {\n        if (this.currentLine == row)\n            this.$tokenizeRow(row);\n        return this.states[row] || \"start\";\n    };\n\n    this.$tokenizeRow = function(row) {\n        var line = this.doc.getLine(row);\n        var state = this.states[row - 1];\n\n        var data = this.tokenizer.getLineTokens(line, state, row);\n\n        if (this.states[row] + \"\" !== data.state + \"\") {\n            this.states[row] = data.state;\n            this.lines[row + 1] = null;\n            if (this.currentLine > row + 1)\n                this.currentLine = row + 1;\n        } else if (this.currentLine == row) {\n            this.currentLine = row + 1;\n        }\n\n        return this.lines[row] = data.tokens;\n    };\n\n}).call(BackgroundTokenizer.prototype);\n\nexports.BackgroundTokenizer = BackgroundTokenizer;\n});\n\nace.define(\"ace/search_highlight\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\n\nvar SearchHighlight = function(regExp, clazz, type) {\n    this.setRegexp(regExp);\n    this.clazz = clazz;\n    this.type = type || \"text\";\n};\n\n(function() {\n    this.MAX_RANGES = 500;\n    \n    this.setRegexp = function(regExp) {\n        if (this.regExp+\"\" == regExp+\"\")\n            return;\n        this.regExp = regExp;\n        this.cache = [];\n    };\n\n    this.update = function(html, markerLayer, session, config) {\n        if (!this.regExp)\n            return;\n        var start = config.firstRow, end = config.lastRow;\n\n        for (var i = start; i <= end; i++) {\n            var ranges = this.cache[i];\n            if (ranges == null) {\n                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);\n                if (ranges.length > this.MAX_RANGES)\n                    ranges = ranges.slice(0, this.MAX_RANGES);\n                ranges = ranges.map(function(match) {\n                    return new Range(i, match.offset, i, match.offset + match.length);\n                });\n                this.cache[i] = ranges.length ? ranges : \"\";\n            }\n\n            for (var j = ranges.length; j --; ) {\n                markerLayer.drawSingleLineMarker(\n                    html, ranges[j].toScreenRange(session), this.clazz, config);\n            }\n        }\n    };\n\n}).call(SearchHighlight.prototype);\n\nexports.SearchHighlight = SearchHighlight;\n});\n\nace.define(\"ace/edit_session/fold_line\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nfunction FoldLine(foldData, folds) {\n    this.foldData = foldData;\n    if (Array.isArray(folds)) {\n        this.folds = folds;\n    } else {\n        folds = this.folds = [ folds ];\n    }\n\n    var last = folds[folds.length - 1];\n    this.range = new Range(folds[0].start.row, folds[0].start.column,\n                           last.end.row, last.end.column);\n    this.start = this.range.start;\n    this.end   = this.range.end;\n\n    this.folds.forEach(function(fold) {\n        fold.setFoldLine(this);\n    }, this);\n}\n\n(function() {\n    this.shiftRow = function(shift) {\n        this.start.row += shift;\n        this.end.row += shift;\n        this.folds.forEach(function(fold) {\n            fold.start.row += shift;\n            fold.end.row += shift;\n        });\n    };\n\n    this.addFold = function(fold) {\n        if (fold.sameRow) {\n            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\n                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\n            }\n            this.folds.push(fold);\n            this.folds.sort(function(a, b) {\n                return -a.range.compareEnd(b.start.row, b.start.column);\n            });\n            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\n                this.end.row = fold.end.row;\n                this.end.column =  fold.end.column;\n            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\n                this.start.row = fold.start.row;\n                this.start.column = fold.start.column;\n            }\n        } else if (fold.start.row == this.end.row) {\n            this.folds.push(fold);\n            this.end.row = fold.end.row;\n            this.end.column = fold.end.column;\n        } else if (fold.end.row == this.start.row) {\n            this.folds.unshift(fold);\n            this.start.row = fold.start.row;\n            this.start.column = fold.start.column;\n        } else {\n            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\n        }\n        fold.foldLine = this;\n    };\n\n    this.containsRow = function(row) {\n        return row >= this.start.row && row <= this.end.row;\n    };\n\n    this.walk = function(callback, endRow, endColumn) {\n        var lastEnd = 0,\n            folds = this.folds,\n            fold,\n            cmp, stop, isNewRow = true;\n\n        if (endRow == null) {\n            endRow = this.end.row;\n            endColumn = this.end.column;\n        }\n\n        for (var i = 0; i < folds.length; i++) {\n            fold = folds[i];\n\n            cmp = fold.range.compareStart(endRow, endColumn);\n            if (cmp == -1) {\n                callback(null, endRow, endColumn, lastEnd, isNewRow);\n                return;\n            }\n\n            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\n            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\n            if (stop || cmp === 0) {\n                return;\n            }\n            isNewRow = !fold.sameRow;\n            lastEnd = fold.end.column;\n        }\n        callback(null, endRow, endColumn, lastEnd, isNewRow);\n    };\n\n    this.getNextFoldTo = function(row, column) {\n        var fold, cmp;\n        for (var i = 0; i < this.folds.length; i++) {\n            fold = this.folds[i];\n            cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                return {\n                    fold: fold,\n                    kind: \"after\"\n                };\n            } else if (cmp === 0) {\n                return {\n                    fold: fold,\n                    kind: \"inside\"\n                };\n            }\n        }\n        return null;\n    };\n\n    this.addRemoveChars = function(row, column, len) {\n        var ret = this.getNextFoldTo(row, column),\n            fold, folds;\n        if (ret) {\n            fold = ret.fold;\n            if (ret.kind == \"inside\"\n                && fold.start.column != column\n                && fold.start.row != row)\n            {\n                window.console && window.console.log(row, column, fold);\n            } else if (fold.start.row == row) {\n                folds = this.folds;\n                var i = folds.indexOf(fold);\n                if (i === 0) {\n                    this.start.column += len;\n                }\n                for (i; i < folds.length; i++) {\n                    fold = folds[i];\n                    fold.start.column += len;\n                    if (!fold.sameRow) {\n                        return;\n                    }\n                    fold.end.column += len;\n                }\n                this.end.column += len;\n            }\n        }\n    };\n\n    this.split = function(row, column) {\n        var pos = this.getNextFoldTo(row, column);\n        \n        if (!pos || pos.kind == \"inside\")\n            return null;\n            \n        var fold = pos.fold;\n        var folds = this.folds;\n        var foldData = this.foldData;\n        \n        var i = folds.indexOf(fold);\n        var foldBefore = folds[i - 1];\n        this.end.row = foldBefore.end.row;\n        this.end.column = foldBefore.end.column;\n        folds = folds.splice(i, folds.length - i);\n\n        var newFoldLine = new FoldLine(foldData, folds);\n        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\n        return newFoldLine;\n    };\n\n    this.merge = function(foldLineNext) {\n        var folds = foldLineNext.folds;\n        for (var i = 0; i < folds.length; i++) {\n            this.addFold(folds[i]);\n        }\n        var foldData = this.foldData;\n        foldData.splice(foldData.indexOf(foldLineNext), 1);\n    };\n\n    this.toString = function() {\n        var ret = [this.range.toString() + \": [\" ];\n\n        this.folds.forEach(function(fold) {\n            ret.push(\"  \" + fold.toString());\n        });\n        ret.push(\"]\");\n        return ret.join(\"\\n\");\n    };\n\n    this.idxToPosition = function(idx) {\n        var lastFoldEndColumn = 0;\n\n        for (var i = 0; i < this.folds.length; i++) {\n            var fold = this.folds[i];\n\n            idx -= fold.start.column - lastFoldEndColumn;\n            if (idx < 0) {\n                return {\n                    row: fold.start.row,\n                    column: fold.start.column + idx\n                };\n            }\n\n            idx -= fold.placeholder.length;\n            if (idx < 0) {\n                return fold.start;\n            }\n\n            lastFoldEndColumn = fold.end.column;\n        }\n\n        return {\n            row: this.end.row,\n            column: this.end.column + idx\n        };\n    };\n}).call(FoldLine.prototype);\n\nexports.FoldLine = FoldLine;\n});\n\nace.define(\"ace/range_list\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar Range = require(\"./range\").Range;\nvar comparePoints = Range.comparePoints;\n\nvar RangeList = function() {\n    this.ranges = [];\n    this.$bias = 1;\n};\n\n(function() {\n    this.comparePoints = comparePoints;\n\n    this.pointIndex = function(pos, excludeEdges, startIndex) {\n        var list = this.ranges;\n\n        for (var i = startIndex || 0; i < list.length; i++) {\n            var range = list[i];\n            var cmpEnd = comparePoints(pos, range.end);\n            if (cmpEnd > 0)\n                continue;\n            var cmpStart = comparePoints(pos, range.start);\n            if (cmpEnd === 0)\n                return excludeEdges && cmpStart !== 0 ? -i-2 : i;\n            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))\n                return i;\n\n            return -i-1;\n        }\n        return -i - 1;\n    };\n\n    this.add = function(range) {\n        var excludeEdges = !range.isEmpty();\n        var startIndex = this.pointIndex(range.start, excludeEdges);\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n\n        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);\n\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n        else\n            endIndex++;\n        return this.ranges.splice(startIndex, endIndex - startIndex, range);\n    };\n\n    this.addList = function(list) {\n        var removed = [];\n        for (var i = list.length; i--; ) {\n            removed.push.apply(removed, this.add(list[i]));\n        }\n        return removed;\n    };\n\n    this.substractPoint = function(pos) {\n        var i = this.pointIndex(pos);\n\n        if (i >= 0)\n            return this.ranges.splice(i, 1);\n    };\n    this.merge = function() {\n        var removed = [];\n        var list = this.ranges;\n        \n        list = list.sort(function(a, b) {\n            return comparePoints(a.start, b.start);\n        });\n        \n        var next = list[0], range;\n        for (var i = 1; i < list.length; i++) {\n            range = next;\n            next = list[i];\n            var cmp = comparePoints(range.end, next.start);\n            if (cmp < 0)\n                continue;\n\n            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())\n                continue;\n\n            if (comparePoints(range.end, next.end) < 0) {\n                range.end.row = next.end.row;\n                range.end.column = next.end.column;\n            }\n\n            list.splice(i, 1);\n            removed.push(next);\n            next = range;\n            i--;\n        }\n        \n        this.ranges = list;\n\n        return removed;\n    };\n\n    this.contains = function(row, column) {\n        return this.pointIndex({row: row, column: column}) >= 0;\n    };\n\n    this.containsPoint = function(pos) {\n        return this.pointIndex(pos) >= 0;\n    };\n\n    this.rangeAtPoint = function(pos) {\n        var i = this.pointIndex(pos);\n        if (i >= 0)\n            return this.ranges[i];\n    };\n\n\n    this.clipRows = function(startRow, endRow) {\n        var list = this.ranges;\n        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)\n            return [];\n\n        var startIndex = this.pointIndex({row: startRow, column: 0});\n        if (startIndex < 0)\n            startIndex = -startIndex - 1;\n        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);\n        if (endIndex < 0)\n            endIndex = -endIndex - 1;\n\n        var clipped = [];\n        for (var i = startIndex; i < endIndex; i++) {\n            clipped.push(list[i]);\n        }\n        return clipped;\n    };\n\n    this.removeAll = function() {\n        return this.ranges.splice(0, this.ranges.length);\n    };\n\n    this.attach = function(session) {\n        if (this.session)\n            this.detach();\n\n        this.session = session;\n        this.onChange = this.$onChange.bind(this);\n\n        this.session.on('change', this.onChange);\n    };\n\n    this.detach = function() {\n        if (!this.session)\n            return;\n        this.session.removeListener('change', this.onChange);\n        this.session = null;\n    };\n\n    this.$onChange = function(delta) {\n        var start = delta.start;\n        var end = delta.end;\n        var startRow = start.row;\n        var endRow = end.row;\n        var ranges = this.ranges;\n        for (var i = 0, n = ranges.length; i < n; i++) {\n            var r = ranges[i];\n            if (r.end.row >= startRow)\n                break;\n        }\n        \n        if (delta.action == \"insert\") {\n            var lineDif = endRow - startRow;\n            var colDiff = -start.column + end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                if (r.start.row > startRow)\n                    break;\n    \n                if (r.start.row == startRow && r.start.column >= start.column) {\n                    if (r.start.column == start.column && this.$bias <= 0) {\n                    } else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                if (r.end.row == startRow && r.end.column >= start.column) {\n                    if (r.end.column == start.column && this.$bias < 0) {\n                        continue;\n                    }\n                    if (r.end.column == start.column && colDiff > 0 && i < n - 1) {\n                        if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)\n                            r.end.column -= colDiff;\n                    }\n                    r.end.column += colDiff;\n                    r.end.row += lineDif;\n                }\n            }\n        } else {\n            var lineDif = startRow - endRow;\n            var colDiff = start.column - end.column;\n            for (; i < n; i++) {\n                var r = ranges[i];\n                \n                if (r.start.row > endRow)\n                    break;\n                    \n                if (r.end.row < endRow\n                    && (\n                        startRow < r.end.row \n                        || startRow == r.end.row && start.column < r.end.column\n                    )\n                ) {\n                    r.end.row = startRow;\n                    r.end.column = start.column;\n                }\n                else if (r.end.row == endRow) {\n                    if (r.end.column <= end.column) {\n                        if (lineDif || r.end.column > start.column) {\n                            r.end.column = start.column;\n                            r.end.row = start.row;\n                        }\n                    }\n                    else {\n                        r.end.column += colDiff;\n                        r.end.row += lineDif;\n                    }\n                }\n                else if (r.end.row > endRow) {\n                    r.end.row += lineDif;\n                }\n                \n                if (r.start.row < endRow\n                    && (\n                        startRow < r.start.row \n                        || startRow == r.start.row && start.column < r.start.column\n                    )\n                ) {\n                    r.start.row = startRow;\n                    r.start.column = start.column;\n                }\n                else if (r.start.row == endRow) {\n                    if (r.start.column <= end.column) {\n                        if (lineDif || r.start.column > start.column) {\n                            r.start.column = start.column;\n                            r.start.row = start.row;\n                        }\n                    }\n                    else {\n                        r.start.column += colDiff;\n                        r.start.row += lineDif;\n                    }\n                }\n                else if (r.start.row > endRow) {\n                    r.start.row += lineDif;\n                }\n            }\n        }\n\n        if (lineDif != 0 && i < n) {\n            for (; i < n; i++) {\n                var r = ranges[i];\n                r.start.row += lineDif;\n                r.end.row += lineDif;\n            }\n        }\n    };\n\n}).call(RangeList.prototype);\n\nexports.RangeList = RangeList;\n});\n\nace.define(\"ace/edit_session/fold\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar RangeList = require(\"../range_list\").RangeList;\nvar oop = require(\"../lib/oop\");\nvar Fold = exports.Fold = function(range, placeholder) {\n    this.foldLine = null;\n    this.placeholder = placeholder;\n    this.range = range;\n    this.start = range.start;\n    this.end = range.end;\n\n    this.sameRow = range.start.row == range.end.row;\n    this.subFolds = this.ranges = [];\n};\n\noop.inherits(Fold, RangeList);\n\n(function() {\n\n    this.toString = function() {\n        return '\"' + this.placeholder + '\" ' + this.range.toString();\n    };\n\n    this.setFoldLine = function(foldLine) {\n        this.foldLine = foldLine;\n        this.subFolds.forEach(function(fold) {\n            fold.setFoldLine(foldLine);\n        });\n    };\n\n    this.clone = function() {\n        var range = this.range.clone();\n        var fold = new Fold(range, this.placeholder);\n        this.subFolds.forEach(function(subFold) {\n            fold.subFolds.push(subFold.clone());\n        });\n        fold.collapseChildren = this.collapseChildren;\n        return fold;\n    };\n\n    this.addSubFold = function(fold) {\n        if (this.range.isEqual(fold))\n            return;\n        consumeRange(fold, this.start);\n\n        var row = fold.start.row, column = fold.start.column;\n        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {\n            cmp = this.subFolds[i].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        var afterStart = this.subFolds[i];\n        var firstConsumed = 0;\n\n        if (cmp == 0) {\n            if (afterStart.range.containsRange(fold))\n                return afterStart.addSubFold(fold);\n            else\n                firstConsumed = 1;\n        }\n        var row = fold.range.end.row, column = fold.range.end.column;\n        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {\n            cmp = this.subFolds[j].range.compare(row, column);\n            if (cmp != 1)\n                break;\n        }\n        if (cmp == 0)  j++;\n        var consumedFolds = this.subFolds.splice(i, j - i, fold);\n        var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;\n        for (var k = firstConsumed; k < last; k++) {\n            fold.addSubFold(consumedFolds[k]);\n        }\n        fold.setFoldLine(this.foldLine);\n\n        return fold;\n    };\n    \n    this.restoreRange = function(range) {\n        return restoreRange(range, this.start);\n    };\n\n}).call(Fold.prototype);\n\nfunction consumePoint(point, anchor) {\n    point.row -= anchor.row;\n    if (point.row == 0)\n        point.column -= anchor.column;\n}\nfunction consumeRange(range, anchor) {\n    consumePoint(range.start, anchor);\n    consumePoint(range.end, anchor);\n}\nfunction restorePoint(point, anchor) {\n    if (point.row == 0)\n        point.column += anchor.column;\n    point.row += anchor.row;\n}\nfunction restoreRange(range, anchor) {\n    restorePoint(range.start, anchor);\n    restorePoint(range.end, anchor);\n}\n\n});\n\nace.define(\"ace/edit_session/folding\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/edit_session/fold_line\",\"ace/edit_session/fold\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar FoldLine = require(\"./fold_line\").FoldLine;\nvar Fold = require(\"./fold\").Fold;\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\n\nfunction Folding() {\n    this.getFoldAt = function(row, column, side) {\n        var foldLine = this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n\n        var folds = foldLine.folds;\n        for (var i = 0; i < folds.length; i++) {\n            var range = folds[i].range;\n            if (range.contains(row, column)) {\n                if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {\n                    continue;\n                } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {\n                    continue;\n                }\n                return folds[i];\n            }\n        }\n    };\n    this.getFoldsInRange = function(range) {\n        var start = range.start;\n        var end = range.end;\n        var foldLines = this.$foldData;\n        var foundFolds = [];\n\n        start.column += 1;\n        end.column -= 1;\n\n        for (var i = 0; i < foldLines.length; i++) {\n            var cmp = foldLines[i].range.compareRange(range);\n            if (cmp == 2) {\n                continue;\n            }\n            else if (cmp == -2) {\n                break;\n            }\n\n            var folds = foldLines[i].folds;\n            for (var j = 0; j < folds.length; j++) {\n                var fold = folds[j];\n                cmp = fold.range.compareRange(range);\n                if (cmp == -2) {\n                    break;\n                } else if (cmp == 2) {\n                    continue;\n                } else\n                if (cmp == 42) {\n                    break;\n                }\n                foundFolds.push(fold);\n            }\n        }\n        start.column -= 1;\n        end.column += 1;\n\n        return foundFolds;\n    };\n\n    this.getFoldsInRangeList = function(ranges) {\n        if (Array.isArray(ranges)) {\n            var folds = [];\n            ranges.forEach(function(range) {\n                folds = folds.concat(this.getFoldsInRange(range));\n            }, this);\n        } else {\n            var folds = this.getFoldsInRange(ranges);\n        }\n        return folds;\n    };\n    this.getAllFolds = function() {\n        var folds = [];\n        var foldLines = this.$foldData;\n        \n        for (var i = 0; i < foldLines.length; i++)\n            for (var j = 0; j < foldLines[i].folds.length; j++)\n                folds.push(foldLines[i].folds[j]);\n\n        return folds;\n    };\n    this.getFoldStringAt = function(row, column, trim, foldLine) {\n        foldLine = foldLine || this.getFoldLine(row);\n        if (!foldLine)\n            return null;\n\n        var lastFold = {\n            end: { column: 0 }\n        };\n        var str, fold;\n        for (var i = 0; i < foldLine.folds.length; i++) {\n            fold = foldLine.folds[i];\n            var cmp = fold.range.compareEnd(row, column);\n            if (cmp == -1) {\n                str = this\n                    .getLine(fold.start.row)\n                    .substring(lastFold.end.column, fold.start.column);\n                break;\n            }\n            else if (cmp === 0) {\n                return null;\n            }\n            lastFold = fold;\n        }\n        if (!str)\n            str = this.getLine(fold.start.row).substring(lastFold.end.column);\n\n        if (trim == -1)\n            return str.substring(0, column - lastFold.end.column);\n        else if (trim == 1)\n            return str.substring(column - lastFold.end.column);\n        else\n            return str;\n    };\n\n    this.getFoldLine = function(docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\n                return foldLine;\n            } else if (foldLine.end.row > docRow) {\n                return null;\n            }\n        }\n        return null;\n    };\n    this.getNextFoldLine = function(docRow, startFoldLine) {\n        var foldData = this.$foldData;\n        var i = 0;\n        if (startFoldLine)\n            i = foldData.indexOf(startFoldLine);\n        if (i == -1)\n            i = 0;\n        for (i; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (foldLine.end.row >= docRow) {\n                return foldLine;\n            }\n        }\n        return null;\n    };\n\n    this.getFoldedRowCount = function(first, last) {\n        var foldData = this.$foldData, rowCount = last-first+1;\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i],\n                end = foldLine.end.row,\n                start = foldLine.start.row;\n            if (end >= last) {\n                if (start < last) {\n                    if (start >= first)\n                        rowCount -= last-start;\n                    else\n                        rowCount = 0; // in one fold\n                }\n                break;\n            } else if (end >= first){\n                if (start >= first) // fold inside range\n                    rowCount -=  end-start;\n                else\n                    rowCount -=  end-first+1;\n            }\n        }\n        return rowCount;\n    };\n\n    this.$addFoldLine = function(foldLine) {\n        this.$foldData.push(foldLine);\n        this.$foldData.sort(function(a, b) {\n            return a.start.row - b.start.row;\n        });\n        return foldLine;\n    };\n    this.addFold = function(placeholder, range) {\n        var foldData = this.$foldData;\n        var added = false;\n        var fold;\n        \n        if (placeholder instanceof Fold)\n            fold = placeholder;\n        else {\n            fold = new Fold(range, placeholder);\n            fold.collapseChildren = range.collapseChildren;\n        }\n        this.$clipRangeToDocument(fold.range);\n\n        var startRow = fold.start.row;\n        var startColumn = fold.start.column;\n        var endRow = fold.end.row;\n        var endColumn = fold.end.column;\n\n        var startFold = this.getFoldAt(startRow, startColumn, 1);\n        var endFold = this.getFoldAt(endRow, endColumn, -1);\n        if (startFold && endFold == startFold)\n            return startFold.addSubFold(fold);\n\n        if (startFold && !startFold.range.isStart(startRow, startColumn))\n            this.removeFold(startFold);\n        \n        if (endFold && !endFold.range.isEnd(endRow, endColumn))\n            this.removeFold(endFold);\n        var folds = this.getFoldsInRange(fold.range);\n        if (folds.length > 0) {\n            this.removeFolds(folds);\n            folds.forEach(function(subFold) {\n                fold.addSubFold(subFold);\n            });\n        }\n\n        for (var i = 0; i < foldData.length; i++) {\n            var foldLine = foldData[i];\n            if (endRow == foldLine.start.row) {\n                foldLine.addFold(fold);\n                added = true;\n                break;\n            } else if (startRow == foldLine.end.row) {\n                foldLine.addFold(fold);\n                added = true;\n                if (!fold.sameRow) {\n                    var foldLineNext = foldData[i + 1];\n                    if (foldLineNext && foldLineNext.start.row == endRow) {\n                        foldLine.merge(foldLineNext);\n                        break;\n                    }\n                }\n                break;\n            } else if (endRow <= foldLine.start.row) {\n                break;\n            }\n        }\n\n        if (!added)\n            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\n\n        if (this.$useWrapMode)\n            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\n        else\n            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"add\" });\n\n        return fold;\n    };\n\n    this.addFolds = function(folds) {\n        folds.forEach(function(fold) {\n            this.addFold(fold);\n        }, this);\n    };\n\n    this.removeFold = function(fold) {\n        var foldLine = fold.foldLine;\n        var startRow = foldLine.start.row;\n        var endRow = foldLine.end.row;\n\n        var foldLines = this.$foldData;\n        var folds = foldLine.folds;\n        if (folds.length == 1) {\n            foldLines.splice(foldLines.indexOf(foldLine), 1);\n        } else\n        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\n            folds.pop();\n            foldLine.end.row = folds[folds.length - 1].end.row;\n            foldLine.end.column = folds[folds.length - 1].end.column;\n        } else\n        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\n            folds.shift();\n            foldLine.start.row = folds[0].start.row;\n            foldLine.start.column = folds[0].start.column;\n        } else\n        if (fold.sameRow) {\n            folds.splice(folds.indexOf(fold), 1);\n        } else\n        {\n            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\n            folds = newFoldLine.folds;\n            folds.shift();\n            newFoldLine.start.row = folds[0].start.row;\n            newFoldLine.start.column = folds[0].start.column;\n        }\n\n        if (!this.$updating) {\n            if (this.$useWrapMode)\n                this.$updateWrapData(startRow, endRow);\n            else\n                this.$updateRowLengthCache(startRow, endRow);\n        }\n        this.$modified = true;\n        this._signal(\"changeFold\", { data: fold, action: \"remove\" });\n    };\n\n    this.removeFolds = function(folds) {\n        var cloneFolds = [];\n        for (var i = 0; i < folds.length; i++) {\n            cloneFolds.push(folds[i]);\n        }\n\n        cloneFolds.forEach(function(fold) {\n            this.removeFold(fold);\n        }, this);\n        this.$modified = true;\n    };\n\n    this.expandFold = function(fold) {\n        this.removeFold(fold);\n        fold.subFolds.forEach(function(subFold) {\n            fold.restoreRange(subFold);\n            this.addFold(subFold);\n        }, this);\n        if (fold.collapseChildren > 0) {\n            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);\n        }\n        fold.subFolds = [];\n    };\n\n    this.expandFolds = function(folds) {\n        folds.forEach(function(fold) {\n            this.expandFold(fold);\n        }, this);\n    };\n\n    this.unfold = function(location, expandInner) {\n        var range, folds;\n        if (location == null) {\n            range = new Range(0, 0, this.getLength(), 0);\n            expandInner = true;\n        } else if (typeof location == \"number\")\n            range = new Range(location, 0, location, this.getLine(location).length);\n        else if (\"row\" in location)\n            range = Range.fromPoints(location, location);\n        else\n            range = location;\n        \n        folds = this.getFoldsInRangeList(range);\n        if (expandInner) {\n            this.removeFolds(folds);\n        } else {\n            var subFolds = folds;\n            while (subFolds.length) {\n                this.expandFolds(subFolds);\n                subFolds = this.getFoldsInRangeList(range);\n            }\n        }\n        if (folds.length)\n            return folds;\n    };\n    this.isRowFolded = function(docRow, startFoldRow) {\n        return !!this.getFoldLine(docRow, startFoldRow);\n    };\n\n    this.getRowFoldEnd = function(docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.end.row : docRow;\n    };\n\n    this.getRowFoldStart = function(docRow, startFoldRow) {\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\n        return foldLine ? foldLine.start.row : docRow;\n    };\n\n    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {\n        if (startRow == null)\n            startRow = foldLine.start.row;\n        if (startColumn == null)\n            startColumn = 0;\n        if (endRow == null)\n            endRow = foldLine.end.row;\n        if (endColumn == null)\n            endColumn = this.getLine(endRow).length;\n        var doc = this.doc;\n        var textLine = \"\";\n\n        foldLine.walk(function(placeholder, row, column, lastColumn) {\n            if (row < startRow)\n                return;\n            if (row == startRow) {\n                if (column < startColumn)\n                    return;\n                lastColumn = Math.max(startColumn, lastColumn);\n            }\n\n            if (placeholder != null) {\n                textLine += placeholder;\n            } else {\n                textLine += doc.getLine(row).substring(lastColumn, column);\n            }\n        }, endRow, endColumn);\n        return textLine;\n    };\n\n    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {\n        var foldLine = this.getFoldLine(row);\n\n        if (!foldLine) {\n            var line;\n            line = this.doc.getLine(row);\n            return line.substring(startColumn || 0, endColumn || line.length);\n        } else {\n            return this.getFoldDisplayLine(\n                foldLine, row, endColumn, startRow, startColumn);\n        }\n    };\n\n    this.$cloneFoldData = function() {\n        var fd = [];\n        fd = this.$foldData.map(function(foldLine) {\n            var folds = foldLine.folds.map(function(fold) {\n                return fold.clone();\n            });\n            return new FoldLine(fd, folds);\n        });\n\n        return fd;\n    };\n\n    this.toggleFold = function(tryToUnfold) {\n        var selection = this.selection;\n        var range = selection.getRange();\n        var fold;\n        var bracketPos;\n\n        if (range.isEmpty()) {\n            var cursor = range.start;\n            fold = this.getFoldAt(cursor.row, cursor.column);\n\n            if (fold) {\n                this.expandFold(fold);\n                return;\n            } else if (bracketPos = this.findMatchingBracket(cursor)) {\n                if (range.comparePoint(bracketPos) == 1) {\n                    range.end = bracketPos;\n                } else {\n                    range.start = bracketPos;\n                    range.start.column++;\n                    range.end.column--;\n                }\n            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {\n                if (range.comparePoint(bracketPos) == 1)\n                    range.end = bracketPos;\n                else\n                    range.start = bracketPos;\n\n                range.start.column++;\n            } else {\n                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\n            }\n        } else {\n            var folds = this.getFoldsInRange(range);\n            if (tryToUnfold && folds.length) {\n                this.expandFolds(folds);\n                return;\n            } else if (folds.length == 1 ) {\n                fold = folds[0];\n            }\n        }\n\n        if (!fold)\n            fold = this.getFoldAt(range.start.row, range.start.column);\n\n        if (fold && fold.range.toString() == range.toString()) {\n            this.expandFold(fold);\n            return;\n        }\n\n        var placeholder = \"...\";\n        if (!range.isMultiLine()) {\n            placeholder = this.getTextRange(range);\n            if (placeholder.length < 4)\n                return;\n            placeholder = placeholder.trim().substring(0, 2) + \"..\";\n        }\n\n        this.addFold(placeholder, range);\n    };\n\n    this.getCommentFoldRange = function(row, column, dir) {\n        var iterator = new TokenIterator(this, row, column);\n        var token = iterator.getCurrentToken();\n        var type = token.type;\n        if (token && /^comment|string/.test(type)) {\n            type = type.match(/comment|string/)[0];\n            if (type == \"comment\")\n                type += \"|doc-start\";\n            var re = new RegExp(type);\n            var range = new Range();\n            if (dir != 1) {\n                do {\n                    token = iterator.stepBackward();\n                } while (token && re.test(token.type));\n                iterator.stepForward();\n            }\n            \n            range.start.row = iterator.getCurrentTokenRow();\n            range.start.column = iterator.getCurrentTokenColumn() + 2;\n\n            iterator = new TokenIterator(this, row, column);\n            \n            if (dir != -1) {\n                var lastRow = -1;\n                do {\n                    token = iterator.stepForward();\n                    if (lastRow == -1) {\n                        var state = this.getState(iterator.$row);\n                        if (!re.test(state))\n                            lastRow = iterator.$row;\n                    } else if (iterator.$row > lastRow) {\n                        break;\n                    }\n                } while (token && re.test(token.type));\n                token = iterator.stepBackward();\n            } else\n                token = iterator.getCurrentToken();\n\n            range.end.row = iterator.getCurrentTokenRow();\n            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;\n            return range;\n        }\n    };\n\n    this.foldAll = function(startRow, endRow, depth) {\n        if (depth == undefined)\n            depth = 100000; // JSON.stringify doesn't hanle Infinity\n        var foldWidgets = this.foldWidgets;\n        if (!foldWidgets)\n            return; // mode doesn't support folding\n        endRow = endRow || this.getLength();\n        startRow = startRow || 0;\n        for (var row = startRow; row < endRow; row++) {\n            if (foldWidgets[row] == null)\n                foldWidgets[row] = this.getFoldWidget(row);\n            if (foldWidgets[row] != \"start\")\n                continue;\n\n            var range = this.getFoldWidgetRange(row);\n            if (range && range.isMultiLine()\n                && range.end.row <= endRow\n                && range.start.row >= startRow\n            ) {\n                row = range.end.row;\n                try {\n                    var fold = this.addFold(\"...\", range);\n                    if (fold)\n                        fold.collapseChildren = depth;\n                } catch(e) {}\n            }\n        }\n    };\n    this.$foldStyles = {\n        \"manual\": 1,\n        \"markbegin\": 1,\n        \"markbeginend\": 1\n    };\n    this.$foldStyle = \"markbegin\";\n    this.setFoldStyle = function(style) {\n        if (!this.$foldStyles[style])\n            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\n        \n        if (this.$foldStyle == style)\n            return;\n\n        this.$foldStyle = style;\n        \n        if (style == \"manual\")\n            this.unfold();\n        var mode = this.$foldMode;\n        this.$setFolding(null);\n        this.$setFolding(mode);\n    };\n\n    this.$setFolding = function(foldMode) {\n        if (this.$foldMode == foldMode)\n            return;\n            \n        this.$foldMode = foldMode;\n        \n        this.off('change', this.$updateFoldWidgets);\n        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n        this._signal(\"changeAnnotation\");\n        \n        if (!foldMode || this.$foldStyle == \"manual\") {\n            this.foldWidgets = null;\n            return;\n        }\n        \n        this.foldWidgets = [];\n        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\n        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\n        \n        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\n        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);\n        this.on('change', this.$updateFoldWidgets);\n        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\n    };\n\n    this.getParentFoldRangeData = function (row, ignoreCurrent) {\n        var fw = this.foldWidgets;\n        if (!fw || (ignoreCurrent && fw[row]))\n            return {};\n\n        var i = row - 1, firstRange;\n        while (i >= 0) {\n            var c = fw[i];\n            if (c == null)\n                c = fw[i] = this.getFoldWidget(i);\n\n            if (c == \"start\") {\n                var range = this.getFoldWidgetRange(i);\n                if (!firstRange)\n                    firstRange = range;\n                if (range && range.end.row >= row)\n                    break;\n            }\n            i--;\n        }\n\n        return {\n            range: i !== -1 && range,\n            firstRange: firstRange\n        };\n    };\n\n    this.onFoldWidgetClick = function(row, e) {\n        e = e.domEvent;\n        var options = {\n            children: e.shiftKey,\n            all: e.ctrlKey || e.metaKey,\n            siblings: e.altKey\n        };\n        \n        var range = this.$toggleFoldWidget(row, options);\n        if (!range) {\n            var el = (e.target || e.srcElement);\n            if (el && /ace_fold-widget/.test(el.className))\n                el.className += \" ace_invalid\";\n        }\n    };\n    \n    this.$toggleFoldWidget = function(row, options) {\n        if (!this.getFoldWidget)\n            return;\n        var type = this.getFoldWidget(row);\n        var line = this.getLine(row);\n\n        var dir = type === \"end\" ? -1 : 1;\n        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\n\n        if (fold) {\n            if (options.children || options.all)\n                this.removeFold(fold);\n            else\n                this.expandFold(fold);\n            return fold;\n        }\n\n        var range = this.getFoldWidgetRange(row, true);\n        if (range && !range.isMultiLine()) {\n            fold = this.getFoldAt(range.start.row, range.start.column, 1);\n            if (fold && range.isEqual(fold.range)) {\n                this.removeFold(fold);\n                return fold;\n            }\n        }\n        \n        if (options.siblings) {\n            var data = this.getParentFoldRangeData(row);\n            if (data.range) {\n                var startRow = data.range.start.row + 1;\n                var endRow = data.range.end.row;\n            }\n            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\n        } else if (options.children) {\n            endRow = range ? range.end.row : this.getLength();\n            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);\n        } else if (range) {\n            if (options.all) \n                range.collapseChildren = 10000;\n            this.addFold(\"...\", range);\n        }\n        \n        return range;\n    };\n    \n    \n    \n    this.toggleFoldWidget = function(toggleParent) {\n        var row = this.selection.getCursor().row;\n        row = this.getRowFoldStart(row);\n        var range = this.$toggleFoldWidget(row, {});\n        \n        if (range)\n            return;\n        var data = this.getParentFoldRangeData(row, true);\n        range = data.range || data.firstRange;\n        \n        if (range) {\n            row = range.start.row;\n            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\n\n            if (fold) {\n                this.removeFold(fold);\n            } else {\n                this.addFold(\"...\", range);\n            }\n        }\n    };\n\n    this.updateFoldWidgets = function(delta) {\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n\n        if (len === 0) {\n            this.foldWidgets[firstRow] = null;\n        } else if (delta.action == 'remove') {\n            this.foldWidgets.splice(firstRow, len + 1, null);\n        } else {\n            var args = Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.foldWidgets.splice.apply(this.foldWidgets, args);\n        }\n    };\n    this.tokenizerUpdateFoldWidgets = function(e) {\n        var rows = e.data;\n        if (rows.first != rows.last) {\n            if (this.foldWidgets.length > rows.first)\n                this.foldWidgets.splice(rows.first, this.foldWidgets.length);\n        }\n    };\n}\n\nexports.Folding = Folding;\n\n});\n\nace.define(\"ace/edit_session/bracket_match\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\nvar Range = require(\"../range\").Range;\n\n\nfunction BracketMatch() {\n\n    this.findMatchingBracket = function(position, chr) {\n        if (position.column == 0) return null;\n\n        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);\n        if (charBeforeCursor == \"\") return null;\n\n        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match)\n            return null;\n\n        if (match[1])\n            return this.$findClosingBracket(match[1], position);\n        else\n            return this.$findOpeningBracket(match[2], position);\n    };\n    \n    this.getBracketRange = function(pos) {\n        var line = this.getLine(pos.row);\n        var before = true, range;\n\n        var chr = line.charAt(pos.column - 1);\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match) {\n            chr = line.charAt(pos.column);\n            pos = {row: pos.row, column: pos.column + 1};\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n            before = false;\n        }\n        if (!match)\n            return null;\n\n        if (match[1]) {\n            var bracketPos = this.$findClosingBracket(match[1], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(pos, bracketPos);\n            if (!before) {\n                range.end.column++;\n                range.start.column--;\n            }\n            range.cursor = range.end;\n        } else {\n            var bracketPos = this.$findOpeningBracket(match[2], pos);\n            if (!bracketPos)\n                return null;\n            range = Range.fromPoints(bracketPos, pos);\n            if (!before) {\n                range.start.column++;\n                range.end.column--;\n            }\n            range.cursor = range.start;\n        }\n        \n        return range;\n    };\n    this.getMatchingBracketRanges = function(pos) {\n        var line = this.getLine(pos.row);\n\n        var chr = line.charAt(pos.column - 1);\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        if (!match) {\n            chr = line.charAt(pos.column);\n            pos = {row: pos.row, column: pos.column + 1};\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n        }\n\n        if (!match)\n            return null;\n\n        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);\n        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos)\n            : this.$findOpeningBracket(match[2], pos);\n        if (!bracketPos)\n            return [startRange];\n        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);\n\n        return [startRange, endRange];\n    };\n\n    this.$brackets = {\n        \")\": \"(\",\n        \"(\": \")\",\n        \"]\": \"[\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"<\": \">\",\n        \">\": \"<\"\n    };\n\n    this.$findOpeningBracket = function(bracket, position, typeRe) {\n        var openBracket = this.$brackets[bracket];\n        var depth = 1;\n\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n        \n         if (!typeRe){\n            typeRe = new RegExp(\n                \"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\n                    .replace(/\\b(?:end)\\b/, \"(?:start|begin|end)\")\n                + \")+\"\n            );\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\n        var value = token.value;\n        \n        while (true) {\n        \n            while (valueIndex >= 0) {\n                var chr = value.charAt(valueIndex);\n                if (chr == openBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return {row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex -= 1;\n            }\n            do {\n                token = iterator.stepBackward();\n            } while (token && !typeRe.test(token.type));\n\n            if (token == null)\n                break;\n                \n            value = token.value;\n            valueIndex = value.length - 1;\n        }\n        \n        return null;\n    };\n\n    this.$findClosingBracket = function(bracket, position, typeRe) {\n        var closingBracket = this.$brackets[bracket];\n        var depth = 1;\n\n        var iterator = new TokenIterator(this, position.row, position.column);\n        var token = iterator.getCurrentToken();\n        if (!token)\n            token = iterator.stepForward();\n        if (!token)\n            return;\n\n        if (!typeRe){\n            typeRe = new RegExp(\n                \"(\\\\.?\" +\n                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\n                    .replace(/\\b(?:start|begin)\\b/, \"(?:start|begin|end)\")\n                + \")+\"\n            );\n        }\n        var valueIndex = position.column - iterator.getCurrentTokenColumn();\n\n        while (true) {\n\n            var value = token.value;\n            var valueLength = value.length;\n            while (valueIndex < valueLength) {\n                var chr = value.charAt(valueIndex);\n                if (chr == closingBracket) {\n                    depth -= 1;\n                    if (depth == 0) {\n                        return {row: iterator.getCurrentTokenRow(),\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\n                    }\n                }\n                else if (chr == bracket) {\n                    depth += 1;\n                }\n                valueIndex += 1;\n            }\n            do {\n                token = iterator.stepForward();\n            } while (token && !typeRe.test(token.type));\n\n            if (token == null)\n                break;\n\n            valueIndex = 0;\n        }\n        \n        return null;\n    };\n}\nexports.BracketMatch = BracketMatch;\n\n});\n\nace.define(\"ace/edit_session\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/bidihandler\",\"ace/config\",\"ace/lib/event_emitter\",\"ace/selection\",\"ace/mode/text\",\"ace/range\",\"ace/document\",\"ace/background_tokenizer\",\"ace/search_highlight\",\"ace/edit_session/folding\",\"ace/edit_session/bracket_match\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar lang = require(\"./lib/lang\");\nvar BidiHandler = require(\"./bidihandler\").BidiHandler;\nvar config = require(\"./config\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar Selection = require(\"./selection\").Selection;\nvar TextMode = require(\"./mode/text\").Mode;\nvar Range = require(\"./range\").Range;\nvar Document = require(\"./document\").Document;\nvar BackgroundTokenizer = require(\"./background_tokenizer\").BackgroundTokenizer;\nvar SearchHighlight = require(\"./search_highlight\").SearchHighlight;\n\nvar EditSession = function(text, mode) {\n    this.$breakpoints = [];\n    this.$decorations = [];\n    this.$frontMarkers = {};\n    this.$backMarkers = {};\n    this.$markerId = 1;\n    this.$undoSelect = true;\n\n    this.$foldData = [];\n    this.id = \"session\" + (++EditSession.$uid);\n    this.$foldData.toString = function() {\n        return this.join(\"\\n\");\n    };\n    this.on(\"changeFold\", this.onChangeFold.bind(this));\n    this.$onChange = this.onChange.bind(this);\n\n    if (typeof text != \"object\" || !text.getLine)\n        text = new Document(text);\n\n    this.setDocument(text);\n    this.selection = new Selection(this);\n    this.$bidiHandler = new BidiHandler(this);\n\n    config.resetOptions(this);\n    this.setMode(mode);\n    config._signal(\"session\", this);\n};\n\n\nEditSession.$uid = 0;\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setDocument = function(doc) {\n        if (this.doc)\n            this.doc.removeListener(\"change\", this.$onChange);\n\n        this.doc = doc;\n        doc.on(\"change\", this.$onChange);\n\n        if (this.bgTokenizer)\n            this.bgTokenizer.setDocument(this.getDocument());\n\n        this.resetCaches();\n    };\n    this.getDocument = function() {\n        return this.doc;\n    };\n    this.$resetRowCache = function(docRow) {\n        if (!docRow) {\n            this.$docRowCache = [];\n            this.$screenRowCache = [];\n            return;\n        }\n        var l = this.$docRowCache.length;\n        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\n        if (l > i) {\n            this.$docRowCache.splice(i, l);\n            this.$screenRowCache.splice(i, l);\n        }\n    };\n\n    this.$getRowCacheIndex = function(cacheArray, val) {\n        var low = 0;\n        var hi = cacheArray.length - 1;\n\n        while (low <= hi) {\n            var mid = (low + hi) >> 1;\n            var c = cacheArray[mid];\n\n            if (val > c)\n                low = mid + 1;\n            else if (val < c)\n                hi = mid - 1;\n            else\n                return mid;\n        }\n\n        return low -1;\n    };\n\n    this.resetCaches = function() {\n        this.$modified = true;\n        this.$wrapData = [];\n        this.$rowLengthCache = [];\n        this.$resetRowCache(0);\n        if (this.bgTokenizer)\n            this.bgTokenizer.start(0);\n    };\n\n    this.onChangeFold = function(e) {\n        var fold = e.data;\n        this.$resetRowCache(fold.start.row);\n    };\n\n    this.onChange = function(delta) {\n        this.$modified = true;\n        this.$bidiHandler.onChange(delta);\n        this.$resetRowCache(delta.start.row);\n\n        var removedFolds = this.$updateInternalDataOnChange(delta);\n        if (!this.$fromUndo && this.$undoManager) {\n            if (removedFolds && removedFolds.length) {\n                this.$undoManager.add({\n                    action: \"removeFolds\",\n                    folds:  removedFolds\n                }, this.mergeUndoDeltas);\n                this.mergeUndoDeltas = true;\n            }\n            this.$undoManager.add(delta, this.mergeUndoDeltas);\n            this.mergeUndoDeltas = true;\n            \n            this.$informUndoManager.schedule();\n        }\n\n        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);\n        this._signal(\"change\", delta);\n    };\n    this.setValue = function(text) {\n        this.doc.setValue(text);\n        this.selection.moveTo(0, 0);\n\n        this.$resetRowCache(0);\n        this.setUndoManager(this.$undoManager);\n        this.getUndoManager().reset();\n    };\n    this.getValue =\n    this.toString = function() {\n        return this.doc.getValue();\n    };\n    this.getSelection = function() {\n        return this.selection;\n    };\n    this.getState = function(row) {\n        return this.bgTokenizer.getState(row);\n    };\n    this.getTokens = function(row) {\n        return this.bgTokenizer.getTokens(row);\n    };\n    this.getTokenAt = function(row, column) {\n        var tokens = this.bgTokenizer.getTokens(row);\n        var token, c = 0;\n        if (column == null) {\n            var i = tokens.length - 1;\n            c = this.getLine(row).length;\n        } else {\n            for (var i = 0; i < tokens.length; i++) {\n                c += tokens[i].value.length;\n                if (c >= column)\n                    break;\n            }\n        }\n        token = tokens[i];\n        if (!token)\n            return null;\n        token.index = i;\n        token.start = c - token.value.length;\n        return token;\n    };\n    this.setUndoManager = function(undoManager) {\n        this.$undoManager = undoManager;\n        \n        if (this.$informUndoManager)\n            this.$informUndoManager.cancel();\n        \n        if (undoManager) {\n            var self = this;\n            undoManager.addSession(this);\n            this.$syncInformUndoManager = function() {\n                self.$informUndoManager.cancel();\n                self.mergeUndoDeltas = false;\n            };\n            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\n        } else {\n            this.$syncInformUndoManager = function() {};\n        }\n    };\n    this.markUndoGroup = function() {\n        if (this.$syncInformUndoManager)\n            this.$syncInformUndoManager();\n    };\n    \n    this.$defaultUndoManager = {\n        undo: function() {},\n        redo: function() {},\n        hasUndo: function() {},\n        hasRedo: function() {},\n        reset: function() {},\n        add: function() {},\n        addSelection: function() {},\n        startNewGroup: function() {},\n        addSession: function() {}\n    };\n    this.getUndoManager = function() {\n        return this.$undoManager || this.$defaultUndoManager;\n    };\n    this.getTabString = function() {\n        if (this.getUseSoftTabs()) {\n            return lang.stringRepeat(\" \", this.getTabSize());\n        } else {\n            return \"\\t\";\n        }\n    };\n    this.setUseSoftTabs = function(val) {\n        this.setOption(\"useSoftTabs\", val);\n    };\n    this.getUseSoftTabs = function() {\n        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\n    };\n    this.setTabSize = function(tabSize) {\n        this.setOption(\"tabSize\", tabSize);\n    };\n    this.getTabSize = function() {\n        return this.$tabSize;\n    };\n    this.isTabStop = function(position) {\n        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\n    };\n    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {\n        this.setOption(\"navigateWithinSoftTabs\", navigateWithinSoftTabs);\n    };\n    this.getNavigateWithinSoftTabs = function() {\n        return this.$navigateWithinSoftTabs;\n    };\n\n    this.$overwrite = false;\n    this.setOverwrite = function(overwrite) {\n        this.setOption(\"overwrite\", overwrite);\n    };\n    this.getOverwrite = function() {\n        return this.$overwrite;\n    };\n    this.toggleOverwrite = function() {\n        this.setOverwrite(!this.$overwrite);\n    };\n    this.addGutterDecoration = function(row, className) {\n        if (!this.$decorations[row])\n            this.$decorations[row] = \"\";\n        this.$decorations[row] += \" \" + className;\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.removeGutterDecoration = function(row, className) {\n        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.getBreakpoints = function() {\n        return this.$breakpoints;\n    };\n    this.setBreakpoints = function(rows) {\n        this.$breakpoints = [];\n        for (var i=0; i<rows.length; i++) {\n            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\n        }\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.clearBreakpoints = function() {\n        this.$breakpoints = [];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.setBreakpoint = function(row, className) {\n        if (className === undefined)\n            className = \"ace_breakpoint\";\n        if (className)\n            this.$breakpoints[row] = className;\n        else\n            delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.clearBreakpoint = function(row) {\n        delete this.$breakpoints[row];\n        this._signal(\"changeBreakpoint\", {});\n    };\n    this.addMarker = function(range, clazz, type, inFront) {\n        var id = this.$markerId++;\n\n        var marker = {\n            range : range,\n            type : type || \"line\",\n            renderer: typeof type == \"function\" ? type : null,\n            clazz : clazz,\n            inFront: !!inFront,\n            id: id\n        };\n\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        } else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n\n        return id;\n    };\n    this.addDynamicMarker = function(marker, inFront) {\n        if (!marker.update)\n            return;\n        var id = this.$markerId++;\n        marker.id = id;\n        marker.inFront = !!inFront;\n\n        if (inFront) {\n            this.$frontMarkers[id] = marker;\n            this._signal(\"changeFrontMarker\");\n        } else {\n            this.$backMarkers[id] = marker;\n            this._signal(\"changeBackMarker\");\n        }\n\n        return marker;\n    };\n    this.removeMarker = function(markerId) {\n        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\n        if (!marker)\n            return;\n\n        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\n        delete (markers[markerId]);\n        this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\n    };\n    this.getMarkers = function(inFront) {\n        return inFront ? this.$frontMarkers : this.$backMarkers;\n    };\n\n    this.highlight = function(re) {\n        if (!this.$searchHighlight) {\n            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\n            this.$searchHighlight = this.addDynamicMarker(highlight);\n        }\n        this.$searchHighlight.setRegexp(re);\n    };\n    this.highlightLines = function(startRow, endRow, clazz, inFront) {\n        if (typeof endRow != \"number\") {\n            clazz = endRow;\n            endRow = startRow;\n        }\n        if (!clazz)\n            clazz = \"ace_step\";\n\n        var range = new Range(startRow, 0, endRow, Infinity);\n        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\n        return range;\n    };\n    this.setAnnotations = function(annotations) {\n        this.$annotations = annotations;\n        this._signal(\"changeAnnotation\", {});\n    };\n    this.getAnnotations = function() {\n        return this.$annotations || [];\n    };\n    this.clearAnnotations = function() {\n        this.setAnnotations([]);\n    };\n    this.$detectNewLine = function(text) {\n        var match = text.match(/^.*?(\\r?\\n)/m);\n        if (match) {\n            this.$autoNewLine = match[1];\n        } else {\n            this.$autoNewLine = \"\\n\";\n        }\n    };\n    this.getWordRange = function(row, column) {\n        var line = this.getLine(row);\n\n        var inToken = false;\n        if (column > 0)\n            inToken = !!line.charAt(column - 1).match(this.tokenRe);\n\n        if (!inToken)\n            inToken = !!line.charAt(column).match(this.tokenRe);\n\n        if (inToken)\n            var re = this.tokenRe;\n        else if (/^\\s+$/.test(line.slice(column-1, column+1)))\n            var re = /\\s/;\n        else\n            var re = this.nonTokenRe;\n\n        var start = column;\n        if (start > 0) {\n            do {\n                start--;\n            }\n            while (start >= 0 && line.charAt(start).match(re));\n            start++;\n        }\n\n        var end = column;\n        while (end < line.length && line.charAt(end).match(re)) {\n            end++;\n        }\n\n        return new Range(row, start, row, end);\n    };\n    this.getAWordRange = function(row, column) {\n        var wordRange = this.getWordRange(row, column);\n        var line = this.getLine(wordRange.end.row);\n\n        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\n            wordRange.end.column += 1;\n        }\n        return wordRange;\n    };\n    this.setNewLineMode = function(newLineMode) {\n        this.doc.setNewLineMode(newLineMode);\n    };\n    this.getNewLineMode = function() {\n        return this.doc.getNewLineMode();\n    };\n    this.setUseWorker = function(useWorker) { this.setOption(\"useWorker\", useWorker); };\n    this.getUseWorker = function() { return this.$useWorker; };\n    this.onReloadTokenizer = function(e) {\n        var rows = e.data;\n        this.bgTokenizer.start(rows.first);\n        this._signal(\"tokenizerUpdate\", e);\n    };\n\n    this.$modes = config.$modes;\n    this.$mode = null;\n    this.$modeId = null;\n    this.setMode = function(mode, cb) {\n        if (mode && typeof mode === \"object\") {\n            if (mode.getTokenizer)\n                return this.$onChangeMode(mode);\n            var options = mode;\n            var path = options.path;\n        } else {\n            path = mode || \"ace/mode/text\";\n        }\n        if (!this.$modes[\"ace/mode/text\"])\n            this.$modes[\"ace/mode/text\"] = new TextMode();\n\n        if (this.$modes[path] && !options) {\n            this.$onChangeMode(this.$modes[path]);\n            cb && cb();\n            return;\n        }\n        this.$modeId = path;\n        config.loadModule([\"mode\", path], function(m) {\n            if (this.$modeId !== path)\n                return cb && cb();\n            if (this.$modes[path] && !options) {\n                this.$onChangeMode(this.$modes[path]);\n            } else if (m && m.Mode) {\n                m = new m.Mode(options);\n                if (!options) {\n                    this.$modes[path] = m;\n                    m.$id = path;\n                }\n                this.$onChangeMode(m);\n            }\n            cb && cb();\n        }.bind(this));\n        if (!this.$mode)\n            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\n    };\n\n    this.$onChangeMode = function(mode, $isPlaceholder) {\n        if (!$isPlaceholder)\n            this.$modeId = mode.$id;\n        if (this.$mode === mode) \n            return;\n\n        this.$mode = mode;\n\n        this.$stopWorker();\n\n        if (this.$useWorker)\n            this.$startWorker();\n\n        var tokenizer = mode.getTokenizer();\n\n        if(tokenizer.addEventListener !== undefined) {\n            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\n            tokenizer.addEventListener(\"update\", onReloadTokenizer);\n        }\n\n        if (!this.bgTokenizer) {\n            this.bgTokenizer = new BackgroundTokenizer(tokenizer);\n            var _self = this;\n            this.bgTokenizer.addEventListener(\"update\", function(e) {\n                _self._signal(\"tokenizerUpdate\", e);\n            });\n        } else {\n            this.bgTokenizer.setTokenizer(tokenizer);\n        }\n\n        this.bgTokenizer.setDocument(this.getDocument());\n\n        this.tokenRe = mode.tokenRe;\n        this.nonTokenRe = mode.nonTokenRe;\n\n        \n        if (!$isPlaceholder) {\n            if (mode.attachToSession)\n                mode.attachToSession(this);\n            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\n            this.$setFolding(mode.foldingRules);\n            this.bgTokenizer.start(0);\n            this._emit(\"changeMode\");\n        }\n    };\n\n    this.$stopWorker = function() {\n        if (this.$worker) {\n            this.$worker.terminate();\n            this.$worker = null;\n        }\n    };\n\n    this.$startWorker = function() {\n        try {\n            this.$worker = this.$mode.createWorker(this);\n        } catch (e) {\n            config.warn(\"Could not load worker\", e);\n            this.$worker = null;\n        }\n    };\n    this.getMode = function() {\n        return this.$mode;\n    };\n\n    this.$scrollTop = 0;\n    this.setScrollTop = function(scrollTop) {\n        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\n            return;\n\n        this.$scrollTop = scrollTop;\n        this._signal(\"changeScrollTop\", scrollTop);\n    };\n    this.getScrollTop = function() {\n        return this.$scrollTop;\n    };\n\n    this.$scrollLeft = 0;\n    this.setScrollLeft = function(scrollLeft) {\n        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\n            return;\n\n        this.$scrollLeft = scrollLeft;\n        this._signal(\"changeScrollLeft\", scrollLeft);\n    };\n    this.getScrollLeft = function() {\n        return this.$scrollLeft;\n    };\n    this.getScreenWidth = function() {\n        this.$computeWidth();\n        if (this.lineWidgets) \n            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\n        return this.screenWidth;\n    };\n    \n    this.getLineWidgetMaxWidth = function() {\n        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;\n        var width = 0;\n        this.lineWidgets.forEach(function(w) {\n            if (w && w.screenWidth > width)\n                width = w.screenWidth;\n        });\n        return this.lineWidgetWidth = width;\n    };\n\n    this.$computeWidth = function(force) {\n        if (this.$modified || force) {\n            this.$modified = false;\n\n            if (this.$useWrapMode)\n                return this.screenWidth = this.$wrapLimit;\n\n            var lines = this.doc.getAllLines();\n            var cache = this.$rowLengthCache;\n            var longestScreenLine = 0;\n            var foldIndex = 0;\n            var foldLine = this.$foldData[foldIndex];\n            var foldStart = foldLine ? foldLine.start.row : Infinity;\n            var len = lines.length;\n\n            for (var i = 0; i < len; i++) {\n                if (i > foldStart) {\n                    i = foldLine.end.row + 1;\n                    if (i >= len)\n                        break;\n                    foldLine = this.$foldData[foldIndex++];\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n\n                if (cache[i] == null)\n                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\n\n                if (cache[i] > longestScreenLine)\n                    longestScreenLine = cache[i];\n            }\n            this.screenWidth = longestScreenLine;\n        }\n    };\n    this.getLine = function(row) {\n        return this.doc.getLine(row);\n    };\n    this.getLines = function(firstRow, lastRow) {\n        return this.doc.getLines(firstRow, lastRow);\n    };\n    this.getLength = function() {\n        return this.doc.getLength();\n    };\n    this.getTextRange = function(range) {\n        return this.doc.getTextRange(range || this.selection.getRange());\n    };\n    this.insert = function(position, text) {\n        return this.doc.insert(position, text);\n    };\n    this.remove = function(range) {\n        return this.doc.remove(range);\n    };\n    this.removeFullLines = function(firstRow, lastRow){\n        return this.doc.removeFullLines(firstRow, lastRow);\n    };\n    this.undoChanges = function(deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n\n        this.$fromUndo = true;\n        for (var i = deltas.length - 1; i != -1; i--) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.revertDelta(delta);\n            } else if (delta.folds) {\n                this.addFolds(delta.folds);\n            }\n        }\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionBefore)\n                this.selection.fromJSON(deltas.selectionBefore);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, true));\n        }\n        this.$fromUndo = false;\n    };\n    this.redoChanges = function(deltas, dontSelect) {\n        if (!deltas.length)\n            return;\n\n        this.$fromUndo = true;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.action == \"insert\" || delta.action == \"remove\") {\n                this.doc.applyDelta(delta);\n            }\n        }\n\n        if (!dontSelect && this.$undoSelect) {\n            if (deltas.selectionAfter)\n                this.selection.fromJSON(deltas.selectionAfter);\n            else\n                this.selection.setRange(this.$getUndoSelection(deltas, false));\n        }\n        this.$fromUndo = false;\n    };\n    this.setUndoSelect = function(enable) {\n        this.$undoSelect = enable;\n    };\n\n    this.$getUndoSelection = function(deltas, isUndo) {\n        function isInsert(delta) {\n            return isUndo ? delta.action !== \"insert\" : delta.action === \"insert\";\n        }\n\n        var range, point;\n        var lastDeltaIsInsert;\n\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (!delta.start) continue; // skip folds\n            if (!range) {\n                if (isInsert(delta)) {\n                    range = Range.fromPoints(delta.start, delta.end);\n                    lastDeltaIsInsert = true;\n                } else {\n                    range = Range.fromPoints(delta.start, delta.start);\n                    lastDeltaIsInsert = false;\n                }\n                continue;\n            }\n            \n            if (isInsert(delta)) {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range.setStart(point);\n                }\n                point = delta.end;\n                if (range.compare(point.row, point.column) == 1) {\n                    range.setEnd(point);\n                }\n                lastDeltaIsInsert = true;\n            } else {\n                point = delta.start;\n                if (range.compare(point.row, point.column) == -1) {\n                    range = Range.fromPoints(delta.start, delta.start);\n                }\n                lastDeltaIsInsert = false;\n            }\n        }\n        return range;\n    };\n    this.replace = function(range, text) {\n        return this.doc.replace(range, text);\n    };\n    this.moveText = function(fromRange, toPosition, copy) {\n        var text = this.getTextRange(fromRange);\n        var folds = this.getFoldsInRange(fromRange);\n\n        var toRange = Range.fromPoints(toPosition, toPosition);\n        if (!copy) {\n            this.remove(fromRange);\n            var rowDiff = fromRange.start.row - fromRange.end.row;\n            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\n            if (collDiff) {\n                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\n                    toRange.start.column += collDiff;\n                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\n                    toRange.end.column += collDiff;\n            }\n            if (rowDiff && toRange.start.row >= fromRange.end.row) {\n                toRange.start.row += rowDiff;\n                toRange.end.row += rowDiff;\n            }\n        }\n\n        toRange.end = this.insert(toRange.start, text);\n        if (folds.length) {\n            var oldStart = fromRange.start;\n            var newStart = toRange.start;\n            var rowDiff = newStart.row - oldStart.row;\n            var collDiff = newStart.column - oldStart.column;\n            this.addFolds(folds.map(function(x) {\n                x = x.clone();\n                if (x.start.row == oldStart.row)\n                    x.start.column += collDiff;\n                if (x.end.row == oldStart.row)\n                    x.end.column += collDiff;\n                x.start.row += rowDiff;\n                x.end.row += rowDiff;\n                return x;\n            }));\n        }\n\n        return toRange;\n    };\n    this.indentRows = function(startRow, endRow, indentString) {\n        indentString = indentString.replace(/\\t/g, this.getTabString());\n        for (var row=startRow; row<=endRow; row++)\n            this.doc.insertInLine({row: row, column: 0}, indentString);\n    };\n    this.outdentRows = function (range) {\n        var rowRange = range.collapseRows();\n        var deleteRange = new Range(0, 0, 0, 0);\n        var size = this.getTabSize();\n\n        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\n            var line = this.getLine(i);\n\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            for (var j = 0; j < size; ++j)\n                if (line.charAt(j) != ' ')\n                    break;\n            if (j < size && line.charAt(j) == '\\t') {\n                deleteRange.start.column = j;\n                deleteRange.end.column = j + 1;\n            } else {\n                deleteRange.start.column = 0;\n                deleteRange.end.column = j;\n            }\n            this.remove(deleteRange);\n        }\n    };\n\n    this.$moveLines = function(firstRow, lastRow, dir) {\n        firstRow = this.getRowFoldStart(firstRow);\n        lastRow = this.getRowFoldEnd(lastRow);\n        if (dir < 0) {\n            var row = this.getRowFoldStart(firstRow + dir);\n            if (row < 0) return 0;\n            var diff = row-firstRow;\n        } else if (dir > 0) {\n            var row = this.getRowFoldEnd(lastRow + dir);\n            if (row > this.doc.getLength()-1) return 0;\n            var diff = row-lastRow;\n        } else {\n            firstRow = this.$clipRowToDocument(firstRow);\n            lastRow = this.$clipRowToDocument(lastRow);\n            var diff = lastRow - firstRow + 1;\n        }\n\n        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\n        var folds = this.getFoldsInRange(range).map(function(x){\n            x = x.clone();\n            x.start.row += diff;\n            x.end.row += diff;\n            return x;\n        });\n        \n        var lines = dir == 0\n            ? this.doc.getLines(firstRow, lastRow)\n            : this.doc.removeFullLines(firstRow, lastRow);\n        this.doc.insertFullLines(firstRow+diff, lines);\n        folds.length && this.addFolds(folds);\n        return diff;\n    };\n    this.moveLinesUp = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, -1);\n    };\n    this.moveLinesDown = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 1);\n    };\n    this.duplicateLines = function(firstRow, lastRow) {\n        return this.$moveLines(firstRow, lastRow, 0);\n    };\n\n\n    this.$clipRowToDocument = function(row) {\n        return Math.max(0, Math.min(row, this.doc.getLength()-1));\n    };\n\n    this.$clipColumnToRow = function(row, column) {\n        if (column < 0)\n            return 0;\n        return Math.min(this.doc.getLine(row).length, column);\n    };\n\n\n    this.$clipPositionToDocument = function(row, column) {\n        column = Math.max(0, column);\n\n        if (row < 0) {\n            row = 0;\n            column = 0;\n        } else {\n            var len = this.doc.getLength();\n            if (row >= len) {\n                row = len - 1;\n                column = this.doc.getLine(len-1).length;\n            } else {\n                column = Math.min(this.doc.getLine(row).length, column);\n            }\n        }\n\n        return {\n            row: row,\n            column: column\n        };\n    };\n\n    this.$clipRangeToDocument = function(range) {\n        if (range.start.row < 0) {\n            range.start.row = 0;\n            range.start.column = 0;\n        } else {\n            range.start.column = this.$clipColumnToRow(\n                range.start.row,\n                range.start.column\n            );\n        }\n\n        var len = this.doc.getLength() - 1;\n        if (range.end.row > len) {\n            range.end.row = len;\n            range.end.column = this.doc.getLine(len).length;\n        } else {\n            range.end.column = this.$clipColumnToRow(\n                range.end.row,\n                range.end.column\n            );\n        }\n        return range;\n    };\n    this.$wrapLimit = 80;\n    this.$useWrapMode = false;\n    this.$wrapLimitRange = {\n        min : null,\n        max : null\n    };\n    this.setUseWrapMode = function(useWrapMode) {\n        if (useWrapMode != this.$useWrapMode) {\n            this.$useWrapMode = useWrapMode;\n            this.$modified = true;\n            this.$resetRowCache(0);\n            if (useWrapMode) {\n                var len = this.getLength();\n                this.$wrapData = Array(len);\n                this.$updateWrapData(0, len - 1);\n            }\n\n            this._signal(\"changeWrapMode\");\n        }\n    };\n    this.getUseWrapMode = function() {\n        return this.$useWrapMode;\n    };\n    this.setWrapLimitRange = function(min, max) {\n        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\n            this.$wrapLimitRange = { min: min, max: max };\n            this.$modified = true;\n            this.$bidiHandler.markAsDirty();\n            if (this.$useWrapMode)\n                this._signal(\"changeWrapMode\");\n        }\n    };\n    this.adjustWrapLimit = function(desiredLimit, $printMargin) {\n        var limits = this.$wrapLimitRange;\n        if (limits.max < 0)\n            limits = {min: $printMargin, max: $printMargin};\n        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\n        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\n            this.$wrapLimit = wrapLimit;\n            this.$modified = true;\n            if (this.$useWrapMode) {\n                this.$updateWrapData(0, this.getLength() - 1);\n                this.$resetRowCache(0);\n                this._signal(\"changeWrapLimit\");\n            }\n            return true;\n        }\n        return false;\n    };\n\n    this.$constrainWrapLimit = function(wrapLimit, min, max) {\n        if (min)\n            wrapLimit = Math.max(min, wrapLimit);\n\n        if (max)\n            wrapLimit = Math.min(max, wrapLimit);\n\n        return wrapLimit;\n    };\n    this.getWrapLimit = function() {\n        return this.$wrapLimit;\n    };\n    this.setWrapLimit = function (limit) {\n        this.setWrapLimitRange(limit, limit);\n    };\n    this.getWrapLimitRange = function() {\n        return {\n            min : this.$wrapLimitRange.min,\n            max : this.$wrapLimitRange.max\n        };\n    };\n\n    this.$updateInternalDataOnChange = function(delta) {\n        var useWrapMode = this.$useWrapMode;\n        var action = delta.action;\n        var start = delta.start;\n        var end = delta.end;\n        var firstRow = start.row;\n        var lastRow = end.row;\n        var len = lastRow - firstRow;\n        var removedFolds = null;\n        \n        this.$updating = true;\n        if (len != 0) {\n            if (action === \"remove\") {\n                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\n\n                var foldLines = this.$foldData;\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n\n                var foldLine = this.getFoldLine(end.row);\n                var idx = 0;\n                if (foldLine) {\n                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\n                    foldLine.shiftRow(-len);\n\n                    var foldLineBefore = this.getFoldLine(firstRow);\n                    if (foldLineBefore && foldLineBefore !== foldLine) {\n                        foldLineBefore.merge(foldLine);\n                        foldLine = foldLineBefore;\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= end.row) {\n                        foldLine.shiftRow(-len);\n                    }\n                }\n\n                lastRow = firstRow;\n            } else {\n                var args = Array(len);\n                args.unshift(firstRow, 0);\n                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;\n                arr.splice.apply(arr, args);\n                var foldLines = this.$foldData;\n                var foldLine = this.getFoldLine(firstRow);\n                var idx = 0;\n                if (foldLine) {\n                    var cmp = foldLine.range.compareInside(start.row, start.column);\n                    if (cmp == 0) {\n                        foldLine = foldLine.split(start.row, start.column);\n                        if (foldLine) {\n                            foldLine.shiftRow(len);\n                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\n                        }\n                    } else\n                    if (cmp == -1) {\n                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\n                        foldLine.shiftRow(len);\n                    }\n                    idx = foldLines.indexOf(foldLine) + 1;\n                }\n\n                for (idx; idx < foldLines.length; idx++) {\n                    var foldLine = foldLines[idx];\n                    if (foldLine.start.row >= firstRow) {\n                        foldLine.shiftRow(len);\n                    }\n                }\n            }\n        } else {\n            len = Math.abs(delta.start.column - delta.end.column);\n            if (action === \"remove\") {\n                removedFolds = this.getFoldsInRange(delta);\n                this.removeFolds(removedFolds);\n\n                len = -len;\n            }\n            var foldLine = this.getFoldLine(firstRow);\n            if (foldLine) {\n                foldLine.addRemoveChars(firstRow, start.column, len);\n            }\n        }\n\n        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\n            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\n        }\n        this.$updating = false;\n\n        if (useWrapMode)\n            this.$updateWrapData(firstRow, lastRow);\n        else\n            this.$updateRowLengthCache(firstRow, lastRow);\n\n        return removedFolds;\n    };\n\n    this.$updateRowLengthCache = function(firstRow, lastRow, b) {\n        this.$rowLengthCache[firstRow] = null;\n        this.$rowLengthCache[lastRow] = null;\n    };\n\n    this.$updateWrapData = function(firstRow, lastRow) {\n        var lines = this.doc.getAllLines();\n        var tabSize = this.getTabSize();\n        var wrapData = this.$wrapData;\n        var wrapLimit = this.$wrapLimit;\n        var tokens;\n        var foldLine;\n\n        var row = firstRow;\n        lastRow = Math.min(lastRow, lines.length - 1);\n        while (row <= lastRow) {\n            foldLine = this.getFoldLine(row, foldLine);\n            if (!foldLine) {\n                tokens = this.$getDisplayTokens(lines[row]);\n                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row ++;\n            } else {\n                tokens = [];\n                foldLine.walk(function(placeholder, row, column, lastColumn) {\n                        var walkTokens;\n                        if (placeholder != null) {\n                            walkTokens = this.$getDisplayTokens(\n                                            placeholder, tokens.length);\n                            walkTokens[0] = PLACEHOLDER_START;\n                            for (var i = 1; i < walkTokens.length; i++) {\n                                walkTokens[i] = PLACEHOLDER_BODY;\n                            }\n                        } else {\n                            walkTokens = this.$getDisplayTokens(\n                                lines[row].substring(lastColumn, column),\n                                tokens.length);\n                        }\n                        tokens = tokens.concat(walkTokens);\n                    }.bind(this),\n                    foldLine.end.row,\n                    lines[foldLine.end.row].length + 1\n                );\n\n                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n                row = foldLine.end.row + 1;\n            }\n        }\n    };\n    var CHAR = 1,\n        CHAR_EXT = 2,\n        PLACEHOLDER_START = 3,\n        PLACEHOLDER_BODY =  4,\n        PUNCTUATION = 9,\n        SPACE = 10,\n        TAB = 11,\n        TAB_SPACE = 12;\n\n\n    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {\n        if (tokens.length == 0) {\n            return [];\n        }\n\n        var splits = [];\n        var displayLength = tokens.length;\n        var lastSplit = 0, lastDocSplit = 0;\n\n        var isCode = this.$wrapAsCode;\n\n        var indentedSoftWrap = this.$indentedSoftWrap;\n        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)\n            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);\n\n        function getWrapIndent() {\n            var indentation = 0;\n            if (maxIndent === 0)\n                return indentation;\n            if (indentedSoftWrap) {\n                for (var i = 0; i < tokens.length; i++) {\n                    var token = tokens[i];\n                    if (token == SPACE)\n                        indentation += 1;\n                    else if (token == TAB)\n                        indentation += tabSize;\n                    else if (token == TAB_SPACE)\n                        continue;\n                    else\n                        break;\n                }\n            }\n            if (isCode && indentedSoftWrap !== false)\n                indentation += tabSize;\n            return Math.min(indentation, maxIndent);\n        }\n        function addSplit(screenPos) {\n            var len = screenPos - lastSplit;\n            for (var i = lastSplit; i < screenPos; i++) {\n                var ch = tokens[i];\n                if (ch === 12 || ch === 2) len -= 1;\n            }\n\n            if (!splits.length) {\n                indent = getWrapIndent();\n                splits.indent = indent;\n            }\n            lastDocSplit += len;\n            splits.push(lastDocSplit);\n            lastSplit = screenPos;\n        }\n        var indent = 0;\n        while (displayLength - lastSplit > wrapLimit - indent) {\n            var split = lastSplit + wrapLimit - indent;\n            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\n                addSplit(split);\n                continue;\n            }\n            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\n                for (split; split != lastSplit - 1; split--) {\n                    if (tokens[split] == PLACEHOLDER_START) {\n                        break;\n                    }\n                }\n                if (split > lastSplit) {\n                    addSplit(split);\n                    continue;\n                }\n                split = lastSplit + wrapLimit;\n                for (split; split < tokens.length; split++) {\n                    if (tokens[split] != PLACEHOLDER_BODY) {\n                        break;\n                    }\n                }\n                if (split == tokens.length) {\n                    break;  // Breaks the while-loop.\n                }\n                addSplit(split);\n                continue;\n            }\n            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);\n            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                split --;\n            }\n            if (isCode) {\n                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n                    split --;\n                }\n                while (split > minSplit && tokens[split] == PUNCTUATION) {\n                    split --;\n                }\n            } else {\n                while (split > minSplit && tokens[split] < SPACE) {\n                    split --;\n                }\n            }\n            if (split > minSplit) {\n                addSplit(++split);\n                continue;\n            }\n            split = lastSplit + wrapLimit;\n            if (tokens[split] == CHAR_EXT)\n                split--;\n            addSplit(split - indent);\n        }\n        return splits;\n    };\n    this.$getDisplayTokens = function(str, offset) {\n        var arr = [];\n        var tabSize;\n        offset = offset || 0;\n\n        for (var i = 0; i < str.length; i++) {\n            var c = str.charCodeAt(i);\n            if (c == 9) {\n                tabSize = this.getScreenTabSize(arr.length + offset);\n                arr.push(TAB);\n                for (var n = 1; n < tabSize; n++) {\n                    arr.push(TAB_SPACE);\n                }\n            }\n            else if (c == 32) {\n                arr.push(SPACE);\n            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {\n                arr.push(PUNCTUATION);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                arr.push(CHAR, CHAR_EXT);\n            } else {\n                arr.push(CHAR);\n            }\n        }\n        return arr;\n    };\n    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n        if (maxScreenColumn == 0)\n            return [0, 0];\n        if (maxScreenColumn == null)\n            maxScreenColumn = Infinity;\n        screenColumn = screenColumn || 0;\n\n        var c, column;\n        for (column = 0; column < str.length; column++) {\n            c = str.charCodeAt(column);\n            if (c == 9) {\n                screenColumn += this.getScreenTabSize(screenColumn);\n            }\n            else if (c >= 0x1100 && isFullWidth(c)) {\n                screenColumn += 2;\n            } else {\n                screenColumn += 1;\n            }\n            if (screenColumn > maxScreenColumn) {\n                break;\n            }\n        }\n\n        return [screenColumn, column];\n    };\n\n    this.lineWidgets = null;\n    this.getRowLength = function(row) {\n        var h = 1;\n        if (this.lineWidgets)\n            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        \n        if (!this.$useWrapMode || !this.$wrapData[row])\n            return h;\n        else\n            return this.$wrapData[row].length + h;\n    };\n    this.getRowLineCount = function(row) {\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1;\n        } else {\n            return this.$wrapData[row].length + 1;\n        }\n    };\n\n    this.getRowWrapIndent = function(screenRow) {\n        if (this.$useWrapMode) {\n            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n            var splits = this.$wrapData[pos.row];\n            return splits.length && splits[0] < pos.column ? splits.indent : 0;\n        } else {\n            return 0;\n        }\n    };\n    this.getScreenLastRowColumn = function(screenRow) {\n        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n        return this.documentToScreenColumn(pos.row, pos.column);\n    };\n    this.getDocumentLastRowColumn = function(docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.getScreenLastRowColumn(screenRow);\n    };\n    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {\n        var screenRow = this.documentToScreenRow(docRow, docColumn);\n        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\n    };\n    this.getRowSplitData = function(row) {\n        if (!this.$useWrapMode) {\n            return undefined;\n        } else {\n            return this.$wrapData[row];\n        }\n    };\n    this.getScreenTabSize = function(screenColumn) {\n        return this.$tabSize - (screenColumn % this.$tabSize | 0);\n    };\n\n\n    this.screenToDocumentRow = function(screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).row;\n    };\n\n\n    this.screenToDocumentColumn = function(screenRow, screenColumn) {\n        return this.screenToDocumentPosition(screenRow, screenColumn).column;\n    };\n    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {\n        if (screenRow < 0)\n            return {row: 0, column: 0};\n\n        var line;\n        var docRow = 0;\n        var docColumn = 0;\n        var column;\n        var row = 0;\n        var rowLength = 0;\n\n        var rowCache = this.$screenRowCache;\n        var i = this.$getRowCacheIndex(rowCache, screenRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var docRow = this.$docRowCache[i];\n            var doCache = screenRow > rowCache[l - 1];\n        } else {\n            var doCache = !l;\n        }\n\n        var maxRow = this.getLength() - 1;\n        var foldLine = this.getNextFoldLine(docRow);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (row <= screenRow) {\n            rowLength = this.getRowLength(docRow);\n            if (row + rowLength > screenRow || docRow >= maxRow) {\n                break;\n            } else {\n                row += rowLength;\n                docRow++;\n                if (docRow > foldStart) {\n                    docRow = foldLine.end.row+1;\n                    foldLine = this.getNextFoldLine(docRow, foldLine);\n                    foldStart = foldLine ? foldLine.start.row : Infinity;\n                }\n            }\n\n            if (doCache) {\n                this.$docRowCache.push(docRow);\n                this.$screenRowCache.push(row);\n            }\n        }\n\n        if (foldLine && foldLine.start.row <= docRow) {\n            line = this.getFoldDisplayLine(foldLine);\n            docRow = foldLine.start.row;\n        } else if (row + rowLength <= screenRow || docRow > maxRow) {\n            return {\n                row: maxRow,\n                column: this.getLine(maxRow).length\n            };\n        } else {\n            line = this.getLine(docRow);\n            foldLine = null;\n        }\n        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);\n        if (this.$useWrapMode) {\n            var splits = this.$wrapData[docRow];\n            if (splits) {\n                column = splits[splitIndex];\n                if(splitIndex > 0 && splits.length) {\n                    wrapIndent = splits.indent;\n                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\n                    line = line.substring(docColumn);\n                }\n            }\n        }\n\n        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))\n            screenColumn = this.$bidiHandler.offsetToCol(offsetX);\n\n        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];\n        if (this.$useWrapMode && docColumn >= column)\n            docColumn = column - 1;\n\n        if (foldLine)\n            return foldLine.idxToPosition(docColumn);\n\n        return {row: docRow, column: docColumn};\n    };\n    this.documentToScreenPosition = function(docRow, docColumn) {\n        if (typeof docColumn === \"undefined\")\n            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);\n        else\n            pos = this.$clipPositionToDocument(docRow, docColumn);\n\n        docRow = pos.row;\n        docColumn = pos.column;\n\n        var screenRow = 0;\n        var foldStartRow = null;\n        var fold = null;\n        fold = this.getFoldAt(docRow, docColumn, 1);\n        if (fold) {\n            docRow = fold.start.row;\n            docColumn = fold.start.column;\n        }\n\n        var rowEnd, row = 0;\n\n\n        var rowCache = this.$docRowCache;\n        var i = this.$getRowCacheIndex(rowCache, docRow);\n        var l = rowCache.length;\n        if (l && i >= 0) {\n            var row = rowCache[i];\n            var screenRow = this.$screenRowCache[i];\n            var doCache = docRow > rowCache[l - 1];\n        } else {\n            var doCache = !l;\n        }\n\n        var foldLine = this.getNextFoldLine(row);\n        var foldStart = foldLine ?foldLine.start.row :Infinity;\n\n        while (row < docRow) {\n            if (row >= foldStart) {\n                rowEnd = foldLine.end.row + 1;\n                if (rowEnd > docRow)\n                    break;\n                foldLine = this.getNextFoldLine(rowEnd, foldLine);\n                foldStart = foldLine ?foldLine.start.row :Infinity;\n            }\n            else {\n                rowEnd = row + 1;\n            }\n\n            screenRow += this.getRowLength(row);\n            row = rowEnd;\n\n            if (doCache) {\n                this.$docRowCache.push(row);\n                this.$screenRowCache.push(screenRow);\n            }\n        }\n        var textLine = \"\";\n        if (foldLine && row >= foldStart) {\n            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\n            foldStartRow = foldLine.start.row;\n        } else {\n            textLine = this.getLine(docRow).substring(0, docColumn);\n            foldStartRow = docRow;\n        }\n        var wrapIndent = 0;\n        if (this.$useWrapMode) {\n            var wrapRow = this.$wrapData[foldStartRow];\n            if (wrapRow) {\n                var screenRowOffset = 0;\n                while (textLine.length >= wrapRow[screenRowOffset]) {\n                    screenRow ++;\n                    screenRowOffset++;\n                }\n                textLine = textLine.substring(\n                    wrapRow[screenRowOffset - 1] || 0, textLine.length\n                );\n                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;\n            }\n        }\n        \n        if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)\n            screenRow += this.lineWidgets[row].rowsAbove;\n\n        return {\n            row: screenRow,\n            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]\n        };\n    };\n    this.documentToScreenColumn = function(row, docColumn) {\n        return this.documentToScreenPosition(row, docColumn).column;\n    };\n    this.documentToScreenRow = function(docRow, docColumn) {\n        return this.documentToScreenPosition(docRow, docColumn).row;\n    };\n    this.getScreenLength = function() {\n        var screenRows = 0;\n        var fold = null;\n        if (!this.$useWrapMode) {\n            screenRows = this.getLength();\n            var foldData = this.$foldData;\n            for (var i = 0; i < foldData.length; i++) {\n                fold = foldData[i];\n                screenRows -= fold.end.row - fold.start.row;\n            }\n        } else {\n            var lastRow = this.$wrapData.length;\n            var row = 0, i = 0;\n            var fold = this.$foldData[i++];\n            var foldStart = fold ? fold.start.row :Infinity;\n\n            while (row < lastRow) {\n                var splits = this.$wrapData[row];\n                screenRows += splits ? splits.length + 1 : 1;\n                row ++;\n                if (row > foldStart) {\n                    row = fold.end.row+1;\n                    fold = this.$foldData[i++];\n                    foldStart = fold ?fold.start.row :Infinity;\n                }\n            }\n        }\n        if (this.lineWidgets)\n            screenRows += this.$getWidgetScreenLength();\n\n        return screenRows;\n    };\n    this.$setFontMetrics = function(fm) {\n        if (!this.$enableVarChar) return;\n        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n            if (maxScreenColumn === 0)\n                return [0, 0];\n            if (!maxScreenColumn)\n                maxScreenColumn = Infinity;\n            screenColumn = screenColumn || 0;\n            \n            var c, column;\n            for (column = 0; column < str.length; column++) {\n                c = str.charAt(column);\n                if (c === \"\\t\") {\n                    screenColumn += this.getScreenTabSize(screenColumn);\n                } else {\n                    screenColumn += fm.getCharacterWidth(c);\n                }\n                if (screenColumn > maxScreenColumn) {\n                    break;\n                }\n            }\n            \n            return [screenColumn, column];\n        };\n    };\n    \n    this.destroy = function() {\n        if (this.bgTokenizer) {\n            this.bgTokenizer.setDocument(null);\n            this.bgTokenizer = null;\n        }\n        this.$stopWorker();\n    };\n\n    this.isFullWidth = isFullWidth;\n    function isFullWidth(c) {\n        if (c < 0x1100)\n            return false;\n        return c >= 0x1100 && c <= 0x115F ||\n               c >= 0x11A3 && c <= 0x11A7 ||\n               c >= 0x11FA && c <= 0x11FF ||\n               c >= 0x2329 && c <= 0x232A ||\n               c >= 0x2E80 && c <= 0x2E99 ||\n               c >= 0x2E9B && c <= 0x2EF3 ||\n               c >= 0x2F00 && c <= 0x2FD5 ||\n               c >= 0x2FF0 && c <= 0x2FFB ||\n               c >= 0x3000 && c <= 0x303E ||\n               c >= 0x3041 && c <= 0x3096 ||\n               c >= 0x3099 && c <= 0x30FF ||\n               c >= 0x3105 && c <= 0x312D ||\n               c >= 0x3131 && c <= 0x318E ||\n               c >= 0x3190 && c <= 0x31BA ||\n               c >= 0x31C0 && c <= 0x31E3 ||\n               c >= 0x31F0 && c <= 0x321E ||\n               c >= 0x3220 && c <= 0x3247 ||\n               c >= 0x3250 && c <= 0x32FE ||\n               c >= 0x3300 && c <= 0x4DBF ||\n               c >= 0x4E00 && c <= 0xA48C ||\n               c >= 0xA490 && c <= 0xA4C6 ||\n               c >= 0xA960 && c <= 0xA97C ||\n               c >= 0xAC00 && c <= 0xD7A3 ||\n               c >= 0xD7B0 && c <= 0xD7C6 ||\n               c >= 0xD7CB && c <= 0xD7FB ||\n               c >= 0xF900 && c <= 0xFAFF ||\n               c >= 0xFE10 && c <= 0xFE19 ||\n               c >= 0xFE30 && c <= 0xFE52 ||\n               c >= 0xFE54 && c <= 0xFE66 ||\n               c >= 0xFE68 && c <= 0xFE6B ||\n               c >= 0xFF01 && c <= 0xFF60 ||\n               c >= 0xFFE0 && c <= 0xFFE6;\n    }\n\n}).call(EditSession.prototype);\n\nrequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\nrequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\n\n\nconfig.defineOptions(EditSession.prototype, \"session\", {\n    wrap: {\n        set: function(value) {\n            if (!value || value == \"off\")\n                value = false;\n            else if (value == \"free\")\n                value = true;\n            else if (value == \"printMargin\")\n                value = -1;\n            else if (typeof value == \"string\")\n                value = parseInt(value, 10) || false;\n\n            if (this.$wrap == value)\n                return;\n            this.$wrap = value;\n            if (!value) {\n                this.setUseWrapMode(false);\n            } else {\n                var col = typeof value == \"number\" ? value : null;\n                this.setWrapLimitRange(col, col);\n                this.setUseWrapMode(true);\n            }\n        },\n        get: function() {\n            if (this.getUseWrapMode()) {\n                if (this.$wrap == -1)\n                    return \"printMargin\";\n                if (!this.getWrapLimitRange().min)\n                    return \"free\";\n                return this.$wrap;\n            }\n            return \"off\";\n        },\n        handlesSet: true\n    },    \n    wrapMethod: {\n        set: function(val) {\n            val = val == \"auto\"\n                ? this.$mode.type != \"text\"\n                : val != \"text\";\n            if (val != this.$wrapAsCode) {\n                this.$wrapAsCode = val;\n                if (this.$useWrapMode) {\n                    this.$useWrapMode = false;\n                    this.setUseWrapMode(true);\n                }\n            }\n        },\n        initialValue: \"auto\"\n    },\n    indentedSoftWrap: {\n        set: function() {\n            if (this.$useWrapMode) {\n                this.$useWrapMode = false;\n                this.setUseWrapMode(true);\n            }\n        },\n        initialValue: true \n    },\n    firstLineNumber: {\n        set: function() {this._signal(\"changeBreakpoint\");},\n        initialValue: 1\n    },\n    useWorker: {\n        set: function(useWorker) {\n            this.$useWorker = useWorker;\n\n            this.$stopWorker();\n            if (useWorker)\n                this.$startWorker();\n        },\n        initialValue: true\n    },\n    useSoftTabs: {initialValue: true},\n    tabSize: {\n        set: function(tabSize) {\n            tabSize = parseInt(tabSize);\n            if (tabSize > 0 && this.$tabSize !== tabSize) {\n                this.$modified = true;\n                this.$rowLengthCache = [];\n                this.$tabSize = tabSize;\n                this._signal(\"changeTabSize\");\n            }\n        },\n        initialValue: 4,\n        handlesSet: true\n    },\n    navigateWithinSoftTabs: {initialValue: false},\n    foldStyle: {\n        set: function(val) {this.setFoldStyle(val);},\n        handlesSet: true\n    },\n    overwrite: {\n        set: function(val) {this._signal(\"changeOverwrite\");},\n        initialValue: false\n    },\n    newLineMode: {\n        set: function(val) {this.doc.setNewLineMode(val);},\n        get: function() {return this.doc.getNewLineMode();},\n        handlesSet: true\n    },\n    mode: {\n        set: function(val) { this.setMode(val); },\n        get: function() { return this.$modeId; },\n        handlesSet: true\n    }\n});\n\nexports.EditSession = EditSession;\n});\n\nace.define(\"ace/search\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"./lib/lang\");\nvar oop = require(\"./lib/oop\");\nvar Range = require(\"./range\").Range;\n\nvar Search = function() {\n    this.$options = {};\n};\n\n(function() {\n    this.set = function(options) {\n        oop.mixin(this.$options, options);\n        return this;\n    };\n    this.getOptions = function() {\n        return lang.copyObject(this.$options);\n    };\n    this.setOptions = function(options) {\n        this.$options = options;\n    };\n    this.find = function(session) {\n        var options = this.$options;\n        var iterator = this.$matchIterator(session, options);\n        if (!iterator)\n            return false;\n\n        var firstRange = null;\n        iterator.forEach(function(sr, sc, er, ec) {\n            firstRange = new Range(sr, sc, er, ec);\n            if (sc == ec && options.start && options.start.start\n                && options.skipCurrent != false && firstRange.isEqual(options.start)\n            ) {\n                firstRange = null;\n                return false;\n            }\n            \n            return true;\n        });\n\n        return firstRange;\n    };\n    this.findAll = function(session) {\n        var options = this.$options;\n        if (!options.needle)\n            return [];\n        this.$assembleRegExp(options);\n\n        var range = options.range;\n        var lines = range\n            ? session.getLines(range.start.row, range.end.row)\n            : session.doc.getAllLines();\n\n        var ranges = [];\n        var re = options.re;\n        if (options.$isMultiLine) {\n            var len = re.length;\n            var maxRow = lines.length - len;\n            var prevRange;\n            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\n                for (var j = 0; j < len; j++)\n                    if (lines[row + j].search(re[j]) == -1)\n                        continue outer;\n                \n                var startLine = lines[row];\n                var line = lines[row + len - 1];\n                var startIndex = startLine.length - startLine.match(re[0])[0].length;\n                var endIndex = line.match(re[len - 1])[0].length;\n                \n                if (prevRange && prevRange.end.row === row &&\n                    prevRange.end.column > startIndex\n                ) {\n                    continue;\n                }\n                ranges.push(prevRange = new Range(\n                    row, startIndex, row + len - 1, endIndex\n                ));\n                if (len > 2)\n                    row = row + len - 2;\n            }\n        } else {\n            for (var i = 0; i < lines.length; i++) {\n                var matches = lang.getMatchOffsets(lines[i], re);\n                for (var j = 0; j < matches.length; j++) {\n                    var match = matches[j];\n                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));\n                }\n            }\n        }\n\n        if (range) {\n            var startColumn = range.start.column;\n            var endColumn = range.start.column;\n            var i = 0, j = ranges.length - 1;\n            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)\n                i++;\n\n            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)\n                j--;\n            \n            ranges = ranges.slice(i, j + 1);\n            for (i = 0, j = ranges.length; i < j; i++) {\n                ranges[i].start.row += range.start.row;\n                ranges[i].end.row += range.start.row;\n            }\n        }\n\n        return ranges;\n    };\n    this.replace = function(input, replacement) {\n        var options = this.$options;\n\n        var re = this.$assembleRegExp(options);\n        if (options.$isMultiLine)\n            return replacement;\n\n        if (!re)\n            return;\n\n        var match = re.exec(input);\n        if (!match || match[0].length != input.length)\n            return null;\n        \n        replacement = input.replace(re, replacement);\n        if (options.preserveCase) {\n            replacement = replacement.split(\"\");\n            for (var i = Math.min(input.length, input.length); i--; ) {\n                var ch = input[i];\n                if (ch && ch.toLowerCase() != ch)\n                    replacement[i] = replacement[i].toUpperCase();\n                else\n                    replacement[i] = replacement[i].toLowerCase();\n            }\n            replacement = replacement.join(\"\");\n        }\n        \n        return replacement;\n    };\n\n    this.$assembleRegExp = function(options, $disableFakeMultiline) {\n        if (options.needle instanceof RegExp)\n            return options.re = options.needle;\n\n        var needle = options.needle;\n\n        if (!options.needle)\n            return options.re = false;\n\n        if (!options.regExp)\n            needle = lang.escapeRegExp(needle);\n\n        if (options.wholeWord)\n            needle = addWordBoundary(needle, options);\n\n        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\n\n        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\n        if (options.$isMultiLine)\n            return options.re = this.$assembleMultilineRegExp(needle, modifier);\n\n        try {\n            var re = new RegExp(needle, modifier);\n        } catch(e) {\n            re = false;\n        }\n        return options.re = re;\n    };\n\n    this.$assembleMultilineRegExp = function(needle, modifier) {\n        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\n        var re = [];\n        for (var i = 0; i < parts.length; i++) try {\n            re.push(new RegExp(parts[i], modifier));\n        } catch(e) {\n            return false;\n        }\n        return re;\n    };\n\n    this.$matchIterator = function(session, options) {\n        var re = this.$assembleRegExp(options);\n        if (!re)\n            return false;\n        var backwards = options.backwards == true;\n        var skipCurrent = options.skipCurrent != false;\n\n        var range = options.range;\n        var start = options.start;\n        if (!start)\n            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\n         \n        if (start.start)\n            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\n\n        var firstRow = range ? range.start.row : 0;\n        var lastRow = range ? range.end.row : session.getLength() - 1;\n        \n        if (backwards) {\n            var forEach = function(callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row--; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\n                        return;\n            };\n        }\n        else {\n            var forEach = function(callback) {\n                var row = start.row;\n                if (forEachInLine(row, start.column, callback))\n                    return;\n                for (row = row + 1; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n                if (options.wrap == false)\n                    return;\n                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\n                    if (forEachInLine(row, 0, callback))\n                        return;\n            };\n        }\n        \n        if (options.$isMultiLine) {\n            var len = re.length;\n            var forEachInLine = function(row, offset, callback) {\n                var startRow = backwards ? row - len + 1 : row;\n                if (startRow < 0) return;\n                var line = session.getLine(startRow);\n                var startIndex = line.search(re[0]);\n                if (!backwards && startIndex < offset || startIndex === -1) return;\n                for (var i = 1; i < len; i++) {\n                    line = session.getLine(startRow + i);\n                    if (line.search(re[i]) == -1)\n                        return;\n                }\n                var endIndex = line.match(re[len - 1])[0].length;\n                if (backwards && endIndex > offset) return;\n                if (callback(startRow, startIndex, startRow + len - 1, endIndex))\n                    return true;\n            };\n        }\n        else if (backwards) {\n            var forEachInLine = function(row, endIndex, callback) {\n                var line = session.getLine(row);\n                var matches = [];\n                var m, last = 0;\n                re.lastIndex = 0;\n                while((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (!length) {\n                        if (last >= line.length) break;\n                        re.lastIndex = last += 1;\n                    }\n                    if (m.index + length > endIndex)\n                        break;\n                    matches.push(m.index, length);\n                }\n                for (var i = matches.length - 1; i >= 0; i -= 2) {\n                    var column = matches[i - 1];\n                    var length = matches[i];\n                    if (callback(row, column, row, column + length))\n                        return true;\n                }\n            };\n        }\n        else {\n            var forEachInLine = function(row, startIndex, callback) {\n                var line = session.getLine(row);\n                var last;\n                var m;\n                re.lastIndex = startIndex;\n                while((m = re.exec(line))) {\n                    var length = m[0].length;\n                    last = m.index;\n                    if (callback(row, last, row,last + length))\n                        return true;\n                    if (!length) {\n                        re.lastIndex = last += 1;\n                        if (last >= line.length) return false;\n                    }\n                }\n            };\n        }\n        return {forEach: forEach};\n    };\n\n}).call(Search.prototype);\n\nfunction addWordBoundary(needle, options) {\n    function wordBoundary(c) {\n        if (/\\w/.test(c) || options.regExp) return \"\\\\b\";\n        return \"\";\n    }\n    return wordBoundary(needle[0]) + needle\n        + wordBoundary(needle[needle.length - 1]);\n}\n\nexports.Search = Search;\n});\n\nace.define(\"ace/keyboard/hash_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar keyUtil = require(\"../lib/keys\");\nvar useragent = require(\"../lib/useragent\");\nvar KEY_MODS = keyUtil.KEY_MODS;\n\nfunction HashHandler(config, platform) {\n    this.platform = platform || (useragent.isMac ? \"mac\" : \"win\");\n    this.commands = {};\n    this.commandKeyBinding = {};\n    this.addCommands(config);\n    this.$singleCommand = true;\n}\n\nfunction MultiHashHandler(config, platform) {\n    HashHandler.call(this, config, platform);\n    this.$singleCommand = false;\n}\n\nMultiHashHandler.prototype = HashHandler.prototype;\n\n(function() {\n    \n\n    this.addCommand = function(command) {\n        if (this.commands[command.name])\n            this.removeCommand(command);\n\n        this.commands[command.name] = command;\n\n        if (command.bindKey)\n            this._buildKeyHash(command);\n    };\n\n    this.removeCommand = function(command, keepCommand) {\n        var name = command && (typeof command === 'string' ? command : command.name);\n        command = this.commands[name];\n        if (!keepCommand)\n            delete this.commands[name];\n        var ckb = this.commandKeyBinding;\n        for (var keyId in ckb) {\n            var cmdGroup = ckb[keyId];\n            if (cmdGroup == command) {\n                delete ckb[keyId];\n            } else if (Array.isArray(cmdGroup)) {\n                var i = cmdGroup.indexOf(command);\n                if (i != -1) {\n                    cmdGroup.splice(i, 1);\n                    if (cmdGroup.length == 1)\n                        ckb[keyId] = cmdGroup[0];\n                }\n            }\n        }\n    };\n\n    this.bindKey = function(key, command, position) {\n        if (typeof key == \"object\" && key) {\n            if (position == undefined)\n                position = key.position;\n            key = key[this.platform];\n        }\n        if (!key)\n            return;\n        if (typeof command == \"function\")\n            return this.addCommand({exec: command, bindKey: key, name: command.name || key});\n        \n        key.split(\"|\").forEach(function(keyPart) {\n            var chain = \"\";\n            if (keyPart.indexOf(\" \") != -1) {\n                var parts = keyPart.split(/\\s+/);\n                keyPart = parts.pop();\n                parts.forEach(function(keyPart) {\n                    var binding = this.parseKeys(keyPart);\n                    var id = KEY_MODS[binding.hashId] + binding.key;\n                    chain += (chain ? \" \" : \"\") + id;\n                    this._addCommandToBinding(chain, \"chainKeys\");\n                }, this);\n                chain += \" \";\n            }\n            var binding = this.parseKeys(keyPart);\n            var id = KEY_MODS[binding.hashId] + binding.key;\n            this._addCommandToBinding(chain + id, command, position);\n        }, this);\n    };\n    \n    function getPosition(command) {\n        return typeof command == \"object\" && command.bindKey\n            && command.bindKey.position \n            || (command.isDefault ? -100 : 0);\n    }\n    this._addCommandToBinding = function(keyId, command, position) {\n        var ckb = this.commandKeyBinding, i;\n        if (!command) {\n            delete ckb[keyId];\n        } else if (!ckb[keyId] || this.$singleCommand) {\n            ckb[keyId] = command;\n        } else {\n            if (!Array.isArray(ckb[keyId])) {\n                ckb[keyId] = [ckb[keyId]];\n            } else if ((i = ckb[keyId].indexOf(command)) != -1) {\n                ckb[keyId].splice(i, 1);\n            }\n            \n            if (typeof position != \"number\") {\n                position = getPosition(command);\n            }\n\n            var commands = ckb[keyId];\n            for (i = 0; i < commands.length; i++) {\n                var other = commands[i];\n                var otherPos = getPosition(other);\n                if (otherPos > position)\n                    break;\n            }\n            commands.splice(i, 0, command);\n        }\n    };\n\n    this.addCommands = function(commands) {\n        commands && Object.keys(commands).forEach(function(name) {\n            var command = commands[name];\n            if (!command)\n                return;\n            \n            if (typeof command === \"string\")\n                return this.bindKey(command, name);\n\n            if (typeof command === \"function\")\n                command = { exec: command };\n\n            if (typeof command !== \"object\")\n                return;\n\n            if (!command.name)\n                command.name = name;\n\n            this.addCommand(command);\n        }, this);\n    };\n\n    this.removeCommands = function(commands) {\n        Object.keys(commands).forEach(function(name) {\n            this.removeCommand(commands[name]);\n        }, this);\n    };\n\n    this.bindKeys = function(keyList) {\n        Object.keys(keyList).forEach(function(key) {\n            this.bindKey(key, keyList[key]);\n        }, this);\n    };\n\n    this._buildKeyHash = function(command) {\n        this.bindKey(command.bindKey, command);\n    };\n    this.parseKeys = function(keys) {\n        var parts = keys.toLowerCase().split(/[\\-\\+]([\\-\\+])?/).filter(function(x){return x;});\n        var key = parts.pop();\n\n        var keyCode = keyUtil[key];\n        if (keyUtil.FUNCTION_KEYS[keyCode])\n            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();\n        else if (!parts.length)\n            return {key: key, hashId: -1};\n        else if (parts.length == 1 && parts[0] == \"shift\")\n            return {key: key.toUpperCase(), hashId: -1};\n\n        var hashId = 0;\n        for (var i = parts.length; i--;) {\n            var modifier = keyUtil.KEY_MODS[parts[i]];\n            if (modifier == null) {\n                if (typeof console != \"undefined\")\n                    console.error(\"invalid modifier \" + parts[i] + \" in \" + keys);\n                return false;\n            }\n            hashId |= modifier;\n        }\n        return {key: key, hashId: hashId};\n    };\n\n    this.findKeyCommand = function findKeyCommand(hashId, keyString) {\n        var key = KEY_MODS[hashId] + keyString;\n        return this.commandKeyBinding[key];\n    };\n\n    this.handleKeyboard = function(data, hashId, keyString, keyCode) {\n        if (keyCode < 0) return;\n        var key = KEY_MODS[hashId] + keyString;\n        var command = this.commandKeyBinding[key];\n        if (data.$keyChain) {\n            data.$keyChain += \" \" + key;\n            command = this.commandKeyBinding[data.$keyChain] || command;\n        }\n        \n        if (command) {\n            if (command == \"chainKeys\" || command[command.length - 1] == \"chainKeys\") {\n                data.$keyChain = data.$keyChain || key;\n                return {command: \"null\"};\n            }\n        }\n        \n        if (data.$keyChain) {\n            if ((!hashId || hashId == 4) && keyString.length == 1)\n                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input\n            else if (hashId == -1 || keyCode > 0)\n                data.$keyChain = \"\"; // reset keyChain\n        }\n        return {command: command};\n    };\n    \n    this.getStatusText = function(editor, data) {\n        return data.$keyChain || \"\";\n    };\n\n}).call(HashHandler.prototype);\n\nexports.HashHandler = HashHandler;\nexports.MultiHashHandler = MultiHashHandler;\n});\n\nace.define(\"ace/commands/command_manager\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/keyboard/hash_handler\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar MultiHashHandler = require(\"../keyboard/hash_handler\").MultiHashHandler;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar CommandManager = function(platform, commands) {\n    MultiHashHandler.call(this, commands, platform);\n    this.byName = this.commands;\n    this.setDefaultHandler(\"exec\", function(e) {\n        return e.command.exec(e.editor, e.args || {});\n    });\n};\n\noop.inherits(CommandManager, MultiHashHandler);\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.exec = function(command, editor, args) {\n        if (Array.isArray(command)) {\n            for (var i = command.length; i--; ) {\n                if (this.exec(command[i], editor, args)) return true;\n            }\n            return false;\n        }\n\n        if (typeof command === \"string\")\n            command = this.commands[command];\n\n        if (!command)\n            return false;\n\n        if (editor && editor.$readOnly && !command.readOnly)\n            return false;\n\n        if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))\n            return false;\n\n        var e = {editor: editor, command: command, args: args};\n        e.returnValue = this._emit(\"exec\", e);\n        this._signal(\"afterExec\", e);\n\n        return e.returnValue === false ? false : true;\n    };\n\n    this.toggleRecording = function(editor) {\n        if (this.$inReplay)\n            return;\n\n        editor && editor._emit(\"changeStatus\");\n        if (this.recording) {\n            this.macro.pop();\n            this.removeEventListener(\"exec\", this.$addCommandToMacro);\n\n            if (!this.macro.length)\n                this.macro = this.oldMacro;\n\n            return this.recording = false;\n        }\n        if (!this.$addCommandToMacro) {\n            this.$addCommandToMacro = function(e) {\n                this.macro.push([e.command, e.args]);\n            }.bind(this);\n        }\n\n        this.oldMacro = this.macro;\n        this.macro = [];\n        this.on(\"exec\", this.$addCommandToMacro);\n        return this.recording = true;\n    };\n\n    this.replay = function(editor) {\n        if (this.$inReplay || !this.macro)\n            return;\n\n        if (this.recording)\n            return this.toggleRecording(editor);\n\n        try {\n            this.$inReplay = true;\n            this.macro.forEach(function(x) {\n                if (typeof x == \"string\")\n                    this.exec(x, editor);\n                else\n                    this.exec(x[0], editor, x[1]);\n            }, this);\n        } finally {\n            this.$inReplay = false;\n        }\n    };\n\n    this.trimMacro = function(m) {\n        return m.map(function(x){\n            if (typeof x[0] != \"string\")\n                x[0] = x[0].name;\n            if (!x[1])\n                x = x[0];\n            return x;\n        });\n    };\n\n}).call(CommandManager.prototype);\n\nexports.CommandManager = CommandManager;\n\n});\n\nace.define(\"ace/commands/default_commands\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/config\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar lang = require(\"../lib/lang\");\nvar config = require(\"../config\");\nvar Range = require(\"../range\").Range;\n\nfunction bindKey(win, mac) {\n    return {win: win, mac: mac};\n}\nexports.commands = [{\n    name: \"showSettingsMenu\",\n    bindKey: bindKey(\"Ctrl-,\", \"Command-,\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/settings_menu\", function(module) {\n            module.init(editor);\n            editor.showSettingsMenu();\n        });\n    },\n    readOnly: true\n}, {\n    name: \"goToNextError\",\n    bindKey: bindKey(\"Alt-E\", \"F4\"),\n    exec: function(editor) {\n        config.loadModule(\"./ext/error_marker\", function(module) {\n            module.showErrorMarker(editor, 1);\n        });\n    },\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"goToPreviousError\",\n    bindKey: bindKey(\"Alt-Shift-E\", \"Shift-F4\"),\n    exec: function(editor) {\n        config.loadModule(\"./ext/error_marker\", function(module) {\n            module.showErrorMarker(editor, -1);\n        });\n    },\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"selectall\",\n    description: \"Select all\",\n    bindKey: bindKey(\"Ctrl-A\", \"Command-A\"),\n    exec: function(editor) { editor.selectAll(); },\n    readOnly: true\n}, {\n    name: \"centerselection\",\n    description: \"Center selection\",\n    bindKey: bindKey(null, \"Ctrl-L\"),\n    exec: function(editor) { editor.centerSelection(); },\n    readOnly: true\n}, {\n    name: \"gotoline\",\n    description: \"Go to line...\",\n    bindKey: bindKey(\"Ctrl-L\", \"Command-L\"),\n    exec: function(editor, line) {\n        if (typeof line === \"number\" && !isNaN(line))\n            editor.gotoLine(line);\n        editor.prompt({ $type: \"gotoLine\" });\n    },\n    readOnly: true\n}, {\n    name: \"fold\",\n    bindKey: bindKey(\"Alt-L|Ctrl-F1\", \"Command-Alt-L|Command-F1\"),\n    exec: function(editor) { editor.session.toggleFold(false); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"unfold\",\n    bindKey: bindKey(\"Alt-Shift-L|Ctrl-Shift-F1\", \"Command-Alt-Shift-L|Command-Shift-F1\"),\n    exec: function(editor) { editor.session.toggleFold(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"toggleFoldWidget\",\n    bindKey: bindKey(\"F2\", \"F2\"),\n    exec: function(editor) { editor.session.toggleFoldWidget(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"toggleParentFoldWidget\",\n    bindKey: bindKey(\"Alt-F2\", \"Alt-F2\"),\n    exec: function(editor) { editor.session.toggleFoldWidget(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"foldall\",\n    description: \"Fold all\",\n    bindKey: bindKey(null, \"Ctrl-Command-Option-0\"),\n    exec: function(editor) { editor.session.foldAll(); },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"foldOther\",\n    description: \"Fold other\",\n    bindKey: bindKey(\"Alt-0\", \"Command-Option-0\"),\n    exec: function(editor) { \n        editor.session.foldAll();\n        editor.session.unfold(editor.selection.getAllRanges());\n    },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"unfoldall\",\n    description: \"Unfold all\",\n    bindKey: bindKey(\"Alt-Shift-0\", \"Command-Option-Shift-0\"),\n    exec: function(editor) { editor.session.unfold(); },\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"findnext\",\n    description: \"Find next\",\n    bindKey: bindKey(\"Ctrl-K\", \"Command-G\"),\n    exec: function(editor) { editor.findNext(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"findprevious\",\n    description: \"Find previous\",\n    bindKey: bindKey(\"Ctrl-Shift-K\", \"Command-Shift-G\"),\n    exec: function(editor) { editor.findPrevious(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"center\",\n    readOnly: true\n}, {\n    name: \"selectOrFindNext\",\n    description: \"Select or find next\",\n    bindKey: bindKey(\"Alt-K\", \"Ctrl-G\"),\n    exec: function(editor) {\n        if (editor.selection.isEmpty())\n            editor.selection.selectWord();\n        else\n            editor.findNext(); \n    },\n    readOnly: true\n}, {\n    name: \"selectOrFindPrevious\",\n    description: \"Select or find previous\",\n    bindKey: bindKey(\"Alt-Shift-K\", \"Ctrl-Shift-G\"),\n    exec: function(editor) { \n        if (editor.selection.isEmpty())\n            editor.selection.selectWord();\n        else\n            editor.findPrevious();\n    },\n    readOnly: true\n}, {\n    name: \"find\",\n    description: \"Find\",\n    bindKey: bindKey(\"Ctrl-F\", \"Command-F\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor);});\n    },\n    readOnly: true\n}, {\n    name: \"overwrite\",\n    description: \"Overwrite\",\n    bindKey: \"Insert\",\n    exec: function(editor) { editor.toggleOverwrite(); },\n    readOnly: true\n}, {\n    name: \"selecttostart\",\n    description: \"Select to start\",\n    bindKey: bindKey(\"Ctrl-Shift-Home\", \"Command-Shift-Home|Command-Shift-Up\"),\n    exec: function(editor) { editor.getSelection().selectFileStart(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"gotostart\",\n    description: \"Go to start\",\n    bindKey: bindKey(\"Ctrl-Home\", \"Command-Home|Command-Up\"),\n    exec: function(editor) { editor.navigateFileStart(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"selectup\",\n    description: \"Select up\",\n    bindKey: bindKey(\"Shift-Up\", \"Shift-Up|Ctrl-Shift-P\"),\n    exec: function(editor) { editor.getSelection().selectUp(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"golineup\",\n    description: \"Go line up\",\n    bindKey: bindKey(\"Up\", \"Up|Ctrl-P\"),\n    exec: function(editor, args) { editor.navigateUp(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttoend\",\n    description: \"Select to end\",\n    bindKey: bindKey(\"Ctrl-Shift-End\", \"Command-Shift-End|Command-Shift-Down\"),\n    exec: function(editor) { editor.getSelection().selectFileEnd(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"gotoend\",\n    description: \"Go to end\",\n    bindKey: bindKey(\"Ctrl-End\", \"Command-End|Command-Down\"),\n    exec: function(editor) { editor.navigateFileEnd(); },\n    multiSelectAction: \"forEach\",\n    readOnly: true,\n    scrollIntoView: \"animate\",\n    aceCommandGroup: \"fileJump\"\n}, {\n    name: \"selectdown\",\n    description: \"Select down\",\n    bindKey: bindKey(\"Shift-Down\", \"Shift-Down|Ctrl-Shift-N\"),\n    exec: function(editor) { editor.getSelection().selectDown(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"golinedown\",\n    description: \"Go line down\",\n    bindKey: bindKey(\"Down\", \"Down|Ctrl-N\"),\n    exec: function(editor, args) { editor.navigateDown(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectwordleft\",\n    description: \"Select word left\",\n    bindKey: bindKey(\"Ctrl-Shift-Left\", \"Option-Shift-Left\"),\n    exec: function(editor) { editor.getSelection().selectWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotowordleft\",\n    description: \"Go to word left\",\n    bindKey: bindKey(\"Ctrl-Left\", \"Option-Left\"),\n    exec: function(editor) { editor.navigateWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttolinestart\",\n    description: \"Select to line start\",\n    bindKey: bindKey(\"Alt-Shift-Left\", \"Command-Shift-Left|Ctrl-Shift-A\"),\n    exec: function(editor) { editor.getSelection().selectLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotolinestart\",\n    description: \"Go to line start\",\n    bindKey: bindKey(\"Alt-Left|Home\", \"Command-Left|Home|Ctrl-A\"),\n    exec: function(editor) { editor.navigateLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectleft\",\n    description: \"Select left\",\n    bindKey: bindKey(\"Shift-Left\", \"Shift-Left|Ctrl-Shift-B\"),\n    exec: function(editor) { editor.getSelection().selectLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotoleft\",\n    description: \"Go to left\",\n    bindKey: bindKey(\"Left\", \"Left|Ctrl-B\"),\n    exec: function(editor, args) { editor.navigateLeft(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectwordright\",\n    description: \"Select word right\",\n    bindKey: bindKey(\"Ctrl-Shift-Right\", \"Option-Shift-Right\"),\n    exec: function(editor) { editor.getSelection().selectWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotowordright\",\n    description: \"Go to word right\",\n    bindKey: bindKey(\"Ctrl-Right\", \"Option-Right\"),\n    exec: function(editor) { editor.navigateWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selecttolineend\",\n    description: \"Select to line end\",\n    bindKey: bindKey(\"Alt-Shift-Right\", \"Command-Shift-Right|Shift-End|Ctrl-Shift-E\"),\n    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotolineend\",\n    description: \"Go to line end\",\n    bindKey: bindKey(\"Alt-Right|End\", \"Command-Right|End|Ctrl-E\"),\n    exec: function(editor) { editor.navigateLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectright\",\n    description: \"Select right\",\n    bindKey: bindKey(\"Shift-Right\", \"Shift-Right\"),\n    exec: function(editor) { editor.getSelection().selectRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"gotoright\",\n    description: \"Go to right\",\n    bindKey: bindKey(\"Right\", \"Right|Ctrl-F\"),\n    exec: function(editor, args) { editor.navigateRight(args.times); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectpagedown\",\n    description: \"Select page down\",\n    bindKey: \"Shift-PageDown\",\n    exec: function(editor) { editor.selectPageDown(); },\n    readOnly: true\n}, {\n    name: \"pagedown\",\n    description: \"Page down\",\n    bindKey: bindKey(null, \"Option-PageDown\"),\n    exec: function(editor) { editor.scrollPageDown(); },\n    readOnly: true\n}, {\n    name: \"gotopagedown\",\n    description: \"Go to page down\",\n    bindKey: bindKey(\"PageDown\", \"PageDown|Ctrl-V\"),\n    exec: function(editor) { editor.gotoPageDown(); },\n    readOnly: true\n}, {\n    name: \"selectpageup\",\n    description: \"Select page up\",\n    bindKey: \"Shift-PageUp\",\n    exec: function(editor) { editor.selectPageUp(); },\n    readOnly: true\n}, {\n    name: \"pageup\",\n    description: \"Page up\",\n    bindKey: bindKey(null, \"Option-PageUp\"),\n    exec: function(editor) { editor.scrollPageUp(); },\n    readOnly: true\n}, {\n    name: \"gotopageup\",\n    description: \"Go to page up\",\n    bindKey: \"PageUp\",\n    exec: function(editor) { editor.gotoPageUp(); },\n    readOnly: true\n}, {\n    name: \"scrollup\",\n    description: \"Scroll up\",\n    bindKey: bindKey(\"Ctrl-Up\", null),\n    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },\n    readOnly: true\n}, {\n    name: \"scrolldown\",\n    description: \"Scroll down\",\n    bindKey: bindKey(\"Ctrl-Down\", null),\n    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },\n    readOnly: true\n}, {\n    name: \"selectlinestart\",\n    description: \"Select line start\",\n    bindKey: \"Shift-Home\",\n    exec: function(editor) { editor.getSelection().selectLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectlineend\",\n    description: \"Select line end\",\n    bindKey: \"Shift-End\",\n    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"togglerecording\",\n    description: \"Toggle recording\",\n    bindKey: bindKey(\"Ctrl-Alt-E\", \"Command-Option-E\"),\n    exec: function(editor) { editor.commands.toggleRecording(editor); },\n    readOnly: true\n}, {\n    name: \"replaymacro\",\n    description: \"Replay macro\",\n    bindKey: bindKey(\"Ctrl-Shift-E\", \"Command-Shift-E\"),\n    exec: function(editor) { editor.commands.replay(editor); },\n    readOnly: true\n}, {\n    name: \"jumptomatching\",\n    description: \"Jump to matching\",\n    bindKey: bindKey(\"Ctrl-\\\\|Ctrl-P\", \"Command-\\\\\"),\n    exec: function(editor) { editor.jumpToMatching(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"selecttomatching\",\n    description: \"Select to matching\",\n    bindKey: bindKey(\"Ctrl-Shift-\\\\|Ctrl-Shift-P\", \"Command-Shift-\\\\\"),\n    exec: function(editor) { editor.jumpToMatching(true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"expandToMatching\",\n    description: \"Expand to matching\",\n    bindKey: bindKey(\"Ctrl-Shift-M\", \"Ctrl-Shift-M\"),\n    exec: function(editor) { editor.jumpToMatching(true, true); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"animate\",\n    readOnly: true\n}, {\n    name: \"passKeysToBrowser\",\n    description: \"Pass keys to browser\",\n    bindKey: bindKey(null, null),\n    exec: function() {},\n    passEvent: true,\n    readOnly: true\n}, {\n    name: \"copy\",\n    description: \"Copy\",\n    exec: function(editor) {\n    },\n    readOnly: true\n},\n{\n    name: \"cut\",\n    description: \"Cut\",\n    exec: function(editor) {\n        var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();\n        var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();\n        editor._emit(\"cut\", range);\n\n        if (!range.isEmpty())\n            editor.session.remove(range);\n        editor.clearSelection();\n    },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"paste\",\n    description: \"Paste\",\n    exec: function(editor, args) {\n        editor.$handlePaste(args);\n    },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removeline\",\n    description: \"Remove line\",\n    bindKey: bindKey(\"Ctrl-D\", \"Command-D\"),\n    exec: function(editor) { editor.removeLines(); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEachLine\"\n}, {\n    name: \"duplicateSelection\",\n    description: \"Duplicate selection\",\n    bindKey: bindKey(\"Ctrl-Shift-D\", \"Command-Shift-D\"),\n    exec: function(editor) { editor.duplicateSelection(); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"sortlines\",\n    description: \"Sort lines\",\n    bindKey: bindKey(\"Ctrl-Alt-S\", \"Command-Alt-S\"),\n    exec: function(editor) { editor.sortLines(); },\n    scrollIntoView: \"selection\",\n    multiSelectAction: \"forEachLine\"\n}, {\n    name: \"togglecomment\",\n    description: \"Toggle comment\",\n    bindKey: bindKey(\"Ctrl-/\", \"Command-/\"),\n    exec: function(editor) { editor.toggleCommentLines(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"toggleBlockComment\",\n    description: \"Toggle block comment\",\n    bindKey: bindKey(\"Ctrl-Shift-/\", \"Command-Shift-/\"),\n    exec: function(editor) { editor.toggleBlockComment(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"modifyNumberUp\",\n    description: \"Modify number up\",\n    bindKey: bindKey(\"Ctrl-Shift-Up\", \"Alt-Shift-Up\"),\n    exec: function(editor) { editor.modifyNumber(1); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"modifyNumberDown\",\n    description: \"Modify number down\",\n    bindKey: bindKey(\"Ctrl-Shift-Down\", \"Alt-Shift-Down\"),\n    exec: function(editor) { editor.modifyNumber(-1); },\n    scrollIntoView: \"cursor\",\n    multiSelectAction: \"forEach\"\n}, {\n    name: \"replace\",\n    description: \"Replace\",\n    bindKey: bindKey(\"Ctrl-H\", \"Command-Option-F\"),\n    exec: function(editor) {\n        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor, true);});\n    }\n}, {\n    name: \"undo\",\n    description: \"Undo\",\n    bindKey: bindKey(\"Ctrl-Z\", \"Command-Z\"),\n    exec: function(editor) { editor.undo(); }\n}, {\n    name: \"redo\",\n    description: \"Redo\",\n    bindKey: bindKey(\"Ctrl-Shift-Z|Ctrl-Y\", \"Command-Shift-Z|Command-Y\"),\n    exec: function(editor) { editor.redo(); }\n}, {\n    name: \"copylinesup\",\n    description: \"Copy lines up\",\n    bindKey: bindKey(\"Alt-Shift-Up\", \"Command-Option-Up\"),\n    exec: function(editor) { editor.copyLinesUp(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"movelinesup\",\n    description: \"Move lines up\",\n    bindKey: bindKey(\"Alt-Up\", \"Option-Up\"),\n    exec: function(editor) { editor.moveLinesUp(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"copylinesdown\",\n    description: \"Copy lines down\",\n    bindKey: bindKey(\"Alt-Shift-Down\", \"Command-Option-Down\"),\n    exec: function(editor) { editor.copyLinesDown(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"movelinesdown\",\n    description: \"Move lines down\",\n    bindKey: bindKey(\"Alt-Down\", \"Option-Down\"),\n    exec: function(editor) { editor.moveLinesDown(); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"del\",\n    description: \"Delete\",\n    bindKey: bindKey(\"Delete\", \"Delete|Ctrl-D|Shift-Delete\"),\n    exec: function(editor) { editor.remove(\"right\"); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"backspace\",\n    description: \"Backspace\",\n    bindKey: bindKey(\n        \"Shift-Backspace|Backspace\",\n        \"Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H\"\n    ),\n    exec: function(editor) { editor.remove(\"left\"); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"cut_or_delete\",\n    description: \"Cut or delete\",\n    bindKey: bindKey(\"Shift-Delete\", null),\n    exec: function(editor) { \n        if (editor.selection.isEmpty()) {\n            editor.remove(\"left\");\n        } else {\n            return false;\n        }\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolinestart\",\n    description: \"Remove to line start\",\n    bindKey: bindKey(\"Alt-Backspace\", \"Command-Backspace\"),\n    exec: function(editor) { editor.removeToLineStart(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolineend\",\n    description: \"Remove to line end\",\n    bindKey: bindKey(\"Alt-Delete\", \"Ctrl-K|Command-Delete\"),\n    exec: function(editor) { editor.removeToLineEnd(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolinestarthard\",\n    description: \"Remove to line start hard\",\n    bindKey: bindKey(\"Ctrl-Shift-Backspace\", null),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n        range.start.column = 0;\n        editor.session.remove(range);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removetolineendhard\",\n    description: \"Remove to line end hard\",\n    bindKey: bindKey(\"Ctrl-Shift-Delete\", null),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n        range.end.column = Number.MAX_VALUE;\n        editor.session.remove(range);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removewordleft\",\n    description: \"Remove word left\",\n    bindKey: bindKey(\"Ctrl-Backspace\", \"Alt-Backspace|Ctrl-Alt-Backspace\"),\n    exec: function(editor) { editor.removeWordLeft(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"removewordright\",\n    description: \"Remove word right\",\n    bindKey: bindKey(\"Ctrl-Delete\", \"Alt-Delete\"),\n    exec: function(editor) { editor.removeWordRight(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"outdent\",\n    description: \"Outdent\",\n    bindKey: bindKey(\"Shift-Tab\", \"Shift-Tab\"),\n    exec: function(editor) { editor.blockOutdent(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"indent\",\n    description: \"Indent\",\n    bindKey: bindKey(\"Tab\", \"Tab\"),\n    exec: function(editor) { editor.indent(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"blockoutdent\",\n    description: \"Block outdent\",\n    bindKey: bindKey(\"Ctrl-[\", \"Ctrl-[\"),\n    exec: function(editor) { editor.blockOutdent(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"blockindent\",\n    description: \"Block indent\",\n    bindKey: bindKey(\"Ctrl-]\", \"Ctrl-]\"),\n    exec: function(editor) { editor.blockIndent(); },\n    multiSelectAction: \"forEachLine\",\n    scrollIntoView: \"selectionPart\"\n}, {\n    name: \"insertstring\",\n    description: \"Insert string\",\n    exec: function(editor, str) { editor.insert(str); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"inserttext\",\n    description: \"Insert text\",\n    exec: function(editor, args) {\n        editor.insert(lang.stringRepeat(args.text  || \"\", args.times || 1));\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"splitline\",\n    description: \"Split line\",\n    bindKey: bindKey(null, \"Ctrl-O\"),\n    exec: function(editor) { editor.splitLine(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"transposeletters\",\n    description: \"Transpose letters\",\n    bindKey: bindKey(\"Alt-Shift-X\", \"Ctrl-T\"),\n    exec: function(editor) { editor.transposeLetters(); },\n    multiSelectAction: function(editor) {editor.transposeSelections(1); },\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"touppercase\",\n    description: \"To uppercase\",\n    bindKey: bindKey(\"Ctrl-U\", \"Ctrl-U\"),\n    exec: function(editor) { editor.toUpperCase(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"tolowercase\",\n    description: \"To lowercase\",\n    bindKey: bindKey(\"Ctrl-Shift-U\", \"Ctrl-Shift-U\"),\n    exec: function(editor) { editor.toLowerCase(); },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"expandtoline\",\n    description: \"Expand to line\",\n    bindKey: bindKey(\"Ctrl-Shift-L\", \"Command-Shift-L\"),\n    exec: function(editor) {\n        var range = editor.selection.getRange();\n\n        range.start.column = range.end.column = 0;\n        range.end.row++;\n        editor.selection.setRange(range, false);\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"joinlines\",\n    description: \"Join lines\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        var isBackwards = editor.selection.isBackwards();\n        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();\n        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();\n        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;\n        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());\n        var selectedCount = selectedText.replace(/\\n\\s*/, \" \").length;\n        var insertLine = editor.session.doc.getLine(selectionStart.row);\n\n        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {\n            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));\n            if (curLine.length !== 0) {\n                curLine = \" \" + curLine;\n            }\n            insertLine += curLine;\n        }\n\n        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {\n            insertLine += editor.session.doc.getNewLineCharacter();\n        }\n\n        editor.clearSelection();\n        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);\n\n        if (selectedCount > 0) {\n            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);\n            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);\n        } else {\n            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;\n            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);\n        }\n    },\n    multiSelectAction: \"forEach\",\n    readOnly: true\n}, {\n    name: \"invertSelection\",\n    description: \"Invert selection\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        var endRow = editor.session.doc.getLength() - 1;\n        var endCol = editor.session.doc.getLine(endRow).length;\n        var ranges = editor.selection.rangeList.ranges;\n        var newRanges = [];\n        if (ranges.length < 1) {\n            ranges = [editor.selection.getRange()];\n        }\n\n        for (var i = 0; i < ranges.length; i++) {\n            if (i == (ranges.length - 1)) {\n                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {\n                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));\n                }\n            }\n\n            if (i === 0) {\n                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {\n                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));\n                }\n            } else {\n                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));\n            }\n        }\n\n        editor.exitMultiSelectMode();\n        editor.clearSelection();\n\n        for(var i = 0; i < newRanges.length; i++) {\n            editor.selection.addRange(newRanges[i], false);\n        }\n    },\n    readOnly: true,\n    scrollIntoView: \"none\"\n}, {\n    name: \"addLineAfter\",\n    exec: function(editor) {\n        editor.selection.clearSelection();\n        editor.navigateLineEnd();\n        editor.insert(\"\\n\");\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"addLineBefore\",\n    exec: function(editor) {\n        editor.selection.clearSelection();\n        var cursor = editor.getCursorPosition();\n        editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);\n        editor.insert(\"\\n\");\n        if (cursor.row === 0) editor.navigateUp();\n    },\n    multiSelectAction: \"forEach\",\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"openCommandPallete\",\n    description: \"Open command pallete\",\n    bindKey: bindKey(\"F1\", \"F1\"),\n    exec: function(editor) {\n        editor.prompt({ $type: \"commands\" });\n    },\n    readOnly: true\n}, {\n    name: \"modeSelect\",\n    description: \"Change language mode...\",\n    bindKey: bindKey(null, null),\n    exec: function(editor) {\n        editor.prompt({ $type: \"modes\" });\n    },\n    readOnly: true\n}];\n\n});\n\nace.define(\"ace/editor\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/keyboard/textinput\",\"ace/mouse/mouse_handler\",\"ace/mouse/fold_handler\",\"ace/keyboard/keybinding\",\"ace/edit_session\",\"ace/search\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/commands/command_manager\",\"ace/commands/default_commands\",\"ace/config\",\"ace/token_iterator\",\"ace/clipboard\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar lang = require(\"./lib/lang\");\nvar useragent = require(\"./lib/useragent\");\nvar TextInput = require(\"./keyboard/textinput\").TextInput;\nvar MouseHandler = require(\"./mouse/mouse_handler\").MouseHandler;\nvar FoldHandler = require(\"./mouse/fold_handler\").FoldHandler;\nvar KeyBinding = require(\"./keyboard/keybinding\").KeyBinding;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar Search = require(\"./search\").Search;\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar CommandManager = require(\"./commands/command_manager\").CommandManager;\nvar defaultCommands = require(\"./commands/default_commands\").commands;\nvar config = require(\"./config\");\nvar TokenIterator = require(\"./token_iterator\").TokenIterator;\n\nvar clipboard = require(\"./clipboard\");\nvar Editor = function(renderer, session, options) {\n    var container = renderer.getContainerElement();\n    this.container = container;\n    this.renderer = renderer;\n    this.id = \"editor\" + (++Editor.$uid);\n\n    this.commands = new CommandManager(useragent.isMac ? \"mac\" : \"win\", defaultCommands);\n    if (typeof document == \"object\") {\n        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);\n        this.renderer.textarea = this.textInput.getElement();\n        this.$mouseHandler = new MouseHandler(this);\n        new FoldHandler(this);\n    }\n\n    this.keyBinding = new KeyBinding(this);\n\n    this.$search = new Search().set({\n        wrap: true\n    });\n\n    this.$historyTracker = this.$historyTracker.bind(this);\n    this.commands.on(\"exec\", this.$historyTracker);\n\n    this.$initOperationListeners();\n    \n    this._$emitInputEvent = lang.delayedCall(function() {\n        this._signal(\"input\", {});\n        if (this.session && this.session.bgTokenizer)\n            this.session.bgTokenizer.scheduleStart();\n    }.bind(this));\n    \n    this.on(\"change\", function(_, _self) {\n        _self._$emitInputEvent.schedule(31);\n    });\n\n    this.setSession(session || options && options.session || new EditSession(\"\"));\n    config.resetOptions(this);\n    if (options)\n        this.setOptions(options);\n    config._signal(\"editor\", this);\n};\n\nEditor.$uid = 0;\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$initOperationListeners = function() {\n        this.commands.on(\"exec\", this.startOperation.bind(this), true);\n        this.commands.on(\"afterExec\", this.endOperation.bind(this), true);\n\n        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));\n        this.on(\"change\", function() {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.docChanged = true;\n        }.bind(this), true);\n        \n        this.on(\"changeSelection\", function() {\n            if (!this.curOp) {\n                this.startOperation();\n                this.curOp.selectionBefore = this.$lastSel;\n            }\n            this.curOp.selectionChanged = true;\n        }.bind(this), true);\n    };\n\n    this.curOp = null;\n    this.prevOp = {};\n    this.startOperation = function(commandEvent) {\n        if (this.curOp) {\n            if (!commandEvent || this.curOp.command)\n                return;\n            this.prevOp = this.curOp;\n        }\n        if (!commandEvent) {\n            this.previousCommand = null;\n            commandEvent = {};\n        }\n\n        this.$opResetTimer.schedule();\n        this.curOp = this.session.curOp = {\n            command: commandEvent.command || {},\n            args: commandEvent.args,\n            scrollTop: this.renderer.scrollTop\n        };\n        this.curOp.selectionBefore = this.selection.toJSON();\n    };\n\n    this.endOperation = function(e) {\n        if (this.curOp) {\n            if (e && e.returnValue === false)\n                return (this.curOp = null);\n            if (e == true && this.curOp.command && this.curOp.command.name == \"mouse\")\n                return;\n            this._signal(\"beforeEndOperation\");\n            if (!this.curOp) return;\n            var command = this.curOp.command;\n            var scrollIntoView = command && command.scrollIntoView;\n            if (scrollIntoView) {\n                switch (scrollIntoView) {\n                    case \"center-animate\":\n                        scrollIntoView = \"animate\";\n                    case \"center\":\n                        this.renderer.scrollCursorIntoView(null, 0.5);\n                        break;\n                    case \"animate\":\n                    case \"cursor\":\n                        this.renderer.scrollCursorIntoView();\n                        break;\n                    case \"selectionPart\":\n                        var range = this.selection.getRange();\n                        var config = this.renderer.layerConfig;\n                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {\n                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                if (scrollIntoView == \"animate\")\n                    this.renderer.animateScrolling(this.curOp.scrollTop);\n            }\n            var sel = this.selection.toJSON();\n            this.curOp.selectionAfter = sel;\n            this.$lastSel = this.selection.toJSON();\n            this.session.getUndoManager().addSelection(sel);\n            this.prevOp = this.curOp;\n            this.curOp = null;\n        }\n    };\n    this.$mergeableCommands = [\"backspace\", \"del\", \"insertstring\"];\n    this.$historyTracker = function(e) {\n        if (!this.$mergeUndoDeltas)\n            return;\n\n        var prev = this.prevOp;\n        var mergeableCommands = this.$mergeableCommands;\n        var shouldMerge = prev.command && (e.command.name == prev.command.name);\n        if (e.command.name == \"insertstring\") {\n            var text = e.args;\n            if (this.mergeNextCommand === undefined)\n                this.mergeNextCommand = true;\n\n            shouldMerge = shouldMerge\n                && this.mergeNextCommand // previous command allows to coalesce with\n                && (!/\\s/.test(text) || /\\s/.test(prev.args)); // previous insertion was of same type\n\n            this.mergeNextCommand = true;\n        } else {\n            shouldMerge = shouldMerge\n                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable\n        }\n\n        if (\n            this.$mergeUndoDeltas != \"always\"\n            && Date.now() - this.sequenceStartTime > 2000\n        ) {\n            shouldMerge = false; // the sequence is too long\n        }\n\n        if (shouldMerge)\n            this.session.mergeUndoDeltas = true;\n        else if (mergeableCommands.indexOf(e.command.name) !== -1)\n            this.sequenceStartTime = Date.now();\n    };\n    this.setKeyboardHandler = function(keyboardHandler, cb) {\n        if (keyboardHandler && typeof keyboardHandler === \"string\" && keyboardHandler != \"ace\") {\n            this.$keybindingId = keyboardHandler;\n            var _self = this;\n            config.loadModule([\"keybinding\", keyboardHandler], function(module) {\n                if (_self.$keybindingId == keyboardHandler)\n                    _self.keyBinding.setKeyboardHandler(module && module.handler);\n                cb && cb();\n            });\n        } else {\n            this.$keybindingId = null;\n            this.keyBinding.setKeyboardHandler(keyboardHandler);\n            cb && cb();\n        }\n    };\n    this.getKeyboardHandler = function() {\n        return this.keyBinding.getKeyboardHandler();\n    };\n    this.setSession = function(session) {\n        if (this.session == session)\n            return;\n        if (this.curOp) this.endOperation();\n        this.curOp = {};\n\n        var oldSession = this.session;\n        if (oldSession) {\n            this.session.off(\"change\", this.$onDocumentChange);\n            this.session.off(\"changeMode\", this.$onChangeMode);\n            this.session.off(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n            this.session.off(\"changeTabSize\", this.$onChangeTabSize);\n            this.session.off(\"changeWrapLimit\", this.$onChangeWrapLimit);\n            this.session.off(\"changeWrapMode\", this.$onChangeWrapMode);\n            this.session.off(\"changeFold\", this.$onChangeFold);\n            this.session.off(\"changeFrontMarker\", this.$onChangeFrontMarker);\n            this.session.off(\"changeBackMarker\", this.$onChangeBackMarker);\n            this.session.off(\"changeBreakpoint\", this.$onChangeBreakpoint);\n            this.session.off(\"changeAnnotation\", this.$onChangeAnnotation);\n            this.session.off(\"changeOverwrite\", this.$onCursorChange);\n            this.session.off(\"changeScrollTop\", this.$onScrollTopChange);\n            this.session.off(\"changeScrollLeft\", this.$onScrollLeftChange);\n\n            var selection = this.session.getSelection();\n            selection.off(\"changeCursor\", this.$onCursorChange);\n            selection.off(\"changeSelection\", this.$onSelectionChange);\n        }\n\n        this.session = session;\n        if (session) {\n            this.$onDocumentChange = this.onDocumentChange.bind(this);\n            session.on(\"change\", this.$onDocumentChange);\n            this.renderer.setSession(session);\n    \n            this.$onChangeMode = this.onChangeMode.bind(this);\n            session.on(\"changeMode\", this.$onChangeMode);\n    \n            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);\n            session.on(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n    \n            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);\n            session.on(\"changeTabSize\", this.$onChangeTabSize);\n    \n            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n            session.on(\"changeWrapLimit\", this.$onChangeWrapLimit);\n    \n            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);\n            session.on(\"changeWrapMode\", this.$onChangeWrapMode);\n    \n            this.$onChangeFold = this.onChangeFold.bind(this);\n            session.on(\"changeFold\", this.$onChangeFold);\n    \n            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);\n            this.session.on(\"changeFrontMarker\", this.$onChangeFrontMarker);\n    \n            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);\n            this.session.on(\"changeBackMarker\", this.$onChangeBackMarker);\n    \n            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);\n            this.session.on(\"changeBreakpoint\", this.$onChangeBreakpoint);\n    \n            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);\n            this.session.on(\"changeAnnotation\", this.$onChangeAnnotation);\n    \n            this.$onCursorChange = this.onCursorChange.bind(this);\n            this.session.on(\"changeOverwrite\", this.$onCursorChange);\n    \n            this.$onScrollTopChange = this.onScrollTopChange.bind(this);\n            this.session.on(\"changeScrollTop\", this.$onScrollTopChange);\n    \n            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);\n            this.session.on(\"changeScrollLeft\", this.$onScrollLeftChange);\n    \n            this.selection = session.getSelection();\n            this.selection.on(\"changeCursor\", this.$onCursorChange);\n    \n            this.$onSelectionChange = this.onSelectionChange.bind(this);\n            this.selection.on(\"changeSelection\", this.$onSelectionChange);\n    \n            this.onChangeMode();\n    \n            this.onCursorChange();\n    \n            this.onScrollTopChange();\n            this.onScrollLeftChange();\n            this.onSelectionChange();\n            this.onChangeFrontMarker();\n            this.onChangeBackMarker();\n            this.onChangeBreakpoint();\n            this.onChangeAnnotation();\n            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();\n            this.renderer.updateFull();\n        } else {\n            this.selection = null;\n            this.renderer.setSession(session);\n        }\n\n        this._signal(\"changeSession\", {\n            session: session,\n            oldSession: oldSession\n        });\n        \n        this.curOp = null;\n        \n        oldSession && oldSession._signal(\"changeEditor\", {oldEditor: this});\n        session && session._signal(\"changeEditor\", {editor: this});\n        \n        if (session && session.bgTokenizer)\n            session.bgTokenizer.scheduleStart();\n    };\n    this.getSession = function() {\n        return this.session;\n    };\n    this.setValue = function(val, cursorPos) {\n        this.session.doc.setValue(val);\n\n        if (!cursorPos)\n            this.selectAll();\n        else if (cursorPos == 1)\n            this.navigateFileEnd();\n        else if (cursorPos == -1)\n            this.navigateFileStart();\n\n        return val;\n    };\n    this.getValue = function() {\n        return this.session.getValue();\n    };\n    this.getSelection = function() {\n        return this.selection;\n    };\n    this.resize = function(force) {\n        this.renderer.onResize(force);\n    };\n    this.setTheme = function(theme, cb) {\n        this.renderer.setTheme(theme, cb);\n    };\n    this.getTheme = function() {\n        return this.renderer.getTheme();\n    };\n    this.setStyle = function(style) {\n        this.renderer.setStyle(style);\n    };\n    this.unsetStyle = function(style) {\n        this.renderer.unsetStyle(style);\n    };\n    this.getFontSize = function () {\n        return this.getOption(\"fontSize\") ||\n           dom.computedStyle(this.container).fontSize;\n    };\n    this.setFontSize = function(size) {\n        this.setOption(\"fontSize\", size);\n    };\n\n    this.$highlightBrackets = function() {\n        if (this.$highlightPending) {\n            return;\n        }\n        var self = this;\n        this.$highlightPending = true;\n        setTimeout(function () {\n            self.$highlightPending = false;\n            var session = self.session;\n            if (!session || !session.bgTokenizer) return;\n            if (session.$bracketHighlight) {\n                session.$bracketHighlight.markerIds.forEach(function(id) {\n                    session.removeMarker(id);\n                });\n                session.$bracketHighlight = null;\n            }\n            var ranges = session.getMatchingBracketRanges(self.getCursorPosition());\n            if (!ranges && session.$mode.getMatching) \n                ranges = session.$mode.getMatching(self.session);\n            if (!ranges)\n                return;\n\n            var markerType = \"ace_bracket\";\n            if (!Array.isArray(ranges)) {\n                ranges = [ranges];\n            } else if (ranges.length == 1) {\n                markerType = \"ace_error_bracket\";\n            }\n            if (ranges.length == 2) {\n                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)\n                    ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];\n                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)\n                    ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];\n            }\n\n            session.$bracketHighlight = {\n                ranges: ranges,\n                markerIds: ranges.map(function(range) {\n                    return session.addMarker(range, markerType, \"text\");\n                })\n            };\n        }, 50);\n    };\n    this.$highlightTags = function() {\n        if (this.$highlightTagPending)\n            return;\n        var self = this;\n        this.$highlightTagPending = true;\n        setTimeout(function() {\n            self.$highlightTagPending = false;\n            \n            var session = self.session;\n            if (!session || !session.bgTokenizer) return;\n            \n            var pos = self.getCursorPosition();\n            var iterator = new TokenIterator(self.session, pos.row, pos.column);\n            var token = iterator.getCurrentToken();\n            \n            if (!token || !/\\b(?:tag-open|tag-name)/.test(token.type)) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n                return;\n            }\n            \n            if (token.type.indexOf(\"tag-open\") != -1) {\n                token = iterator.stepForward();\n                if (!token)\n                    return;\n            }\n            \n            var tag = token.value;\n            var depth = 0;\n            var prevToken = iterator.stepBackward();\n            \n            if (prevToken.value == '<'){\n                do {\n                    prevToken = token;\n                    token = iterator.stepForward();\n                    \n                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                        if (prevToken.value === '<'){\n                            depth++;\n                        } else if (prevToken.value === '</'){\n                            depth--;\n                        }\n                    }\n                    \n                } while (token && depth >= 0);\n            } else {\n                do {\n                    token = prevToken;\n                    prevToken = iterator.stepBackward();\n                    \n                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                        if (prevToken.value === '<') {\n                            depth++;\n                        } else if (prevToken.value === '</') {\n                            depth--;\n                        }\n                    }\n                } while (prevToken && depth <= 0);\n                iterator.stepForward();\n            }\n            \n            if (!token) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n                return;\n            }\n            \n            var row = iterator.getCurrentTokenRow();\n            var column = iterator.getCurrentTokenColumn();\n            var range = new Range(row, column, row, column+token.value.length);\n            var sbm = session.$backMarkers[session.$tagHighlight];\n            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {\n                session.removeMarker(session.$tagHighlight);\n                session.$tagHighlight = null;\n            }\n            \n            if (!session.$tagHighlight)\n                session.$tagHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n        }, 50);\n    };\n    this.focus = function() {\n        var _self = this;\n        setTimeout(function() {\n            if (!_self.isFocused())\n                _self.textInput.focus();\n        });\n        this.textInput.focus();\n    };\n    this.isFocused = function() {\n        return this.textInput.isFocused();\n    };\n    this.blur = function() {\n        this.textInput.blur();\n    };\n    this.onFocus = function(e) {\n        if (this.$isFocused)\n            return;\n        this.$isFocused = true;\n        this.renderer.showCursor();\n        this.renderer.visualizeFocus();\n        this._emit(\"focus\", e);\n    };\n    this.onBlur = function(e) {\n        if (!this.$isFocused)\n            return;\n        this.$isFocused = false;\n        this.renderer.hideCursor();\n        this.renderer.visualizeBlur();\n        this._emit(\"blur\", e);\n    };\n\n    this.$cursorChange = function() {\n        this.renderer.updateCursor();\n    };\n    this.onDocumentChange = function(delta) {\n        var wrap = this.session.$useWrapMode;\n        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);\n        this.renderer.updateLines(delta.start.row, lastRow, wrap);\n\n        this._signal(\"change\", delta);\n        this.$cursorChange();\n        this.$updateHighlightActiveLine();\n    };\n\n    this.onTokenizerUpdate = function(e) {\n        var rows = e.data;\n        this.renderer.updateLines(rows.first, rows.last);\n    };\n\n\n    this.onScrollTopChange = function() {\n        this.renderer.scrollToY(this.session.getScrollTop());\n    };\n\n    this.onScrollLeftChange = function() {\n        this.renderer.scrollToX(this.session.getScrollLeft());\n    };\n    this.onCursorChange = function() {\n        this.$cursorChange();\n\n        this.$highlightBrackets();\n        this.$highlightTags();\n        this.$updateHighlightActiveLine();\n        this._signal(\"changeSelection\");\n    };\n\n    this.$updateHighlightActiveLine = function() {\n        var session = this.getSession();\n\n        var highlight;\n        if (this.$highlightActiveLine) {\n            if (this.$selectionStyle != \"line\" || !this.selection.isMultiLine())\n                highlight = this.getCursorPosition();\n            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())\n                highlight = false;\n            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))\n                highlight = false;\n        }\n\n        if (session.$highlightLineMarker && !highlight) {\n            session.removeMarker(session.$highlightLineMarker.id);\n            session.$highlightLineMarker = null;\n        } else if (!session.$highlightLineMarker && highlight) {\n            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);\n            range.id = session.addMarker(range, \"ace_active-line\", \"screenLine\");\n            session.$highlightLineMarker = range;\n        } else if (highlight) {\n            session.$highlightLineMarker.start.row = highlight.row;\n            session.$highlightLineMarker.end.row = highlight.row;\n            session.$highlightLineMarker.start.column = highlight.column;\n            session._signal(\"changeBackMarker\");\n        }\n    };\n\n    this.onSelectionChange = function(e) {\n        var session = this.session;\n\n        if (session.$selectionMarker) {\n            session.removeMarker(session.$selectionMarker);\n        }\n        session.$selectionMarker = null;\n\n        if (!this.selection.isEmpty()) {\n            var range = this.selection.getRange();\n            var style = this.getSelectionStyle();\n            session.$selectionMarker = session.addMarker(range, \"ace_selection\", style);\n        } else {\n            this.$updateHighlightActiveLine();\n        }\n\n        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();\n        this.session.highlight(re);\n\n        this._signal(\"changeSelection\");\n    };\n\n    this.$getSelectionHighLightRegexp = function() {\n        var session = this.session;\n\n        var selection = this.getSelectionRange();\n        if (selection.isEmpty() || selection.isMultiLine())\n            return;\n\n        var startColumn = selection.start.column;\n        var endColumn = selection.end.column;\n        var line = session.getLine(selection.start.row);\n        \n        var needle = line.substring(startColumn, endColumn);\n        if (needle.length > 5000 || !/[\\w\\d]/.test(needle))\n            return;\n\n        var re = this.$search.$assembleRegExp({\n            wholeWord: true,\n            caseSensitive: true,\n            needle: needle\n        });\n        \n        var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);\n        if (!re.test(wordWithBoundary))\n            return;\n        \n        return re;\n    };\n\n\n    this.onChangeFrontMarker = function() {\n        this.renderer.updateFrontMarkers();\n    };\n\n    this.onChangeBackMarker = function() {\n        this.renderer.updateBackMarkers();\n    };\n\n\n    this.onChangeBreakpoint = function() {\n        this.renderer.updateBreakpoints();\n    };\n\n    this.onChangeAnnotation = function() {\n        this.renderer.setAnnotations(this.session.getAnnotations());\n    };\n\n\n    this.onChangeMode = function(e) {\n        this.renderer.updateText();\n        this._emit(\"changeMode\", e);\n    };\n\n\n    this.onChangeWrapLimit = function() {\n        this.renderer.updateFull();\n    };\n\n    this.onChangeWrapMode = function() {\n        this.renderer.onResize(true);\n    };\n\n\n    this.onChangeFold = function() {\n        this.$updateHighlightActiveLine();\n        this.renderer.updateFull();\n    };\n    this.getSelectedText = function() {\n        return this.session.getTextRange(this.getSelectionRange());\n    };\n    this.getCopyText = function() {\n        var text = this.getSelectedText();\n        var nl = this.session.doc.getNewLineCharacter();\n        var copyLine= false;\n        if (!text && this.$copyWithEmptySelection) {\n            copyLine = true;\n            var ranges = this.selection.getAllRanges();\n            for (var i = 0; i < ranges.length; i++) {\n                var range = ranges[i];\n                if (i && ranges[i - 1].start.row == range.start.row)\n                    continue;\n                text += this.session.getLine(range.start.row) + nl;\n            }\n        }\n        var e = {text: text};\n        this._signal(\"copy\", e);\n        clipboard.lineMode = copyLine ? e.text : \"\";\n        return e.text;\n    };\n    this.onCopy = function() {\n        this.commands.exec(\"copy\", this);\n    };\n    this.onCut = function() {\n        this.commands.exec(\"cut\", this);\n    };\n    this.onPaste = function(text, event) {\n        var e = {text: text, event: event};\n        this.commands.exec(\"paste\", this, e);\n    };\n    \n    this.$handlePaste = function(e) {\n        if (typeof e == \"string\") \n            e = {text: e};\n        this._signal(\"paste\", e);\n        var text = e.text;\n\n        var lineMode = text == clipboard.lineMode;\n        var session = this.session;\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {\n            if (lineMode)\n                session.insert({ row: this.selection.lead.row, column: 0 }, text);\n            else\n                this.insert(text);\n        } else if (lineMode) {\n            this.selection.rangeList.ranges.forEach(function(range) {\n                session.insert({ row: range.start.row, column: 0 }, text);\n            });\n        } else {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var ranges = this.selection.rangeList.ranges;\n    \n            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);\n            if (lines.length != ranges.length || isFullLine)\n                return this.commands.exec(\"insertstring\", this, text);\n    \n            for (var i = ranges.length; i--;) {\n                var range = ranges[i];\n                if (!range.isEmpty())\n                    session.remove(range);\n    \n                session.insert(range.start, lines[i]);\n            }\n        }\n    };\n\n    this.execCommand = function(command, args) {\n        return this.commands.exec(command, this, args);\n    };\n    this.insert = function(text, pasted) {\n        var session = this.session;\n        var mode = session.getMode();\n        var cursor = this.getCursorPosition();\n\n        if (this.getBehavioursEnabled() && !pasted) {\n            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);\n            if (transform) {\n                if (text !== transform.text) {\n                    if (!this.inVirtualSelectionMode) {\n                        this.session.mergeUndoDeltas = false;\n                        this.mergeNextCommand = false;\n                    }\n                }\n                text = transform.text;\n\n            }\n        }\n        \n        if (text == \"\\t\")\n            text = this.session.getTabString();\n        if (!this.selection.isEmpty()) {\n            var range = this.getSelectionRange();\n            cursor = this.session.remove(range);\n            this.clearSelection();\n        }\n        else if (this.session.getOverwrite() && text.indexOf(\"\\n\") == -1) {\n            var range = new Range.fromPoints(cursor, cursor);\n            range.end.column += text.length;\n            this.session.remove(range);\n        }\n\n        if (text == \"\\n\" || text == \"\\r\\n\") {\n            var line = session.getLine(cursor.row);\n            if (cursor.column > line.search(/\\S|$/)) {\n                var d = line.substr(cursor.column).search(/\\S|$/);\n                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);\n            }\n        }\n        this.clearSelection();\n\n        var start = cursor.column;\n        var lineState = session.getState(cursor.row);\n        var line = session.getLine(cursor.row);\n        var shouldOutdent = mode.checkOutdent(lineState, line, text);\n        session.insert(cursor, text);\n\n        if (transform && transform.selection) {\n            if (transform.selection.length == 2) { // Transform relative to the current column\n                this.selection.setSelectionRange(\n                    new Range(cursor.row, start + transform.selection[0],\n                              cursor.row, start + transform.selection[1]));\n            } else { // Transform relative to the current row.\n                this.selection.setSelectionRange(\n                    new Range(cursor.row + transform.selection[0],\n                              transform.selection[1],\n                              cursor.row + transform.selection[2],\n                              transform.selection[3]));\n            }\n        }\n\n        if (session.getDocument().isNewLine(text)) {\n            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());\n\n            session.insert({row: cursor.row+1, column: 0}, lineIndent);\n        }\n        if (shouldOutdent)\n            mode.autoOutdent(lineState, session, cursor.row);\n    };\n\n    this.onTextInput = function(text, composition) {\n        if (!composition)\n            return this.keyBinding.onTextInput(text);\n        \n        this.startOperation({command: { name: \"insertstring\" }});\n        var applyComposition = this.applyComposition.bind(this, text, composition);\n        if (this.selection.rangeCount)\n            this.forEachSelection(applyComposition);\n        else\n            applyComposition();\n        this.endOperation();\n    };\n    \n    this.applyComposition = function(text, composition) {\n        if (composition.extendLeft || composition.extendRight) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.extendLeft;\n            r.end.column += composition.extendRight;\n            this.selection.setRange(r);\n            if (!text && !r.isEmpty())\n                this.remove();\n        }\n        if (text || !this.selection.isEmpty())\n            this.insert(text, true);\n        if (composition.restoreStart || composition.restoreEnd) {\n            var r = this.selection.getRange();\n            r.start.column -= composition.restoreStart;\n            r.end.column -= composition.restoreEnd;\n            this.selection.setRange(r);\n        }\n    };\n\n    this.onCommandKey = function(e, hashId, keyCode) {\n        return this.keyBinding.onCommandKey(e, hashId, keyCode);\n    };\n    this.setOverwrite = function(overwrite) {\n        this.session.setOverwrite(overwrite);\n    };\n    this.getOverwrite = function() {\n        return this.session.getOverwrite();\n    };\n    this.toggleOverwrite = function() {\n        this.session.toggleOverwrite();\n    };\n    this.setScrollSpeed = function(speed) {\n        this.setOption(\"scrollSpeed\", speed);\n    };\n    this.getScrollSpeed = function() {\n        return this.getOption(\"scrollSpeed\");\n    };\n    this.setDragDelay = function(dragDelay) {\n        this.setOption(\"dragDelay\", dragDelay);\n    };\n    this.getDragDelay = function() {\n        return this.getOption(\"dragDelay\");\n    };\n    this.setSelectionStyle = function(val) {\n        this.setOption(\"selectionStyle\", val);\n    };\n    this.getSelectionStyle = function() {\n        return this.getOption(\"selectionStyle\");\n    };\n    this.setHighlightActiveLine = function(shouldHighlight) {\n        this.setOption(\"highlightActiveLine\", shouldHighlight);\n    };\n    this.getHighlightActiveLine = function() {\n        return this.getOption(\"highlightActiveLine\");\n    };\n    this.setHighlightGutterLine = function(shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n\n    this.getHighlightGutterLine = function() {\n        return this.getOption(\"highlightGutterLine\");\n    };\n    this.setHighlightSelectedWord = function(shouldHighlight) {\n        this.setOption(\"highlightSelectedWord\", shouldHighlight);\n    };\n    this.getHighlightSelectedWord = function() {\n        return this.$highlightSelectedWord;\n    };\n\n    this.setAnimatedScroll = function(shouldAnimate){\n        this.renderer.setAnimatedScroll(shouldAnimate);\n    };\n\n    this.getAnimatedScroll = function(){\n        return this.renderer.getAnimatedScroll();\n    };\n    this.setShowInvisibles = function(showInvisibles) {\n        this.renderer.setShowInvisibles(showInvisibles);\n    };\n    this.getShowInvisibles = function() {\n        return this.renderer.getShowInvisibles();\n    };\n\n    this.setDisplayIndentGuides = function(display) {\n        this.renderer.setDisplayIndentGuides(display);\n    };\n\n    this.getDisplayIndentGuides = function() {\n        return this.renderer.getDisplayIndentGuides();\n    };\n    this.setShowPrintMargin = function(showPrintMargin) {\n        this.renderer.setShowPrintMargin(showPrintMargin);\n    };\n    this.getShowPrintMargin = function() {\n        return this.renderer.getShowPrintMargin();\n    };\n    this.setPrintMarginColumn = function(showPrintMargin) {\n        this.renderer.setPrintMarginColumn(showPrintMargin);\n    };\n    this.getPrintMarginColumn = function() {\n        return this.renderer.getPrintMarginColumn();\n    };\n    this.setReadOnly = function(readOnly) {\n        this.setOption(\"readOnly\", readOnly);\n    };\n    this.getReadOnly = function() {\n        return this.getOption(\"readOnly\");\n    };\n    this.setBehavioursEnabled = function (enabled) {\n        this.setOption(\"behavioursEnabled\", enabled);\n    };\n    this.getBehavioursEnabled = function () {\n        return this.getOption(\"behavioursEnabled\");\n    };\n    this.setWrapBehavioursEnabled = function (enabled) {\n        this.setOption(\"wrapBehavioursEnabled\", enabled);\n    };\n    this.getWrapBehavioursEnabled = function () {\n        return this.getOption(\"wrapBehavioursEnabled\");\n    };\n    this.setShowFoldWidgets = function(show) {\n        this.setOption(\"showFoldWidgets\", show);\n\n    };\n    this.getShowFoldWidgets = function() {\n        return this.getOption(\"showFoldWidgets\");\n    };\n\n    this.setFadeFoldWidgets = function(fade) {\n        this.setOption(\"fadeFoldWidgets\", fade);\n    };\n\n    this.getFadeFoldWidgets = function() {\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n    this.remove = function(dir) {\n        if (this.selection.isEmpty()){\n            if (dir == \"left\")\n                this.selection.selectLeft();\n            else\n                this.selection.selectRight();\n        }\n\n        var range = this.getSelectionRange();\n        if (this.getBehavioursEnabled()) {\n            var session = this.session;\n            var state = session.getState(range.start.row);\n            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);\n\n            if (range.end.column === 0) {\n                var text = session.getTextRange(range);\n                if (text[text.length - 1] == \"\\n\") {\n                    var line = session.getLine(range.end.row);\n                    if (/^\\s+$/.test(line)) {\n                        range.end.column = line.length;\n                    }\n                }\n            }\n            if (new_range)\n                range = new_range;\n        }\n\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    this.removeWordRight = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectWordRight();\n\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeWordLeft = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectWordLeft();\n\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeToLineStart = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectLineStart();\n        if (this.selection.isEmpty())\n            this.selection.selectLeft();\n        this.session.remove(this.getSelectionRange());\n        this.clearSelection();\n    };\n    this.removeToLineEnd = function() {\n        if (this.selection.isEmpty())\n            this.selection.selectLineEnd();\n\n        var range = this.getSelectionRange();\n        if (range.start.column == range.end.column && range.start.row == range.end.row) {\n            range.end.column = 0;\n            range.end.row++;\n        }\n\n        this.session.remove(range);\n        this.clearSelection();\n    };\n    this.splitLine = function() {\n        if (!this.selection.isEmpty()) {\n            this.session.remove(this.getSelectionRange());\n            this.clearSelection();\n        }\n\n        var cursor = this.getCursorPosition();\n        this.insert(\"\\n\");\n        this.moveCursorToPosition(cursor);\n    };\n    this.transposeLetters = function() {\n        if (!this.selection.isEmpty()) {\n            return;\n        }\n\n        var cursor = this.getCursorPosition();\n        var column = cursor.column;\n        if (column === 0)\n            return;\n\n        var line = this.session.getLine(cursor.row);\n        var swap, range;\n        if (column < line.length) {\n            swap = line.charAt(column) + line.charAt(column-1);\n            range = new Range(cursor.row, column-1, cursor.row, column+1);\n        }\n        else {\n            swap = line.charAt(column-1) + line.charAt(column-2);\n            range = new Range(cursor.row, column-2, cursor.row, column);\n        }\n        this.session.replace(range, swap);\n        this.session.selection.moveToPosition(range.end);\n    };\n    this.toLowerCase = function() {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toLowerCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    this.toUpperCase = function() {\n        var originalRange = this.getSelectionRange();\n        if (this.selection.isEmpty()) {\n            this.selection.selectWord();\n        }\n\n        var range = this.getSelectionRange();\n        var text = this.session.getTextRange(range);\n        this.session.replace(range, text.toUpperCase());\n        this.selection.setSelectionRange(originalRange);\n    };\n    this.indent = function() {\n        var session = this.session;\n        var range = this.getSelectionRange();\n\n        if (range.start.row < range.end.row) {\n            var rows = this.$getSelectedRows();\n            session.indentRows(rows.first, rows.last, \"\\t\");\n            return;\n        } else if (range.start.column < range.end.column) {\n            var text = session.getTextRange(range);\n            if (!/^\\s+$/.test(text)) {\n                var rows = this.$getSelectedRows();\n                session.indentRows(rows.first, rows.last, \"\\t\");\n                return;\n            }\n        }\n        \n        var line = session.getLine(range.start.row);\n        var position = range.start;\n        var size = session.getTabSize();\n        var column = session.documentToScreenColumn(position.row, position.column);\n\n        if (this.session.getUseSoftTabs()) {\n            var count = (size - column % size);\n            var indentString = lang.stringRepeat(\" \", count);\n        } else {\n            var count = column % size;\n            while (line[range.start.column - 1] == \" \" && count) {\n                range.start.column--;\n                count--;\n            }\n            this.selection.setSelectionRange(range);\n            indentString = \"\\t\";\n        }\n        return this.insert(indentString);\n    };\n    this.blockIndent = function() {\n        var rows = this.$getSelectedRows();\n        this.session.indentRows(rows.first, rows.last, \"\\t\");\n    };\n    this.blockOutdent = function() {\n        var selection = this.session.getSelection();\n        this.session.outdentRows(selection.getRange());\n    };\n    this.sortLines = function() {\n        var rows = this.$getSelectedRows();\n        var session = this.session;\n\n        var lines = [];\n        for (var i = rows.first; i <= rows.last; i++)\n            lines.push(session.getLine(i));\n\n        lines.sort(function(a, b) {\n            if (a.toLowerCase() < b.toLowerCase()) return -1;\n            if (a.toLowerCase() > b.toLowerCase()) return 1;\n            return 0;\n        });\n\n        var deleteRange = new Range(0, 0, 0, 0);\n        for (var i = rows.first; i <= rows.last; i++) {\n            var line = session.getLine(i);\n            deleteRange.start.row = i;\n            deleteRange.end.row = i;\n            deleteRange.end.column = line.length;\n            session.replace(deleteRange, lines[i-rows.first]);\n        }\n    };\n    this.toggleCommentLines = function() {\n        var state = this.session.getState(this.getCursorPosition().row);\n        var rows = this.$getSelectedRows();\n        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);\n    };\n\n    this.toggleBlockComment = function() {\n        var cursor = this.getCursorPosition();\n        var state = this.session.getState(cursor.row);\n        var range = this.getSelectionRange();\n        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);\n    };\n    this.getNumberAt = function(row, column) {\n        var _numberRx = /[\\-]?[0-9]+(?:\\.[0-9]+)?/g;\n        _numberRx.lastIndex = 0;\n\n        var s = this.session.getLine(row);\n        while (_numberRx.lastIndex < column) {\n            var m = _numberRx.exec(s);\n            if(m.index <= column && m.index+m[0].length >= column){\n                var number = {\n                    value: m[0],\n                    start: m.index,\n                    end: m.index+m[0].length\n                };\n                return number;\n            }\n        }\n        return null;\n    };\n    this.modifyNumber = function(amount) {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        var charRange = new Range(row, column-1, row, column);\n\n        var c = this.session.getTextRange(charRange);\n        if (!isNaN(parseFloat(c)) && isFinite(c)) {\n            var nr = this.getNumberAt(row, column);\n            if (nr) {\n                var fp = nr.value.indexOf(\".\") >= 0 ? nr.start + nr.value.indexOf(\".\") + 1 : nr.end;\n                var decimals = nr.start + nr.value.length - fp;\n\n                var t = parseFloat(nr.value);\n                t *= Math.pow(10, decimals);\n\n\n                if(fp !== nr.end && column < fp){\n                    amount *= Math.pow(10, nr.end - column - 1);\n                } else {\n                    amount *= Math.pow(10, nr.end - column);\n                }\n\n                t += amount;\n                t /= Math.pow(10, decimals);\n                var nnr = t.toFixed(decimals);\n                var replaceRange = new Range(row, nr.start, row, nr.end);\n                this.session.replace(replaceRange, nnr);\n                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));\n\n            }\n        } else {\n            this.toggleWord();\n        }\n    };\n\n    this.$toggleWordPairs = [\n        [\"first\", \"last\"],\n        [\"true\", \"false\"],\n        [\"yes\", \"no\"],\n        [\"width\", \"height\"],\n        [\"top\", \"bottom\"],\n        [\"right\", \"left\"],\n        [\"on\", \"off\"],\n        [\"x\", \"y\"],\n        [\"get\", \"set\"],\n        [\"max\", \"min\"],\n        [\"horizontal\", \"vertical\"],\n        [\"show\", \"hide\"],\n        [\"add\", \"remove\"],\n        [\"up\", \"down\"],\n        [\"before\", \"after\"],\n        [\"even\", \"odd\"],\n        [\"in\", \"out\"],\n        [\"inside\", \"outside\"],\n        [\"next\", \"previous\"],\n        [\"increase\", \"decrease\"],\n        [\"attach\", \"detach\"],\n        [\"&&\", \"||\"],\n        [\"==\", \"!=\"]\n    ];\n\n    this.toggleWord = function () {\n        var row = this.selection.getCursor().row;\n        var column = this.selection.getCursor().column;\n        this.selection.selectWord();\n        var currentState = this.getSelectedText();\n        var currWordStart = this.selection.getWordRange().start.column;\n        var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, '$1 ').split(/\\s/);\n        var delta = column - currWordStart - 1;\n        if (delta < 0) delta = 0;\n        var curLength = 0, itLength = 0;\n        var that = this;\n        if (currentState.match(/[A-Za-z0-9_]+/)) {\n            wordParts.forEach(function (item, i) {\n                itLength = curLength + item.length;\n                if (delta >= curLength && delta <= itLength) {\n                    currentState = item;\n                    that.selection.clearSelection();\n                    that.moveCursorTo(row, curLength + currWordStart);\n                    that.selection.selectTo(row, itLength + currWordStart);\n                }\n                curLength = itLength;\n            });\n        }\n\n        var wordPairs = this.$toggleWordPairs;\n        var reg;\n        for (var i = 0; i < wordPairs.length; i++) {\n            var item = wordPairs[i];\n            for (var j = 0; j <= 1; j++) {\n                var negate = +!j;\n                var firstCondition = currentState.match(new RegExp('^\\\\s?_?(' + lang.escapeRegExp(item[j]) + ')\\\\s?$', 'i'));\n                if (firstCondition) {\n                    var secondCondition = currentState.match(new RegExp('([_]|^|\\\\s)(' + lang.escapeRegExp(firstCondition[1]) + ')($|\\\\s)', 'g'));\n                    if (secondCondition) {\n                        reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), 'i'), function (result) {\n                            var res = item[negate];\n                            if (result.toUpperCase() == result) {\n                                res = res.toUpperCase();\n                            } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {\n                                res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);\n                            }\n                            return res;\n                        });\n                        this.insert(reg);\n                        reg = \"\";\n                    }\n                }\n            }\n        }\n    };\n    this.removeLines = function() {\n        var rows = this.$getSelectedRows();\n        this.session.removeFullLines(rows.first, rows.last);\n        this.clearSelection();\n    };\n\n    this.duplicateSelection = function() {\n        var sel = this.selection;\n        var doc = this.session;\n        var range = sel.getRange();\n        var reverse = sel.isBackwards();\n        if (range.isEmpty()) {\n            var row = range.start.row;\n            doc.duplicateLines(row, row);\n        } else {\n            var point = reverse ? range.start : range.end;\n            var endPoint = doc.insert(point, doc.getTextRange(range), false);\n            range.start = point;\n            range.end = endPoint;\n\n            sel.setSelectionRange(range, reverse);\n        }\n    };\n    this.moveLinesDown = function() {\n        this.$moveLines(1, false);\n    };\n    this.moveLinesUp = function() {\n        this.$moveLines(-1, false);\n    };\n    this.moveText = function(range, toPosition, copy) {\n        return this.session.moveText(range, toPosition, copy);\n    };\n    this.copyLinesUp = function() {\n        this.$moveLines(-1, true);\n    };\n    this.copyLinesDown = function() {\n        this.$moveLines(1, true);\n    };\n    this.$moveLines = function(dir, copy) {\n        var rows, moved;\n        var selection = this.selection;\n        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {\n            var range = selection.toOrientedRange();\n            rows = this.$getSelectedRows(range);\n            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);\n            if (copy && dir == -1) moved = 0;\n            range.moveBy(moved, 0);\n            selection.fromOrientedRange(range);\n        } else {\n            var ranges = selection.rangeList.ranges;\n            selection.rangeList.detach(this.session);\n            this.inVirtualSelectionMode = true;\n            \n            var diff = 0;\n            var totalDiff = 0;\n            var l = ranges.length;\n            for (var i = 0; i < l; i++) {\n                var rangeIndex = i;\n                ranges[i].moveBy(diff, 0);\n                rows = this.$getSelectedRows(ranges[i]);\n                var first = rows.first;\n                var last = rows.last;\n                while (++i < l) {\n                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);\n                    var subRows = this.$getSelectedRows(ranges[i]);\n                    if (copy && subRows.first != last)\n                        break;\n                    else if (!copy && subRows.first > last + 1)\n                        break;\n                    last = subRows.last;\n                }\n                i--;\n                diff = this.session.$moveLines(first, last, copy ? 0 : dir);\n                if (copy && dir == -1) rangeIndex = i + 1;\n                while (rangeIndex <= i) {\n                    ranges[rangeIndex].moveBy(diff, 0);\n                    rangeIndex++;\n                }\n                if (!copy) diff = 0;\n                totalDiff += diff;\n            }\n            \n            selection.fromOrientedRange(selection.ranges[0]);\n            selection.rangeList.attach(this.session);\n            this.inVirtualSelectionMode = false;\n        }\n    };\n    this.$getSelectedRows = function(range) {\n        range = (range || this.getSelectionRange()).collapseRows();\n\n        return {\n            first: this.session.getRowFoldStart(range.start.row),\n            last: this.session.getRowFoldEnd(range.end.row)\n        };\n    };\n\n    this.onCompositionStart = function(compositionState) {\n        this.renderer.showComposition(compositionState);\n    };\n\n    this.onCompositionUpdate = function(text) {\n        this.renderer.setCompositionText(text);\n    };\n\n    this.onCompositionEnd = function() {\n        this.renderer.hideComposition();\n    };\n    this.getFirstVisibleRow = function() {\n        return this.renderer.getFirstVisibleRow();\n    };\n    this.getLastVisibleRow = function() {\n        return this.renderer.getLastVisibleRow();\n    };\n    this.isRowVisible = function(row) {\n        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());\n    };\n    this.isRowFullyVisible = function(row) {\n        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());\n    };\n    this.$getVisibleRowCount = function() {\n        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;\n    };\n\n    this.$moveByPage = function(dir, select) {\n        var renderer = this.renderer;\n        var config = this.renderer.layerConfig;\n        var rows = dir * Math.floor(config.height / config.lineHeight);\n\n        if (select === true) {\n            this.selection.$moveSelection(function(){\n                this.moveCursorBy(rows, 0);\n            });\n        } else if (select === false) {\n            this.selection.moveCursorBy(rows, 0);\n            this.selection.clearSelection();\n        }\n\n        var scrollTop = renderer.scrollTop;\n\n        renderer.scrollBy(0, rows * config.lineHeight);\n        if (select != null)\n            renderer.scrollCursorIntoView(null, 0.5);\n\n        renderer.animateScrolling(scrollTop);\n    };\n    this.selectPageDown = function() {\n        this.$moveByPage(1, true);\n    };\n    this.selectPageUp = function() {\n        this.$moveByPage(-1, true);\n    };\n    this.gotoPageDown = function() {\n       this.$moveByPage(1, false);\n    };\n    this.gotoPageUp = function() {\n        this.$moveByPage(-1, false);\n    };\n    this.scrollPageDown = function() {\n        this.$moveByPage(1);\n    };\n    this.scrollPageUp = function() {\n        this.$moveByPage(-1);\n    };\n    this.scrollToRow = function(row) {\n        this.renderer.scrollToRow(row);\n    };\n    this.scrollToLine = function(line, center, animate, callback) {\n        this.renderer.scrollToLine(line, center, animate, callback);\n    };\n    this.centerSelection = function() {\n        var range = this.getSelectionRange();\n        var pos = {\n            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),\n            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)\n        };\n        this.renderer.alignCursor(pos, 0.5);\n    };\n    this.getCursorPosition = function() {\n        return this.selection.getCursor();\n    };\n    this.getCursorPositionScreen = function() {\n        return this.session.documentToScreenPosition(this.getCursorPosition());\n    };\n    this.getSelectionRange = function() {\n        return this.selection.getRange();\n    };\n    this.selectAll = function() {\n        this.selection.selectAll();\n    };\n    this.clearSelection = function() {\n        this.selection.clearSelection();\n    };\n    this.moveCursorTo = function(row, column) {\n        this.selection.moveCursorTo(row, column);\n    };\n    this.moveCursorToPosition = function(pos) {\n        this.selection.moveCursorToPosition(pos);\n    };\n    this.jumpToMatching = function(select, expand) {\n        var cursor = this.getCursorPosition();\n        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);\n        var prevToken = iterator.getCurrentToken();\n        var token = prevToken || iterator.stepForward();\n\n        if (!token) return;\n        var matchType;\n        var found = false;\n        var depth = {};\n        var i = cursor.column - token.start;\n        var bracketType;\n        var brackets = {\n            \")\": \"(\",\n            \"(\": \"(\",\n            \"]\": \"[\",\n            \"[\": \"[\",\n            \"{\": \"{\",\n            \"}\": \"{\"\n        };\n        \n        do {\n            if (token.value.match(/[{}()\\[\\]]/g)) {\n                for (; i < token.value.length && !found; i++) {\n                    if (!brackets[token.value[i]]) {\n                        continue;\n                    }\n\n                    bracketType = brackets[token.value[i]] + '.' + token.type.replace(\"rparen\", \"lparen\");\n\n                    if (isNaN(depth[bracketType])) {\n                        depth[bracketType] = 0;\n                    }\n\n                    switch (token.value[i]) {\n                        case '(':\n                        case '[':\n                        case '{':\n                            depth[bracketType]++;\n                            break;\n                        case ')':\n                        case ']':\n                        case '}':\n                            depth[bracketType]--;\n\n                            if (depth[bracketType] === -1) {\n                                matchType = 'bracket';\n                                found = true;\n                            }\n                        break;\n                    }\n                }\n            }\n            else if (token.type.indexOf('tag-name') !== -1) {\n                if (isNaN(depth[token.value])) {\n                    depth[token.value] = 0;\n                }\n                \n                if (prevToken.value === '<') {\n                    depth[token.value]++;\n                }\n                else if (prevToken.value === '</') {\n                    depth[token.value]--;\n                }\n                \n                if (depth[token.value] === -1) {\n                    matchType = 'tag';\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                prevToken = token;\n                token = iterator.stepForward();\n                i = 0;\n            }\n        } while (token && !found);\n        if (!matchType)\n            return;\n\n        var range, pos;\n        if (matchType === 'bracket') {\n            range = this.session.getBracketRange(cursor);\n            if (!range) {\n                range = new Range(\n                    iterator.getCurrentTokenRow(),\n                    iterator.getCurrentTokenColumn() + i - 1,\n                    iterator.getCurrentTokenRow(),\n                    iterator.getCurrentTokenColumn() + i - 1\n                );\n                pos = range.start;\n                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)\n                    range = this.session.getBracketRange(pos);\n            }\n        }\n        else if (matchType === 'tag') {\n            if (token && token.type.indexOf('tag-name') !== -1) \n                var tag = token.value;\n            else\n                return;\n\n            range = new Range(\n                iterator.getCurrentTokenRow(),\n                iterator.getCurrentTokenColumn() - 2,\n                iterator.getCurrentTokenRow(),\n                iterator.getCurrentTokenColumn() - 2\n            );\n            if (range.compare(cursor.row, cursor.column) === 0) {\n                found = false;\n                do {\n                    token = prevToken;\n                    prevToken = iterator.stepBackward();\n                    \n                    if (prevToken) {\n                        if (prevToken.type.indexOf('tag-close') !== -1) {\n                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);\n                        }\n\n                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {\n                            if (prevToken.value === '<') {\n                                depth[tag]++;\n                            }\n                            else if (prevToken.value === '</') {\n                                depth[tag]--;\n                            }\n                            \n                            if (depth[tag] === 0)\n                                found = true;\n                        }\n                    }\n                } while (prevToken && !found);\n            }\n            if (token && token.type.indexOf('tag-name')) {\n                pos = range.start;\n                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)\n                    pos = range.end;\n            }\n        }\n\n        pos = range && range.cursor || pos;\n        if (pos) {\n            if (select) {\n                if (range && expand) {\n                    this.selection.setRange(range);\n                } else if (range && range.isEqual(this.getSelectionRange())) {\n                    this.clearSelection();\n                } else {\n                    this.selection.selectTo(pos.row, pos.column);\n                }\n            } else {\n                this.selection.moveTo(pos.row, pos.column);\n            }\n        }\n    };\n    this.gotoLine = function(lineNumber, column, animate) {\n        this.selection.clearSelection();\n        this.session.unfold({row: lineNumber - 1, column: column || 0});\n        this.exitMultiSelectMode && this.exitMultiSelectMode();\n        this.moveCursorTo(lineNumber - 1, column || 0);\n\n        if (!this.isRowFullyVisible(lineNumber - 1))\n            this.scrollToLine(lineNumber - 1, true, animate);\n    };\n    this.navigateTo = function(row, column) {\n        this.selection.moveTo(row, column);\n    };\n    this.navigateUp = function(times) {\n        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {\n            var selectionStart = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionStart);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(-times || -1, 0);\n    };\n    this.navigateDown = function(times) {\n        if (this.selection.isMultiLine() && this.selection.isBackwards()) {\n            var selectionEnd = this.selection.anchor.getPosition();\n            return this.moveCursorToPosition(selectionEnd);\n        }\n        this.selection.clearSelection();\n        this.selection.moveCursorBy(times || 1, 0);\n    };\n    this.navigateLeft = function(times) {\n        if (!this.selection.isEmpty()) {\n            var selectionStart = this.getSelectionRange().start;\n            this.moveCursorToPosition(selectionStart);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorLeft();\n            }\n        }\n        this.clearSelection();\n    };\n    this.navigateRight = function(times) {\n        if (!this.selection.isEmpty()) {\n            var selectionEnd = this.getSelectionRange().end;\n            this.moveCursorToPosition(selectionEnd);\n        }\n        else {\n            times = times || 1;\n            while (times--) {\n                this.selection.moveCursorRight();\n            }\n        }\n        this.clearSelection();\n    };\n    this.navigateLineStart = function() {\n        this.selection.moveCursorLineStart();\n        this.clearSelection();\n    };\n    this.navigateLineEnd = function() {\n        this.selection.moveCursorLineEnd();\n        this.clearSelection();\n    };\n    this.navigateFileEnd = function() {\n        this.selection.moveCursorFileEnd();\n        this.clearSelection();\n    };\n    this.navigateFileStart = function() {\n        this.selection.moveCursorFileStart();\n        this.clearSelection();\n    };\n    this.navigateWordRight = function() {\n        this.selection.moveCursorWordRight();\n        this.clearSelection();\n    };\n    this.navigateWordLeft = function() {\n        this.selection.moveCursorWordLeft();\n        this.clearSelection();\n    };\n    this.replace = function(replacement, options) {\n        if (options)\n            this.$search.set(options);\n\n        var range = this.$search.find(this.session);\n        var replaced = 0;\n        if (!range)\n            return replaced;\n\n        if (this.$tryReplace(range, replacement)) {\n            replaced = 1;\n        }\n\n        this.selection.setSelectionRange(range);\n        this.renderer.scrollSelectionIntoView(range.start, range.end);\n\n        return replaced;\n    };\n    this.replaceAll = function(replacement, options) {\n        if (options) {\n            this.$search.set(options);\n        }\n\n        var ranges = this.$search.findAll(this.session);\n        var replaced = 0;\n        if (!ranges.length)\n            return replaced;\n\n        var selection = this.getSelectionRange();\n        this.selection.moveTo(0, 0);\n\n        for (var i = ranges.length - 1; i >= 0; --i) {\n            if(this.$tryReplace(ranges[i], replacement)) {\n                replaced++;\n            }\n        }\n\n        this.selection.setSelectionRange(selection);\n\n        return replaced;\n    };\n\n    this.$tryReplace = function(range, replacement) {\n        var input = this.session.getTextRange(range);\n        replacement = this.$search.replace(input, replacement);\n        if (replacement !== null) {\n            range.end = this.session.replace(range, replacement);\n            return range;\n        } else {\n            return null;\n        }\n    };\n    this.getLastSearchOptions = function() {\n        return this.$search.getOptions();\n    };\n    this.find = function(needle, options, animate) {\n        if (!options)\n            options = {};\n\n        if (typeof needle == \"string\" || needle instanceof RegExp)\n            options.needle = needle;\n        else if (typeof needle == \"object\")\n            oop.mixin(options, needle);\n\n        var range = this.selection.getRange();\n        if (options.needle == null) {\n            needle = this.session.getTextRange(range)\n                || this.$search.$options.needle;\n            if (!needle) {\n                range = this.session.getWordRange(range.start.row, range.start.column);\n                needle = this.session.getTextRange(range);\n            }\n            this.$search.set({needle: needle});\n        }\n\n        this.$search.set(options);\n        if (!options.start)\n            this.$search.set({start: range});\n\n        var newRange = this.$search.find(this.session);\n        if (options.preventScroll)\n            return newRange;\n        if (newRange) {\n            this.revealRange(newRange, animate);\n            return newRange;\n        }\n        if (options.backwards)\n            range.start = range.end;\n        else\n            range.end = range.start;\n        this.selection.setRange(range);\n    };\n    this.findNext = function(options, animate) {\n        this.find({skipCurrent: true, backwards: false}, options, animate);\n    };\n    this.findPrevious = function(options, animate) {\n        this.find(options, {skipCurrent: true, backwards: true}, animate);\n    };\n\n    this.revealRange = function(range, animate) {\n        this.session.unfold(range);\n        this.selection.setSelectionRange(range);\n\n        var scrollTop = this.renderer.scrollTop;\n        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);\n        if (animate !== false)\n            this.renderer.animateScrolling(scrollTop);\n    };\n    this.undo = function() {\n        this.session.getUndoManager().undo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    this.redo = function() {\n        this.session.getUndoManager().redo(this.session);\n        this.renderer.scrollCursorIntoView(null, 0.5);\n    };\n    this.destroy = function() {\n        this.renderer.destroy();\n        this._signal(\"destroy\", this);\n        if (this.session)\n            this.session.destroy();\n        if (this._$emitInputEvent)\n            this._$emitInputEvent.cancel();\n        this.session = null;\n    };\n    this.setAutoScrollEditorIntoView = function(enable) {\n        if (!enable)\n            return;\n        var rect;\n        var self = this;\n        var shouldScroll = false;\n        if (!this.$scrollAnchor)\n            this.$scrollAnchor = document.createElement(\"div\");\n        var scrollAnchor = this.$scrollAnchor;\n        scrollAnchor.style.cssText = \"position:absolute\";\n        this.container.insertBefore(scrollAnchor, this.container.firstChild);\n        var onChangeSelection = this.on(\"changeSelection\", function() {\n            shouldScroll = true;\n        });\n        var onBeforeRender = this.renderer.on(\"beforeRender\", function() {\n            if (shouldScroll)\n                rect = self.renderer.container.getBoundingClientRect();\n        });\n        var onAfterRender = this.renderer.on(\"afterRender\", function() {\n            if (shouldScroll && rect && (self.isFocused()\n                || self.searchBox && self.searchBox.isFocused())\n            ) {\n                var renderer = self.renderer;\n                var pos = renderer.$cursorLayer.$pixelPos;\n                var config = renderer.layerConfig;\n                var top = pos.top - config.offset;\n                if (pos.top >= 0 && top + rect.top < 0) {\n                    shouldScroll = true;\n                } else if (pos.top < config.height &&\n                    pos.top + rect.top + config.lineHeight > window.innerHeight) {\n                    shouldScroll = false;\n                } else {\n                    shouldScroll = null;\n                }\n                if (shouldScroll != null) {\n                    scrollAnchor.style.top = top + \"px\";\n                    scrollAnchor.style.left = pos.left + \"px\";\n                    scrollAnchor.style.height = config.lineHeight + \"px\";\n                    scrollAnchor.scrollIntoView(shouldScroll);\n                }\n                shouldScroll = rect = null;\n            }\n        });\n        this.setAutoScrollEditorIntoView = function(enable) {\n            if (enable)\n                return;\n            delete this.setAutoScrollEditorIntoView;\n            this.off(\"changeSelection\", onChangeSelection);\n            this.renderer.off(\"afterRender\", onAfterRender);\n            this.renderer.off(\"beforeRender\", onBeforeRender);\n        };\n    };\n\n\n    this.$resetCursorStyle = function() {\n        var style = this.$cursorStyle || \"ace\";\n        var cursorLayer = this.renderer.$cursorLayer;\n        if (!cursorLayer)\n            return;\n        cursorLayer.setSmoothBlinking(/smooth/.test(style));\n        cursorLayer.isBlinking = !this.$readOnly && style != \"wide\";\n        dom.setCssClass(cursorLayer.element, \"ace_slim-cursors\", /slim/.test(style));\n    };\n    this.prompt = function(message, options, callback) {\n        var editor = this;\n        config.loadModule(\"./ext/prompt\", function (module) {\n            module.prompt(editor, message, options, callback);\n        });\n    };\n\n}).call(Editor.prototype);\n\n\n\nconfig.defineOptions(Editor.prototype, \"editor\", {\n    selectionStyle: {\n        set: function(style) {\n            this.onSelectionChange();\n            this._signal(\"changeSelectionStyle\", {data: style});\n        },\n        initialValue: \"line\"\n    },\n    highlightActiveLine: {\n        set: function() {this.$updateHighlightActiveLine();},\n        initialValue: true\n    },\n    highlightSelectedWord: {\n        set: function(shouldHighlight) {this.$onSelectionChange();},\n        initialValue: true\n    },\n    readOnly: {\n        set: function(readOnly) {\n            this.textInput.setReadOnly(readOnly);\n            this.$resetCursorStyle(); \n        },\n        initialValue: false\n    },\n    copyWithEmptySelection: {\n        set: function(value) {\n            this.textInput.setCopyWithEmptySelection(value);\n        },\n        initialValue: false\n    },\n    cursorStyle: {\n        set: function(val) { this.$resetCursorStyle(); },\n        values: [\"ace\", \"slim\", \"smooth\", \"wide\"],\n        initialValue: \"ace\"\n    },\n    mergeUndoDeltas: {\n        values: [false, true, \"always\"],\n        initialValue: true\n    },\n    behavioursEnabled: {initialValue: true},\n    wrapBehavioursEnabled: {initialValue: true},\n    autoScrollEditorIntoView: {\n        set: function(val) {this.setAutoScrollEditorIntoView(val);}\n    },\n    keyboardHandler: {\n        set: function(val) { this.setKeyboardHandler(val); },\n        get: function() { return this.$keybindingId; },\n        handlesSet: true\n    },\n    value: {\n        set: function(val) { this.session.setValue(val); },\n        get: function() { return this.getValue(); },\n        handlesSet: true,\n        hidden: true\n    },\n    session: {\n        set: function(val) { this.setSession(val); },\n        get: function() { return this.session; },\n        handlesSet: true,\n        hidden: true\n    },\n    \n    showLineNumbers: {\n        set: function(show) {\n            this.renderer.$gutterLayer.setShowLineNumbers(show);\n            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);\n            if (show && this.$relativeLineNumbers)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        },\n        initialValue: true\n    },\n    relativeLineNumbers: {\n        set: function(value) {\n            if (this.$showLineNumbers && value)\n                relativeNumberRenderer.attach(this);\n            else\n                relativeNumberRenderer.detach(this);\n        }\n    },\n    placeholder: {\n        set: function(message) {\n            if (!this.$updatePlaceholder) {\n                this.$updatePlaceholder = function() {\n                    var value = this.renderer.$composition || this.getValue();\n                    if (value && this.renderer.placeholderNode) {\n                        this.renderer.off(\"afterRender\", this.$updatePlaceholder);\n                        dom.removeCssClass(this.container, \"ace_hasPlaceholder\");\n                        this.renderer.placeholderNode.remove();\n                        this.renderer.placeholderNode = null;\n                    } else if (!value && !this.renderer.placeholderNode) {\n                        this.renderer.on(\"afterRender\", this.$updatePlaceholder);\n                        dom.addCssClass(this.container, \"ace_hasPlaceholder\");\n                        var el = dom.createElement(\"div\");\n                        el.className = \"ace_placeholder\";\n                        el.textContent = this.$placeholder || \"\";\n                        this.renderer.placeholderNode = el;\n                        this.renderer.content.appendChild(this.renderer.placeholderNode);\n                    }\n                }.bind(this);\n                this.on(\"input\", this.$updatePlaceholder);\n            }\n            this.$updatePlaceholder();\n        }\n    },\n\n    hScrollBarAlwaysVisible: \"renderer\",\n    vScrollBarAlwaysVisible: \"renderer\",\n    highlightGutterLine: \"renderer\",\n    animatedScroll: \"renderer\",\n    showInvisibles: \"renderer\",\n    showPrintMargin: \"renderer\",\n    printMarginColumn: \"renderer\",\n    printMargin: \"renderer\",\n    fadeFoldWidgets: \"renderer\",\n    showFoldWidgets: \"renderer\",\n    displayIndentGuides: \"renderer\",\n    showGutter: \"renderer\",\n    fontSize: \"renderer\",\n    fontFamily: \"renderer\",\n    maxLines: \"renderer\",\n    minLines: \"renderer\",\n    scrollPastEnd: \"renderer\",\n    fixedWidthGutter: \"renderer\",\n    theme: \"renderer\",\n    hasCssTransforms: \"renderer\",\n    maxPixelHeight: \"renderer\",\n    useTextareaForIME: \"renderer\",\n\n    scrollSpeed: \"$mouseHandler\",\n    dragDelay: \"$mouseHandler\",\n    dragEnabled: \"$mouseHandler\",\n    focusTimeout: \"$mouseHandler\",\n    tooltipFollowsMouse: \"$mouseHandler\",\n\n    firstLineNumber: \"session\",\n    overwrite: \"session\",\n    newLineMode: \"session\",\n    useWorker: \"session\",\n    useSoftTabs: \"session\",\n    navigateWithinSoftTabs: \"session\",\n    tabSize: \"session\",\n    wrap: \"session\",\n    indentedSoftWrap: \"session\",\n    foldStyle: \"session\",\n    mode: \"session\"\n});\n\n\nvar relativeNumberRenderer = {\n    getText: function(session, row) {\n        return (Math.abs(session.selection.lead.row - row) || (row + 1 + (row < 9 ? \"\\xb7\" : \"\"))) + \"\";\n    },\n    getWidth: function(session, lastLineNumber, config) {\n        return Math.max(\n            lastLineNumber.toString().length,\n            (config.lastRow + 1).toString().length,\n            2\n        ) * config.characterWidth;\n    },\n    update: function(e, editor) {\n        editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);\n    },\n    attach: function(editor) {\n        editor.renderer.$gutterLayer.$renderer = this;\n        editor.on(\"changeSelection\", this.update);\n        this.update(null, editor);\n    },\n    detach: function(editor) {\n        if (editor.renderer.$gutterLayer.$renderer == this)\n            editor.renderer.$gutterLayer.$renderer = null;\n        editor.off(\"changeSelection\", this.update);\n        this.update(null, editor);\n    }\n};\n\nexports.Editor = Editor;\n});\n\nace.define(\"ace/undomanager\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar UndoManager = function() {\n    this.$maxRev = 0;\n    this.$fromUndo = false;\n    this.reset();\n};\n\n(function() {\n    \n    this.addSession = function(session) {\n        this.$session = session;\n    };\n    this.add = function(delta, allowMerge, session) {\n        if (this.$fromUndo) return;\n        if (delta == this.$lastDelta) return;\n        if (!this.$keepRedoStack) this.$redoStack.length = 0;\n        if (allowMerge === false || !this.lastDeltas) {\n            this.lastDeltas = [];\n            this.$undoStack.push(this.lastDeltas);\n            delta.id = this.$rev = ++this.$maxRev;\n        }\n        if (delta.action == \"remove\" || delta.action == \"insert\")\n            this.$lastDelta = delta;\n        this.lastDeltas.push(delta);\n    };\n    \n    this.addSelection = function(selection, rev) {\n        this.selections.push({\n            value: selection,\n            rev: rev || this.$rev\n        });\n    };\n    \n    this.startNewGroup = function() {\n        this.lastDeltas = null;\n        return this.$rev;\n    };\n    \n    this.markIgnored = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        var stack = this.$undoStack;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id <= from)\n                break;\n            if (delta.id < to)\n                delta.ignore = true;\n        }\n        this.lastDeltas = null;\n    };\n    \n    this.getSelection = function(rev, after) {\n        var stack = this.selections;\n        for (var i = stack.length; i--;) {\n            var selection = stack[i];\n            if (selection.rev < rev) {\n                if (after)\n                    selection = stack[i + 1];\n                return selection;\n            }\n        }\n    };\n    \n    this.getRevision = function() {\n        return this.$rev;\n    };\n    \n    this.getDeltas = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        var stack = this.$undoStack;\n        var end = null, start = 0;\n        for (var i = stack.length; i--;) {\n            var delta = stack[i][0];\n            if (delta.id < to && !end)\n                end = i+1;\n            if (delta.id <= from) {\n                start = i + 1;\n                break;\n            }\n        }\n        return stack.slice(start, end);\n    };\n    \n    this.getChangedRanges = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        \n    };\n    \n    this.getChangedLines = function(from, to) {\n        if (to == null) to = this.$rev + 1;\n        \n    };\n\n    this.validateDeltaBoundaries = function(deltaSet, docLength, invertAction) {\n        if (!deltaSet) {\n            return false;\n        }\n        return deltaSet.every(function(delta) {\n            var action = delta.action;\n            if (invertAction && delta.action === \"insert\") action = \"remove\";\n            if (invertAction && delta.action === \"remove\") action = \"insert\";\n            switch(action) {\n                case \"insert\":\n                    return delta.start.row <= docLength;\n                case \"remove\":\n                    return delta.start.row < docLength && delta.end.row < docLength;\n                default:\n                    return true;\n            }\n        });\n    };\n    this.undo = function(session, dontSelect) {\n        this.lastDeltas = null;\n        var stack = this.$undoStack;\n        \n        if (!rearrangeUndoStack(stack, stack.length))\n            return;\n        \n        if (!session)\n            session = this.$session;\n        \n        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)\n            this.$redoStack = [];\n        \n        this.$fromUndo = true;\n        \n        var deltaSet = stack.pop();\n        var undoSelectionRange = null;\n        if (this.validateDeltaBoundaries(deltaSet, session.getLength(), true)) {\n            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);\n            this.$redoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        \n        this.$fromUndo = false;\n\n        return undoSelectionRange;\n    };\n    this.redo = function(session, dontSelect) {\n        this.lastDeltas = null;\n        \n        if (!session)\n            session = this.$session;\n        \n        this.$fromUndo = true;\n        if (this.$redoStackBaseRev != this.$rev) {\n            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);\n            rebaseRedoStack(this.$redoStack, diff);\n            this.$redoStackBaseRev = this.$rev;\n            this.$redoStack.forEach(function(x) {\n                x[0].id = ++this.$maxRev;\n            }, this);\n        }\n        var deltaSet = this.$redoStack.pop();\n        var redoSelectionRange = null;\n        \n        if (this.validateDeltaBoundaries(deltaSet, session.getLength(), false)) {\n            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);\n            this.$undoStack.push(deltaSet);\n            this.$syncRev();\n        }\n        this.$fromUndo = false;\n        \n        return redoSelectionRange;\n    };\n    \n    this.$syncRev = function() {\n        var stack = this.$undoStack;\n        var nextDelta = stack[stack.length - 1];\n        var id = nextDelta && nextDelta[0].id || 0;\n        this.$redoStackBaseRev = id;\n        this.$rev = id;\n    };\n    this.reset = function() {\n        this.lastDeltas = null;\n        this.$lastDelta = null;\n        this.$undoStack = [];\n        this.$redoStack = [];\n        this.$rev = 0;\n        this.mark = 0;\n        this.$redoStackBaseRev = this.$rev;\n        this.selections = [];\n    };\n    this.canUndo = function() {\n        return this.$undoStack.length > 0;\n    };\n    this.canRedo = function() {\n        return this.$redoStack.length > 0;\n    };\n    this.bookmark = function(rev) {\n        if (rev == undefined)\n            rev = this.$rev;\n        this.mark = rev;\n    };\n    this.isAtBookmark = function() {\n        return this.$rev === this.mark;\n    };\n    \n    this.toJSON = function() {\n        \n    };\n    \n    this.fromJSON = function() {\n        \n    };\n    \n    this.hasUndo = this.canUndo;\n    this.hasRedo = this.canRedo;\n    this.isClean = this.isAtBookmark;\n    this.markClean = this.bookmark;\n    \n    this.$prettyPrint = function(delta) {\n        if (delta) return stringifyDelta(delta);\n        return stringifyDelta(this.$undoStack) + \"\\n---\\n\" + stringifyDelta(this.$redoStack);\n    };\n}).call(UndoManager.prototype);\n\nfunction rearrangeUndoStack(stack, pos) {\n    for (var i = pos; i--; ) {\n        var deltaSet = stack[i];\n        if (deltaSet && !deltaSet[0].ignore) {\n            while(i < pos - 1) {\n                var swapped = swapGroups(stack[i], stack[i + 1]);\n                stack[i] = swapped[0];\n                stack[i + 1] = swapped[1];\n                i++;\n            }\n            return true;\n        }\n    }\n}\n\nvar Range = require(\"./range\").Range;\nvar cmp = Range.comparePoints;\nvar comparePoints = Range.comparePoints;\n\nfunction $updateMarkers(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert) end = start;\n\n    for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = comparePoints(point, start);\n        if (cmp < 0) {\n            continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n            if (isInsert) {\n                if (point.bias == 1) {\n                    cmp = 1;\n                }\n                else {\n                    point.bias == -1;\n                    continue;\n                }\n            }\n        }\n        var cmp2 = isInsert ? cmp : comparePoints(point, end);\n        if (cmp2 > 0) {\n            point.row += rowShift;\n            point.column += point.row == end.row ? colShift : 0;\n            continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n            point.row = start.row;\n            point.column = start.column;\n            if (cmp2 === 0)\n                point.bias = 1;\n        }\n    }\n}\n\n\n\nfunction clonePos(pos) {\n    return {row: pos.row,column: pos.column};\n}\nfunction cloneDelta(d) {\n    return {\n        start: clonePos(d.start),\n        end: clonePos(d.end),\n        action: d.action,\n        lines: d.lines.slice()\n    };\n}\nfunction stringifyDelta(d) {\n    d = d || this;\n    if (Array.isArray(d)) {\n        return d.map(stringifyDelta).join(\"\\n\");\n    }\n    var type = \"\";\n    if (d.action) {\n        type = d.action == \"insert\" ? \"+\" : \"-\";\n        type += \"[\" + d.lines + \"]\";\n    } else if (d.value) {\n        if (Array.isArray(d.value)) {\n            type = d.value.map(stringifyRange).join(\"\\n\");\n        } else {\n            type = stringifyRange(d.value);\n        }\n    }\n    if (d.start) {\n        type += stringifyRange(d);\n    }\n    if (d.id || d.rev) {\n        type += \"\\t(\" + (d.id || d.rev) + \")\";\n    }\n    return type;\n}\nfunction stringifyRange(r) {\n    return r.start.row + \":\" + r.start.column \n        + \"=>\" + r.end.row + \":\" + r.end.column;\n}\n\nfunction swap(d1, d2) {\n    var i1 = d1.action == \"insert\";\n    var i2 = d2.action == \"insert\";\n    \n    if (i1 && i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        } else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        } else {\n            return null;\n        }\n    } else if (i1 && !i2) {\n        if (cmp(d2.start, d1.end) >= 0) {\n            shift(d2, d1, -1);\n        } else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        } else {\n            return null;\n        }\n    } else if (!i1 && i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        } else if (cmp(d2.start, d1.start) <= 0) {\n            shift(d1, d2, +1);\n        } else {\n            return null;\n        }\n    } else if (!i1 && !i2) {\n        if (cmp(d2.start, d1.start) >= 0) {\n            shift(d2, d1, +1);\n        } else if (cmp(d2.end, d1.start) <= 0) {\n            shift(d1, d2, -1);\n        } else {\n            return null;\n        }\n    }\n    return [d2, d1];\n}\nfunction swapGroups(ds1, ds2) {\n    for (var i = ds1.length; i--; ) {\n        for (var j = 0; j < ds2.length; j++) {\n            if (!swap(ds1[i], ds2[j])) {\n                while (i < ds1.length) {\n                    while (j--) {\n                        swap(ds2[j], ds1[i]);\n                    }\n                    j = ds2.length;\n                    i++;\n                }                \n                return [ds1, ds2];\n            }\n        }\n    }\n    ds1.selectionBefore = ds2.selectionBefore = \n    ds1.selectionAfter = ds2.selectionAfter = null;\n    return [ds2, ds1];\n}\nfunction xform(d1, c1) {\n    var i1 = d1.action == \"insert\";\n    var i2 = c1.action == \"insert\";\n    \n    if (i1 && i2) {\n        if (cmp(d1.start, c1.start) < 0) {\n            shift(c1, d1, 1);\n        } else {\n            shift(d1, c1, 1);\n        }\n    } else if (i1 && !i2) {\n        if (cmp(d1.start, c1.end) >= 0) {\n            shift(d1, c1, -1);\n        } else if (cmp(d1.start, c1.start) <= 0) {\n            shift(c1, d1, +1);\n        } else {\n            shift(d1, Range.fromPoints(c1.start, d1.start), -1);\n            shift(c1, d1, +1);\n        }\n    } else if (!i1 && i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        } else if (cmp(c1.start, d1.start) <= 0) {\n            shift(d1, c1, +1);\n        } else {\n            shift(c1, Range.fromPoints(d1.start, c1.start), -1);\n            shift(d1, c1, +1);\n        }\n    } else if (!i1 && !i2) {\n        if (cmp(c1.start, d1.end) >= 0) {\n            shift(c1, d1, -1);\n        } else if (cmp(c1.end, d1.start) <= 0) {\n            shift(d1, c1, -1);\n        } else {\n            var before, after;\n            if (cmp(d1.start, c1.start) < 0) {\n                before = d1;\n                d1 = splitDelta(d1, c1.start);\n            }\n            if (cmp(d1.end, c1.end) > 0) {\n                after = splitDelta(d1, c1.end);\n            }\n\n            shiftPos(c1.end, d1.start, d1.end, -1);\n            if (after && !before) {\n                d1.lines = after.lines;\n                d1.start = after.start;\n                d1.end = after.end;\n                after = d1;\n            }\n\n            return [c1, before, after].filter(Boolean);\n        }\n    }\n    return [c1, d1];\n}\n    \nfunction shift(d1, d2, dir) {\n    shiftPos(d1.start, d2.start, d2.end, dir);\n    shiftPos(d1.end, d2.start, d2.end, dir);\n}\nfunction shiftPos(pos, start, end, dir) {\n    if (pos.row == (dir == 1 ? start : end).row) {\n        pos.column += dir * (end.column - start.column);\n    }\n    pos.row += dir * (end.row - start.row);\n}\nfunction splitDelta(c, pos) {\n    var lines = c.lines;\n    var end = c.end;\n    c.end = clonePos(pos);    \n    var rowsBefore = c.end.row - c.start.row;\n    var otherLines = lines.splice(rowsBefore, lines.length);\n    \n    var col = rowsBefore ? pos.column : pos.column - c.start.column;\n    lines.push(otherLines[0].substring(0, col));\n    otherLines[0] = otherLines[0].substr(col)   ; \n    var rest = {\n        start: clonePos(pos),\n        end: end,\n        lines: otherLines,\n        action: c.action\n    };\n    return rest;\n}\n\nfunction moveDeltasByOne(redoStack, d) {\n    d = cloneDelta(d);\n    for (var j = redoStack.length; j--;) {\n        var deltaSet = redoStack[j];\n        for (var i = 0; i < deltaSet.length; i++) {\n            var x = deltaSet[i];\n            var xformed = xform(x, d);\n            d = xformed[0];\n            if (xformed.length != 2) {\n                if (xformed[2]) {\n                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);\n                    i++;\n                } else if (!xformed[1]) {\n                    deltaSet.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        if (!deltaSet.length) {\n            redoStack.splice(j, 1); \n        }\n    }\n    return redoStack;\n}\nfunction rebaseRedoStack(redoStack, deltaSets) {\n    for (var i = 0; i < deltaSets.length; i++) {\n        var deltas = deltaSets[i];\n        for (var j = 0; j < deltas.length; j++) {\n            moveDeltasByOne(redoStack, deltas[j]);\n        }\n    }\n}\n\nexports.UndoManager = UndoManager;\n\n});\n\nace.define(\"ace/layer/lines\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\n\nvar Lines = function(element, canvasHeight) {\n    this.element = element;\n    this.canvasHeight = canvasHeight || 500000;\n    this.element.style.height = (this.canvasHeight * 2) + \"px\";\n    \n    this.cells = [];\n    this.cellCache = [];\n    this.$offsetCoefficient = 0;\n};\n\n(function() {\n    \n    this.moveContainer = function(config) {\n        dom.translate(this.element, 0, -((config.firstRowScreen * config.lineHeight) % this.canvasHeight) - config.offset * this.$offsetCoefficient);\n    };    \n    \n    this.pageChanged = function(oldConfig, newConfig) {\n        return (\n            Math.floor((oldConfig.firstRowScreen * oldConfig.lineHeight) / this.canvasHeight) !==\n            Math.floor((newConfig.firstRowScreen * newConfig.lineHeight) / this.canvasHeight)\n        );\n    };\n    \n    this.computeLineTop = function(row, config, session) {\n        var screenTop = config.firstRowScreen * config.lineHeight;\n        var screenPage = Math.floor(screenTop / this.canvasHeight);\n        var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;\n        return lineTop - (screenPage * this.canvasHeight);\n    };\n    \n    this.computeLineHeight = function(row, config, session) {\n        return config.lineHeight * session.getRowLineCount(row);\n    };\n    \n    this.getLength = function() {\n        return this.cells.length;\n    };\n    \n    this.get = function(index) {\n        return this.cells[index];\n    };\n    \n    this.shift = function() {\n        this.$cacheCell(this.cells.shift());\n    };\n    \n    this.pop = function() {\n        this.$cacheCell(this.cells.pop());\n    };\n    \n    this.push = function(cell) {\n        if (Array.isArray(cell)) {\n            this.cells.push.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i=0; i<cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            this.element.appendChild(fragment);\n        } else {\n            this.cells.push(cell);\n            this.element.appendChild(cell.element);\n        }\n    };\n    \n    this.unshift = function(cell) {\n        if (Array.isArray(cell)) {\n            this.cells.unshift.apply(this.cells, cell);\n            var fragment = dom.createFragment(this.element);\n            for (var i=0; i<cell.length; i++) {\n                fragment.appendChild(cell[i].element);\n            }\n            if (this.element.firstChild)\n                this.element.insertBefore(fragment, this.element.firstChild);\n            else\n                this.element.appendChild(fragment);\n        } else {\n            this.cells.unshift(cell);\n            this.element.insertAdjacentElement(\"afterbegin\", cell.element);\n        }\n    };\n    \n    this.last = function() {\n        if (this.cells.length)\n            return this.cells[this.cells.length-1];\n        else\n            return null;\n    };\n    \n    this.$cacheCell = function(cell) {\n        if (!cell)\n            return;\n            \n        cell.element.remove();\n        this.cellCache.push(cell);\n    };\n    \n    this.createCell = function(row, config, session, initElement) {\n        var cell = this.cellCache.pop();\n        if (!cell) {\n            var element = dom.createElement(\"div\");\n            if (initElement)\n                initElement(element);\n            \n            this.element.appendChild(element);\n            \n            cell = {\n                element: element,\n                text: \"\",\n                row: row\n            };\n        }\n        cell.row = row;\n        \n        return cell;\n    };\n    \n}).call(Lines.prototype);\n\nexports.Lines = Lines;\n\n});\n\nace.define(\"ace/layer/gutter\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/layer/lines\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar Lines = require(\"./lines\").Lines;\n\nvar Gutter = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_gutter-layer\";\n    parentEl.appendChild(this.element);\n    this.setShowFoldWidgets(this.$showFoldWidgets);\n    \n    this.gutterWidth = 0;\n\n    this.$annotations = [];\n    this.$updateAnnotations = this.$updateAnnotations.bind(this);\n    \n    this.$lines = new Lines(this.element);\n    this.$lines.$offsetCoefficient = 1;\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.setSession = function(session) {\n        if (this.session)\n            this.session.removeEventListener(\"change\", this.$updateAnnotations);\n        this.session = session;\n        if (session)\n            session.on(\"change\", this.$updateAnnotations);\n    };\n\n    this.addGutterDecoration = function(row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.addGutterDecoration\");\n        this.session.addGutterDecoration(row, className);\n    };\n\n    this.removeGutterDecoration = function(row, className) {\n        if (window.console)\n            console.warn && console.warn(\"deprecated use session.removeGutterDecoration\");\n        this.session.removeGutterDecoration(row, className);\n    };\n\n    this.setAnnotations = function(annotations) {\n        this.$annotations = [];\n        for (var i = 0; i < annotations.length; i++) {\n            var annotation = annotations[i];\n            var row = annotation.row;\n            var rowInfo = this.$annotations[row];\n            if (!rowInfo)\n                rowInfo = this.$annotations[row] = {text: []};\n           \n            var annoText = annotation.text;\n            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || \"\";\n\n            if (rowInfo.text.indexOf(annoText) === -1)\n                rowInfo.text.push(annoText);\n\n            var type = annotation.type;\n            if (type == \"error\")\n                rowInfo.className = \" ace_error\";\n            else if (type == \"warning\" && rowInfo.className != \" ace_error\")\n                rowInfo.className = \" ace_warning\";\n            else if (type == \"info\" && (!rowInfo.className))\n                rowInfo.className = \" ace_info\";\n        }\n    };\n\n    this.$updateAnnotations = function (delta) {\n        if (!this.$annotations.length)\n            return;\n        var firstRow = delta.start.row;\n        var len = delta.end.row - firstRow;\n        if (len === 0) {\n        } else if (delta.action == 'remove') {\n            this.$annotations.splice(firstRow, len + 1, null);\n        } else {\n            var args = new Array(len + 1);\n            args.unshift(firstRow, 1);\n            this.$annotations.splice.apply(this.$annotations, args);\n        }\n    };\n\n    this.update = function(config) {\n        this.config = config;\n        \n        var session = this.session;\n        var firstRow = config.firstRow;\n        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n            session.getLength() - 1);\n            \n        this.oldLastRow = lastRow;\n        this.config = config;\n        \n        this.$lines.moveContainer(config);\n        this.$updateCursorRow();\n            \n        var fold = session.getNextFoldLine(firstRow);\n        var foldStart = fold ? fold.start.row : Infinity;\n\n        var cell = null;\n        var index = -1;\n        var row = firstRow;\n        \n        while (true) {\n            if (row > foldStart) {\n                row = fold.end.row + 1;\n                fold = session.getNextFoldLine(row, fold);\n                foldStart = fold ? fold.start.row : Infinity;\n            }\n            if (row > lastRow) {\n                while (this.$lines.getLength() > index + 1)\n                    this.$lines.pop();\n                    \n                break;\n            }\n\n            cell = this.$lines.get(++index);\n            if (cell) {\n                cell.row = row;\n            } else {\n                cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n                this.$lines.push(cell);\n            }\n\n            this.$renderCell(cell, config, fold, row);\n            row++;\n        }\n        \n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n\n    this.$updateGutterWidth = function(config) {\n        var session = this.session;\n        \n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        \n        var firstLineNumber = session.$firstLineNumber;\n        var lastLineText = this.$lines.last() ? this.$lines.last().text : \"\";\n        \n        if (this.$fixedWidth || session.$useWrapMode)\n            lastLineText = session.getLength() + firstLineNumber - 1;\n\n        var gutterWidth = gutterRenderer \n            ? gutterRenderer.getWidth(session, lastLineText, config)\n            : lastLineText.toString().length * config.characterWidth;\n        \n        var padding = this.$padding || this.$computePadding();\n        gutterWidth += padding.left + padding.right;\n        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {\n            this.gutterWidth = gutterWidth;\n            this.element.parentNode.style.width = \n            this.element.style.width = Math.ceil(this.gutterWidth) + \"px\";\n            this._signal(\"changeGutterWidth\", gutterWidth);\n        }\n    };\n    \n    this.$updateCursorRow = function() {\n        if (!this.$highlightGutterLine)\n            return;\n            \n        var position = this.session.selection.getCursor();\n        if (this.$cursorRow === position.row)\n            return;\n        \n        this.$cursorRow = position.row;\n    };\n    \n    this.updateLineHighlight = function() {\n        if (!this.$highlightGutterLine)\n            return;\n        var row = this.session.selection.cursor.row;\n        this.$cursorRow = row;\n\n        if (this.$cursorCell && this.$cursorCell.row == row)\n            return;\n        if (this.$cursorCell)\n            this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n        var cells = this.$lines.cells;\n        this.$cursorCell = null;\n        for (var i = 0; i < cells.length; i++) {\n            var cell = cells[i];\n            if (cell.row >= this.$cursorRow) {\n                if (cell.row > this.$cursorRow) {\n                    var fold = this.session.getFoldLine(this.$cursorRow);\n                    if (i > 0 && fold && fold.start.row == cells[i - 1].row)\n                        cell = cells[i - 1];\n                    else\n                        break;\n                }\n                cell.element.className = \"ace_gutter-active-line \" + cell.element.className;\n                this.$cursorCell = cell;\n                break;\n            }\n        }\n    };\n    \n    this.scrollLines = function(config) {\n        var oldConfig = this.config;\n        this.config = config;\n        \n        this.$updateCursorRow();\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n        \n        this.$lines.moveContainer(config);\n\n        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n            this.session.getLength() - 1);\n        var oldLastRow = this.oldLastRow;\n        this.oldLastRow = lastRow;\n        \n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n                this.$lines.shift();\n\n        if (oldLastRow > lastRow)\n            for (var row=this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row>0; row--)\n                this.$lines.pop();\n\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n\n        if (lastRow > oldLastRow) {\n            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));\n        }\n        \n        this.updateLineHighlight();\n        \n        this._signal(\"afterRender\");\n        this.$updateGutterWidth(config);\n    };\n\n    this.$renderLines = function(config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n\n            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);\n            this.$renderCell(cell, config, foldLine, row);\n            fragment.push(cell);\n\n            row++;\n        }\n        return fragment;\n    };\n    \n    this.$renderCell = function(cell, config, fold, row) {\n        var element = cell.element;\n        \n        var session = this.session;\n        \n        var textNode = element.childNodes[0];\n        var foldWidget = element.childNodes[1];\n\n        var firstLineNumber = session.$firstLineNumber;\n        \n        var breakpoints = session.$breakpoints;\n        var decorations = session.$decorations;\n        var gutterRenderer = session.gutterRenderer || this.$renderer;\n        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;\n        var foldStart = fold ? fold.start.row : Number.MAX_VALUE;\n        \n        var className = \"ace_gutter-cell \";\n        if (this.$highlightGutterLine) {\n            if (row == this.$cursorRow || (fold && row < this.$cursorRow && row >= foldStart &&  this.$cursorRow <= fold.end.row)) {\n                className += \"ace_gutter-active-line \";\n                if (this.$cursorCell != cell) {\n                    if (this.$cursorCell)\n                        this.$cursorCell.element.className = this.$cursorCell.element.className.replace(\"ace_gutter-active-line \", \"\");\n                    this.$cursorCell = cell;\n                }\n            }\n        }\n        \n        if (breakpoints[row])\n            className += breakpoints[row];\n        if (decorations[row])\n            className += decorations[row];\n        if (this.$annotations[row])\n            className += this.$annotations[row].className;\n        if (element.className != className)\n            element.className = className;\n\n        if (foldWidgets) {\n            var c = foldWidgets[row];\n            if (c == null)\n                c = foldWidgets[row] = session.getFoldWidget(row);\n        }\n\n        if (c) {\n            var className = \"ace_fold-widget ace_\" + c;\n            if (c == \"start\" && row == foldStart && row < fold.end.row)\n                className += \" ace_closed\";\n            else\n                className += \" ace_open\";\n            if (foldWidget.className != className)\n                foldWidget.className = className;\n\n            var foldHeight = config.lineHeight + \"px\";\n            dom.setStyle(foldWidget.style, \"height\", foldHeight);\n            dom.setStyle(foldWidget.style, \"display\", \"inline-block\");\n        } else {\n            if (foldWidget) {\n                dom.setStyle(foldWidget.style, \"display\", \"none\");\n            }\n        }\n        \n        var text = (gutterRenderer\n            ? gutterRenderer.getText(session, row)\n            : row + firstLineNumber).toString();\n            \n        if (text !== textNode.data) {\n            textNode.data = text;\n        }\n        \n        dom.setStyle(cell.element.style, \"height\", this.$lines.computeLineHeight(row, config, session) + \"px\");\n        dom.setStyle(cell.element.style, \"top\", this.$lines.computeLineTop(row, config, session) + \"px\");\n        \n        cell.text = text;\n        return cell;\n    };\n\n    this.$fixedWidth = false;\n    \n    this.$highlightGutterLine = true;\n    this.$renderer = \"\";\n    this.setHighlightGutterLine = function(highlightGutterLine) {\n        this.$highlightGutterLine = highlightGutterLine;\n    };\n    \n    this.$showLineNumbers = true;\n    this.$renderer = \"\";\n    this.setShowLineNumbers = function(show) {\n        this.$renderer = !show && {\n            getWidth: function() {return 0;},\n            getText: function() {return \"\";}\n        };\n    };\n    \n    this.getShowLineNumbers = function() {\n        return this.$showLineNumbers;\n    };\n    \n    this.$showFoldWidgets = true;\n    this.setShowFoldWidgets = function(show) {\n        if (show)\n            dom.addCssClass(this.element, \"ace_folding-enabled\");\n        else\n            dom.removeCssClass(this.element, \"ace_folding-enabled\");\n\n        this.$showFoldWidgets = show;\n        this.$padding = null;\n    };\n    \n    this.getShowFoldWidgets = function() {\n        return this.$showFoldWidgets;\n    };\n\n    this.$computePadding = function() {\n        if (!this.element.firstChild)\n            return {left: 0, right: 0};\n        var style = dom.computedStyle(this.element.firstChild);\n        this.$padding = {};\n        this.$padding.left = (parseInt(style.borderLeftWidth) || 0)\n            + (parseInt(style.paddingLeft) || 0) + 1;\n        this.$padding.right = (parseInt(style.borderRightWidth) || 0)\n            + (parseInt(style.paddingRight) || 0);\n        return this.$padding;\n    };\n\n    this.getRegion = function(point) {\n        var padding = this.$padding || this.$computePadding();\n        var rect = this.element.getBoundingClientRect();\n        if (point.x < padding.left + rect.left)\n            return \"markers\";\n        if (this.$showFoldWidgets && point.x > rect.right - padding.right)\n            return \"foldWidgets\";\n    };\n\n}).call(Gutter.prototype);\n\nfunction onCreateCell(element) {\n    var textNode = document.createTextNode('');\n    element.appendChild(textNode);\n    \n    var foldWidget = dom.createElement(\"span\");\n    element.appendChild(foldWidget);\n    \n    return element;\n}\n\nexports.Gutter = Gutter;\n\n});\n\nace.define(\"ace/layer/marker\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\nvar dom = require(\"../lib/dom\");\n\nvar Marker = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_marker-layer\";\n    parentEl.appendChild(this.element);\n};\n\n(function() {\n\n    this.$padding = 0;\n\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n    };\n    this.setSession = function(session) {\n        this.session = session;\n    };\n    \n    this.setMarkers = function(markers) {\n        this.markers = markers;\n    };\n    \n    this.elt = function(className, css) {\n        var x = this.i != -1 && this.element.childNodes[this.i];\n        if (!x) {\n            x = document.createElement(\"div\");\n            this.element.appendChild(x);\n            this.i = -1;\n        } else {\n            this.i++;\n        }\n        x.style.cssText = css;\n        x.className = className;\n    };\n\n    this.update = function(config) {\n        if (!config) return;\n\n        this.config = config;\n\n        this.i = 0;\n        var html;\n        for (var key in this.markers) {\n            var marker = this.markers[key];\n\n            if (!marker.range) {\n                marker.update(html, this, this.session, config);\n                continue;\n            }\n\n            var range = marker.range.clipRows(config.firstRow, config.lastRow);\n            if (range.isEmpty()) continue;\n\n            range = range.toScreenRange(this.session);\n            if (marker.renderer) {\n                var top = this.$getTop(range.start.row, config);\n                var left = this.$padding + range.start.column * config.characterWidth;\n                marker.renderer(html, range, left, top, config);\n            } else if (marker.type == \"fullLine\") {\n                this.drawFullLineMarker(html, range, marker.clazz, config);\n            } else if (marker.type == \"screenLine\") {\n                this.drawScreenLineMarker(html, range, marker.clazz, config);\n            } else if (range.isMultiLine()) {\n                if (marker.type == \"text\")\n                    this.drawTextMarker(html, range, marker.clazz, config);\n                else\n                    this.drawMultiLineMarker(html, range, marker.clazz, config);\n            } else {\n                this.drawSingleLineMarker(html, range, marker.clazz + \" ace_start\" + \" ace_br15\", config);\n            }\n        }\n        if (this.i !=-1) {\n            while (this.i < this.element.childElementCount)\n                this.element.removeChild(this.element.lastChild);\n        }\n    };\n\n    this.$getTop = function(row, layerConfig) {\n        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;\n    };\n\n    function getBorderClass(tl, tr, br, bl) {\n        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);\n    }\n    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {\n        var session = this.session;\n        var start = range.start.row;\n        var end = range.end.row;\n        var row = start;\n        var prev = 0; \n        var curr = 0;\n        var next = session.getScreenLastRowColumn(row);\n        var lineRange = new Range(row, range.start.column, row, curr);\n        for (; row <= end; row++) {\n            lineRange.start.row = lineRange.end.row = row;\n            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);\n            lineRange.end.column = next;\n            prev = curr;\n            curr = next;\n            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;\n            this.drawSingleLineMarker(stringBuilder, lineRange, \n                clazz + (row == start  ? \" ace_start\" : \"\") + \" ace_br\"\n                    + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end),\n                layerConfig, row == end ? 0 : 1, extraStyle);\n        }\n    };\n    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var padding = this.$padding;\n        var height = config.lineHeight;\n        var top = this.$getTop(range.start.row, config);\n        var left = padding + range.start.column * config.characterWidth;\n        extraStyle = extraStyle || \"\";\n\n        if (this.session.$bidiHandler.isBidiRow(range.start.row)) {\n           var range1 = range.clone();\n           range1.end.row = range1.start.row;\n           range1.end.column = this.session.getLine(range1.start.row).length;\n           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br1 ace_start\", config, null, extraStyle);\n        } else {\n            this.elt(\n                clazz + \" ace_br1 ace_start\",\n                \"height:\"+ height+ \"px;\"+ \"right:0;\"+ \"top:\"+top+ \"px;left:\"+ left+ \"px;\" + (extraStyle || \"\")\n            );\n        }\n        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {\n           var range1 = range.clone();\n           range1.start.row = range1.end.row;\n           range1.start.column = 0;\n           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + \" ace_br12\", config, null, extraStyle);\n        } else {\n            top = this.$getTop(range.end.row, config);\n            var width = range.end.column * config.characterWidth;\n\n            this.elt(\n                clazz + \" ace_br12\",\n                \"height:\"+ height+ \"px;\"+\n                \"width:\"+ width+ \"px;\"+\n                \"top:\"+ top+ \"px;\"+\n                \"left:\"+ padding+ \"px;\"+ (extraStyle || \"\")\n            );\n        }\n        height = (range.end.row - range.start.row - 1) * config.lineHeight;\n        if (height <= 0)\n            return;\n        top = this.$getTop(range.start.row + 1, config);\n        \n        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);\n\n        this.elt(\n            clazz + (radiusClass ? \" ace_br\" + radiusClass : \"\"),\n            \"height:\"+ height+ \"px;\"+\n            \"right:0;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:\"+ padding+ \"px;\"+ (extraStyle || \"\")\n        );\n    };\n    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        if (this.session.$bidiHandler.isBidiRow(range.start.row))\n            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);\n        var height = config.lineHeight;\n        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;\n\n        var top = this.$getTop(range.start.row, config);\n        var left = this.$padding + range.start.column * config.characterWidth;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"width:\"+ width+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:\"+ left+ \"px;\"+ (extraStyle || \"\")\n        );\n    };\n    this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;\n        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);\n\n        selections.forEach(function(selection) {\n            this.elt(\n                clazz,\n                \"height:\" + height + \"px;\" +\n                \"width:\" + selection.width + (extraLength || 0) + \"px;\" +\n                \"top:\" + top + \"px;\" +\n                \"left:\" + (padding + selection.left) + \"px;\" + (extraStyle || \"\")\n            );\n        }, this);\n    };\n\n    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n        if (range.start.row != range.end.row)\n            height += this.$getTop(range.end.row, config) - top;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:0;right:0;\"+ (extraStyle || \"\")\n        );\n    };\n    \n    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n        var top = this.$getTop(range.start.row, config);\n        var height = config.lineHeight;\n\n        this.elt(\n            clazz,\n            \"height:\"+ height+ \"px;\"+\n            \"top:\"+ top+ \"px;\"+\n            \"left:0;right:0;\"+ (extraStyle || \"\")\n        );\n    };\n\n}).call(Marker.prototype);\n\nexports.Marker = Marker;\n\n});\n\nace.define(\"ace/layer/text\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/layer/lines\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar Lines = require(\"./lines\").Lines;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar Text = function(parentEl) {\n    this.dom = dom; \n    this.element = this.dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_text-layer\";\n    parentEl.appendChild(this.element);\n    this.$updateEolChar = this.$updateEolChar.bind(this);\n    this.$lines = new Lines(this.element);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n\n    this.EOF_CHAR = \"\\xB6\";\n    this.EOL_CHAR_LF = \"\\xAC\";\n    this.EOL_CHAR_CRLF = \"\\xa4\";\n    this.EOL_CHAR = this.EOL_CHAR_LF;\n    this.TAB_CHAR = \"\\u2014\"; //\"\\u21E5\";\n    this.SPACE_CHAR = \"\\xB7\";\n    this.$padding = 0;\n    this.MAX_LINE_LENGTH = 10000;\n\n    this.$updateEolChar = function() {\n        var doc = this.session.doc;\n        var unixMode = doc.getNewLineCharacter() == \"\\n\" && doc.getNewLineMode() != \"windows\";\n        var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;\n        if (this.EOL_CHAR != EOL_CHAR) {\n            this.EOL_CHAR = EOL_CHAR;\n            return true;\n        }\n    };\n\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n        this.element.style.margin = \"0 \" + padding + \"px\";\n    };\n\n    this.getLineHeight = function() {\n        return this.$fontMetrics.$characterSize.height || 0;\n    };\n\n    this.getCharacterWidth = function() {\n        return this.$fontMetrics.$characterSize.width || 0;\n    };\n    \n    this.$setFontMetrics = function(measure) {\n        this.$fontMetrics = measure;\n        this.$fontMetrics.on(\"changeCharacterSize\", function(e) {\n            this._signal(\"changeCharacterSize\", e);\n        }.bind(this));\n        this.$pollSizeChanges();\n    };\n\n    this.checkForSizeChanges = function() {\n        this.$fontMetrics.checkForSizeChanges();\n    };\n    this.$pollSizeChanges = function() {\n        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();\n    };\n    this.setSession = function(session) {\n        this.session = session;\n        if (session)\n            this.$computeTabString();\n    };\n\n    this.showInvisibles = false;\n    this.setShowInvisibles = function(showInvisibles) {\n        if (this.showInvisibles == showInvisibles)\n            return false;\n\n        this.showInvisibles = showInvisibles;\n        this.$computeTabString();\n        return true;\n    };\n\n    this.displayIndentGuides = true;\n    this.setDisplayIndentGuides = function(display) {\n        if (this.displayIndentGuides == display)\n            return false;\n\n        this.displayIndentGuides = display;\n        this.$computeTabString();\n        return true;\n    };\n\n    this.$tabStrings = [];\n    this.onChangeTabSize =\n    this.$computeTabString = function() {\n        var tabSize = this.session.getTabSize();\n        this.tabSize = tabSize;\n        var tabStr = this.$tabStrings = [0];\n        for (var i = 1; i < tabSize + 1; i++) {\n            if (this.showInvisibles) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_tab\";\n                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);\n                tabStr.push(span);\n            } else {\n                tabStr.push(this.dom.createTextNode(lang.stringRepeat(\" \", i), this.element));\n            }\n        }\n        if (this.displayIndentGuides) {\n            this.$indentGuideRe =  /\\s\\S| \\t|\\t |\\s$/;\n            var className = \"ace_indent-guide\";\n            var spaceClass = \"\";\n            var tabClass = \"\";\n            if (this.showInvisibles) {\n                className += \" ace_invisible\";\n                spaceClass = \" ace_invisible_space\";\n                tabClass = \" ace_invisible_tab\";\n                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);\n                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);\n            } else {\n                var spaceContent = lang.stringRepeat(\" \", this.tabSize);\n                var tabContent = spaceContent;\n            }\n\n            var span = this.dom.createElement(\"span\");\n            span.className = className + spaceClass;\n            span.textContent = spaceContent;\n            this.$tabStrings[\" \"] = span;\n            \n            var span = this.dom.createElement(\"span\");\n            span.className = className + tabClass;\n            span.textContent = tabContent;\n            this.$tabStrings[\"\\t\"] = span;\n        }\n    };\n\n    this.updateLines = function(config, firstRow, lastRow) {\n        if (this.config.lastRow != config.lastRow ||\n            this.config.firstRow != config.firstRow) {\n            return this.update(config);\n        }\n        \n        this.config = config;\n\n        var first = Math.max(firstRow, config.firstRow);\n        var last = Math.min(lastRow, config.lastRow);\n\n        var lineElements = this.element.childNodes;\n        var lineElementsIdx = 0;\n\n        for (var row = config.firstRow; row < first; row++) {\n            var foldLine = this.session.getFoldLine(row);\n            if (foldLine) {\n                if (foldLine.containsRow(first)) {\n                    first = foldLine.start.row;\n                    break;\n                } else {\n                    row = foldLine.end.row;\n                }\n            }\n            lineElementsIdx ++;\n        }\n\n        var heightChanged = false;\n        var row = first;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row :Infinity;\n            }\n            if (row > last)\n                break;\n\n            var lineElement = lineElements[lineElementsIdx++];\n            if (lineElement) {\n                this.dom.removeChildren(lineElement);\n                this.$renderLine(\n                    lineElement, row, row == foldStart ? foldLine : false\n                );\n\n                if (heightChanged)\n                    lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + \"px\";\n\n                var height = (config.lineHeight * this.session.getRowLength(row)) + \"px\";\n                if (lineElement.style.height != height) {\n                    heightChanged = true;\n                    lineElement.style.height = height;\n                }\n            }\n            row++;\n        }\n        if (heightChanged) {\n            while (lineElementsIdx < this.$lines.cells.length) {\n                var cell = this.$lines.cells[lineElementsIdx++];\n                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + \"px\";\n            }\n        }\n    };\n\n    this.scrollLines = function(config) {\n        var oldConfig = this.config;\n        this.config = config;\n\n        if (this.$lines.pageChanged(oldConfig, config))\n            return this.update(config);\n            \n        this.$lines.moveContainer(config);\n        \n        var lastRow = config.lastRow;\n        var oldLastRow = oldConfig ? oldConfig.lastRow : -1;\n\n        if (!oldConfig || oldLastRow < config.firstRow)\n            return this.update(config);\n\n        if (lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (!oldConfig || oldConfig.lastRow < config.firstRow)\n            return this.update(config);\n\n        if (config.lastRow < oldConfig.firstRow)\n            return this.update(config);\n\n        if (oldConfig.firstRow < config.firstRow)\n            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n                this.$lines.shift();\n\n        if (oldConfig.lastRow > config.lastRow)\n            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)\n                this.$lines.pop();\n\n        if (config.firstRow < oldConfig.firstRow) {\n            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));\n        }\n\n        if (config.lastRow > oldConfig.lastRow) {\n            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));\n        }\n    };\n\n    this.$renderLinesFragment = function(config, firstRow, lastRow) {\n        var fragment = [];\n        var row = firstRow;\n        var foldLine = this.session.getNextFoldLine(row);\n        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n        while (true) {\n            if (row > foldStart) {\n                row = foldLine.end.row+1;\n                foldLine = this.session.getNextFoldLine(row, foldLine);\n                foldStart = foldLine ? foldLine.start.row : Infinity;\n            }\n            if (row > lastRow)\n                break;\n\n            var line = this.$lines.createCell(row, config, this.session);\n            \n            var lineEl = line.element;\n            this.dom.removeChildren(lineEl);\n            dom.setStyle(lineEl.style, \"height\", this.$lines.computeLineHeight(row, config, this.session) + \"px\");\n            dom.setStyle(lineEl.style, \"top\", this.$lines.computeLineTop(row, config, this.session) + \"px\");\n            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);\n\n            if (this.$useLineGroups()) {\n                lineEl.className = \"ace_line_group\";\n            } else {\n                lineEl.className = \"ace_line\";\n            }\n            fragment.push(line);\n\n            row++;\n        }\n        return fragment;\n    };\n\n    this.update = function(config) {\n        this.$lines.moveContainer(config);\n        \n        this.config = config;\n\n        var firstRow = config.firstRow;\n        var lastRow = config.lastRow;\n\n        var lines = this.$lines;\n        while (lines.getLength())\n            lines.pop();\n            \n        lines.push(this.$renderLinesFragment(config, firstRow, lastRow));\n    };\n\n    this.$textToken = {\n        \"text\": true,\n        \"rparen\": true,\n        \"lparen\": true\n    };\n\n    this.$renderToken = function(parent, screenColumn, token, value) {\n        var self = this;\n        var re = /(\\t)|( +)|([\\x00-\\x1f\\x80-\\xa0\\xad\\u1680\\u180E\\u2000-\\u200f\\u2028\\u2029\\u202F\\u205F\\uFEFF\\uFFF9-\\uFFFC]+)|(\\u3000)|([\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3001-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u4DBF\\u4E00-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFAFF\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/g;\n        \n        var valueFragment = this.dom.createFragment(this.element);\n\n        var m;\n        var i = 0;\n        while (m = re.exec(value)) {\n            var tab = m[1];\n            var simpleSpace = m[2];\n            var controlCharacter = m[3];\n            var cjkSpace = m[4];\n            var cjk = m[5];\n            \n            if (!self.showInvisibles && simpleSpace)\n                continue;\n\n            var before = i != m.index ? value.slice(i, m.index) : \"\";\n\n            i = m.index + m[0].length;\n            \n            if (before) {\n                valueFragment.appendChild(this.dom.createTextNode(before, this.element));\n            }\n                \n            if (tab) {\n                var tabSize = self.session.getScreenTabSize(screenColumn + m.index);\n                valueFragment.appendChild(self.$tabStrings[tabSize].cloneNode(true));\n                screenColumn += tabSize - 1;\n            } else if (simpleSpace) {\n                if (self.showInvisibles) {\n                    var span = this.dom.createElement(\"span\");\n                    span.className = \"ace_invisible ace_invisible_space\";\n                    span.textContent = lang.stringRepeat(self.SPACE_CHAR, simpleSpace.length);\n                    valueFragment.appendChild(span);\n                } else {\n                    valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));\n                }\n            } else if (controlCharacter) {\n                var span = this.dom.createElement(\"span\");\n                span.className = \"ace_invisible ace_invisible_space ace_invalid\";\n                span.textContent = lang.stringRepeat(self.SPACE_CHAR, controlCharacter.length);\n                valueFragment.appendChild(span);\n            } else if (cjkSpace) {\n                screenColumn += 1;\n                \n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = self.showInvisibles ? \"ace_cjk ace_invisible ace_invisible_space\" : \"ace_cjk\";\n                span.textContent = self.showInvisibles ? self.SPACE_CHAR : cjkSpace;\n                valueFragment.appendChild(span);\n            } else if (cjk) {\n                screenColumn += 1;\n                var span = this.dom.createElement(\"span\");\n                span.style.width = (self.config.characterWidth * 2) + \"px\";\n                span.className = \"ace_cjk\";\n                span.textContent = cjk;\n                valueFragment.appendChild(span);\n            }\n        }\n        \n        valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));\n\n        if (!this.$textToken[token.type]) {\n            var classes = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n            var span = this.dom.createElement(\"span\");\n            if (token.type == \"fold\")\n                span.style.width = (token.value.length * this.config.characterWidth) + \"px\";\n                \n            span.className = classes;\n            span.appendChild(valueFragment);\n            \n            parent.appendChild(span);\n        }\n        else {\n            parent.appendChild(valueFragment);\n        }\n        \n        return screenColumn + value.length;\n    };\n\n    this.renderIndentGuide = function(parent, value, max) {\n        var cols = value.search(this.$indentGuideRe);\n        if (cols <= 0 || cols >= max)\n            return value;\n        if (value[0] == \" \") {\n            cols -= cols % this.tabSize;\n            var count = cols/this.tabSize;\n            for (var i=0; i<count; i++) {\n                parent.appendChild(this.$tabStrings[\" \"].cloneNode(true));\n            }\n            return value.substr(cols);\n        } else if (value[0] == \"\\t\") {\n            for (var i=0; i<cols; i++) {\n                parent.appendChild(this.$tabStrings[\"\\t\"].cloneNode(true));\n            }\n            return value.substr(cols);\n        }\n        return value;\n    };\n\n    this.$createLineElement = function(parent) {\n        var lineEl = this.dom.createElement(\"div\");\n        lineEl.className = \"ace_line\";\n        lineEl.style.height = this.config.lineHeight + \"px\";\n        \n        return lineEl;\n    };\n\n    this.$renderWrappedLine = function(parent, tokens, splits) {\n        var chars = 0;\n        var split = 0;\n        var splitChars = splits[0];\n        var screenColumn = 0;\n\n        var lineEl = this.$createLineElement();\n        parent.appendChild(lineEl);\n        \n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            var value = token.value;\n            if (i == 0 && this.displayIndentGuides) {\n                chars = value.length;\n                value = this.renderIndentGuide(lineEl, value, splitChars);\n                if (!value)\n                    continue;\n                chars -= value.length;\n            }\n\n            if (chars + value.length < splitChars) {\n                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);\n                chars += value.length;\n            } else {\n                while (chars + value.length >= splitChars) {\n                    screenColumn = this.$renderToken(\n                        lineEl, screenColumn,\n                        token, value.substring(0, splitChars - chars)\n                    );\n                    value = value.substring(splitChars - chars);\n                    chars = splitChars;\n\n                    lineEl = this.$createLineElement();\n                    parent.appendChild(lineEl);\n\n                    lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(\"\\xa0\", splits.indent), this.element));\n\n                    split ++;\n                    screenColumn = 0;\n                    splitChars = splits[split] || Number.MAX_VALUE;\n                }\n                if (value.length != 0) {\n                    chars += value.length;\n                    screenColumn = this.$renderToken(\n                        lineEl, screenColumn, token, value\n                    );\n                }\n            }\n        }\n        \n        if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)\n            this.$renderOverflowMessage(lineEl, screenColumn, null, \"\", true);\n    };\n\n    this.$renderSimpleLine = function(parent, tokens) {\n        var screenColumn = 0;\n        var token = tokens[0];\n        var value = token.value;\n        if (this.displayIndentGuides)\n            value = this.renderIndentGuide(parent, value);\n        if (value)\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        for (var i = 1; i < tokens.length; i++) {\n            token = tokens[i];\n            value = token.value;\n            if (screenColumn + value.length > this.MAX_LINE_LENGTH)\n                return this.$renderOverflowMessage(parent, screenColumn, token, value);\n            screenColumn = this.$renderToken(parent, screenColumn, token, value);\n        }\n    };\n    \n    this.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {\n        token && this.$renderToken(parent, screenColumn, token,\n            value.slice(0, this.MAX_LINE_LENGTH - screenColumn));\n            \n        var overflowEl = this.dom.createElement(\"span\");\n        overflowEl.className = \"ace_inline_button ace_keyword ace_toggle_wrap\";\n        overflowEl.textContent = hide ? \"<hide>\" : \"<click to see more...>\";\n        \n        parent.appendChild(overflowEl);        \n    };\n    this.$renderLine = function(parent, row, foldLine) {\n        if (!foldLine && foldLine != false)\n            foldLine = this.session.getFoldLine(row);\n\n        if (foldLine)\n            var tokens = this.$getFoldLineTokens(row, foldLine);\n        else\n            var tokens = this.session.getTokens(row);\n\n        var lastLineEl = parent;\n        if (tokens.length) {\n            var splits = this.session.getRowSplitData(row);\n            if (splits && splits.length) {\n                this.$renderWrappedLine(parent, tokens, splits);\n                var lastLineEl = parent.lastChild;\n            } else {\n                var lastLineEl = parent;\n                if (this.$useLineGroups()) {\n                    lastLineEl = this.$createLineElement();\n                    parent.appendChild(lastLineEl);\n                }\n                this.$renderSimpleLine(lastLineEl, tokens);\n            }\n        } else if (this.$useLineGroups()) {\n            lastLineEl = this.$createLineElement();\n            parent.appendChild(lastLineEl);\n        }\n\n        if (this.showInvisibles && lastLineEl) {\n            if (foldLine)\n                row = foldLine.end.row;\n\n            var invisibleEl = this.dom.createElement(\"span\");\n            invisibleEl.className = \"ace_invisible ace_invisible_eol\";\n            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;\n            \n            lastLineEl.appendChild(invisibleEl);\n        }\n    };\n\n    this.$getFoldLineTokens = function(row, foldLine) {\n        var session = this.session;\n        var renderTokens = [];\n\n        function addTokens(tokens, from, to) {\n            var idx = 0, col = 0;\n            while ((col + tokens[idx].value.length) < from) {\n                col += tokens[idx].value.length;\n                idx++;\n\n                if (idx == tokens.length)\n                    return;\n            }\n            if (col != from) {\n                var value = tokens[idx].value.substring(from - col);\n                if (value.length > (to - from))\n                    value = value.substring(0, to - from);\n\n                renderTokens.push({\n                    type: tokens[idx].type,\n                    value: value\n                });\n\n                col = from + value.length;\n                idx += 1;\n            }\n\n            while (col < to && idx < tokens.length) {\n                var value = tokens[idx].value;\n                if (value.length + col > to) {\n                    renderTokens.push({\n                        type: tokens[idx].type,\n                        value: value.substring(0, to - col)\n                    });\n                } else\n                    renderTokens.push(tokens[idx]);\n                col += value.length;\n                idx += 1;\n            }\n        }\n\n        var tokens = session.getTokens(row);\n        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {\n            if (placeholder != null) {\n                renderTokens.push({\n                    type: \"fold\",\n                    value: placeholder\n                });\n            } else {\n                if (isNewRow)\n                    tokens = session.getTokens(row);\n\n                if (tokens.length)\n                    addTokens(tokens, lastColumn, column);\n            }\n        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);\n\n        return renderTokens;\n    };\n\n    this.$useLineGroups = function() {\n        return this.session.getUseWrapMode();\n    };\n\n    this.destroy = function() {};\n}).call(Text.prototype);\n\nexports.Text = Text;\n\n});\n\nace.define(\"ace/layer/cursor\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"../lib/dom\");\n\nvar Cursor = function(parentEl) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_layer ace_cursor-layer\";\n    parentEl.appendChild(this.element);\n    \n    this.isVisible = false;\n    this.isBlinking = true;\n    this.blinkInterval = 1000;\n    this.smoothBlinking = false;\n\n    this.cursors = [];\n    this.cursor = this.addCursor();\n    dom.addCssClass(this.element, \"ace_hidden-cursors\");\n    this.$updateCursors = this.$updateOpacity.bind(this);\n};\n\n(function() {\n    \n    this.$updateOpacity = function(val) {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--; )\n            dom.setStyle(cursors[i].style, \"opacity\", val ? \"\" : \"0\");\n    };\n\n    this.$startCssAnimation = function() {\n        var cursors = this.cursors;\n        for (var i = cursors.length; i--; )\n            cursors[i].style.animationDuration = this.blinkInterval + \"ms\";\n\n        setTimeout(function() {\n            dom.addCssClass(this.element, \"ace_animate-blinking\");\n        }.bind(this));\n    };\n    \n    this.$stopCssAnimation = function() {\n        dom.removeCssClass(this.element, \"ace_animate-blinking\");\n    };\n\n    this.$padding = 0;\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n    };\n\n    this.setSession = function(session) {\n        this.session = session;\n    };\n\n    this.setBlinking = function(blinking) {\n        if (blinking != this.isBlinking) {\n            this.isBlinking = blinking;\n            this.restartTimer();\n        }\n    };\n\n    this.setBlinkInterval = function(blinkInterval) {\n        if (blinkInterval != this.blinkInterval) {\n            this.blinkInterval = blinkInterval;\n            this.restartTimer();\n        }\n    };\n\n    this.setSmoothBlinking = function(smoothBlinking) {\n        if (smoothBlinking != this.smoothBlinking) {\n            this.smoothBlinking = smoothBlinking;\n            dom.setCssClass(this.element, \"ace_smooth-blinking\", smoothBlinking);\n            this.$updateCursors(true);\n            this.restartTimer();\n        }\n    };\n\n    this.addCursor = function() {\n        var el = dom.createElement(\"div\");\n        el.className = \"ace_cursor\";\n        this.element.appendChild(el);\n        this.cursors.push(el);\n        return el;\n    };\n\n    this.removeCursor = function() {\n        if (this.cursors.length > 1) {\n            var el = this.cursors.pop();\n            el.parentNode.removeChild(el);\n            return el;\n        }\n    };\n\n    this.hideCursor = function() {\n        this.isVisible = false;\n        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n\n    this.showCursor = function() {\n        this.isVisible = true;\n        dom.removeCssClass(this.element, \"ace_hidden-cursors\");\n        this.restartTimer();\n    };\n\n    this.restartTimer = function() {\n        var update = this.$updateCursors;\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n        this.$stopCssAnimation();\n\n        if (this.smoothBlinking) {\n            dom.removeCssClass(this.element, \"ace_smooth-blinking\");\n        }\n        \n        update(true);\n\n        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {\n            this.$stopCssAnimation();\n            return;\n        }\n\n        if (this.smoothBlinking) {\n            setTimeout(function(){\n                dom.addCssClass(this.element, \"ace_smooth-blinking\");\n            }.bind(this));\n        }\n        \n        if (dom.HAS_CSS_ANIMATION) {\n            this.$startCssAnimation();\n        } else {\n            var blink = function(){\n                this.timeoutId = setTimeout(function() {\n                    update(false);\n                }, 0.6 * this.blinkInterval);\n            }.bind(this);\n    \n            this.intervalId = setInterval(function() {\n                update(true);\n                blink();\n            }, this.blinkInterval);\n            blink();\n        }\n    };\n\n    this.getPixelPosition = function(position, onScreen) {\n        if (!this.config || !this.session)\n            return {left : 0, top : 0};\n\n        if (!position)\n            position = this.session.selection.getCursor();\n        var pos = this.session.documentToScreenPosition(position);\n        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)\n            ? this.session.$bidiHandler.getPosLeft(pos.column)\n            : pos.column * this.config.characterWidth);\n\n        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *\n            this.config.lineHeight;\n\n        return {left : cursorLeft, top : cursorTop};\n    };\n\n    this.isCursorInView = function(pixelPos, config) {\n        return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;\n    };\n\n    this.update = function(config) {\n        this.config = config;\n\n        var selections = this.session.$selectionMarkers;\n        var i = 0, cursorIndex = 0;\n\n        if (selections === undefined || selections.length === 0){\n            selections = [{cursor: null}];\n        }\n\n        for (var i = 0, n = selections.length; i < n; i++) {\n            var pixelPos = this.getPixelPosition(selections[i].cursor, true);\n            if ((pixelPos.top > config.height + config.offset ||\n                 pixelPos.top < 0) && i > 1) {\n                continue;\n            }\n\n            var element = this.cursors[cursorIndex++] || this.addCursor();\n            var style = element.style;\n            \n            if (!this.drawCursor) {\n                if (!this.isCursorInView(pixelPos, config)) {\n                    dom.setStyle(style, \"display\", \"none\");\n                } else {\n                    dom.setStyle(style, \"display\", \"block\");\n                    dom.translate(element, pixelPos.left, pixelPos.top);\n                    dom.setStyle(style, \"width\", Math.round(config.characterWidth) + \"px\");\n                    dom.setStyle(style, \"height\", config.lineHeight + \"px\");\n                }\n            } else {\n                this.drawCursor(element, pixelPos, config, selections[i], this.session);\n            }\n        }\n        while (this.cursors.length > cursorIndex)\n            this.removeCursor();\n\n        var overwrite = this.session.getOverwrite();\n        this.$setOverwrite(overwrite);\n        this.$pixelPos = pixelPos;\n        this.restartTimer();\n    };\n    \n    this.drawCursor = null;\n\n    this.$setOverwrite = function(overwrite) {\n        if (overwrite != this.overwrite) {\n            this.overwrite = overwrite;\n            if (overwrite)\n                dom.addCssClass(this.element, \"ace_overwrite-cursors\");\n            else\n                dom.removeCssClass(this.element, \"ace_overwrite-cursors\");\n        }\n    };\n\n    this.destroy = function() {\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeoutId);\n    };\n\n}).call(Cursor.prototype);\n\nexports.Cursor = Cursor;\n\n});\n\nace.define(\"ace/scrollbar\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar MAX_SCROLL_H = 0x8000;\nvar ScrollBar = function(parent) {\n    this.element = dom.createElement(\"div\");\n    this.element.className = \"ace_scrollbar ace_scrollbar\" + this.classSuffix;\n\n    this.inner = dom.createElement(\"div\");\n    this.inner.className = \"ace_scrollbar-inner\";\n    this.inner.textContent = \"\\xa0\";\n    this.element.appendChild(this.inner);\n\n    parent.appendChild(this.element);\n\n    this.setVisible(false);\n    this.skipEvent = false;\n\n    event.addListener(this.element, \"scroll\", this.onScroll.bind(this));\n    event.addListener(this.element, \"mousedown\", event.preventDefault);\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n\n    this.setVisible = function(isVisible) {\n        this.element.style.display = isVisible ? \"\" : \"none\";\n        this.isVisible = isVisible;\n        this.coeff = 1;\n    };\n}).call(ScrollBar.prototype);\nvar VScrollBar = function(parent, renderer) {\n    ScrollBar.call(this, parent);\n    this.scrollTop = 0;\n    this.scrollHeight = 0;\n    renderer.$scrollbarWidth = \n    this.width = dom.scrollbarWidth(parent.ownerDocument);\n    this.inner.style.width =\n    this.element.style.width = (this.width || 15) + 5 + \"px\";\n    this.$minWidth = 0;\n};\n\noop.inherits(VScrollBar, ScrollBar);\n\n(function() {\n\n    this.classSuffix = '-v';\n    this.onScroll = function() {\n        if (!this.skipEvent) {\n            this.scrollTop = this.element.scrollTop;\n            if (this.coeff != 1) {\n                var h = this.element.clientHeight / this.scrollHeight;\n                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);\n            }\n            this._emit(\"scroll\", {data: this.scrollTop});\n        }\n        this.skipEvent = false;\n    };\n    this.getWidth = function() {\n        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);\n    };\n    this.setHeight = function(height) {\n        this.element.style.height = height + \"px\";\n    };\n    this.setInnerHeight = \n    this.setScrollHeight = function(height) {\n        this.scrollHeight = height;\n        if (height > MAX_SCROLL_H) {\n            this.coeff = MAX_SCROLL_H / height;\n            height = MAX_SCROLL_H;\n        } else if (this.coeff != 1) {\n            this.coeff = 1;\n        }\n        this.inner.style.height = height + \"px\";\n    };\n    this.setScrollTop = function(scrollTop) {\n        if (this.scrollTop != scrollTop) {\n            this.skipEvent = true;\n            this.scrollTop = scrollTop;\n            this.element.scrollTop = scrollTop * this.coeff;\n        }\n    };\n\n}).call(VScrollBar.prototype);\nvar HScrollBar = function(parent, renderer) {\n    ScrollBar.call(this, parent);\n    this.scrollLeft = 0;\n    this.height = renderer.$scrollbarWidth;\n    this.inner.style.height =\n    this.element.style.height = (this.height || 15) + 5 + \"px\";\n};\n\noop.inherits(HScrollBar, ScrollBar);\n\n(function() {\n\n    this.classSuffix = '-h';\n    this.onScroll = function() {\n        if (!this.skipEvent) {\n            this.scrollLeft = this.element.scrollLeft;\n            this._emit(\"scroll\", {data: this.scrollLeft});\n        }\n        this.skipEvent = false;\n    };\n    this.getHeight = function() {\n        return this.isVisible ? this.height : 0;\n    };\n    this.setWidth = function(width) {\n        this.element.style.width = width + \"px\";\n    };\n    this.setInnerWidth = function(width) {\n        this.inner.style.width = width + \"px\";\n    };\n    this.setScrollWidth = function(width) {\n        this.inner.style.width = width + \"px\";\n    };\n    this.setScrollLeft = function(scrollLeft) {\n        if (this.scrollLeft != scrollLeft) {\n            this.skipEvent = true;\n            this.scrollLeft = this.element.scrollLeft = scrollLeft;\n        }\n    };\n\n}).call(HScrollBar.prototype);\n\n\nexports.ScrollBar = VScrollBar; // backward compatibility\nexports.ScrollBarV = VScrollBar; // backward compatibility\nexports.ScrollBarH = HScrollBar; // backward compatibility\n\nexports.VScrollBar = VScrollBar;\nexports.HScrollBar = HScrollBar;\n});\n\nace.define(\"ace/renderloop\",[\"require\",\"exports\",\"module\",\"ace/lib/event\"], function(require, exports, module) {\n\"use strict\";\n\nvar event = require(\"./lib/event\");\n\n\nvar RenderLoop = function(onRender, win) {\n    this.onRender = onRender;\n    this.pending = false;\n    this.changes = 0;\n    this.$recursionLimit = 2;\n    this.window = win || window;\n    var _self = this;\n    this._flush = function(ts) {\n        _self.pending = false;\n        var changes = _self.changes;\n\n        if (changes) {\n            event.blockIdle(100);\n            _self.changes = 0;\n            _self.onRender(changes);\n        }\n        \n        if (_self.changes) {\n            if (_self.$recursionLimit-- < 0) return;\n            _self.schedule();\n        } else {\n            _self.$recursionLimit = 2;\n        }\n    };\n};\n\n(function() {\n\n    this.schedule = function(change) {\n        this.changes = this.changes | change;\n        if (this.changes && !this.pending) {\n            event.nextFrame(this._flush);\n            this.pending = true;\n        }\n    };\n\n    this.clear = function(change) {\n        var changes = this.changes;\n        this.changes = 0;\n        return changes;\n    };\n\n}).call(RenderLoop.prototype);\n\nexports.RenderLoop = RenderLoop;\n});\n\nace.define(\"ace/layer/font_metrics\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(require, exports, module) {\n\nvar oop = require(\"../lib/oop\");\nvar dom = require(\"../lib/dom\");\nvar lang = require(\"../lib/lang\");\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\nvar CHAR_COUNT = 256;\nvar USE_OBSERVER = typeof ResizeObserver == \"function\";\nvar L = 200;\n\nvar FontMetrics = exports.FontMetrics = function(parentEl) {\n    this.el = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.el.style, true);\n    \n    this.$main = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.$main.style);\n    \n    this.$measureNode = dom.createElement(\"div\");\n    this.$setMeasureNodeStyles(this.$measureNode.style);\n    \n    \n    this.el.appendChild(this.$main);\n    this.el.appendChild(this.$measureNode);\n    parentEl.appendChild(this.el);\n    \n    this.$measureNode.innerHTML = lang.stringRepeat(\"X\", CHAR_COUNT);\n    \n    this.$characterSize = {width: 0, height: 0};\n    \n    \n    if (USE_OBSERVER)\n        this.$addObserver();\n    else\n        this.checkForSizeChanges();\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n        \n    this.$characterSize = {width: 0, height: 0};\n    \n    this.$setMeasureNodeStyles = function(style, isRoot) {\n        style.width = style.height = \"auto\";\n        style.left = style.top = \"0px\";\n        style.visibility = \"hidden\";\n        style.position = \"absolute\";\n        style.whiteSpace = \"pre\";\n\n        if (useragent.isIE < 8) {\n            style[\"font-family\"] = \"inherit\";\n        } else {\n            style.font = \"inherit\";\n        }\n        style.overflow = isRoot ? \"hidden\" : \"visible\";\n    };\n\n    this.checkForSizeChanges = function(size) {\n        if (size === undefined)\n            size = this.$measureSizes();\n        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {\n            this.$measureNode.style.fontWeight = \"bold\";\n            var boldSize = this.$measureSizes();\n            this.$measureNode.style.fontWeight = \"\";\n            this.$characterSize = size;\n            this.charSizes = Object.create(null);\n            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;\n            this._emit(\"changeCharacterSize\", {data: size});\n        }\n    };\n    \n    this.$addObserver = function() {\n        var self = this;\n        this.$observer = new window.ResizeObserver(function(e) {\n            var rect = e[0].contentRect;\n            self.checkForSizeChanges({\n                height: rect.height,\n                width: rect.width / CHAR_COUNT\n            });\n        });\n        this.$observer.observe(this.$measureNode);\n    };\n\n    this.$pollSizeChanges = function() {\n        if (this.$pollSizeChangesTimer || this.$observer)\n            return this.$pollSizeChangesTimer;\n        var self = this;\n        \n        return this.$pollSizeChangesTimer = event.onIdle(function cb() {\n            self.checkForSizeChanges();\n            event.onIdle(cb, 500);\n        }, 500);\n    };\n    \n    this.setPolling = function(val) {\n        if (val) {\n            this.$pollSizeChanges();\n        } else if (this.$pollSizeChangesTimer) {\n            clearInterval(this.$pollSizeChangesTimer);\n            this.$pollSizeChangesTimer = 0;\n        }\n    };\n\n    this.$measureSizes = function(node) {\n        var size = {\n            height: (node || this.$measureNode).clientHeight,\n            width: (node || this.$measureNode).clientWidth / CHAR_COUNT\n        };\n        if (size.width === 0 || size.height === 0)\n            return null;\n        return size;\n    };\n\n    this.$measureCharWidth = function(ch) {\n        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);\n        var rect = this.$main.getBoundingClientRect();\n        return rect.width / CHAR_COUNT;\n    };\n    \n    this.getCharacterWidth = function(ch) {\n        var w = this.charSizes[ch];\n        if (w === undefined) {\n            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;\n        }\n        return w;\n    };\n\n    this.destroy = function() {\n        clearInterval(this.$pollSizeChangesTimer);\n        if (this.$observer)\n            this.$observer.disconnect();\n        if (this.el && this.el.parentNode)\n            this.el.parentNode.removeChild(this.el);\n    };\n\n    \n    this.$getZoom = function getZoom(element) {\n        if (!element) return 1;\n        return (window.getComputedStyle(element).zoom || 1) * getZoom(element.parentElement);\n    };\n    this.$initTransformMeasureNodes = function() {\n        var t = function(t, l) {\n            return [\"div\", {\n                style: \"position: absolute;top:\" + t + \"px;left:\" + l + \"px;\"\n            }];\n        };\n        this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);\n    };\n    this.transformCoordinates = function(clientPos, elPos) {\n        if (clientPos) {\n            var zoom = this.$getZoom(this.el);\n            clientPos = mul(1 / zoom, clientPos);\n        }\n        function solve(l1, l2, r) {\n            var det = l1[1] * l2[0] - l1[0] * l2[1];\n            return [\n                (-l2[1] * r[0] + l2[0] * r[1]) / det,\n                (+l1[1] * r[0] - l1[0] * r[1]) / det\n            ];\n        }\n        function sub(a, b) { return [a[0] - b[0], a[1] - b[1]]; }\n        function add(a, b) { return [a[0] + b[0], a[1] + b[1]]; }\n        function mul(a, b) { return [a * b[0], a * b[1]]; }\n\n        if (!this.els)\n            this.$initTransformMeasureNodes();\n        \n        function p(el) {\n            var r = el.getBoundingClientRect();\n            return [r.left, r.top];\n        }\n\n        var a = p(this.els[0]);\n        var b = p(this.els[1]);\n        var c = p(this.els[2]);\n        var d = p(this.els[3]);\n\n        var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));\n\n        var m1 = mul(1 + h[0], sub(b, a));\n        var m2 = mul(1 + h[1], sub(c, a));\n        \n        if (elPos) {\n            var x = elPos;\n            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;\n            var ut = add(mul(x[0], m1), mul(x[1], m2));\n            return  add(mul(1 / k / L, ut), a);\n        }\n        var u = sub(clientPos, a);\n        var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);\n        return mul(L, f);\n    };\n    \n}).call(FontMetrics.prototype);\n\n});\n\nace.define(\"ace/virtual_renderer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/config\",\"ace/layer/gutter\",\"ace/layer/marker\",\"ace/layer/text\",\"ace/layer/cursor\",\"ace/scrollbar\",\"ace/scrollbar\",\"ace/renderloop\",\"ace/layer/font_metrics\",\"ace/lib/event_emitter\",\"ace/lib/useragent\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"./lib/oop\");\nvar dom = require(\"./lib/dom\");\nvar config = require(\"./config\");\nvar GutterLayer = require(\"./layer/gutter\").Gutter;\nvar MarkerLayer = require(\"./layer/marker\").Marker;\nvar TextLayer = require(\"./layer/text\").Text;\nvar CursorLayer = require(\"./layer/cursor\").Cursor;\nvar HScrollBar = require(\"./scrollbar\").HScrollBar;\nvar VScrollBar = require(\"./scrollbar\").VScrollBar;\nvar RenderLoop = require(\"./renderloop\").RenderLoop;\nvar FontMetrics = require(\"./layer/font_metrics\").FontMetrics;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar editorCss = \"\\\n.ace_br1 {border-top-left-radius    : 3px;}\\\n.ace_br2 {border-top-right-radius   : 3px;}\\\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\\\n.ace_br4 {border-bottom-right-radius: 3px;}\\\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\\\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\\\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\\\n.ace_br8 {border-bottom-left-radius : 3px;}\\\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\\\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\\\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\\\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\\\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\\\n.ace_editor {\\\nposition: relative;\\\noverflow: hidden;\\\nfont: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\\\ndirection: ltr;\\\ntext-align: left;\\\n-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\\n}\\\n.ace_scroller {\\\nposition: absolute;\\\noverflow: hidden;\\\ntop: 0;\\\nbottom: 0;\\\nbackground-color: inherit;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\ncursor: text;\\\n}\\\n.ace_content {\\\nposition: absolute;\\\nbox-sizing: border-box;\\\nmin-width: 100%;\\\ncontain: style size layout;\\\nfont-variant-ligatures: no-common-ligatures;\\\n}\\\n.ace_dragging .ace_scroller:before{\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\nbottom: 0;\\\ncontent: '';\\\nbackground: rgba(250, 250, 250, 0.01);\\\nz-index: 1000;\\\n}\\\n.ace_dragging.ace_dark .ace_scroller:before{\\\nbackground: rgba(0, 0, 0, 0.01);\\\n}\\\n.ace_selecting, .ace_selecting * {\\\ncursor: text !important;\\\n}\\\n.ace_gutter {\\\nposition: absolute;\\\noverflow : hidden;\\\nwidth: auto;\\\ntop: 0;\\\nbottom: 0;\\\nleft: 0;\\\ncursor: default;\\\nz-index: 4;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\ncontain: style size layout;\\\n}\\\n.ace_gutter-active-line {\\\nposition: absolute;\\\nleft: 0;\\\nright: 0;\\\n}\\\n.ace_scroller.ace_scroll-left {\\\nbox-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\\\n}\\\n.ace_gutter-cell {\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\npadding-left: 19px;\\\npadding-right: 6px;\\\nbackground-repeat: no-repeat;\\\n}\\\n.ace_gutter-cell.ace_error {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\\\");\\\nbackground-repeat: no-repeat;\\\nbackground-position: 2px center;\\\n}\\\n.ace_gutter-cell.ace_warning {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\\\");\\\nbackground-position: 2px center;\\\n}\\\n.ace_gutter-cell.ace_info {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\\\");\\\nbackground-position: 2px center;\\\n}\\\n.ace_dark .ace_gutter-cell.ace_info {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_scrollbar {\\\ncontain: strict;\\\nposition: absolute;\\\nright: 0;\\\nbottom: 0;\\\nz-index: 6;\\\n}\\\n.ace_scrollbar-inner {\\\nposition: absolute;\\\ncursor: text;\\\nleft: 0;\\\ntop: 0;\\\n}\\\n.ace_scrollbar-v{\\\noverflow-x: hidden;\\\noverflow-y: scroll;\\\ntop: 0;\\\n}\\\n.ace_scrollbar-h {\\\noverflow-x: scroll;\\\noverflow-y: hidden;\\\nleft: 0;\\\n}\\\n.ace_print-margin {\\\nposition: absolute;\\\nheight: 100%;\\\n}\\\n.ace_text-input {\\\nposition: absolute;\\\nz-index: 0;\\\nwidth: 0.5em;\\\nheight: 1em;\\\nopacity: 0;\\\nbackground: transparent;\\\n-moz-appearance: none;\\\nappearance: none;\\\nborder: none;\\\nresize: none;\\\noutline: none;\\\noverflow: hidden;\\\nfont: inherit;\\\npadding: 0 1px;\\\nmargin: 0 -1px;\\\ncontain: strict;\\\n-ms-user-select: text;\\\n-moz-user-select: text;\\\n-webkit-user-select: text;\\\nuser-select: text;\\\nwhite-space: pre!important;\\\n}\\\n.ace_text-input.ace_composition {\\\nbackground: transparent;\\\ncolor: inherit;\\\nz-index: 1000;\\\nopacity: 1;\\\n}\\\n.ace_composition_placeholder { color: transparent }\\\n.ace_composition_marker { \\\nborder-bottom: 1px solid;\\\nposition: absolute;\\\nborder-radius: 0;\\\nmargin-top: 1px;\\\n}\\\n[ace_nocontext=true] {\\\ntransform: none!important;\\\nfilter: none!important;\\\nclip-path: none!important;\\\nmask : none!important;\\\ncontain: none!important;\\\nperspective: none!important;\\\nmix-blend-mode: initial!important;\\\nz-index: auto;\\\n}\\\n.ace_layer {\\\nz-index: 1;\\\nposition: absolute;\\\noverflow: hidden;\\\nword-wrap: normal;\\\nwhite-space: pre;\\\nheight: 100%;\\\nwidth: 100%;\\\nbox-sizing: border-box;\\\npointer-events: none;\\\n}\\\n.ace_gutter-layer {\\\nposition: relative;\\\nwidth: auto;\\\ntext-align: right;\\\npointer-events: auto;\\\nheight: 1000000px;\\\ncontain: style size layout;\\\n}\\\n.ace_text-layer {\\\nfont: inherit !important;\\\nposition: absolute;\\\nheight: 1000000px;\\\nwidth: 1000000px;\\\ncontain: style size layout;\\\n}\\\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\\\ncontain: style size layout;\\\nposition: absolute;\\\ntop: 0;\\\nleft: 0;\\\nright: 0;\\\n}\\\n.ace_hidpi .ace_text-layer,\\\n.ace_hidpi .ace_gutter-layer,\\\n.ace_hidpi .ace_content,\\\n.ace_hidpi .ace_gutter {\\\ncontain: strict;\\\nwill-change: transform;\\\n}\\\n.ace_hidpi .ace_text-layer > .ace_line, \\\n.ace_hidpi .ace_text-layer > .ace_line_group {\\\ncontain: strict;\\\n}\\\n.ace_cjk {\\\ndisplay: inline-block;\\\ntext-align: center;\\\n}\\\n.ace_cursor-layer {\\\nz-index: 4;\\\n}\\\n.ace_cursor {\\\nz-index: 4;\\\nposition: absolute;\\\nbox-sizing: border-box;\\\nborder-left: 2px solid;\\\ntransform: translatez(0);\\\n}\\\n.ace_multiselect .ace_cursor {\\\nborder-left-width: 1px;\\\n}\\\n.ace_slim-cursors .ace_cursor {\\\nborder-left-width: 1px;\\\n}\\\n.ace_overwrite-cursors .ace_cursor {\\\nborder-left-width: 0;\\\nborder-bottom: 1px solid;\\\n}\\\n.ace_hidden-cursors .ace_cursor {\\\nopacity: 0.2;\\\n}\\\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\\\nopacity: 0;\\\n}\\\n.ace_smooth-blinking .ace_cursor {\\\ntransition: opacity 0.18s;\\\n}\\\n.ace_animate-blinking .ace_cursor {\\\nanimation-duration: 1000ms;\\\nanimation-timing-function: step-end;\\\nanimation-name: blink-ace-animate;\\\nanimation-iteration-count: infinite;\\\n}\\\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\\\nanimation-duration: 1000ms;\\\nanimation-timing-function: ease-in-out;\\\nanimation-name: blink-ace-animate-smooth;\\\n}\\\n@keyframes blink-ace-animate {\\\nfrom, to { opacity: 1; }\\\n60% { opacity: 0; }\\\n}\\\n@keyframes blink-ace-animate-smooth {\\\nfrom, to { opacity: 1; }\\\n45% { opacity: 1; }\\\n60% { opacity: 0; }\\\n85% { opacity: 0; }\\\n}\\\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\\\nposition: absolute;\\\nz-index: 3;\\\n}\\\n.ace_marker-layer .ace_selection {\\\nposition: absolute;\\\nz-index: 5;\\\n}\\\n.ace_marker-layer .ace_bracket {\\\nposition: absolute;\\\nz-index: 6;\\\n}\\\n.ace_marker-layer .ace_error_bracket {\\\nposition: absolute;\\\nborder-bottom: 1px solid #DE5555;\\\nborder-radius: 0;\\\n}\\\n.ace_marker-layer .ace_active-line {\\\nposition: absolute;\\\nz-index: 2;\\\n}\\\n.ace_marker-layer .ace_selected-word {\\\nposition: absolute;\\\nz-index: 4;\\\nbox-sizing: border-box;\\\n}\\\n.ace_line .ace_fold {\\\nbox-sizing: border-box;\\\ndisplay: inline-block;\\\nheight: 11px;\\\nmargin-top: -2px;\\\nvertical-align: middle;\\\nbackground-image:\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\\\");\\\nbackground-repeat: no-repeat, repeat-x;\\\nbackground-position: center center, top left;\\\ncolor: transparent;\\\nborder: 1px solid black;\\\nborder-radius: 2px;\\\ncursor: pointer;\\\npointer-events: auto;\\\n}\\\n.ace_dark .ace_fold {\\\n}\\\n.ace_fold:hover{\\\nbackground-image:\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\nurl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_tooltip {\\\nbackground-color: #FFF;\\\nbackground-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\\\nborder: 1px solid gray;\\\nborder-radius: 1px;\\\nbox-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\\\ncolor: black;\\\nmax-width: 100%;\\\npadding: 3px 4px;\\\nposition: fixed;\\\nz-index: 999999;\\\nbox-sizing: border-box;\\\ncursor: default;\\\nwhite-space: pre;\\\nword-wrap: break-word;\\\nline-height: normal;\\\nfont-style: normal;\\\nfont-weight: normal;\\\nletter-spacing: normal;\\\npointer-events: none;\\\n}\\\n.ace_folding-enabled > .ace_gutter-cell {\\\npadding-right: 13px;\\\n}\\\n.ace_fold-widget {\\\nbox-sizing: border-box;\\\nmargin: 0 -12px 0 1px;\\\ndisplay: none;\\\nwidth: 11px;\\\nvertical-align: top;\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\\\");\\\nbackground-repeat: no-repeat;\\\nbackground-position: center;\\\nborder-radius: 3px;\\\nborder: 1px solid transparent;\\\ncursor: pointer;\\\n}\\\n.ace_folding-enabled .ace_fold-widget {\\\ndisplay: inline-block;   \\\n}\\\n.ace_fold-widget.ace_end {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_fold-widget.ace_closed {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\\\");\\\n}\\\n.ace_fold-widget:hover {\\\nborder: 1px solid rgba(0, 0, 0, 0.3);\\\nbackground-color: rgba(255, 255, 255, 0.2);\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\\\n}\\\n.ace_fold-widget:active {\\\nborder: 1px solid rgba(0, 0, 0, 0.4);\\\nbackground-color: rgba(0, 0, 0, 0.05);\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\\\n}\\\n.ace_dark .ace_fold-widget {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\\\");\\\n}\\\n.ace_dark .ace_fold-widget.ace_end {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_dark .ace_fold-widget.ace_closed {\\\nbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\\\");\\\n}\\\n.ace_dark .ace_fold-widget:hover {\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\nbackground-color: rgba(255, 255, 255, 0.1);\\\n}\\\n.ace_dark .ace_fold-widget:active {\\\nbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\n}\\\n.ace_inline_button {\\\nborder: 1px solid lightgray;\\\ndisplay: inline-block;\\\nmargin: -1px 8px;\\\npadding: 0 5px;\\\npointer-events: auto;\\\ncursor: pointer;\\\n}\\\n.ace_inline_button:hover {\\\nborder-color: gray;\\\nbackground: rgba(200,200,200,0.2);\\\ndisplay: inline-block;\\\npointer-events: auto;\\\n}\\\n.ace_fold-widget.ace_invalid {\\\nbackground-color: #FFB4B4;\\\nborder-color: #DE5555;\\\n}\\\n.ace_fade-fold-widgets .ace_fold-widget {\\\ntransition: opacity 0.4s ease 0.05s;\\\nopacity: 0;\\\n}\\\n.ace_fade-fold-widgets:hover .ace_fold-widget {\\\ntransition: opacity 0.05s ease 0.05s;\\\nopacity:1;\\\n}\\\n.ace_underline {\\\ntext-decoration: underline;\\\n}\\\n.ace_bold {\\\nfont-weight: bold;\\\n}\\\n.ace_nobold .ace_bold {\\\nfont-weight: normal;\\\n}\\\n.ace_italic {\\\nfont-style: italic;\\\n}\\\n.ace_error-marker {\\\nbackground-color: rgba(255, 0, 0,0.2);\\\nposition: absolute;\\\nz-index: 9;\\\n}\\\n.ace_highlight-marker {\\\nbackground-color: rgba(255, 255, 0,0.2);\\\nposition: absolute;\\\nz-index: 8;\\\n}\\\n.ace_mobile-menu {\\\nposition: absolute;\\\nline-height: 1.5;\\\nborder-radius: 4px;\\\n-ms-user-select: none;\\\n-moz-user-select: none;\\\n-webkit-user-select: none;\\\nuser-select: none;\\\nbackground: white;\\\nbox-shadow: 1px 3px 2px grey;\\\nborder: 1px solid #dcdcdc;\\\ncolor: black;\\\n}\\\n.ace_dark > .ace_mobile-menu {\\\nbackground: #333;\\\ncolor: #ccc;\\\nbox-shadow: 1px 3px 2px grey;\\\nborder: 1px solid #444;\\\n}\\\n.ace_mobile-button {\\\npadding: 2px;\\\ncursor: pointer;\\\noverflow: hidden;\\\n}\\\n.ace_mobile-button:hover {\\\nbackground-color: #eee;\\\nopacity:1;\\\n}\\\n.ace_mobile-button:active {\\\nbackground-color: #ddd;\\\n}\\\n.ace_placeholder {\\\nfont-family: arial;\\\ntransform: scale(0.9);\\\ntransform-origin: left;\\\nwhite-space: pre;\\\nopacity: 0.7;\\\nmargin: 0 10px;\\\n}\";\n\nvar useragent = require(\"./lib/useragent\");\nvar HIDE_TEXTAREA = useragent.isIE;\n\ndom.importCssString(editorCss, \"ace_editor.css\");\n\nvar VirtualRenderer = function(container, theme) {\n    var _self = this;\n\n    this.container = container || dom.createElement(\"div\");\n\n    dom.addCssClass(this.container, \"ace_editor\");\n    if (dom.HI_DPI) dom.addCssClass(this.container, \"ace_hidpi\");\n\n    this.setTheme(theme);\n\n    this.$gutter = dom.createElement(\"div\");\n    this.$gutter.className = \"ace_gutter\";\n    this.container.appendChild(this.$gutter);\n    this.$gutter.setAttribute(\"aria-hidden\", true);\n\n    this.scroller = dom.createElement(\"div\");\n    this.scroller.className = \"ace_scroller\";\n    \n    this.container.appendChild(this.scroller);\n\n    this.content = dom.createElement(\"div\");\n    this.content.className = \"ace_content\";\n    this.scroller.appendChild(this.content);\n\n    this.$gutterLayer = new GutterLayer(this.$gutter);\n    this.$gutterLayer.on(\"changeGutterWidth\", this.onGutterResize.bind(this));\n\n    this.$markerBack = new MarkerLayer(this.content);\n\n    var textLayer = this.$textLayer = new TextLayer(this.content);\n    this.canvas = textLayer.element;\n\n    this.$markerFront = new MarkerLayer(this.content);\n\n    this.$cursorLayer = new CursorLayer(this.content);\n    this.$horizScroll = false;\n    this.$vScroll = false;\n\n    this.scrollBar = \n    this.scrollBarV = new VScrollBar(this.container, this);\n    this.scrollBarH = new HScrollBar(this.container, this);\n    this.scrollBarV.addEventListener(\"scroll\", function(e) {\n        if (!_self.$scrollAnimation)\n            _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n    });\n    this.scrollBarH.addEventListener(\"scroll\", function(e) {\n        if (!_self.$scrollAnimation)\n            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n    });\n\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this.cursorPos = {\n        row : 0,\n        column : 0\n    };\n\n    this.$fontMetrics = new FontMetrics(this.container);\n    this.$textLayer.$setFontMetrics(this.$fontMetrics);\n    this.$textLayer.addEventListener(\"changeCharacterSize\", function(e) {\n        _self.updateCharacterSize();\n        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);\n        _self._signal(\"changeCharacterSize\", e);\n    });\n\n    this.$size = {\n        width: 0,\n        height: 0,\n        scrollerHeight: 0,\n        scrollerWidth: 0,\n        $dirty: true\n    };\n\n    this.layerConfig = {\n        width : 1,\n        padding : 0,\n        firstRow : 0,\n        firstRowScreen: 0,\n        lastRow : 0,\n        lineHeight : 0,\n        characterWidth : 0,\n        minHeight : 1,\n        maxHeight : 1,\n        offset : 0,\n        height : 1,\n        gutterOffset: 1\n    };\n    \n    this.scrollMargin = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        v: 0,\n        h: 0\n    };\n    \n    this.margin = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        v: 0,\n        h: 0\n    };\n    \n    this.$keepTextAreaAtCursor = !useragent.isIOS;\n\n    this.$loop = new RenderLoop(\n        this.$renderChanges.bind(this),\n        this.container.ownerDocument.defaultView\n    );\n    this.$loop.schedule(this.CHANGE_FULL);\n\n    this.updateCharacterSize();\n    this.setPadding(4);\n    config.resetOptions(this);\n    config._signal(\"renderer\", this);\n};\n\n(function() {\n\n    this.CHANGE_CURSOR = 1;\n    this.CHANGE_MARKER = 2;\n    this.CHANGE_GUTTER = 4;\n    this.CHANGE_SCROLL = 8;\n    this.CHANGE_LINES = 16;\n    this.CHANGE_TEXT = 32;\n    this.CHANGE_SIZE = 64;\n    this.CHANGE_MARKER_BACK = 128;\n    this.CHANGE_MARKER_FRONT = 256;\n    this.CHANGE_FULL = 512;\n    this.CHANGE_H_SCROLL = 1024;\n\n    oop.implement(this, EventEmitter);\n\n    this.updateCharacterSize = function() {\n        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {\n            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;\n            this.setStyle(\"ace_nobold\", !this.$allowBoldFonts);\n        }\n\n        this.layerConfig.characterWidth =\n        this.characterWidth = this.$textLayer.getCharacterWidth();\n        this.layerConfig.lineHeight =\n        this.lineHeight = this.$textLayer.getLineHeight();\n        this.$updatePrintMargin();\n        dom.setStyle(this.scroller.style, \"line-height\", this.lineHeight + \"px\");\n    };\n    this.setSession = function(session) {\n        if (this.session)\n            this.session.doc.off(\"changeNewLineMode\", this.onChangeNewLineMode);\n            \n        this.session = session;\n        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)\n            session.setScrollTop(-this.scrollMargin.top);\n\n        this.$cursorLayer.setSession(session);\n        this.$markerBack.setSession(session);\n        this.$markerFront.setSession(session);\n        this.$gutterLayer.setSession(session);\n        this.$textLayer.setSession(session);\n        if (!session)\n            return;\n        \n        this.$loop.schedule(this.CHANGE_FULL);\n        this.session.$setFontMetrics(this.$fontMetrics);\n        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;\n        \n        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);\n        this.onChangeNewLineMode();\n        this.session.doc.on(\"changeNewLineMode\", this.onChangeNewLineMode);\n    };\n    this.updateLines = function(firstRow, lastRow, force) {\n        if (lastRow === undefined)\n            lastRow = Infinity;\n\n        if (!this.$changedLines) {\n            this.$changedLines = {\n                firstRow: firstRow,\n                lastRow: lastRow\n            };\n        }\n        else {\n            if (this.$changedLines.firstRow > firstRow)\n                this.$changedLines.firstRow = firstRow;\n\n            if (this.$changedLines.lastRow < lastRow)\n                this.$changedLines.lastRow = lastRow;\n        }\n        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {\n            if (force)\n                this.$changedLines.lastRow = this.layerConfig.lastRow;\n            else\n                return;\n        }\n        if (this.$changedLines.firstRow > this.layerConfig.lastRow)\n            return;\n        this.$loop.schedule(this.CHANGE_LINES);\n    };\n\n    this.onChangeNewLineMode = function() {\n        this.$loop.schedule(this.CHANGE_TEXT);\n        this.$textLayer.$updateEolChar();\n        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);\n    };\n    \n    this.onChangeTabSize = function() {\n        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);\n        this.$textLayer.onChangeTabSize();\n    };\n    this.updateText = function() {\n        this.$loop.schedule(this.CHANGE_TEXT);\n    };\n    this.updateFull = function(force) {\n        if (force)\n            this.$renderChanges(this.CHANGE_FULL, true);\n        else\n            this.$loop.schedule(this.CHANGE_FULL);\n    };\n    this.updateFontSize = function() {\n        this.$textLayer.checkForSizeChanges();\n    };\n\n    this.$changes = 0;\n    this.$updateSizeAsync = function() {\n        if (this.$loop.pending)\n            this.$size.$dirty = true;\n        else\n            this.onResize();\n    };\n    this.onResize = function(force, gutterWidth, width, height) {\n        if (this.resizing > 2)\n            return;\n        else if (this.resizing > 0)\n            this.resizing++;\n        else\n            this.resizing = force ? 1 : 0;\n        var el = this.container;\n        if (!height)\n            height = el.clientHeight || el.scrollHeight;\n        if (!width)\n            width = el.clientWidth || el.scrollWidth;\n        var changes = this.$updateCachedSize(force, gutterWidth, width, height);\n\n        \n        if (!this.$size.scrollerHeight || (!width && !height))\n            return this.resizing = 0;\n\n        if (force)\n            this.$gutterLayer.$padding = null;\n\n        if (force)\n            this.$renderChanges(changes | this.$changes, true);\n        else\n            this.$loop.schedule(changes | this.$changes);\n\n        if (this.resizing)\n            this.resizing = 0;\n        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;\n    };\n    \n    this.$updateCachedSize = function(force, gutterWidth, width, height) {\n        height -= (this.$extraHeight || 0);\n        var changes = 0;\n        var size = this.$size;\n        var oldSize = {\n            width: size.width,\n            height: size.height,\n            scrollerHeight: size.scrollerHeight,\n            scrollerWidth: size.scrollerWidth\n        };\n        if (height && (force || size.height != height)) {\n            size.height = height;\n            changes |= this.CHANGE_SIZE;\n\n            size.scrollerHeight = size.height;\n            if (this.$horizScroll)\n                size.scrollerHeight -= this.scrollBarH.getHeight();\n            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + \"px\";\n\n            changes = changes | this.CHANGE_SCROLL;\n        }\n\n        if (width && (force || size.width != width)) {\n            changes |= this.CHANGE_SIZE;\n            size.width = width;\n            \n            if (gutterWidth == null)\n                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n            \n            this.gutterWidth = gutterWidth;\n            \n            dom.setStyle(this.scrollBarH.element.style, \"left\", gutterWidth + \"px\");\n            dom.setStyle(this.scroller.style, \"left\", gutterWidth + this.margin.left + \"px\");\n            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);\n            dom.setStyle(this.$gutter.style, \"left\", this.margin.left + \"px\");\n            \n            var right = this.scrollBarV.getWidth() + \"px\";\n            dom.setStyle(this.scrollBarH.element.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"right\", right);\n            dom.setStyle(this.scroller.style, \"bottom\", this.scrollBarH.getHeight());\n\n            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {\n                changes |= this.CHANGE_FULL;\n            }\n        }\n        \n        size.$dirty = !width || !height;\n\n        if (changes)\n            this._signal(\"resize\", oldSize);\n\n        return changes;\n    };\n\n    this.onGutterResize = function(width) {\n        var gutterWidth = this.$showGutter ? width : 0;\n        if (gutterWidth != this.gutterWidth)\n            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);\n\n        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        } else if (this.$size.$dirty) {\n            this.$loop.schedule(this.CHANGE_FULL);\n        } else {\n            this.$computeLayerConfig();\n        }\n    };\n    this.adjustWrapLimit = function() {\n        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n        var limit = Math.floor(availableWidth / this.characterWidth);\n        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);\n    };\n    this.setAnimatedScroll = function(shouldAnimate){\n        this.setOption(\"animatedScroll\", shouldAnimate);\n    };\n    this.getAnimatedScroll = function() {\n        return this.$animatedScroll;\n    };\n    this.setShowInvisibles = function(showInvisibles) {\n        this.setOption(\"showInvisibles\", showInvisibles);\n        this.session.$bidiHandler.setShowInvisibles(showInvisibles);\n    };\n    this.getShowInvisibles = function() {\n        return this.getOption(\"showInvisibles\");\n    };\n    this.getDisplayIndentGuides = function() {\n        return this.getOption(\"displayIndentGuides\");\n    };\n\n    this.setDisplayIndentGuides = function(display) {\n        this.setOption(\"displayIndentGuides\", display);\n    };\n    this.setShowPrintMargin = function(showPrintMargin) {\n        this.setOption(\"showPrintMargin\", showPrintMargin);\n    };\n    this.getShowPrintMargin = function() {\n        return this.getOption(\"showPrintMargin\");\n    };\n    this.setPrintMarginColumn = function(showPrintMargin) {\n        this.setOption(\"printMarginColumn\", showPrintMargin);\n    };\n    this.getPrintMarginColumn = function() {\n        return this.getOption(\"printMarginColumn\");\n    };\n    this.getShowGutter = function(){\n        return this.getOption(\"showGutter\");\n    };\n    this.setShowGutter = function(show){\n        return this.setOption(\"showGutter\", show);\n    };\n\n    this.getFadeFoldWidgets = function(){\n        return this.getOption(\"fadeFoldWidgets\");\n    };\n\n    this.setFadeFoldWidgets = function(show) {\n        this.setOption(\"fadeFoldWidgets\", show);\n    };\n\n    this.setHighlightGutterLine = function(shouldHighlight) {\n        this.setOption(\"highlightGutterLine\", shouldHighlight);\n    };\n\n    this.getHighlightGutterLine = function() {\n        return this.getOption(\"highlightGutterLine\");\n    };\n\n    this.$updatePrintMargin = function() {\n        if (!this.$showPrintMargin && !this.$printMarginEl)\n            return;\n\n        if (!this.$printMarginEl) {\n            var containerEl = dom.createElement(\"div\");\n            containerEl.className = \"ace_layer ace_print-margin-layer\";\n            this.$printMarginEl = dom.createElement(\"div\");\n            this.$printMarginEl.className = \"ace_print-margin\";\n            containerEl.appendChild(this.$printMarginEl);\n            this.content.insertBefore(containerEl, this.content.firstChild);\n        }\n\n        var style = this.$printMarginEl.style;\n        style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + \"px\";\n        style.visibility = this.$showPrintMargin ? \"visible\" : \"hidden\";\n        \n        if (this.session && this.session.$wrap == -1)\n            this.adjustWrapLimit();\n    };\n    this.getContainerElement = function() {\n        return this.container;\n    };\n    this.getMouseEventTarget = function() {\n        return this.scroller;\n    };\n    this.getTextAreaContainer = function() {\n        return this.container;\n    };\n    this.$moveTextAreaToCursor = function() {\n        if (this.$isMousePressed) return;\n        var style = this.textarea.style;\n        var composition = this.$composition;\n        if (!this.$keepTextAreaAtCursor && !composition) {\n            dom.translate(this.textarea, -100, 0);\n            return;\n        }\n        var pixelPos = this.$cursorLayer.$pixelPos;\n        if (!pixelPos)\n            return;\n        if (composition && composition.markerRange)\n            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);\n        \n        var config = this.layerConfig;\n        var posTop = pixelPos.top;\n        var posLeft = pixelPos.left;\n        posTop -= config.offset;\n\n        var h = composition && composition.useTextareaForIME ? this.lineHeight : HIDE_TEXTAREA ? 0 : 1;\n        if (posTop < 0 || posTop > config.height - h) {\n            dom.translate(this.textarea, 0, 0);\n            return;\n        }\n\n        var w = 1;\n        var maxTop = this.$size.height - h;\n        if (!composition) {\n            posTop += this.lineHeight;\n        }\n        else {\n            if (composition.useTextareaForIME) {\n                var val = this.textarea.value;\n                w = this.characterWidth * (this.session.$getStringScreenWidth(val)[0]);\n            }\n            else {\n                posTop += this.lineHeight + 2;\n            }\n        }\n        \n        posLeft -= this.scrollLeft;\n        if (posLeft > this.$size.scrollerWidth - w)\n            posLeft = this.$size.scrollerWidth - w;\n\n        posLeft += this.gutterWidth + this.margin.left;\n\n        dom.setStyle(style, \"height\", h + \"px\");\n        dom.setStyle(style, \"width\", w + \"px\");\n        dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));\n    };\n    this.getFirstVisibleRow = function() {\n        return this.layerConfig.firstRow;\n    };\n    this.getFirstFullyVisibleRow = function() {\n        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);\n    };\n    this.getLastFullyVisibleRow = function() {\n        var config = this.layerConfig;\n        var lastRow = config.lastRow;\n        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;\n        if (top - this.session.getScrollTop() > config.height - config.lineHeight)\n            return lastRow - 1;\n        return lastRow;\n    };\n    this.getLastVisibleRow = function() {\n        return this.layerConfig.lastRow;\n    };\n\n    this.$padding = null;\n    this.setPadding = function(padding) {\n        this.$padding = padding;\n        this.$textLayer.setPadding(padding);\n        this.$cursorLayer.setPadding(padding);\n        this.$markerFront.setPadding(padding);\n        this.$markerBack.setPadding(padding);\n        this.$loop.schedule(this.CHANGE_FULL);\n        this.$updatePrintMargin();\n    };\n    \n    this.setScrollMargin = function(top, bottom, left, right) {\n        var sm = this.scrollMargin;\n        sm.top = top|0;\n        sm.bottom = bottom|0;\n        sm.right = right|0;\n        sm.left = left|0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        if (sm.top && this.scrollTop <= 0 && this.session)\n            this.session.setScrollTop(-sm.top);\n        this.updateFull();\n    };\n    \n    this.setMargin = function(top, bottom, left, right) {\n        var sm = this.margin;\n        sm.top = top|0;\n        sm.bottom = bottom|0;\n        sm.right = right|0;\n        sm.left = left|0;\n        sm.v = sm.top + sm.bottom;\n        sm.h = sm.left + sm.right;\n        this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);\n        this.updateFull();\n    };\n    this.getHScrollBarAlwaysVisible = function() {\n        return this.$hScrollBarAlwaysVisible;\n    };\n    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {\n        this.setOption(\"hScrollBarAlwaysVisible\", alwaysVisible);\n    };\n    this.getVScrollBarAlwaysVisible = function() {\n        return this.$vScrollBarAlwaysVisible;\n    };\n    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {\n        this.setOption(\"vScrollBarAlwaysVisible\", alwaysVisible);\n    };\n\n    this.$updateScrollBarV = function() {\n        var scrollHeight = this.layerConfig.maxHeight;\n        var scrollerHeight = this.$size.scrollerHeight;\n        if (!this.$maxLines && this.$scrollPastEnd) {\n            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;\n            if (this.scrollTop > scrollHeight - scrollerHeight) {\n                scrollHeight = this.scrollTop + scrollerHeight;\n                this.scrollBarV.scrollTop = null;\n            }\n        }\n        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);\n        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);\n    };\n    this.$updateScrollBarH = function() {\n        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);\n        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);\n    };\n    \n    this.$frozen = false;\n    this.freeze = function() {\n        this.$frozen = true;\n    };\n    \n    this.unfreeze = function() {\n        this.$frozen = false;\n    };\n\n    this.$renderChanges = function(changes, force) {\n        if (this.$changes) {\n            changes |= this.$changes;\n            this.$changes = 0;\n        }\n        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {\n            this.$changes |= changes;\n            return; \n        } \n        if (this.$size.$dirty) {\n            this.$changes |= changes;\n            return this.onResize(true);\n        }\n        if (!this.lineHeight) {\n            this.$textLayer.checkForSizeChanges();\n        }\n        \n        this._signal(\"beforeRender\", changes);\n        \n        if (this.session && this.session.$bidiHandler)\n            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);\n\n        var config = this.layerConfig;\n        if (changes & this.CHANGE_FULL ||\n            changes & this.CHANGE_SIZE ||\n            changes & this.CHANGE_TEXT ||\n            changes & this.CHANGE_LINES ||\n            changes & this.CHANGE_SCROLL ||\n            changes & this.CHANGE_H_SCROLL\n        ) {\n            changes |= this.$computeLayerConfig() | this.$loop.clear();\n            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {\n                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;\n                if (st > 0) {\n                    this.scrollTop = st;\n                    changes = changes | this.CHANGE_SCROLL;\n                    changes |= this.$computeLayerConfig() | this.$loop.clear();\n                }\n            }\n            config = this.layerConfig;\n            this.$updateScrollBarV();\n            if (changes & this.CHANGE_H_SCROLL)\n                this.$updateScrollBarH();\n            \n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            \n            var width = config.width + 2 * this.$padding + \"px\";\n            var height = config.minHeight + \"px\";\n            \n            dom.setStyle(this.content.style, \"width\", width);\n            dom.setStyle(this.content.style, \"height\", height);\n        }\n        if (changes & this.CHANGE_H_SCROLL) {\n            dom.translate(this.content, -this.scrollLeft, -config.offset);\n            this.scroller.className = this.scrollLeft <= 0 ? \"ace_scroller\" : \"ace_scroller ace_scroll-left\";\n        }\n        if (changes & this.CHANGE_FULL) {\n            this.$changedLines = null;\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\", changes);\n            return;\n        }\n        if (changes & this.CHANGE_SCROLL) {\n            this.$changedLines = null;\n            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)\n                this.$textLayer.update(config);\n            else\n                this.$textLayer.scrollLines(config);\n\n            if (this.$showGutter) {\n                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)\n                    this.$gutterLayer.update(config);\n                else\n                    this.$gutterLayer.scrollLines(config);\n            }\n            this.$markerBack.update(config);\n            this.$markerFront.update(config);\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n            this._signal(\"afterRender\", changes);\n            return;\n        }\n\n        if (changes & this.CHANGE_TEXT) {\n            this.$changedLines = null;\n            this.$textLayer.update(config);\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_LINES) {\n            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(config);\n        }\n        else if (changes & this.CHANGE_CURSOR) {\n            if (this.$highlightGutterLine)\n                this.$gutterLayer.updateLineHighlight(config);\n        }\n\n        if (changes & this.CHANGE_CURSOR) {\n            this.$cursorLayer.update(config);\n            this.$moveTextAreaToCursor();\n        }\n\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {\n            this.$markerFront.update(config);\n        }\n\n        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {\n            this.$markerBack.update(config);\n        }\n\n        this._signal(\"afterRender\", changes);\n    };\n\n    \n    this.$autosize = function() {\n        var height = this.session.getScreenLength() * this.lineHeight;\n        var maxHeight = this.$maxLines * this.lineHeight;\n        var desiredHeight = Math.min(maxHeight, \n            Math.max((this.$minLines || 1) * this.lineHeight, height)\n        ) + this.scrollMargin.v + (this.$extraHeight || 0);\n        if (this.$horizScroll)\n            desiredHeight += this.scrollBarH.getHeight();\n        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)\n            desiredHeight = this.$maxPixelHeight;\n        \n        var hideScrollbars = desiredHeight <= 2 * this.lineHeight;\n        var vScroll = !hideScrollbars && height > maxHeight;\n        \n        if (desiredHeight != this.desiredHeight ||\n            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {\n            if (vScroll != this.$vScroll) {\n                this.$vScroll = vScroll;\n                this.scrollBarV.setVisible(vScroll);\n            }\n            \n            var w = this.container.clientWidth;\n            this.container.style.height = desiredHeight + \"px\";\n            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);\n            this.desiredHeight = desiredHeight;\n            \n            this._signal(\"autosize\");\n        }\n    };\n    \n    this.$computeLayerConfig = function() {\n        var session = this.session;\n        var size = this.$size;\n        \n        var hideScrollbars = size.height <= 2 * this.lineHeight;\n        var screenLines = this.session.getScreenLength();\n        var maxHeight = screenLines * this.lineHeight;\n\n        var longestLine = this.$getLongestLine();\n        \n        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||\n            size.scrollerWidth - longestLine - 2 * this.$padding < 0);\n\n        var hScrollChanged = this.$horizScroll !== horizScroll;\n        if (hScrollChanged) {\n            this.$horizScroll = horizScroll;\n            this.scrollBarH.setVisible(horizScroll);\n        }\n        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine\n        if (this.$maxLines && this.lineHeight > 1)\n            this.$autosize();\n\n        var minHeight = size.scrollerHeight + this.lineHeight;\n        \n        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd\n            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd\n            : 0;\n        maxHeight += scrollPastEnd;\n        \n        var sm = this.scrollMargin;\n        this.session.setScrollTop(Math.max(-sm.top,\n            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));\n\n        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, \n            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));\n        \n        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||\n            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);\n        var vScrollChanged = vScrollBefore !== vScroll;\n        if (vScrollChanged) {\n            this.$vScroll = vScroll;\n            this.scrollBarV.setVisible(vScroll);\n        }\n\n        var offset = this.scrollTop % this.lineHeight;\n        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;\n        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));\n        var lastRow = firstRow + lineCount;\n        var firstRowScreen, firstRowHeight;\n        var lineHeight = this.lineHeight;\n        firstRow = session.screenToDocumentRow(firstRow, 0);\n        var foldLine = session.getFoldLine(firstRow);\n        if (foldLine) {\n            firstRow = foldLine.start.row;\n        }\n\n        firstRowScreen = session.documentToScreenRow(firstRow, 0);\n        firstRowHeight = session.getRowLength(firstRow) * lineHeight;\n\n        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);\n        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +\n                                                firstRowHeight;\n\n        offset = this.scrollTop - firstRowScreen * lineHeight;\n\n        var changes = 0;\n        if (this.layerConfig.width != longestLine || hScrollChanged) \n            changes = this.CHANGE_H_SCROLL;\n        if (hScrollChanged || vScrollChanged) {\n            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);\n            this._signal(\"scrollbarVisibilityChanged\");\n            if (vScrollChanged)\n                longestLine = this.$getLongestLine();\n        }\n        \n        this.layerConfig = {\n            width : longestLine,\n            padding : this.$padding,\n            firstRow : firstRow,\n            firstRowScreen: firstRowScreen,\n            lastRow : lastRow,\n            lineHeight : lineHeight,\n            characterWidth : this.characterWidth,\n            minHeight : minHeight,\n            maxHeight : maxHeight,\n            offset : offset,\n            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,\n            height : this.$size.scrollerHeight\n        };\n\n        if (this.session.$bidiHandler)\n            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);\n\n        return changes;\n    };\n\n    this.$updateLines = function() {\n        if (!this.$changedLines) return;\n        var firstRow = this.$changedLines.firstRow;\n        var lastRow = this.$changedLines.lastRow;\n        this.$changedLines = null;\n\n        var layerConfig = this.layerConfig;\n\n        if (firstRow > layerConfig.lastRow + 1) { return; }\n        if (lastRow < layerConfig.firstRow) { return; }\n        if (lastRow === Infinity) {\n            if (this.$showGutter)\n                this.$gutterLayer.update(layerConfig);\n            this.$textLayer.update(layerConfig);\n            return;\n        }\n        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);\n        return true;\n    };\n\n    this.$getLongestLine = function() {\n        var charCount = this.session.getScreenWidth();\n        if (this.showInvisibles && !this.session.$useWrapMode)\n            charCount += 1;\n            \n        if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)\n            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;\n\n        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));\n    };\n    this.updateFrontMarkers = function() {\n        this.$markerFront.setMarkers(this.session.getMarkers(true));\n        this.$loop.schedule(this.CHANGE_MARKER_FRONT);\n    };\n    this.updateBackMarkers = function() {\n        this.$markerBack.setMarkers(this.session.getMarkers());\n        this.$loop.schedule(this.CHANGE_MARKER_BACK);\n    };\n    this.addGutterDecoration = function(row, className){\n        this.$gutterLayer.addGutterDecoration(row, className);\n    };\n    this.removeGutterDecoration = function(row, className){\n        this.$gutterLayer.removeGutterDecoration(row, className);\n    };\n    this.updateBreakpoints = function(rows) {\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    this.setAnnotations = function(annotations) {\n        this.$gutterLayer.setAnnotations(annotations);\n        this.$loop.schedule(this.CHANGE_GUTTER);\n    };\n    this.updateCursor = function() {\n        this.$loop.schedule(this.CHANGE_CURSOR);\n    };\n    this.hideCursor = function() {\n        this.$cursorLayer.hideCursor();\n    };\n    this.showCursor = function() {\n        this.$cursorLayer.showCursor();\n    };\n\n    this.scrollSelectionIntoView = function(anchor, lead, offset) {\n        this.scrollCursorIntoView(anchor, offset);\n        this.scrollCursorIntoView(lead, offset);\n    };\n    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {\n        if (this.$size.scrollerHeight === 0)\n            return;\n\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n\n        var left = pos.left;\n        var top = pos.top;\n        \n        var topMargin = $viewMargin && $viewMargin.top || 0;\n        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;\n        \n        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;\n        \n        if (scrollTop + topMargin > top) {\n            if (offset && scrollTop + topMargin > top + this.lineHeight)\n                top -= offset * this.$size.scrollerHeight;\n            if (top === 0)\n                top = -this.scrollMargin.top;\n            this.session.setScrollTop(top);\n        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {\n            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)\n                top += offset * this.$size.scrollerHeight;\n            this.session.setScrollTop(top + this.lineHeight + bottomMargin - this.$size.scrollerHeight);\n        }\n\n        var scrollLeft = this.scrollLeft;\n\n        if (scrollLeft > left) {\n            if (left < this.$padding + 2 * this.layerConfig.characterWidth)\n                left = -this.scrollMargin.left;\n            this.session.setScrollLeft(left);\n        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {\n            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));\n        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {\n            this.session.setScrollLeft(0);\n        }\n    };\n    this.getScrollTop = function() {\n        return this.session.getScrollTop();\n    };\n    this.getScrollLeft = function() {\n        return this.session.getScrollLeft();\n    };\n    this.getScrollTopRow = function() {\n        return this.scrollTop / this.lineHeight;\n    };\n    this.getScrollBottomRow = function() {\n        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);\n    };\n    this.scrollToRow = function(row) {\n        this.session.setScrollTop(row * this.lineHeight);\n    };\n\n    this.alignCursor = function(cursor, alignment) {\n        if (typeof cursor == \"number\")\n            cursor = {row: cursor, column: 0};\n\n        var pos = this.$cursorLayer.getPixelPosition(cursor);\n        var h = this.$size.scrollerHeight - this.lineHeight;\n        var offset = pos.top - h * (alignment || 0);\n\n        this.session.setScrollTop(offset);\n        return offset;\n    };\n\n    this.STEPS = 8;\n    this.$calcSteps = function(fromValue, toValue){\n        var i = 0;\n        var l = this.STEPS;\n        var steps = [];\n\n        var func  = function(t, x_min, dx) {\n            return dx * (Math.pow(t - 1, 3) + 1) + x_min;\n        };\n\n        for (i = 0; i < l; ++i)\n            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));\n\n        return steps;\n    };\n    this.scrollToLine = function(line, center, animate, callback) {\n        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});\n        var offset = pos.top;\n        if (center)\n            offset -= this.$size.scrollerHeight / 2;\n\n        var initialScroll = this.scrollTop;\n        this.session.setScrollTop(offset);\n        if (animate !== false)\n            this.animateScrolling(initialScroll, callback);\n    };\n\n    this.animateScrolling = function(fromValue, callback) {\n        var toValue = this.scrollTop;\n        if (!this.$animatedScroll)\n            return;\n        var _self = this;\n        \n        if (fromValue == toValue)\n            return;\n        \n        if (this.$scrollAnimation) {\n            var oldSteps = this.$scrollAnimation.steps;\n            if (oldSteps.length) {\n                fromValue = oldSteps[0];\n                if (fromValue == toValue)\n                    return;\n            }\n        }\n        \n        var steps = _self.$calcSteps(fromValue, toValue);\n        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};\n\n        clearInterval(this.$timer);\n\n        _self.session.setScrollTop(steps.shift());\n        _self.session.$scrollTop = toValue;\n        this.$timer = setInterval(function() {\n            if (steps.length) {\n                _self.session.setScrollTop(steps.shift());\n                _self.session.$scrollTop = toValue;\n            } else if (toValue != null) {\n                _self.session.$scrollTop = -1;\n                _self.session.setScrollTop(toValue);\n                toValue = null;\n            } else {\n                _self.$timer = clearInterval(_self.$timer);\n                _self.$scrollAnimation = null;\n                callback && callback();\n            }\n        }, 10);\n    };\n    this.scrollToY = function(scrollTop) {\n        if (this.scrollTop !== scrollTop) {\n            this.$loop.schedule(this.CHANGE_SCROLL);\n            this.scrollTop = scrollTop;\n        }\n    };\n    this.scrollToX = function(scrollLeft) {\n        if (this.scrollLeft !== scrollLeft)\n            this.scrollLeft = scrollLeft;\n        this.$loop.schedule(this.CHANGE_H_SCROLL);\n    };\n    this.scrollTo = function(x, y) {\n        this.session.setScrollTop(y);\n        this.session.setScrollLeft(y);\n    };\n    this.scrollBy = function(deltaX, deltaY) {\n        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);\n        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);\n    };\n    this.isScrollableBy = function(deltaX, deltaY) {\n        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)\n           return true;\n        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight\n            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)\n           return true;\n        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)\n            return true;\n        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth\n            - this.layerConfig.width < -1 + this.scrollMargin.right)\n           return true;\n    };\n\n    this.pixelToScreenCoordinates = function(x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = {top:0, left: 0};\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        } else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n        \n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n\n        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};\n    };\n\n    this.screenToTextCoordinates = function(x, y) {\n        var canvasPos;\n        if (this.$hasCssTransforms) {\n            canvasPos = {top:0, left: 0};\n            var p = this.$fontMetrics.transformCoordinates([x, y]);\n            x = p[1] - this.gutterWidth - this.margin.left;\n            y = p[0];\n        } else {\n            canvasPos = this.scroller.getBoundingClientRect();\n        }\n\n        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;\n        var offset = offsetX / this.characterWidth;\n        var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);\n\n        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n\n        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);\n    };\n    this.textToScreenCoordinates = function(row, column) {\n        var canvasPos = this.scroller.getBoundingClientRect();\n        var pos = this.session.documentToScreenPosition(row, column);\n\n        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)\n             ? this.session.$bidiHandler.getPosLeft(pos.column)\n             : Math.round(pos.column * this.characterWidth));\n        \n        var y = pos.row * this.lineHeight;\n\n        return {\n            pageX: canvasPos.left + x - this.scrollLeft,\n            pageY: canvasPos.top + y - this.scrollTop\n        };\n    };\n    this.visualizeFocus = function() {\n        dom.addCssClass(this.container, \"ace_focus\");\n    };\n    this.visualizeBlur = function() {\n        dom.removeCssClass(this.container, \"ace_focus\");\n    };\n    this.showComposition = function(composition) {\n        this.$composition = composition;\n        if (!composition.cssText) {\n            composition.cssText = this.textarea.style.cssText;\n        }\n        composition.useTextareaForIME = this.$useTextareaForIME;\n        \n        if (this.$useTextareaForIME) {\n            dom.addCssClass(this.textarea, \"ace_composition\");\n            this.textarea.style.cssText = \"\";\n            this.$moveTextAreaToCursor();\n            this.$cursorLayer.element.style.display = \"none\";\n        }\n        else {\n            composition.markerId = this.session.addMarker(composition.markerRange, \"ace_composition_marker\", \"text\");\n        }\n    };\n    this.setCompositionText = function(text) {\n        var cursor = this.session.selection.cursor;\n        this.addToken(text, \"composition_placeholder\", cursor.row, cursor.column);\n        this.$moveTextAreaToCursor();\n    };\n    this.hideComposition = function() {\n        if (!this.$composition)\n            return;\n        \n        if (this.$composition.markerId)\n            this.session.removeMarker(this.$composition.markerId);\n\n        dom.removeCssClass(this.textarea, \"ace_composition\");\n        this.textarea.style.cssText = this.$composition.cssText;\n        this.$composition = null;\n        this.$cursorLayer.element.style.display = \"\";\n    };\n    \n    this.addToken = function(text, type, row, column) {\n        var session = this.session;\n        session.bgTokenizer.lines[row] = null;\n        var newToken = {type: type, value: text};\n        var tokens = session.getTokens(row);\n        if (column == null) {\n            tokens.push(newToken);\n        } else {\n            var l = 0;\n            for (var i =0; i < tokens.length; i++) {\n                var token = tokens[i];\n                l += token.value.length;\n                if (column <= l) {\n                    var diff = token.value.length - (l - column);\n                    var before = token.value.slice(0, diff);\n                    var after = token.value.slice(diff);\n    \n                    tokens.splice(i, 1, {type: token.type, value: before},  newToken,  {type: token.type, value: after});\n                    break;\n                }\n            }\n        }\n        this.updateLines(row, row);\n    };\n    this.setTheme = function(theme, cb) {\n        var _self = this;\n        this.$themeId = theme;\n        _self._dispatchEvent('themeChange',{theme:theme});\n\n        if (!theme || typeof theme == \"string\") {\n            var moduleName = theme || this.$options.theme.initialValue;\n            config.loadModule([\"theme\", moduleName], afterLoad);\n        } else {\n            afterLoad(theme);\n        }\n\n        function afterLoad(module) {\n            if (_self.$themeId != theme)\n                return cb && cb();\n            if (!module || !module.cssClass)\n                throw new Error(\"couldn't load module \" + theme + \" or it didn't call define\");\n            if (module.$id)\n                _self.$themeId = module.$id;\n            dom.importCssString(\n                module.cssText,\n                module.cssClass,\n                _self.container\n            );\n\n            if (_self.theme)\n                dom.removeCssClass(_self.container, _self.theme.cssClass);\n\n            var padding = \"padding\" in module ? module.padding \n                : \"padding\" in (_self.theme || {}) ? 4 : _self.$padding;\n            if (_self.$padding && padding != _self.$padding)\n                _self.setPadding(padding);\n            _self.$theme = module.cssClass;\n\n            _self.theme = module;\n            dom.addCssClass(_self.container, module.cssClass);\n            dom.setCssClass(_self.container, \"ace_dark\", module.isDark);\n            if (_self.$size) {\n                _self.$size.width = 0;\n                _self.$updateSizeAsync();\n            }\n\n            _self._dispatchEvent('themeLoaded', {theme:module});\n            cb && cb();\n        }\n    };\n    this.getTheme = function() {\n        return this.$themeId;\n    };\n    this.setStyle = function(style, include) {\n        dom.setCssClass(this.container, style, include !== false);\n    };\n    this.unsetStyle = function(style) {\n        dom.removeCssClass(this.container, style);\n    };\n    \n    this.setCursorStyle = function(style) {\n        dom.setStyle(this.scroller.style, \"cursor\", style);\n    };\n    this.setMouseCursor = function(cursorStyle) {\n        dom.setStyle(this.scroller.style, \"cursor\", cursorStyle);\n    };\n    \n    this.attachToShadowRoot = function() {\n        dom.importCssString(editorCss, \"ace_editor.css\", this.container);\n    };\n    this.destroy = function() {\n        this.freeze();\n        this.$fontMetrics.destroy();\n        this.$cursorLayer.destroy();\n    };\n\n}).call(VirtualRenderer.prototype);\n\n\nconfig.defineOptions(VirtualRenderer.prototype, \"renderer\", {\n    animatedScroll: {initialValue: false},\n    showInvisibles: {\n        set: function(value) {\n            if (this.$textLayer.setShowInvisibles(value))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: false\n    },\n    showPrintMargin: {\n        set: function() { this.$updatePrintMargin(); },\n        initialValue: true\n    },\n    printMarginColumn: {\n        set: function() { this.$updatePrintMargin(); },\n        initialValue: 80\n    },\n    printMargin: {\n        set: function(val) {\n            if (typeof val == \"number\")\n                this.$printMarginColumn = val;\n            this.$showPrintMargin = !!val;\n            this.$updatePrintMargin();\n        },\n        get: function() {\n            return this.$showPrintMargin && this.$printMarginColumn; \n        }\n    },\n    showGutter: {\n        set: function(show){\n            this.$gutter.style.display = show ? \"block\" : \"none\";\n            this.$loop.schedule(this.CHANGE_FULL);\n            this.onGutterResize();\n        },\n        initialValue: true\n    },\n    fadeFoldWidgets: {\n        set: function(show) {\n            dom.setCssClass(this.$gutter, \"ace_fade-fold-widgets\", show);\n        },\n        initialValue: false\n    },\n    showFoldWidgets: {\n        set: function(show) {\n            this.$gutterLayer.setShowFoldWidgets(show);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    displayIndentGuides: {\n        set: function(show) {\n            if (this.$textLayer.setDisplayIndentGuides(show))\n                this.$loop.schedule(this.CHANGE_TEXT);\n        },\n        initialValue: true\n    },\n    highlightGutterLine: {\n        set: function(shouldHighlight) {\n            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        },\n        initialValue: true\n    },\n    hScrollBarAlwaysVisible: {\n        set: function(val) {\n            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    vScrollBarAlwaysVisible: {\n        set: function(val) {\n            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)\n                this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: false\n    },\n    fontSize: {\n        set: function(size) {\n            if (typeof size == \"number\")\n                size = size + \"px\";\n            this.container.style.fontSize = size;\n            this.updateFontSize();\n        },\n        initialValue: 12\n    },\n    fontFamily: {\n        set: function(name) {\n            this.container.style.fontFamily = name;\n            this.updateFontSize();\n        }\n    },\n    maxLines: {\n        set: function(val) {\n            this.updateFull();\n        }\n    },\n    minLines: {\n        set: function(val) {\n            if (!(this.$minLines < 0x1ffffffffffff))\n                this.$minLines = 0;\n            this.updateFull();\n        }\n    },\n    maxPixelHeight: {\n        set: function(val) {\n            this.updateFull();\n        },\n        initialValue: 0\n    },\n    scrollPastEnd: {\n        set: function(val) {\n            val = +val || 0;\n            if (this.$scrollPastEnd == val)\n                return;\n            this.$scrollPastEnd = val;\n            this.$loop.schedule(this.CHANGE_SCROLL);\n        },\n        initialValue: 0,\n        handlesSet: true\n    },\n    fixedWidthGutter: {\n        set: function(val) {\n            this.$gutterLayer.$fixedWidth = !!val;\n            this.$loop.schedule(this.CHANGE_GUTTER);\n        }\n    },\n    theme: {\n        set: function(val) { this.setTheme(val); },\n        get: function() { return this.$themeId || this.theme; },\n        initialValue: \"./theme/textmate\",\n        handlesSet: true\n    },\n    hasCssTransforms: {\n    },\n    useTextareaForIME: {\n        initialValue: !useragent.isMobile && !useragent.isIE\n    }\n});\n\nexports.VirtualRenderer = VirtualRenderer;\n});\n\nace.define(\"ace/worker/worker_client\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar net = require(\"../lib/net\");\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar config = require(\"../config\");\n\nfunction $workerBlob(workerUrl) {\n    var script = \"importScripts('\" + net.qualifyURL(workerUrl) + \"');\";\n    try {\n        return new Blob([script], {\"type\": \"application/javascript\"});\n    } catch (e) { // Backwards-compatibility\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n        var blobBuilder = new BlobBuilder();\n        blobBuilder.append(script);\n        return blobBuilder.getBlob(\"application/javascript\");\n    }\n}\n\nfunction createWorker(workerUrl) {\n    if (typeof Worker == \"undefined\")\n        return { postMessage: function() {}, terminate: function() {} };\n    if (config.get(\"loadWorkerFromBlob\")) {\n        var blob = $workerBlob(workerUrl);\n        var URL = window.URL || window.webkitURL;\n        var blobURL = URL.createObjectURL(blob);\n        return new Worker(blobURL);\n    }\n    return new Worker(workerUrl);\n}\n\nvar WorkerClient = function(worker) {\n    if (!worker.postMessage)\n        worker = this.$createWorkerFromOldConfig.apply(this, arguments);\n\n    this.$worker = worker;\n    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n    this.changeListener = this.changeListener.bind(this);\n    this.onMessage = this.onMessage.bind(this);\n\n    this.callbackId = 1;\n    this.callbacks = {};\n\n    this.$worker.onmessage = this.onMessage;\n};\n\n(function(){\n\n    oop.implement(this, EventEmitter);\n\n    this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {\n        if (require.nameToUrl && !require.toUrl)\n            require.toUrl = require.nameToUrl;\n\n        if (config.get(\"packaged\") || !require.toUrl) {\n            workerUrl = workerUrl || config.moduleUrl(mod, \"worker\");\n        } else {\n            var normalizePath = this.$normalizePath;\n            workerUrl = workerUrl || normalizePath(require.toUrl(\"ace/worker/worker.js\", null, \"_\"));\n\n            var tlns = {};\n            topLevelNamespaces.forEach(function(ns) {\n                tlns[ns] = normalizePath(require.toUrl(ns, null, \"_\").replace(/(\\.js)?(\\?.*)?$/, \"\"));\n            });\n        }\n\n        this.$worker = createWorker(workerUrl);\n        if (importScripts) {\n            this.send(\"importScripts\", importScripts);\n        }\n        this.$worker.postMessage({\n            init : true,\n            tlns : tlns,\n            module : mod,\n            classname : classname\n        });\n        return this.$worker;\n    };\n\n    this.onMessage = function(e) {\n        var msg = e.data;\n        switch (msg.type) {\n            case \"event\":\n                this._signal(msg.name, {data: msg.data});\n                break;\n            case \"call\":\n                var callback = this.callbacks[msg.id];\n                if (callback) {\n                    callback(msg.data);\n                    delete this.callbacks[msg.id];\n                }\n                break;\n            case \"error\":\n                this.reportError(msg.data);\n                break;\n            case \"log\":\n                window.console && console.log && console.log.apply(console, msg.data);\n                break;\n        }\n    };\n    \n    this.reportError = function(err) {\n        window.console && console.error && console.error(err);\n    };\n\n    this.$normalizePath = function(path) {\n        return net.qualifyURL(path);\n    };\n\n    this.terminate = function() {\n        this._signal(\"terminate\", {});\n        this.deltaQueue = null;\n        this.$worker.terminate();\n        this.$worker = null;\n        if (this.$doc)\n            this.$doc.off(\"change\", this.changeListener);\n        this.$doc = null;\n    };\n\n    this.send = function(cmd, args) {\n        this.$worker.postMessage({command: cmd, args: args});\n    };\n\n    this.call = function(cmd, args, callback) {\n        if (callback) {\n            var id = this.callbackId++;\n            this.callbacks[id] = callback;\n            args.push(id);\n        }\n        this.send(cmd, args);\n    };\n\n    this.emit = function(event, data) {\n        try {\n            if (data.data && data.data.err)\n                data.data.err = {message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code};\n            this.$worker.postMessage({event: event, data: {data: data.data}});\n        }\n        catch(ex) {\n            console.error(ex.stack);\n        }\n    };\n\n    this.attachToDocument = function(doc) {\n        if (this.$doc)\n            this.terminate();\n\n        this.$doc = doc;\n        this.call(\"setValue\", [doc.getValue()]);\n        doc.on(\"change\", this.changeListener);\n    };\n\n    this.changeListener = function(delta) {\n        if (!this.deltaQueue) {\n            this.deltaQueue = [];\n            setTimeout(this.$sendDeltaQueue, 0);\n        }\n        if (delta.action == \"insert\")\n            this.deltaQueue.push(delta.start, delta.lines);\n        else\n            this.deltaQueue.push(delta.start, delta.end);\n    };\n\n    this.$sendDeltaQueue = function() {\n        var q = this.deltaQueue;\n        if (!q) return;\n        this.deltaQueue = null;\n        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {\n            this.call(\"setValue\", [this.$doc.getValue()]);\n        } else\n            this.emit(\"change\", {data: q});\n    };\n\n}).call(WorkerClient.prototype);\n\n\nvar UIWorkerClient = function(topLevelNamespaces, mod, classname) {\n    var main = null;\n    var emitSync = false;\n    var sender = Object.create(EventEmitter);\n\n    var messageBuffer = [];\n    var workerClient = new WorkerClient({\n        messageBuffer: messageBuffer,\n        terminate: function() {},\n        postMessage: function(e) {\n            messageBuffer.push(e);\n            if (!main) return;\n            if (emitSync)\n                setTimeout(processNext);\n            else\n                processNext();\n        }\n    });\n\n    workerClient.setEmitSync = function(val) { emitSync = val; };\n\n    var processNext = function() {\n        var msg = messageBuffer.shift();\n        if (msg.command)\n            main[msg.command].apply(main, msg.args);\n        else if (msg.event)\n            sender._signal(msg.event, msg.data);\n    };\n\n    sender.postMessage = function(msg) {\n        workerClient.onMessage({data: msg});\n    };\n    sender.callback = function(data, callbackId) {\n        this.postMessage({type: \"call\", id: callbackId, data: data});\n    };\n    sender.emit = function(name, data) {\n        this.postMessage({type: \"event\", name: name, data: data});\n    };\n\n    config.loadModule([\"worker\", mod], function(Main) {\n        main = new Main[classname](sender);\n        while (messageBuffer.length)\n            processNext();\n    });\n\n    return workerClient;\n};\n\nexports.UIWorkerClient = UIWorkerClient;\nexports.WorkerClient = WorkerClient;\nexports.createWorker = createWorker;\n\n\n});\n\nace.define(\"ace/placeholder\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/oop\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"./range\").Range;\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar oop = require(\"./lib/oop\");\n\nvar PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {\n    var _self = this;\n    this.length = length;\n    this.session = session;\n    this.doc = session.getDocument();\n    this.mainClass = mainClass;\n    this.othersClass = othersClass;\n    this.$onUpdate = this.onUpdate.bind(this);\n    this.doc.on(\"change\", this.$onUpdate);\n    this.$others = others;\n    \n    this.$onCursorChange = function() {\n        setTimeout(function() {\n            _self.onCursorChange();\n        });\n    };\n    \n    this.$pos = pos;\n    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};\n    this.$undoStackDepth = undoStack.length;\n    this.setup();\n\n    session.selection.on(\"changeCursor\", this.$onCursorChange);\n};\n\n(function() {\n\n    oop.implement(this, EventEmitter);\n    this.setup = function() {\n        var _self = this;\n        var doc = this.doc;\n        var session = this.session;\n        \n        this.selectionBefore = session.selection.toJSON();\n        if (session.selection.inMultiSelectMode)\n            session.selection.toSingleRange();\n\n        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);\n        var pos = this.pos;\n        pos.$insertRight = true;\n        pos.detach();\n        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);\n        this.others = [];\n        this.$others.forEach(function(other) {\n            var anchor = doc.createAnchor(other.row, other.column);\n            anchor.$insertRight = true;\n            anchor.detach();\n            _self.others.push(anchor);\n        });\n        session.setUndoSelect(false);\n    };\n    this.showOtherMarkers = function() {\n        if (this.othersActive) return;\n        var session = this.session;\n        var _self = this;\n        this.othersActive = true;\n        this.others.forEach(function(anchor) {\n            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);\n        });\n    };\n    this.hideOtherMarkers = function() {\n        if (!this.othersActive) return;\n        this.othersActive = false;\n        for (var i = 0; i < this.others.length; i++) {\n            this.session.removeMarker(this.others[i].markerId);\n        }\n    };\n    this.onUpdate = function(delta) {\n        if (this.$updating)\n            return this.updateAnchors(delta);\n            \n        var range = delta;\n        if (range.start.row !== range.end.row) return;\n        if (range.start.row !== this.pos.row) return;\n        this.$updating = true;\n        var lengthDiff = delta.action === \"insert\" ? range.end.column - range.start.column : range.start.column - range.end.column;\n        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;\n        var distanceFromStart = range.start.column - this.pos.column;\n        \n        this.updateAnchors(delta);\n        \n        if (inMainRange)\n            this.length += lengthDiff;\n\n        if (inMainRange && !this.session.$fromUndo) {\n            if (delta.action === 'insert') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n                    this.doc.insertMergedLines(newPos, delta.lines);\n                }\n            } else if (delta.action === 'remove') {\n                for (var i = this.others.length - 1; i >= 0; i--) {\n                    var otherPos = this.others[i];\n                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));\n                }\n            }\n        }\n        \n        this.$updating = false;\n        this.updateMarkers();\n    };\n    \n    this.updateAnchors = function(delta) {\n        this.pos.onChange(delta);\n        for (var i = this.others.length; i--;)\n            this.others[i].onChange(delta);\n        this.updateMarkers();\n    };\n    \n    this.updateMarkers = function() {\n        if (this.$updating)\n            return;\n        var _self = this;\n        var session = this.session;\n        var updateMarker = function(pos, className) {\n            session.removeMarker(pos.markerId);\n            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);\n        };\n        updateMarker(this.pos, this.mainClass);\n        for (var i = this.others.length; i--;)\n            updateMarker(this.others[i], this.othersClass);\n    };\n\n    this.onCursorChange = function(event) {\n        if (this.$updating || !this.session) return;\n        var pos = this.session.selection.getCursor();\n        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {\n            this.showOtherMarkers();\n            this._emit(\"cursorEnter\", event);\n        } else {\n            this.hideOtherMarkers();\n            this._emit(\"cursorLeave\", event);\n        }\n    };    \n    this.detach = function() {\n        this.session.removeMarker(this.pos && this.pos.markerId);\n        this.hideOtherMarkers();\n        this.doc.removeEventListener(\"change\", this.$onUpdate);\n        this.session.selection.removeEventListener(\"changeCursor\", this.$onCursorChange);\n        this.session.setUndoSelect(true);\n        this.session = null;\n    };\n    this.cancel = function() {\n        if (this.$undoStackDepth === -1)\n            return;\n        var undoManager = this.session.getUndoManager();\n        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;\n        for (var i = 0; i < undosRequired; i++) {\n            undoManager.undo(this.session, true);\n        }\n        if (this.selectionBefore)\n            this.session.selection.fromJSON(this.selectionBefore);\n    };\n}).call(PlaceHolder.prototype);\n\n\nexports.PlaceHolder = PlaceHolder;\n});\n\nace.define(\"ace/mouse/multi_select_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(require, exports, module) {\n\nvar event = require(\"../lib/event\");\nvar useragent = require(\"../lib/useragent\");\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\n\nfunction onMouseDown(e) {\n    var ev = e.domEvent;\n    var alt = ev.altKey;\n    var shift = ev.shiftKey;\n    var ctrl = ev.ctrlKey;\n    var accel = e.getAccelKey();\n    var button = e.getButton();\n    \n    if (ctrl && useragent.isMac)\n        button = ev.button;\n\n    if (e.editor.inMultiSelectMode && button == 2) {\n        e.editor.textInput.onContextMenu(e.domEvent);\n        return;\n    }\n    \n    if (!ctrl && !alt && !accel) {\n        if (button === 0 && e.editor.inMultiSelectMode)\n            e.editor.exitMultiSelectMode();\n        return;\n    }\n    \n    if (button !== 0)\n        return;\n\n    var editor = e.editor;\n    var selection = editor.selection;\n    var isMultiSelect = editor.inMultiSelectMode;\n    var pos = e.getDocumentPosition();\n    var cursor = selection.getCursor();\n    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));\n\n    var mouseX = e.x, mouseY = e.y;\n    var onMouseSelection = function(e) {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n    };\n    \n    var session = editor.session;\n    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n    var screenCursor = screenAnchor;\n    \n    var selectionMode;\n    if (editor.$mouseHandler.$enableJumpToDef) {\n        if (ctrl && alt || accel && alt)\n            selectionMode = shift ? \"block\" : \"add\";\n        else if (alt && editor.$blockSelectEnabled)\n            selectionMode = \"block\";\n    } else {\n        if (accel && !alt) {\n            selectionMode = \"add\";\n            if (!isMultiSelect && shift)\n                return;\n        } else if (alt && editor.$blockSelectEnabled) {\n            selectionMode = \"block\";\n        }\n    }\n    \n    if (selectionMode && useragent.isMac && ev.ctrlKey) {\n        editor.$mouseHandler.cancelContextMenu();\n    }\n\n    if (selectionMode == \"add\") {\n        if (!isMultiSelect && inSelection)\n            return; // dragging\n\n        if (!isMultiSelect) {\n            var range = selection.toOrientedRange();\n            editor.addSelectionMarker(range);\n        }\n\n        var oldRange = selection.rangeList.rangeAtPoint(pos);\n        \n        editor.inVirtualSelectionMode = true;\n        \n        if (shift) {\n            oldRange = null;\n            range = selection.ranges[0] || range;\n            editor.removeSelectionMarker(range);\n        }\n        editor.once(\"mouseup\", function() {\n            var tmpSel = selection.toOrientedRange();\n\n            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))\n                selection.substractPoint(tmpSel.cursor);\n            else {\n                if (shift) {\n                    selection.substractPoint(range.cursor);\n                } else if (range) {\n                    editor.removeSelectionMarker(range);\n                    selection.addRange(range);\n                }\n                selection.addRange(tmpSel);\n            }\n            editor.inVirtualSelectionMode = false;\n        });\n\n    } else if (selectionMode == \"block\") {\n        e.stop();\n        editor.inVirtualSelectionMode = true;        \n        var initialRange;\n        var rectSel = [];\n        var blockSelect = function() {\n            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);\n\n            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))\n                return;\n            screenCursor = newCursor;\n            \n            editor.selection.moveToPosition(cursor);\n            editor.renderer.scrollCursorIntoView();\n\n            editor.removeSelectionMarkers(rectSel);\n            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);\n            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())\n                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();\n            rectSel.forEach(editor.addSelectionMarker, editor);\n            editor.updateSelectionMarkers();\n        };\n        if (isMultiSelect && !accel) {\n            selection.toSingleRange();\n        } else if (!isMultiSelect && accel) {\n            initialRange = selection.toOrientedRange();\n            editor.addSelectionMarker(initialRange);\n        }\n        \n        if (shift)\n            screenAnchor = session.documentToScreenPosition(selection.lead);            \n        else\n            selection.moveToPosition(pos);\n        \n        screenCursor = {row: -1, column: -1};\n\n        var onMouseSelectionEnd = function(e) {\n            blockSelect();\n            clearInterval(timerId);\n            editor.removeSelectionMarkers(rectSel);\n            if (!rectSel.length)\n                rectSel = [selection.toOrientedRange()];\n            if (initialRange) {\n                editor.removeSelectionMarker(initialRange);\n                selection.toSingleRange(initialRange);\n            }\n            for (var i = 0; i < rectSel.length; i++)\n                selection.addRange(rectSel[i]);\n            editor.inVirtualSelectionMode = false;\n            editor.$mouseHandler.$clickSelection = null;\n        };\n\n        var onSelectionInterval = blockSelect;\n\n        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);\n        var timerId = setInterval(function() {onSelectionInterval();}, 20);\n\n        return e.preventDefault();\n    }\n}\n\n\nexports.onMouseDown = onMouseDown;\n\n});\n\nace.define(\"ace/commands/multi_select_commands\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\"], function(require, exports, module) {\nexports.defaultCommands = [{\n    name: \"addCursorAbove\",\n    description: \"Add cursor above\",\n    exec: function(editor) { editor.selectMoreLines(-1); },\n    bindKey: {win: \"Ctrl-Alt-Up\", mac: \"Ctrl-Alt-Up\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorBelow\",\n    description: \"Add cursor below\",\n    exec: function(editor) { editor.selectMoreLines(1); },\n    bindKey: {win: \"Ctrl-Alt-Down\", mac: \"Ctrl-Alt-Down\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorAboveSkipCurrent\",\n    description: \"Add cursor above (skip current)\",\n    exec: function(editor) { editor.selectMoreLines(-1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Up\", mac: \"Ctrl-Alt-Shift-Up\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"addCursorBelowSkipCurrent\",\n    description: \"Add cursor below (skip current)\",\n    exec: function(editor) { editor.selectMoreLines(1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Down\", mac: \"Ctrl-Alt-Shift-Down\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectMoreBefore\",\n    description: \"Select more before\",\n    exec: function(editor) { editor.selectMore(-1); },\n    bindKey: {win: \"Ctrl-Alt-Left\", mac: \"Ctrl-Alt-Left\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectMoreAfter\",\n    description: \"Select more after\",\n    exec: function(editor) { editor.selectMore(1); },\n    bindKey: {win: \"Ctrl-Alt-Right\", mac: \"Ctrl-Alt-Right\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectNextBefore\",\n    description: \"Select next before\",\n    exec: function(editor) { editor.selectMore(-1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Left\", mac: \"Ctrl-Alt-Shift-Left\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"selectNextAfter\",\n    description: \"Select next after\",\n    exec: function(editor) { editor.selectMore(1, true); },\n    bindKey: {win: \"Ctrl-Alt-Shift-Right\", mac: \"Ctrl-Alt-Shift-Right\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}, {\n    name: \"toggleSplitSelectionIntoLines\",\n    description: \"Split into lines\",\n    exec: function(editor) {\n        if (editor.multiSelect.rangeCount > 1)\n            editor.multiSelect.joinSelections();\n        else\n            editor.multiSelect.splitIntoLines();\n    },\n    bindKey: {win: \"Ctrl-Alt-L\", mac: \"Ctrl-Alt-L\"},\n    readOnly: true\n}, {\n    name: \"splitSelectionIntoLines\",\n    description: \"Split into lines\",\n    exec: function(editor) { editor.multiSelect.splitIntoLines(); },\n    readOnly: true\n}, {\n    name: \"alignCursors\",\n    description: \"Align cursors\",\n    exec: function(editor) { editor.alignCursors(); },\n    bindKey: {win: \"Ctrl-Alt-A\", mac: \"Ctrl-Alt-A\"},\n    scrollIntoView: \"cursor\"\n}, {\n    name: \"findAll\",\n    description: \"Find all\",\n    exec: function(editor) { editor.findAll(); },\n    bindKey: {win: \"Ctrl-Alt-K\", mac: \"Ctrl-Alt-G\"},\n    scrollIntoView: \"cursor\",\n    readOnly: true\n}];\nexports.multiSelectCommands = [{\n    name: \"singleSelection\",\n    description: \"Single selection\",\n    bindKey: \"esc\",\n    exec: function(editor) { editor.exitMultiSelectMode(); },\n    scrollIntoView: \"cursor\",\n    readOnly: true,\n    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}\n}];\n\nvar HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\nexports.keyboardHandler = new HashHandler(exports.multiSelectCommands);\n\n});\n\nace.define(\"ace/multi_select\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/range\",\"ace/selection\",\"ace/mouse/multi_select_handler\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/commands/multi_select_commands\",\"ace/search\",\"ace/edit_session\",\"ace/editor\",\"ace/config\"], function(require, exports, module) {\n\nvar RangeList = require(\"./range_list\").RangeList;\nvar Range = require(\"./range\").Range;\nvar Selection = require(\"./selection\").Selection;\nvar onMouseDown = require(\"./mouse/multi_select_handler\").onMouseDown;\nvar event = require(\"./lib/event\");\nvar lang = require(\"./lib/lang\");\nvar commands = require(\"./commands/multi_select_commands\");\nexports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);\nvar Search = require(\"./search\").Search;\nvar search = new Search();\n\nfunction find(session, needle, dir) {\n    search.$options.wrap = true;\n    search.$options.needle = needle;\n    search.$options.backwards = dir == -1;\n    return search.find(session);\n}\nvar EditSession = require(\"./edit_session\").EditSession;\n(function() {\n    this.getSelectionMarkers = function() {\n        return this.$selectionMarkers;\n    };\n}).call(EditSession.prototype);\n(function() {\n    this.ranges = null;\n    this.rangeList = null;\n    this.addRange = function(range, $blockChangeEvents) {\n        if (!range)\n            return;\n\n        if (!this.inMultiSelectMode && this.rangeCount === 0) {\n            var oldRange = this.toOrientedRange();\n            this.rangeList.add(oldRange);\n            this.rangeList.add(range);\n            if (this.rangeList.ranges.length != 2) {\n                this.rangeList.removeAll();\n                return $blockChangeEvents || this.fromOrientedRange(range);\n            }\n            this.rangeList.removeAll();\n            this.rangeList.add(oldRange);\n            this.$onAddRange(oldRange);\n        }\n\n        if (!range.cursor)\n            range.cursor = range.end;\n\n        var removed = this.rangeList.add(range);\n\n        this.$onAddRange(range);\n\n        if (removed.length)\n            this.$onRemoveRange(removed);\n\n        if (this.rangeCount > 1 && !this.inMultiSelectMode) {\n            this._signal(\"multiSelect\");\n            this.inMultiSelectMode = true;\n            this.session.$undoSelect = false;\n            this.rangeList.attach(this.session);\n        }\n\n        return $blockChangeEvents || this.fromOrientedRange(range);\n    };\n    this.toSingleRange = function(range) {\n        range = range || this.ranges[0];\n        var removed = this.rangeList.removeAll();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n\n        range && this.fromOrientedRange(range);\n    };\n    this.substractPoint = function(pos) {\n        var removed = this.rangeList.substractPoint(pos);\n        if (removed) {\n            this.$onRemoveRange(removed);\n            return removed[0];\n        }\n    };\n    this.mergeOverlappingRanges = function() {\n        var removed = this.rangeList.merge();\n        if (removed.length)\n            this.$onRemoveRange(removed);\n    };\n\n    this.$onAddRange = function(range) {\n        this.rangeCount = this.rangeList.ranges.length;\n        this.ranges.unshift(range);\n        this._signal(\"addRange\", {range: range});\n    };\n\n    this.$onRemoveRange = function(removed) {\n        this.rangeCount = this.rangeList.ranges.length;\n        if (this.rangeCount == 1 && this.inMultiSelectMode) {\n            var lastRange = this.rangeList.ranges.pop();\n            removed.push(lastRange);\n            this.rangeCount = 0;\n        }\n\n        for (var i = removed.length; i--; ) {\n            var index = this.ranges.indexOf(removed[i]);\n            this.ranges.splice(index, 1);\n        }\n\n        this._signal(\"removeRange\", {ranges: removed});\n\n        if (this.rangeCount === 0 && this.inMultiSelectMode) {\n            this.inMultiSelectMode = false;\n            this._signal(\"singleSelect\");\n            this.session.$undoSelect = true;\n            this.rangeList.detach(this.session);\n        }\n\n        lastRange = lastRange || this.ranges[0];\n        if (lastRange && !lastRange.isEqual(this.getRange()))\n            this.fromOrientedRange(lastRange);\n    };\n    this.$initRangeList = function() {\n        if (this.rangeList)\n            return;\n\n        this.rangeList = new RangeList();\n        this.ranges = [];\n        this.rangeCount = 0;\n    };\n    this.getAllRanges = function() {\n        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];\n    };\n    this.splitIntoLines = function () {\n        var ranges = this.ranges.length ? this.ranges : [this.getRange()];\n        var newRanges = [];\n        for (var i = 0; i < ranges.length; i++) {\n            var range = ranges[i];\n            var row = range.start.row;\n            var endRow = range.end.row;\n            if (row === endRow) {\n                newRanges.push(range.clone());\n            } else {\n                newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));\n                while (++row < endRow)\n                    newRanges.push(this.getLineRange(row, true));\n                newRanges.push(new Range(endRow, 0, endRow, range.end.column));\n            }\n            if (i == 0 && !this.isBackwards())\n                newRanges = newRanges.reverse();\n        }\n        this.toSingleRange();\n        for (var i = newRanges.length; i--;)\n            this.addRange(newRanges[i]);\n    };\n    \n    this.joinSelections = function () {\n        var ranges = this.rangeList.ranges;\n        var lastRange = ranges[ranges.length - 1];\n        var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n        this.toSingleRange();\n        this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n    };\n    this.toggleBlockSelection = function () {\n        if (this.rangeCount > 1) {\n            var ranges = this.rangeList.ranges;\n            var lastRange = ranges[ranges.length - 1];\n            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n            this.toSingleRange();\n            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n        } else {\n            var cursor = this.session.documentToScreenPosition(this.cursor);\n            var anchor = this.session.documentToScreenPosition(this.anchor);\n\n            var rectSel = this.rectangularRangeBlock(cursor, anchor);\n            rectSel.forEach(this.addRange, this);\n        }\n    };\n    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {\n        var rectSel = [];\n\n        var xBackwards = screenCursor.column < screenAnchor.column;\n        if (xBackwards) {\n            var startColumn = screenCursor.column;\n            var endColumn = screenAnchor.column;\n            var startOffsetX = screenCursor.offsetX;\n            var endOffsetX = screenAnchor.offsetX;\n        } else {\n            var startColumn = screenAnchor.column;\n            var endColumn = screenCursor.column;\n            var startOffsetX = screenAnchor.offsetX;\n            var endOffsetX = screenCursor.offsetX;\n        }\n\n        var yBackwards = screenCursor.row < screenAnchor.row;\n        if (yBackwards) {\n            var startRow = screenCursor.row;\n            var endRow = screenAnchor.row;\n        } else {\n            var startRow = screenAnchor.row;\n            var endRow = screenCursor.row;\n        }\n\n        if (startColumn < 0)\n            startColumn = 0;\n        if (startRow < 0)\n            startRow = 0;\n\n        if (startRow == endRow)\n            includeEmptyLines = true;\n\n        var docEnd;\n        for (var row = startRow; row <= endRow; row++) {\n            var range = Range.fromPoints(\n                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),\n                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)\n            );\n            if (range.isEmpty()) {\n                if (docEnd && isSamePoint(range.end, docEnd))\n                    break;\n                docEnd = range.end;\n            }\n            range.cursor = xBackwards ? range.start : range.end;\n            rectSel.push(range);\n        }\n\n        if (yBackwards)\n            rectSel.reverse();\n\n        if (!includeEmptyLines) {\n            var end = rectSel.length - 1;\n            while (rectSel[end].isEmpty() && end > 0)\n                end--;\n            if (end > 0) {\n                var start = 0;\n                while (rectSel[start].isEmpty())\n                    start++;\n            }\n            for (var i = end; i >= start; i--) {\n                if (rectSel[i].isEmpty())\n                    rectSel.splice(i, 1);\n            }\n        }\n\n        return rectSel;\n    };\n}).call(Selection.prototype);\nvar Editor = require(\"./editor\").Editor;\n(function() {\n    this.updateSelectionMarkers = function() {\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n    this.addSelectionMarker = function(orientedRange) {\n        if (!orientedRange.cursor)\n            orientedRange.cursor = orientedRange.end;\n\n        var style = this.getSelectionStyle();\n        orientedRange.marker = this.session.addMarker(orientedRange, \"ace_selection\", style);\n\n        this.session.$selectionMarkers.push(orientedRange);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n        return orientedRange;\n    };\n    this.removeSelectionMarker = function(range) {\n        if (!range.marker)\n            return;\n        this.session.removeMarker(range.marker);\n        var index = this.session.$selectionMarkers.indexOf(range);\n        if (index != -1)\n            this.session.$selectionMarkers.splice(index, 1);\n        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n    };\n\n    this.removeSelectionMarkers = function(ranges) {\n        var markerList = this.session.$selectionMarkers;\n        for (var i = ranges.length; i--; ) {\n            var range = ranges[i];\n            if (!range.marker)\n                continue;\n            this.session.removeMarker(range.marker);\n            var index = markerList.indexOf(range);\n            if (index != -1)\n                markerList.splice(index, 1);\n        }\n        this.session.selectionMarkerCount = markerList.length;\n    };\n\n    this.$onAddRange = function(e) {\n        this.addSelectionMarker(e.range);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onRemoveRange = function(e) {\n        this.removeSelectionMarkers(e.ranges);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onMultiSelect = function(e) {\n        if (this.inMultiSelectMode)\n            return;\n        this.inMultiSelectMode = true;\n\n        this.setStyle(\"ace_multiselect\");\n        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);\n        this.commands.setDefaultHandler(\"exec\", this.$onMultiSelectExec);\n\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n    };\n\n    this.$onSingleSelect = function(e) {\n        if (this.session.multiSelect.inVirtualMode)\n            return;\n        this.inMultiSelectMode = false;\n\n        this.unsetStyle(\"ace_multiselect\");\n        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);\n\n        this.commands.removeDefaultHandler(\"exec\", this.$onMultiSelectExec);\n        this.renderer.updateCursor();\n        this.renderer.updateBackMarkers();\n        this._emit(\"changeSelection\");\n    };\n\n    this.$onMultiSelectExec = function(e) {\n        var command = e.command;\n        var editor = e.editor;\n        if (!editor.multiSelect)\n            return;\n        if (!command.multiSelectAction) {\n            var result = command.exec(editor, e.args || {});\n            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());\n            editor.multiSelect.mergeOverlappingRanges();\n        } else if (command.multiSelectAction == \"forEach\") {\n            result = editor.forEachSelection(command, e.args);\n        } else if (command.multiSelectAction == \"forEachLine\") {\n            result = editor.forEachSelection(command, e.args, true);\n        } else if (command.multiSelectAction == \"single\") {\n            editor.exitMultiSelectMode();\n            result = command.exec(editor, e.args || {});\n        } else {\n            result = command.multiSelectAction(editor, e.args || {});\n        }\n        return result;\n    }; \n    this.forEachSelection = function(cmd, args, options) {\n        if (this.inVirtualSelectionMode)\n            return;\n        var keepOrder = options && options.keepOrder;\n        var $byLines = options == true || options && options.$byLines;\n        var session = this.session;\n        var selection = this.selection;\n        var rangeList = selection.rangeList;\n        var ranges = (keepOrder ? selection : rangeList).ranges;\n        var result;\n        \n        if (!ranges.length)\n            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n        \n        var reg = selection._eventRegistry;\n        selection._eventRegistry = {};\n\n        var tmpSel = new Selection(session);\n        this.inVirtualSelectionMode = true;\n        for (var i = ranges.length; i--;) {\n            if ($byLines) {\n                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)\n                    i--;\n            }\n            tmpSel.fromOrientedRange(ranges[i]);\n            tmpSel.index = i;\n            this.selection = session.selection = tmpSel;\n            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n            if (!result && cmdResult !== undefined)\n                result = cmdResult;\n            tmpSel.toOrientedRange(ranges[i]);\n        }\n        tmpSel.detach();\n\n        this.selection = session.selection = selection;\n        this.inVirtualSelectionMode = false;\n        selection._eventRegistry = reg;\n        selection.mergeOverlappingRanges();\n        if (selection.ranges[0])\n            selection.fromOrientedRange(selection.ranges[0]);\n        \n        var anim = this.renderer.$scrollAnimation;\n        this.onCursorChange();\n        this.onSelectionChange();\n        if (anim && anim.from == anim.to)\n            this.renderer.animateScrolling(anim.from);\n        \n        return result;\n    };\n    this.exitMultiSelectMode = function() {\n        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n            return;\n        this.multiSelect.toSingleRange();\n    };\n\n    this.getSelectedText = function() {\n        var text = \"\";\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var ranges = this.multiSelect.rangeList.ranges;\n            var buf = [];\n            for (var i = 0; i < ranges.length; i++) {\n                buf.push(this.session.getTextRange(ranges[i]));\n            }\n            var nl = this.session.getDocument().getNewLineCharacter();\n            text = buf.join(nl);\n            if (text.length == (buf.length - 1) * nl.length)\n                text = \"\";\n        } else if (!this.selection.isEmpty()) {\n            text = this.session.getTextRange(this.getSelectionRange());\n        }\n        return text;\n    };\n    \n    this.$checkMultiselectChange = function(e, anchor) {\n        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n            var range = this.multiSelect.ranges[0];\n            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)\n                return;\n            var pos = anchor == this.multiSelect.anchor\n                ? range.cursor == range.start ? range.end : range.start\n                : range.cursor;\n            if (pos.row != anchor.row \n                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)\n                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());\n            else\n                this.multiSelect.mergeOverlappingRanges();\n        }\n    };\n    this.findAll = function(needle, options, additive) {\n        options = options || {};\n        options.needle = needle || options.needle;\n        if (options.needle == undefined) {\n            var range = this.selection.isEmpty()\n                ? this.selection.getWordRange()\n                : this.selection.getRange();\n            options.needle = this.session.getTextRange(range);\n        }    \n        this.$search.set(options);\n        \n        var ranges = this.$search.findAll(this.session);\n        if (!ranges.length)\n            return 0;\n\n        var selection = this.multiSelect;\n\n        if (!additive)\n            selection.toSingleRange(ranges[0]);\n\n        for (var i = ranges.length; i--; )\n            selection.addRange(ranges[i], true);\n        if (range && selection.rangeList.rangeAtPoint(range.start))\n            selection.addRange(range, true);\n        \n        return ranges.length;\n    };\n    this.selectMoreLines = function(dir, skip) {\n        var range = this.selection.toOrientedRange();\n        var isBackwards = range.cursor == range.end;\n\n        var screenLead = this.session.documentToScreenPosition(range.cursor);\n        if (this.selection.$desiredColumn)\n            screenLead.column = this.selection.$desiredColumn;\n\n        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);\n\n        if (!range.isEmpty()) {\n            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);\n            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);\n        } else {\n            var anchor = lead;\n        }\n\n        if (isBackwards) {\n            var newRange = Range.fromPoints(lead, anchor);\n            newRange.cursor = newRange.start;\n        } else {\n            var newRange = Range.fromPoints(anchor, lead);\n            newRange.cursor = newRange.end;\n        }\n\n        newRange.desiredColumn = screenLead.column;\n        if (!this.selection.inMultiSelectMode) {\n            this.selection.addRange(range);\n        } else {\n            if (skip)\n                var toRemove = range.cursor;\n        }\n\n        this.selection.addRange(newRange);\n        if (toRemove)\n            this.selection.substractPoint(toRemove);\n    };\n    this.transposeSelections = function(dir) {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var all = sel.ranges;\n\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            if (range.isEmpty()) {\n                var tmp = session.getWordRange(range.start.row, range.start.column);\n                range.start.row = tmp.start.row;\n                range.start.column = tmp.start.column;\n                range.end.row = tmp.end.row;\n                range.end.column = tmp.end.column;\n            }\n        }\n        sel.mergeOverlappingRanges();\n\n        var words = [];\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            words.unshift(session.getTextRange(range));\n        }\n\n        if (dir < 0)\n            words.unshift(words.pop());\n        else\n            words.push(words.shift());\n\n        for (var i = all.length; i--; ) {\n            var range = all[i];\n            var tmp = range.clone();\n            session.replace(range, words[i]);\n            range.start.row = tmp.start.row;\n            range.start.column = tmp.start.column;\n        }\n        sel.fromOrientedRange(sel.ranges[0]);\n    };\n    this.selectMore = function(dir, skip, stopAtFirst) {\n        var session = this.session;\n        var sel = session.multiSelect;\n\n        var range = sel.toOrientedRange();\n        if (range.isEmpty()) {\n            range = session.getWordRange(range.start.row, range.start.column);\n            range.cursor = dir == -1 ? range.start : range.end;\n            this.multiSelect.addRange(range);\n            if (stopAtFirst)\n                return;\n        }\n        var needle = session.getTextRange(range);\n\n        var newRange = find(session, needle, dir);\n        if (newRange) {\n            newRange.cursor = dir == -1 ? newRange.start : newRange.end;\n            this.session.unfold(newRange);\n            this.multiSelect.addRange(newRange);\n            this.renderer.scrollCursorIntoView(null, 0.5);\n        }\n        if (skip)\n            this.multiSelect.substractPoint(range.cursor);\n    };\n    this.alignCursors = function() {\n        var session = this.session;\n        var sel = session.multiSelect;\n        var ranges = sel.ranges;\n        var row = -1;\n        var sameRowRanges = ranges.filter(function(r) {\n            if (r.cursor.row == row)\n                return true;\n            row = r.cursor.row;\n        });\n        \n        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {\n            var range = this.selection.getRange();\n            var fr = range.start.row, lr = range.end.row;\n            var guessRange = fr == lr;\n            if (guessRange) {\n                var max = this.session.getLength();\n                var line;\n                do {\n                    line = this.session.getLine(lr);\n                } while (/[=:]/.test(line) && ++lr < max);\n                do {\n                    line = this.session.getLine(fr);\n                } while (/[=:]/.test(line) && --fr > 0);\n                \n                if (fr < 0) fr = 0;\n                if (lr >= max) lr = max - 1;\n            }\n            var lines = this.session.removeFullLines(fr, lr);\n            lines = this.$reAlignText(lines, guessRange);\n            this.session.insert({row: fr, column: 0}, lines.join(\"\\n\") + \"\\n\");\n            if (!guessRange) {\n                range.start.column = 0;\n                range.end.column = lines[lines.length - 1].length;\n            }\n            this.selection.setRange(range);\n        } else {\n            sameRowRanges.forEach(function(r) {\n                sel.substractPoint(r.cursor);\n            });\n\n            var maxCol = 0;\n            var minSpace = Infinity;\n            var spaceOffsets = ranges.map(function(r) {\n                var p = r.cursor;\n                var line = session.getLine(p.row);\n                var spaceOffset = line.substr(p.column).search(/\\S/g);\n                if (spaceOffset == -1)\n                    spaceOffset = 0;\n\n                if (p.column > maxCol)\n                    maxCol = p.column;\n                if (spaceOffset < minSpace)\n                    minSpace = spaceOffset;\n                return spaceOffset;\n            });\n            ranges.forEach(function(r, i) {\n                var p = r.cursor;\n                var l = maxCol - p.column;\n                var d = spaceOffsets[i] - minSpace;\n                if (l > d)\n                    session.insert(p, lang.stringRepeat(\" \", l - d));\n                else\n                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));\n\n                r.start.column = r.end.column = maxCol;\n                r.start.row = r.end.row = p.row;\n                r.cursor = r.end;\n            });\n            sel.fromOrientedRange(ranges[0]);\n            this.renderer.updateCursor();\n            this.renderer.updateBackMarkers();\n        }\n    };\n\n    this.$reAlignText = function(lines, forceLeft) {\n        var isLeftAligned = true, isRightAligned = true;\n        var startW, textW, endW;\n\n        return lines.map(function(line) {\n            var m = line.match(/(\\s*)(.*?)(\\s*)([=:].*)/);\n            if (!m)\n                return [line];\n\n            if (startW == null) {\n                startW = m[1].length;\n                textW = m[2].length;\n                endW = m[3].length;\n                return m;\n            }\n\n            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)\n                isRightAligned = false;\n            if (startW != m[1].length)\n                isLeftAligned = false;\n\n            if (startW > m[1].length)\n                startW = m[1].length;\n            if (textW < m[2].length)\n                textW = m[2].length;\n            if (endW > m[3].length)\n                endW = m[3].length;\n\n            return m;\n        }).map(forceLeft ? alignLeft :\n            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);\n\n        function spaces(n) {\n            return lang.stringRepeat(\" \", n);\n        }\n\n        function alignLeft(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(textW - m[2].length + endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function alignRight(m) {\n            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n        function unAlign(m) {\n            return !m[2] ? m[0] : spaces(startW) + m[2]\n                + spaces(endW)\n                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n        }\n    };\n}).call(Editor.prototype);\n\n\nfunction isSamePoint(p1, p2) {\n    return p1.row == p2.row && p1.column == p2.column;\n}\nexports.onSessionChange = function(e) {\n    var session = e.session;\n    if (session && !session.multiSelect) {\n        session.$selectionMarkers = [];\n        session.selection.$initRangeList();\n        session.multiSelect = session.selection;\n    }\n    this.multiSelect = session && session.multiSelect;\n\n    var oldSession = e.oldSession;\n    if (oldSession) {\n        oldSession.multiSelect.off(\"addRange\", this.$onAddRange);\n        oldSession.multiSelect.off(\"removeRange\", this.$onRemoveRange);\n        oldSession.multiSelect.off(\"multiSelect\", this.$onMultiSelect);\n        oldSession.multiSelect.off(\"singleSelect\", this.$onSingleSelect);\n        oldSession.multiSelect.lead.off(\"change\", this.$checkMultiselectChange);\n        oldSession.multiSelect.anchor.off(\"change\", this.$checkMultiselectChange);\n    }\n\n    if (session) {\n        session.multiSelect.on(\"addRange\", this.$onAddRange);\n        session.multiSelect.on(\"removeRange\", this.$onRemoveRange);\n        session.multiSelect.on(\"multiSelect\", this.$onMultiSelect);\n        session.multiSelect.on(\"singleSelect\", this.$onSingleSelect);\n        session.multiSelect.lead.on(\"change\", this.$checkMultiselectChange);\n        session.multiSelect.anchor.on(\"change\", this.$checkMultiselectChange);\n    }\n\n    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {\n        if (session.selection.inMultiSelectMode)\n            this.$onMultiSelect();\n        else\n            this.$onSingleSelect();\n    }\n};\nfunction MultiSelect(editor) {\n    if (editor.$multiselectOnSessionChange)\n        return;\n    editor.$onAddRange = editor.$onAddRange.bind(editor);\n    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);\n    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);\n    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);\n    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);\n    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);\n\n    editor.$multiselectOnSessionChange(editor);\n    editor.on(\"changeSession\", editor.$multiselectOnSessionChange);\n\n    editor.on(\"mousedown\", onMouseDown);\n    editor.commands.addCommands(commands.defaultCommands);\n\n    addAltCursorListeners(editor);\n}\n\nfunction addAltCursorListeners(editor){\n    if (!editor.textInput) return;\n    var el = editor.textInput.getElement();\n    var altCursor = false;\n    event.addListener(el, \"keydown\", function(e) {\n        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);\n        if (editor.$blockSelectEnabled && altDown) {\n            if (!altCursor) {\n                editor.renderer.setMouseCursor(\"crosshair\");\n                altCursor = true;\n            }\n        } else if (altCursor) {\n            reset();\n        }\n    });\n\n    event.addListener(el, \"keyup\", reset);\n    event.addListener(el, \"blur\", reset);\n    function reset(e) {\n        if (altCursor) {\n            editor.renderer.setMouseCursor(\"\");\n            altCursor = false;\n        }\n    }\n}\n\nexports.MultiSelect = MultiSelect;\n\n\nrequire(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n    enableMultiselect: {\n        set: function(val) {\n            MultiSelect(this);\n            if (val) {\n                this.on(\"changeSession\", this.$multiselectOnSessionChange);\n                this.on(\"mousedown\", onMouseDown);\n            } else {\n                this.off(\"changeSession\", this.$multiselectOnSessionChange);\n                this.off(\"mousedown\", onMouseDown);\n            }\n        },\n        value: true\n    },\n    enableBlockSelect: {\n        set: function(val) {\n            this.$blockSelectEnabled = val;\n        },\n        value: true\n    }\n});\n\n\n\n});\n\nace.define(\"ace/mode/folding/fold_mode\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\n\n(function() {\n\n    this.foldingStartMarker = null;\n    this.foldingStopMarker = null;\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (this.foldingStartMarker.test(line))\n            return \"start\";\n        if (foldStyle == \"markbeginend\"\n                && this.foldingStopMarker\n                && this.foldingStopMarker.test(line))\n            return \"end\";\n        return \"\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        return null;\n    };\n\n    this.indentationBlock = function(session, row, column) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1)\n            return;\n\n        var startColumn = column || line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            var level = session.getLine(row).search(re);\n\n            if (level == -1)\n                continue;\n\n            if (level <= startLevel) {\n                var token = session.getTokenAt(row, 0);\n                if (!token || token.type !== \"string\")\n                    break;\n            }\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n\n    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {\n        var start = {row: row, column: column + 1};\n        var end = session.$findClosingBracket(bracket, start, typeRe);\n        if (!end)\n            return;\n\n        var fw = session.foldWidgets[end.row];\n        if (fw == null)\n            fw = session.getFoldWidget(end.row);\n\n        if (fw == \"start\" && end.row > start.row) {\n            end.row --;\n            end.column = session.getLine(end.row).length;\n        }\n        return Range.fromPoints(start, end);\n    };\n\n    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {\n        var end = {row: row, column: column};\n        var start = session.$findOpeningBracket(bracket, end);\n\n        if (!start)\n            return;\n\n        start.column++;\n        end.column--;\n\n        return  Range.fromPoints(start, end);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/theme/textmate\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nexports.isDark = false;\nexports.cssClass = \"ace-tm\";\nexports.cssText = \".ace-tm .ace_gutter {\\\nbackground: #f0f0f0;\\\ncolor: #333;\\\n}\\\n.ace-tm .ace_print-margin {\\\nwidth: 1px;\\\nbackground: #e8e8e8;\\\n}\\\n.ace-tm .ace_fold {\\\nbackground-color: #6B72E6;\\\n}\\\n.ace-tm {\\\nbackground-color: #FFFFFF;\\\ncolor: black;\\\n}\\\n.ace-tm .ace_cursor {\\\ncolor: black;\\\n}\\\n.ace-tm .ace_invisible {\\\ncolor: rgb(191, 191, 191);\\\n}\\\n.ace-tm .ace_storage,\\\n.ace-tm .ace_keyword {\\\ncolor: blue;\\\n}\\\n.ace-tm .ace_constant {\\\ncolor: rgb(197, 6, 11);\\\n}\\\n.ace-tm .ace_constant.ace_buildin {\\\ncolor: rgb(88, 72, 246);\\\n}\\\n.ace-tm .ace_constant.ace_language {\\\ncolor: rgb(88, 92, 246);\\\n}\\\n.ace-tm .ace_constant.ace_library {\\\ncolor: rgb(6, 150, 14);\\\n}\\\n.ace-tm .ace_invalid {\\\nbackground-color: rgba(255, 0, 0, 0.1);\\\ncolor: red;\\\n}\\\n.ace-tm .ace_support.ace_function {\\\ncolor: rgb(60, 76, 114);\\\n}\\\n.ace-tm .ace_support.ace_constant {\\\ncolor: rgb(6, 150, 14);\\\n}\\\n.ace-tm .ace_support.ace_type,\\\n.ace-tm .ace_support.ace_class {\\\ncolor: rgb(109, 121, 222);\\\n}\\\n.ace-tm .ace_keyword.ace_operator {\\\ncolor: rgb(104, 118, 135);\\\n}\\\n.ace-tm .ace_string {\\\ncolor: rgb(3, 106, 7);\\\n}\\\n.ace-tm .ace_comment {\\\ncolor: rgb(76, 136, 107);\\\n}\\\n.ace-tm .ace_comment.ace_doc {\\\ncolor: rgb(0, 102, 255);\\\n}\\\n.ace-tm .ace_comment.ace_doc.ace_tag {\\\ncolor: rgb(128, 159, 191);\\\n}\\\n.ace-tm .ace_constant.ace_numeric {\\\ncolor: rgb(0, 0, 205);\\\n}\\\n.ace-tm .ace_variable {\\\ncolor: rgb(49, 132, 149);\\\n}\\\n.ace-tm .ace_xml-pe {\\\ncolor: rgb(104, 104, 91);\\\n}\\\n.ace-tm .ace_entity.ace_name.ace_function {\\\ncolor: #0000A2;\\\n}\\\n.ace-tm .ace_heading {\\\ncolor: rgb(12, 7, 255);\\\n}\\\n.ace-tm .ace_list {\\\ncolor:rgb(185, 6, 144);\\\n}\\\n.ace-tm .ace_meta.ace_tag {\\\ncolor:rgb(0, 22, 142);\\\n}\\\n.ace-tm .ace_string.ace_regex {\\\ncolor: rgb(255, 0, 0)\\\n}\\\n.ace-tm .ace_marker-layer .ace_selection {\\\nbackground: rgb(181, 213, 255);\\\n}\\\n.ace-tm.ace_multiselect .ace_selection.ace_start {\\\nbox-shadow: 0 0 3px 0px white;\\\n}\\\n.ace-tm .ace_marker-layer .ace_step {\\\nbackground: rgb(252, 255, 0);\\\n}\\\n.ace-tm .ace_marker-layer .ace_stack {\\\nbackground: rgb(164, 229, 101);\\\n}\\\n.ace-tm .ace_marker-layer .ace_bracket {\\\nmargin: -1px 0 0 -1px;\\\nborder: 1px solid rgb(192, 192, 192);\\\n}\\\n.ace-tm .ace_marker-layer .ace_active-line {\\\nbackground: rgba(0, 0, 0, 0.07);\\\n}\\\n.ace-tm .ace_gutter-active-line {\\\nbackground-color : #dcdcdc;\\\n}\\\n.ace-tm .ace_marker-layer .ace_selected-word {\\\nbackground: rgb(250, 250, 255);\\\nborder: 1px solid rgb(200, 200, 250);\\\n}\\\n.ace-tm .ace_indent-guide {\\\nbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y;\\\n}\\\n\";\nexports.$id = \"ace/theme/textmate\";\n\nvar dom = require(\"../lib/dom\");\ndom.importCssString(exports.cssText, exports.cssClass);\n});\n\nace.define(\"ace/line_widgets\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar dom = require(\"./lib/dom\");\n\nfunction LineWidgets(session) {\n    this.session = session;\n    this.session.widgetManager = this;\n    this.session.getRowLength = this.getRowLength;\n    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;\n    this.updateOnChange = this.updateOnChange.bind(this);\n    this.renderWidgets = this.renderWidgets.bind(this);\n    this.measureWidgets = this.measureWidgets.bind(this);\n    this.session._changedWidgets = [];\n    this.$onChangeEditor = this.$onChangeEditor.bind(this);\n    \n    this.session.on(\"change\", this.updateOnChange);\n    this.session.on(\"changeFold\", this.updateOnFold);\n    this.session.on(\"changeEditor\", this.$onChangeEditor);\n}\n\n(function() {\n    this.getRowLength = function(row) {\n        var h;\n        if (this.lineWidgets)\n            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n        else \n            h = 0;\n        if (!this.$useWrapMode || !this.$wrapData[row]) {\n            return 1 + h;\n        } else {\n            return this.$wrapData[row].length + 1 + h;\n        }\n    };\n\n    this.$getWidgetScreenLength = function() {\n        var screenRows = 0;\n        this.lineWidgets.forEach(function(w){\n            if (w && w.rowCount && !w.hidden)\n                screenRows += w.rowCount;\n        });\n        return screenRows;\n    };    \n    \n    this.$onChangeEditor = function(e) {\n        this.attach(e.editor);\n    };\n    \n    this.attach = function(editor) {\n        if (editor  && editor.widgetManager && editor.widgetManager != this)\n            editor.widgetManager.detach();\n\n        if (this.editor == editor)\n            return;\n\n        this.detach();\n        this.editor = editor;\n        \n        if (editor) {\n            editor.widgetManager = this;\n            editor.renderer.on(\"beforeRender\", this.measureWidgets);\n            editor.renderer.on(\"afterRender\", this.renderWidgets);\n        }\n    };\n    this.detach = function(e) {\n        var editor = this.editor;\n        if (!editor)\n            return;\n        \n        this.editor = null;\n        editor.widgetManager = null;\n        \n        editor.renderer.off(\"beforeRender\", this.measureWidgets);\n        editor.renderer.off(\"afterRender\", this.renderWidgets);\n        var lineWidgets = this.session.lineWidgets;\n        lineWidgets && lineWidgets.forEach(function(w) {\n            if (w && w.el && w.el.parentNode) {\n                w._inDocument = false;\n                w.el.parentNode.removeChild(w.el);\n            }\n        });\n    };\n\n    this.updateOnFold = function(e, session) {\n        var lineWidgets = session.lineWidgets;\n        if (!lineWidgets || !e.action)\n            return;\n        var fold = e.data;\n        var start = fold.start.row;\n        var end = fold.end.row;\n        var hide = e.action == \"add\";\n        for (var i = start + 1; i < end; i++) {\n            if (lineWidgets[i])\n                lineWidgets[i].hidden = hide;\n        }\n        if (lineWidgets[end]) {\n            if (hide) {\n                if (!lineWidgets[start])\n                    lineWidgets[start] = lineWidgets[end];\n                else\n                    lineWidgets[end].hidden = hide;\n            } else {\n                if (lineWidgets[start] == lineWidgets[end])\n                    lineWidgets[start] = undefined;\n                lineWidgets[end].hidden = hide;\n            }\n        }\n    };\n    \n    this.updateOnChange = function(delta) {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets) return;\n        \n        var startRow = delta.start.row;\n        var len = delta.end.row - startRow;\n\n        if (len === 0) {\n        } else if (delta.action == \"remove\") {\n            var removed = lineWidgets.splice(startRow + 1, len);\n            if (!lineWidgets[startRow] && removed[removed.length - 1]) {\n                lineWidgets[startRow] = removed.pop();\n            }\n            removed.forEach(function(w) {\n                w && this.removeLineWidget(w);\n            }, this);\n            this.$updateRows();\n        } else {\n            var args = new Array(len);\n            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {\n                if (delta.start.column > lineWidgets[startRow].column)\n                    startRow++;\n            }\n            args.unshift(startRow, 0);\n            lineWidgets.splice.apply(lineWidgets, args);\n            this.$updateRows();\n        }\n    };\n    \n    this.$updateRows = function() {\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets) return;\n        var noWidgets = true;\n        lineWidgets.forEach(function(w, i) {\n            if (w) {\n                noWidgets = false;\n                w.row = i;\n                while (w.$oldWidget) {\n                    w.$oldWidget.row = i;\n                    w = w.$oldWidget;\n                }\n            }\n        });\n        if (noWidgets)\n            this.session.lineWidgets = null;\n    };\n\n    this.$registerLineWidget = function(w) {\n        if (!this.session.lineWidgets)\n            this.session.lineWidgets = new Array(this.session.getLength());\n        \n        var old = this.session.lineWidgets[w.row];\n        if (old) {\n            w.$oldWidget = old;\n            if (old.el && old.el.parentNode) {\n                old.el.parentNode.removeChild(old.el);\n                old._inDocument = false;\n            }\n        }\n            \n        this.session.lineWidgets[w.row] = w;\n        return w;\n    };\n    \n    this.addLineWidget = function(w) {\n        this.$registerLineWidget(w);\n        w.session = this.session;\n        \n        if (!this.editor) return w;\n        \n        var renderer = this.editor.renderer;\n        if (w.html && !w.el) {\n            w.el = dom.createElement(\"div\");\n            w.el.innerHTML = w.html;\n        }\n        if (w.el) {\n            dom.addCssClass(w.el, \"ace_lineWidgetContainer\");\n            w.el.style.position = \"absolute\";\n            w.el.style.zIndex = 5;\n            renderer.container.appendChild(w.el);\n            w._inDocument = true;\n            \n            if (!w.coverGutter) {\n                w.el.style.zIndex = 3;\n            }\n            if (w.pixelHeight == null) {\n                w.pixelHeight = w.el.offsetHeight;\n            }\n        }\n        if (w.rowCount == null) {\n            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;\n        }\n        \n        var fold = this.session.getFoldAt(w.row, 0);\n        w.$fold = fold;\n        if (fold) {\n            var lineWidgets = this.session.lineWidgets;\n            if (w.row == fold.end.row && !lineWidgets[fold.start.row])\n                lineWidgets[fold.start.row] = w;\n            else\n                w.hidden = true;\n        }\n            \n        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n        \n        this.$updateRows();\n        this.renderWidgets(null, renderer);\n        this.onWidgetChanged(w);\n        return w;\n    };\n    \n    this.removeLineWidget = function(w) {\n        w._inDocument = false;\n        w.session = null;\n        if (w.el && w.el.parentNode)\n            w.el.parentNode.removeChild(w.el);\n        if (w.editor && w.editor.destroy) try {\n            w.editor.destroy();\n        } catch(e){}\n        if (this.session.lineWidgets) {\n            var w1 = this.session.lineWidgets[w.row];\n            if (w1 == w) {\n                this.session.lineWidgets[w.row] = w.$oldWidget;\n                if (w.$oldWidget)\n                    this.onWidgetChanged(w.$oldWidget);\n            } else {\n                while (w1) {\n                    if (w1.$oldWidget == w) {\n                        w1.$oldWidget = w.$oldWidget;\n                        break;\n                    }\n                    w1 = w1.$oldWidget;\n                }\n            }\n        }\n        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n        this.$updateRows();\n    };\n    \n    this.getWidgetsAtRow = function(row) {\n        var lineWidgets = this.session.lineWidgets;\n        var w = lineWidgets && lineWidgets[row];\n        var list = [];\n        while (w) {\n            list.push(w);\n            w = w.$oldWidget;\n        }\n        return list;\n    };\n    \n    this.onWidgetChanged = function(w) {\n        this.session._changedWidgets.push(w);\n        this.editor && this.editor.renderer.updateFull();\n    };\n    \n    this.measureWidgets = function(e, renderer) {\n        var changedWidgets = this.session._changedWidgets;\n        var config = renderer.layerConfig;\n        \n        if (!changedWidgets || !changedWidgets.length) return;\n        var min = Infinity;\n        for (var i = 0; i < changedWidgets.length; i++) {\n            var w = changedWidgets[i];\n            if (!w || !w.el) continue;\n            if (w.session != this.session) continue;\n            if (!w._inDocument) {\n                if (this.session.lineWidgets[w.row] != w)\n                    continue;\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            \n            w.h = w.el.offsetHeight;\n            \n            if (!w.fixedWidth) {\n                w.w = w.el.offsetWidth;\n                w.screenWidth = Math.ceil(w.w / config.characterWidth);\n            }\n            \n            var rowCount = w.h / config.lineHeight;\n            if (w.coverLine) {\n                rowCount -= this.session.getRowLineCount(w.row);\n                if (rowCount < 0)\n                    rowCount = 0;\n            }\n            if (w.rowCount != rowCount) {\n                w.rowCount = rowCount;\n                if (w.row < min)\n                    min = w.row;\n            }\n        }\n        if (min != Infinity) {\n            this.session._emit(\"changeFold\", {data:{start:{row: min}}});\n            this.session.lineWidgetWidth = null;\n        }\n        this.session._changedWidgets = [];\n    };\n    \n    this.renderWidgets = function(e, renderer) {\n        var config = renderer.layerConfig;\n        var lineWidgets = this.session.lineWidgets;\n        if (!lineWidgets)\n            return;\n        var first = Math.min(this.firstRow, config.firstRow);\n        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);\n        \n        while (first > 0 && !lineWidgets[first])\n            first--;\n        \n        this.firstRow = config.firstRow;\n        this.lastRow = config.lastRow;\n\n        renderer.$cursorLayer.config = config;\n        for (var i = first; i <= last; i++) {\n            var w = lineWidgets[i];\n            if (!w || !w.el) continue;\n            if (w.hidden) {\n                w.el.style.top = -100 - (w.pixelHeight || 0) + \"px\";\n                continue;\n            }\n            if (!w._inDocument) {\n                w._inDocument = true;\n                renderer.container.appendChild(w.el);\n            }\n            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;\n            if (!w.coverLine)\n                top += config.lineHeight * this.session.getRowLineCount(w.row);\n            w.el.style.top = top - config.offset + \"px\";\n            \n            var left = w.coverGutter ? 0 : renderer.gutterWidth;\n            if (!w.fixedWidth)\n                left -= renderer.scrollLeft;\n            w.el.style.left = left + \"px\";\n            \n            if (w.fullWidth && w.screenWidth) {\n                w.el.style.minWidth = config.width + 2 * config.padding + \"px\";\n            }\n            \n            if (w.fixedWidth) {\n                w.el.style.right = renderer.scrollBar.getWidth() + \"px\";\n            } else {\n                w.el.style.right = \"\";\n            }\n        }\n    };\n    \n}).call(LineWidgets.prototype);\n\n\nexports.LineWidgets = LineWidgets;\n\n});\n\nace.define(\"ace/ext/error_marker\",[\"require\",\"exports\",\"module\",\"ace/line_widgets\",\"ace/lib/dom\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\nvar LineWidgets = require(\"../line_widgets\").LineWidgets;\nvar dom = require(\"../lib/dom\");\nvar Range = require(\"../range\").Range;\n\nfunction binarySearch(array, needle, comparator) {\n    var first = 0;\n    var last = array.length - 1;\n\n    while (first <= last) {\n        var mid = (first + last) >> 1;\n        var c = comparator(needle, array[mid]);\n        if (c > 0)\n            first = mid + 1;\n        else if (c < 0)\n            last = mid - 1;\n        else\n            return mid;\n    }\n    return -(first + 1);\n}\n\nfunction findAnnotations(session, row, dir) {\n    var annotations = session.getAnnotations().sort(Range.comparePoints);\n    if (!annotations.length)\n        return;\n    \n    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);\n    if (i < 0)\n        i = -i - 1;\n    \n    if (i >= annotations.length)\n        i = dir > 0 ? 0 : annotations.length - 1;\n    else if (i === 0 && dir < 0)\n        i = annotations.length - 1;\n    \n    var annotation = annotations[i];\n    if (!annotation || !dir)\n        return;\n\n    if (annotation.row === row) {\n        do {\n            annotation = annotations[i += dir];\n        } while (annotation && annotation.row === row);\n        if (!annotation)\n            return annotations.slice();\n    }\n    \n    \n    var matched = [];\n    row = annotation.row;\n    do {\n        matched[dir < 0 ? \"unshift\" : \"push\"](annotation);\n        annotation = annotations[i += dir];\n    } while (annotation && annotation.row == row);\n    return matched.length && matched;\n}\n\nexports.showErrorMarker = function(editor, dir) {\n    var session = editor.session;\n    if (!session.widgetManager) {\n        session.widgetManager = new LineWidgets(session);\n        session.widgetManager.attach(editor);\n    }\n    \n    var pos = editor.getCursorPosition();\n    var row = pos.row;\n    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {\n        return w.type == \"errorMarker\";\n    })[0];\n    if (oldWidget) {\n        oldWidget.destroy();\n    } else {\n        row -= dir;\n    }\n    var annotations = findAnnotations(session, row, dir);\n    var gutterAnno;\n    if (annotations) {\n        var annotation = annotations[0];\n        pos.column = (annotation.pos && typeof annotation.column != \"number\"\n            ? annotation.pos.sc\n            : annotation.column) || 0;\n        pos.row = annotation.row;\n        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];\n    } else if (oldWidget) {\n        return;\n    } else {\n        gutterAnno = {\n            text: [\"Looks good!\"],\n            className: \"ace_ok\"\n        };\n    }\n    editor.session.unfold(pos.row);\n    editor.selection.moveToPosition(pos);\n    \n    var w = {\n        row: pos.row, \n        fixedWidth: true,\n        coverGutter: true,\n        el: dom.createElement(\"div\"),\n        type: \"errorMarker\"\n    };\n    var el = w.el.appendChild(dom.createElement(\"div\"));\n    var arrow = w.el.appendChild(dom.createElement(\"div\"));\n    arrow.className = \"error_widget_arrow \" + gutterAnno.className;\n    \n    var left = editor.renderer.$cursorLayer\n        .getPixelPosition(pos).left;\n    arrow.style.left = left + editor.renderer.gutterWidth - 5 + \"px\";\n    \n    w.el.className = \"error_widget_wrapper\";\n    el.className = \"error_widget \" + gutterAnno.className;\n    el.innerHTML = gutterAnno.text.join(\"<br>\");\n    \n    el.appendChild(dom.createElement(\"div\"));\n    \n    var kb = function(_, hashId, keyString) {\n        if (hashId === 0 && (keyString === \"esc\" || keyString === \"return\")) {\n            w.destroy();\n            return {command: \"null\"};\n        }\n    };\n    \n    w.destroy = function() {\n        if (editor.$mouseHandler.isMousePressed)\n            return;\n        editor.keyBinding.removeKeyboardHandler(kb);\n        session.widgetManager.removeLineWidget(w);\n        editor.off(\"changeSelection\", w.destroy);\n        editor.off(\"changeSession\", w.destroy);\n        editor.off(\"mouseup\", w.destroy);\n        editor.off(\"change\", w.destroy);\n    };\n    \n    editor.keyBinding.addKeyboardHandler(kb);\n    editor.on(\"changeSelection\", w.destroy);\n    editor.on(\"changeSession\", w.destroy);\n    editor.on(\"mouseup\", w.destroy);\n    editor.on(\"change\", w.destroy);\n    \n    editor.session.widgetManager.addLineWidget(w);\n    \n    w.el.onmousedown = editor.focus.bind(editor);\n    \n    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});\n};\n\n\ndom.importCssString(\"\\\n    .error_widget_wrapper {\\\n        background: inherit;\\\n        color: inherit;\\\n        border:none\\\n    }\\\n    .error_widget {\\\n        border-top: solid 2px;\\\n        border-bottom: solid 2px;\\\n        margin: 5px 0;\\\n        padding: 10px 40px;\\\n        white-space: pre-wrap;\\\n    }\\\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\\\n        border-color: #ff5a5a\\\n    }\\\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\\\n        border-color: #F1D817\\\n    }\\\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\\\n        border-color: #5a5a5a\\\n    }\\\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\\\n        border-color: #5aaa5a\\\n    }\\\n    .error_widget_arrow {\\\n        position: absolute;\\\n        border: solid 5px;\\\n        border-top-color: transparent!important;\\\n        border-right-color: transparent!important;\\\n        border-left-color: transparent!important;\\\n        top: -5px;\\\n    }\\\n\", \"\");\n\n});\n\nace.define(\"ace/ace\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/range\",\"ace/editor\",\"ace/edit_session\",\"ace/undomanager\",\"ace/virtual_renderer\",\"ace/worker/worker_client\",\"ace/keyboard/hash_handler\",\"ace/placeholder\",\"ace/multi_select\",\"ace/mode/folding/fold_mode\",\"ace/theme/textmate\",\"ace/ext/error_marker\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nrequire(\"./lib/fixoldbrowsers\");\n\nvar dom = require(\"./lib/dom\");\nvar event = require(\"./lib/event\");\n\nvar Range = require(\"./range\").Range;\nvar Editor = require(\"./editor\").Editor;\nvar EditSession = require(\"./edit_session\").EditSession;\nvar UndoManager = require(\"./undomanager\").UndoManager;\nvar Renderer = require(\"./virtual_renderer\").VirtualRenderer;\nrequire(\"./worker/worker_client\");\nrequire(\"./keyboard/hash_handler\");\nrequire(\"./placeholder\");\nrequire(\"./multi_select\");\nrequire(\"./mode/folding/fold_mode\");\nrequire(\"./theme/textmate\");\nrequire(\"./ext/error_marker\");\n\nexports.config = require(\"./config\");\nexports.require = require;\n\nif (true)\n    exports.define = __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\");\nexports.edit = function(el, options) {\n    if (typeof el == \"string\") {\n        var _id = el;\n        el = document.getElementById(_id);\n        if (!el)\n            throw new Error(\"ace.edit can't find div #\" + _id);\n    }\n\n    if (el && el.env && el.env.editor instanceof Editor)\n        return el.env.editor;\n\n    var value = \"\";\n    if (el && /input|textarea/i.test(el.tagName)) {\n        var oldNode = el;\n        value = oldNode.value;\n        el = dom.createElement(\"pre\");\n        oldNode.parentNode.replaceChild(el, oldNode);\n    } else if (el) {\n        value = el.textContent;\n        el.innerHTML = \"\";\n    }\n\n    var doc = exports.createEditSession(value);\n\n    var editor = new Editor(new Renderer(el), doc, options);\n\n    var env = {\n        document: doc,\n        editor: editor,\n        onResize: editor.resize.bind(editor, null)\n    };\n    if (oldNode) env.textarea = oldNode;\n    event.addListener(window, \"resize\", env.onResize);\n    editor.on(\"destroy\", function() {\n        event.removeListener(window, \"resize\", env.onResize);\n        env.editor.container.env = null; // prevent memory leak on old ie\n    });\n    editor.container.env = editor.env = env;\n    return editor;\n};\nexports.createEditSession = function(text, mode) {\n    var doc = new EditSession(text, mode);\n    doc.setUndoManager(new UndoManager());\n    return doc;\n};\nexports.Range = Range;\nexports.Editor = Editor;\nexports.EditSession = EditSession;\nexports.UndoManager = UndoManager;\nexports.VirtualRenderer = Renderer;\nexports.version = exports.config.version;\n});            (function() {\n                ace.require([\"ace/ace\"], function(a) {\n                    if (a) {\n                        a.config.init(true);\n                        a.define = ace.define;\n                    }\n                    if (!window.ace)\n                        window.ace = a;\n                    for (var key in a) if (a.hasOwnProperty(key))\n                        window.ace[key] = a[key];\n                    window.ace[\"default\"] = window.ace;\n                    if ( true && module) {\n                        module.exports = window.ace;\n                    }\n                });\n            })();\n        \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/ace-builds/src-noconflict/ace.js?");

/***/ }),

/***/ "./node_modules/ace-builds/src-noconflict/mode-html.js":
/*!*************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/mode-html.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {ace.define(\"ace/mode/doc_comment_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar DocCommentHighlightRules = function() {\n    this.$rules = {\n        \"start\" : [ {\n            token : \"comment.doc.tag\",\n            regex : \"@[\\\\w\\\\d_]+\" // TODO: fix email addresses\n        }, \n        DocCommentHighlightRules.getTagRule(),\n        {\n            defaultToken : \"comment.doc\",\n            caseInsensitive: true\n        }]\n    };\n};\n\noop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\nDocCommentHighlightRules.getTagRule = function(start) {\n    return {\n        token : \"comment.doc.tag.storage.type\",\n        regex : \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n};\n\nDocCommentHighlightRules.getStartRule = function(start) {\n    return {\n        token : \"comment.doc\", // doc comment\n        regex : \"\\\\/\\\\*(?=\\\\*)\",\n        next  : start\n    };\n};\n\nDocCommentHighlightRules.getEndRule = function (start) {\n    return {\n        token : \"comment.doc\", // closing comment\n        regex : \"\\\\*\\\\/\",\n        next  : start\n    };\n};\n\n\nexports.DocCommentHighlightRules = DocCommentHighlightRules;\n\n});\n\nace.define(\"ace/mode/javascript_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/doc_comment_highlight_rules\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar identifierRe = \"[a-zA-Z\\\\$_\\u00a1-\\uffff][a-zA-Z\\\\d\\\\$_\\u00a1-\\uffff]*\";\n\nvar JavaScriptHighlightRules = function(options) {\n    var keywordMapper = this.createKeywordMapper({\n        \"variable.language\":\n            \"Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|\"  + // Constructors\n            \"Namespace|QName|XML|XMLList|\"                                             + // E4X\n            \"ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|\"   +\n            \"Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|\"                    +\n            \"Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|\"   + // Errors\n            \"SyntaxError|TypeError|URIError|\"                                          +\n            \"decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|\" + // Non-constructor functions\n            \"isNaN|parseFloat|parseInt|\"                                               +\n            \"JSON|Math|\"                                                               + // Other\n            \"this|arguments|prototype|window|document\"                                 , // Pseudo\n        \"keyword\":\n            \"const|yield|import|get|set|async|await|\" +\n            \"break|case|catch|continue|default|delete|do|else|finally|for|function|\" +\n            \"if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|\" +\n            \"__parent__|__count__|escape|unescape|with|__proto__|\" +\n            \"class|enum|extends|super|export|implements|private|public|interface|package|protected|static\",\n        \"storage.type\":\n            \"const|let|var|function\",\n        \"constant.language\":\n            \"null|Infinity|NaN|undefined\",\n        \"support.function\":\n            \"alert\",\n        \"constant.language.boolean\": \"true|false\"\n    }, \"identifier\");\n    var kwBeforeRe = \"case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void\";\n\n    var escapedRe = \"\\\\\\\\(?:x[0-9a-fA-F]{2}|\" + // hex\n        \"u[0-9a-fA-F]{4}|\" + // unicode\n        \"u{[0-9a-fA-F]{1,6}}|\" + // es6 unicode\n        \"[0-2][0-7]{0,2}|\" + // oct\n        \"3[0-7][0-7]?|\" + // oct\n        \"[4-7][0-7]?|\" + //oct\n        \".)\";\n\n    this.$rules = {\n        \"no_regex\" : [\n            DocCommentHighlightRules.getStartRule(\"doc-start\"),\n            comments(\"no_regex\"),\n            {\n                token : \"string\",\n                regex : \"'(?=.)\",\n                next  : \"qstring\"\n            }, {\n                token : \"string\",\n                regex : '\"(?=.)',\n                next  : \"qqstring\"\n            }, {\n                token : \"constant.numeric\", // hexadecimal, octal and binary\n                regex : /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\\b/\n            }, {\n                token : \"constant.numeric\", // decimal integers and floats\n                regex : /(?:\\d\\d*(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+\\b)?/\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"support.function\",\n                    \"punctuation.operator\", \"entity.name.function\", \"text\",\"keyword.operator\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(prototype)(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"entity.name.function\", \"text\",\n                    \"keyword.operator\", \"text\", \"storage.type\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"entity.name.function\", \"text\", \"keyword.operator\", \"text\", \"storage.type\",\n                    \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"entity.name.function\", \"text\",\n                    \"keyword.operator\", \"text\",\n                    \"storage.type\", \"text\", \"entity.name.function\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(\\\\s+)(\\\\w+)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"storage.type\", \"text\", \"entity.name.function\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(function)(\\\\s+)(\" + identifierRe + \")(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"entity.name.function\", \"text\", \"punctuation.operator\",\n                    \"text\", \"storage.type\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\s*)(:)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"text\", \"text\", \"storage.type\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(:)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : \"keyword\",\n                regex : \"from(?=\\\\s*('|\\\"))\"\n            }, {\n                token : \"keyword\",\n                regex : \"(?:\" + kwBeforeRe + \")\\\\b\",\n                next : \"start\"\n            }, {\n                token : [\"support.constant\"],\n                regex : /that\\b/\n            }, {\n                token : [\"storage.type\", \"punctuation.operator\", \"support.function.firebug\"],\n                regex : /(console)(\\.)(warn|info|log|error|time|trace|timeEnd|assert)\\b/\n            }, {\n                token : keywordMapper,\n                regex : identifierRe\n            }, {\n                token : \"punctuation.operator\",\n                regex : /[.](?![.])/,\n                next  : \"property\"\n            }, {\n                token : \"storage.type\",\n                regex : /=>/,\n                next  : \"start\"\n            }, {\n                token : \"keyword.operator\",\n                regex : /--|\\+\\+|\\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\\|\\||\\?:|[!$%&*+\\-~\\/^]=?/,\n                next  : \"start\"\n            }, {\n                token : \"punctuation.operator\",\n                regex : /[?:,;.]/,\n                next  : \"start\"\n            }, {\n                token : \"paren.lparen\",\n                regex : /[\\[({]/,\n                next  : \"start\"\n            }, {\n                token : \"paren.rparen\",\n                regex : /[\\])}]/\n            }, {\n                token: \"comment\",\n                regex: /^#!.*$/\n            }\n        ],\n        property: [{\n                token : \"text\",\n                regex : \"\\\\s+\"\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"entity.name.function\", \"text\",\n                    \"keyword.operator\", \"text\",\n                    \"storage.type\", \"text\", \"entity.name.function\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(?:(\\\\s+)(\\\\w+))?(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : \"punctuation.operator\",\n                regex : /[.](?![.])/\n            }, {\n                token : \"support.function\",\n                regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\\b(?=\\()/\n            }, {\n                token : \"support.function.dom\",\n                regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\\b(?=\\()/\n            }, {\n                token :  \"support.constant\",\n                regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\\b/\n            }, {\n                token : \"identifier\",\n                regex : identifierRe\n            }, {\n                regex: \"\",\n                token: \"empty\",\n                next: \"no_regex\"\n            }\n        ],\n        \"start\": [\n            DocCommentHighlightRules.getStartRule(\"doc-start\"),\n            comments(\"start\"),\n            {\n                token: \"string.regexp\",\n                regex: \"\\\\/\",\n                next: \"regex\"\n            }, {\n                token : \"text\",\n                regex : \"\\\\s+|^$\",\n                next : \"start\"\n            }, {\n                token: \"empty\",\n                regex: \"\",\n                next: \"no_regex\"\n            }\n        ],\n        \"regex\": [\n            {\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"string.regexp\",\n                regex: \"/[sxngimy]*\",\n                next: \"no_regex\"\n            }, {\n                token : \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {\n                token : \"constant.language.escape\",\n                regex: /\\(\\?[:=!]|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token : \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                next: \"regex_character_class\"\n            }, {\n                token: \"empty\",\n                regex: \"$\",\n                next: \"no_regex\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"regex\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                token: \"empty\",\n                regex: \"$\",\n                next: \"no_regex\"\n            }, {\n                defaultToken: \"string.regexp.charachterclass\"\n            }\n        ],\n        \"function_arguments\": [\n            {\n                token: \"variable.parameter\",\n                regex: identifierRe\n            }, {\n                token: \"punctuation.operator\",\n                regex: \"[, ]+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: \"$\"\n            }, {\n                token: \"empty\",\n                regex: \"\",\n                next: \"no_regex\"\n            }\n        ],\n        \"qqstring\" : [\n            {\n                token : \"constant.language.escape\",\n                regex : escapedRe\n            }, {\n                token : \"string\",\n                regex : \"\\\\\\\\$\",\n                consumeLineEnd  : true\n            }, {\n                token : \"string\",\n                regex : '\"|$',\n                next  : \"no_regex\"\n            }, {\n                defaultToken: \"string\"\n            }\n        ],\n        \"qstring\" : [\n            {\n                token : \"constant.language.escape\",\n                regex : escapedRe\n            }, {\n                token : \"string\",\n                regex : \"\\\\\\\\$\",\n                consumeLineEnd  : true\n            }, {\n                token : \"string\",\n                regex : \"'|$\",\n                next  : \"no_regex\"\n            }, {\n                defaultToken: \"string\"\n            }\n        ]\n    };\n\n\n    if (!options || !options.noES6) {\n        this.$rules.no_regex.unshift({\n            regex: \"[{}]\", onMatch: function(val, state, stack) {\n                this.next = val == \"{\" ? this.nextState : \"\";\n                if (val == \"{\" && stack.length) {\n                    stack.unshift(\"start\", state);\n                }\n                else if (val == \"}\" && stack.length) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    if (this.next.indexOf(\"string\") != -1 || this.next.indexOf(\"jsx\") != -1)\n                        return \"paren.quasi.end\";\n                }\n                return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\n            },\n            nextState: \"start\"\n        }, {\n            token : \"string.quasi.start\",\n            regex : /`/,\n            push  : [{\n                token : \"constant.language.escape\",\n                regex : escapedRe\n            }, {\n                token : \"paren.quasi.start\",\n                regex : /\\${/,\n                push  : \"start\"\n            }, {\n                token : \"string.quasi.end\",\n                regex : /`/,\n                next  : \"pop\"\n            }, {\n                defaultToken: \"string.quasi\"\n            }]\n        });\n\n        if (!options || options.jsx != false)\n            JSX.call(this);\n    }\n\n    this.embedRules(DocCommentHighlightRules, \"doc-\",\n        [ DocCommentHighlightRules.getEndRule(\"no_regex\") ]);\n\n    this.normalizeRules();\n};\n\noop.inherits(JavaScriptHighlightRules, TextHighlightRules);\n\nfunction JSX() {\n    var tagRegex = identifierRe.replace(\"\\\\d\", \"\\\\d\\\\-\");\n    var jsxTag = {\n        onMatch : function(val, state, stack) {\n            var offset = val.charAt(1) == \"/\" ? 2 : 1;\n            if (offset == 1) {\n                if (state != this.nextState)\n                    stack.unshift(this.next, this.nextState, 0);\n                else\n                    stack.unshift(this.next);\n                stack[2]++;\n            } else if (offset == 2) {\n                if (state == this.nextState) {\n                    stack[1]--;\n                    if (!stack[1] || stack[1] < 0) {\n                        stack.shift();\n                        stack.shift();\n                    }\n                }\n            }\n            return [{\n                type: \"meta.tag.punctuation.\" + (offset == 1 ? \"\" : \"end-\") + \"tag-open.xml\",\n                value: val.slice(0, offset)\n            }, {\n                type: \"meta.tag.tag-name.xml\",\n                value: val.substr(offset)\n            }];\n        },\n        regex : \"</?\" + tagRegex + \"\",\n        next: \"jsxAttributes\",\n        nextState: \"jsx\"\n    };\n    this.$rules.start.unshift(jsxTag);\n    var jsxJsRule = {\n        regex: \"{\",\n        token: \"paren.quasi.start\",\n        push: \"start\"\n    };\n    this.$rules.jsx = [\n        jsxJsRule,\n        jsxTag,\n        {include : \"reference\"},\n        {defaultToken: \"string\"}\n    ];\n    this.$rules.jsxAttributes = [{\n        token : \"meta.tag.punctuation.tag-close.xml\",\n        regex : \"/?>\",\n        onMatch : function(value, currentState, stack) {\n            if (currentState == stack[0])\n                stack.shift();\n            if (value.length == 2) {\n                if (stack[0] == this.nextState)\n                    stack[1]--;\n                if (!stack[1] || stack[1] < 0) {\n                    stack.splice(0, 2);\n                }\n            }\n            this.next = stack[0] || \"start\";\n            return [{type: this.token, value: value}];\n        },\n        nextState: \"jsx\"\n    },\n    jsxJsRule,\n    comments(\"jsxAttributes\"),\n    {\n        token : \"entity.other.attribute-name.xml\",\n        regex : tagRegex\n    }, {\n        token : \"keyword.operator.attribute-equals.xml\",\n        regex : \"=\"\n    }, {\n        token : \"text.tag-whitespace.xml\",\n        regex : \"\\\\s+\"\n    }, {\n        token : \"string.attribute-value.xml\",\n        regex : \"'\",\n        stateName : \"jsx_attr_q\",\n        push : [\n            {token : \"string.attribute-value.xml\", regex: \"'\", next: \"pop\"},\n            {include : \"reference\"},\n            {defaultToken : \"string.attribute-value.xml\"}\n        ]\n    }, {\n        token : \"string.attribute-value.xml\",\n        regex : '\"',\n        stateName : \"jsx_attr_qq\",\n        push : [\n            {token : \"string.attribute-value.xml\", regex: '\"', next: \"pop\"},\n            {include : \"reference\"},\n            {defaultToken : \"string.attribute-value.xml\"}\n        ]\n    },\n    jsxTag\n    ];\n    this.$rules.reference = [{\n        token : \"constant.language.escape.reference.xml\",\n        regex : \"(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\\\.-]+;)\"\n    }];\n}\n\nfunction comments(next) {\n    return [\n        {\n            token : \"comment\", // multi line comment\n            regex : /\\/\\*/,\n            next: [\n                DocCommentHighlightRules.getTagRule(),\n                {token : \"comment\", regex : \"\\\\*\\\\/\", next : next || \"pop\"},\n                {defaultToken : \"comment\", caseInsensitive: true}\n            ]\n        }, {\n            token : \"comment\",\n            regex : \"\\\\/\\\\/\",\n            next: [\n                DocCommentHighlightRules.getTagRule(),\n                {token : \"comment\", regex : \"$|^\", next : next || \"pop\"},\n                {defaultToken : \"comment\", caseInsensitive: true}\n            ]\n        }\n    ];\n}\nexports.JavaScriptHighlightRules = JavaScriptHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/range\",\"ace/mode/folding/fold_mode\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Range = require(\"../../range\").Range;\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(commentRegex) {\n    if (commentRegex) {\n        this.foldingStartMarker = new RegExp(\n            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n        );\n        this.foldingStopMarker = new RegExp(\n            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n        );\n    }\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    \n    this.foldingStartMarker = /([\\{\\[\\(])[^\\}\\]\\)]*$|^\\s*(\\/\\*)/;\n    this.foldingStopMarker = /^[^\\[\\{\\(]*([\\}\\]\\)])|^[\\s\\*]*(\\*\\/)/;\n    this.singleLineBlockCommentRe= /^\\s*(\\/\\*).*\\*\\/\\s*$/;\n    this.tripleStarBlockCommentRe = /^\\s*(\\/\\*\\*\\*).*\\*\\/\\s*$/;\n    this.startRegionRe = /^\\s*(\\/\\*|\\/\\/)#?region\\b/;\n    this._getFoldWidgetBase = this.getFoldWidget;\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n    \n        if (this.singleLineBlockCommentRe.test(line)) {\n            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))\n                return \"\";\n        }\n    \n        var fw = this._getFoldWidgetBase(session, foldStyle, row);\n    \n        if (!fw && this.startRegionRe.test(line))\n            return \"start\"; // lineCommentRegionStart\n    \n        return fw;\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n        var line = session.getLine(row);\n        \n        if (this.startRegionRe.test(line))\n            return this.getCommentRegionBlock(session, line, row);\n        \n        var match = line.match(this.foldingStartMarker);\n        if (match) {\n            var i = match.index;\n\n            if (match[1])\n                return this.openingBracketBlock(session, match[1], row, i);\n                \n            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n            \n            if (range && !range.isMultiLine()) {\n                if (forceMultiline) {\n                    range = this.getSectionRange(session, row);\n                } else if (foldStyle != \"all\")\n                    range = null;\n            }\n            \n            return range;\n        }\n\n        if (foldStyle === \"markbegin\")\n            return;\n\n        var match = line.match(this.foldingStopMarker);\n        if (match) {\n            var i = match.index + match[0].length;\n\n            if (match[1])\n                return this.closingBracketBlock(session, match[1], row, i);\n\n            return session.getCommentFoldRange(row, i, -1);\n        }\n    };\n    \n    this.getSectionRange = function(session, row) {\n        var line = session.getLine(row);\n        var startIndent = line.search(/\\S/);\n        var startRow = row;\n        var startColumn = line.length;\n        row = row + 1;\n        var endRow = row;\n        var maxRow = session.getLength();\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var indent = line.search(/\\S/);\n            if (indent === -1)\n                continue;\n            if  (startIndent > indent)\n                break;\n            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n            \n            if (subRange) {\n                if (subRange.start.row <= startRow) {\n                    break;\n                } else if (subRange.isMultiLine()) {\n                    row = subRange.end.row;\n                } else if (startIndent == indent) {\n                    break;\n                }\n            }\n            endRow = row;\n        }\n        \n        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n    };\n    this.getCommentRegionBlock = function(session, line, row) {\n        var startColumn = line.search(/\\s*$/);\n        var maxRow = session.getLength();\n        var startRow = row;\n        \n        var re = /^\\s*(?:\\/\\*|\\/\\/|--)#?(end)?region\\b/;\n        var depth = 1;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var m = re.exec(line);\n            if (!m) continue;\n            if (m[1]) depth--;\n            else depth++;\n\n            if (!depth) break;\n        }\n\n        var endRow = row;\n        if (endRow > startRow) {\n            return new Range(startRow, startColumn, endRow, line.length);\n        }\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/javascript\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/javascript_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/worker/worker_client\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar JavaScriptHighlightRules = require(\"./javascript_highlight_rules\").JavaScriptHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = JavaScriptHighlightRules;\n    \n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n    this.foldingRules = new CStyleFoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n    this.$quotes = {'\"': '\"', \"'\": \"'\", \"`\": \"`\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\" || state == \"no_regex\") {\n            var match = line.match(/^.*(?:\\bcase\\b.*:|[\\{\\(\\[])\\s*$/);\n            if (match) {\n                indent += tab;\n            }\n        } else if (state == \"doc-start\") {\n            if (endState == \"start\" || endState == \"no_regex\") {\n                return \"\";\n            }\n            var match = line.match(/^\\s*(\\/?)\\*/);\n            if (match) {\n                if (match[1]) {\n                    indent += \" \";\n                }\n                indent += \"* \";\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/javascript_worker\", \"JavaScriptWorker\");\n        worker.attachToDocument(session.getDocument());\n\n        worker.on(\"annotate\", function(results) {\n            session.setAnnotations(results.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n    this.$id = \"ace/mode/javascript\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/mode/css_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar supportType = exports.supportType = \"align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|max-zoom|min-height|min-width|min-zoom|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|user-select|user-zoom|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index\";\nvar supportFunction = exports.supportFunction = \"rgb|rgba|url|attr|counter|counters\";\nvar supportConstant = exports.supportConstant = \"absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero|zoom\";\nvar supportConstantColor = exports.supportConstantColor = \"aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen\";\nvar supportConstantFonts = exports.supportConstantFonts = \"arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace\";\n\nvar numRe = exports.numRe = \"\\\\-?(?:(?:[0-9]+(?:\\\\.[0-9]+)?)|(?:\\\\.[0-9]+))\";\nvar pseudoElements = exports.pseudoElements = \"(\\\\:+)\\\\b(after|before|first-letter|first-line|moz-selection|selection)\\\\b\";\nvar pseudoClasses  = exports.pseudoClasses =  \"(:)\\\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\\\b\";\n\nvar CssHighlightRules = function() {\n\n    var keywordMapper = this.createKeywordMapper({\n        \"support.function\": supportFunction,\n        \"support.constant\": supportConstant,\n        \"support.type\": supportType,\n        \"support.constant.color\": supportConstantColor,\n        \"support.constant.fonts\": supportConstantFonts\n    }, \"text\", true);\n\n    this.$rules = {\n        \"start\" : [{\n            include : [\"strings\", \"url\", \"comments\"]\n        }, {\n            token: \"paren.lparen\",\n            regex: \"\\\\{\",\n            next:  \"ruleset\"\n        }, {\n            token: \"paren.rparen\",\n            regex: \"\\\\}\"\n        }, {\n            token: \"string\",\n            regex: \"@(?!viewport)\",\n            next:  \"media\"\n        }, {\n            token: \"keyword\",\n            regex: \"#[a-z0-9-_]+\"\n        }, {\n            token: \"keyword\",\n            regex: \"%\"\n        }, {\n            token: \"variable\",\n            regex: \"\\\\.[a-z0-9-_]+\"\n        }, {\n            token: \"string\",\n            regex: \":[a-z0-9-_]+\"\n        }, {\n            token : \"constant.numeric\",\n            regex : numRe\n        }, {\n            token: \"constant\",\n            regex: \"[a-z0-9-_]+\"\n        }, {\n            caseInsensitive: true\n        }],\n\n        \"media\": [{\n            include : [\"strings\", \"url\", \"comments\"]\n        }, {\n            token: \"paren.lparen\",\n            regex: \"\\\\{\",\n            next:  \"start\"\n        }, {\n            token: \"paren.rparen\",\n            regex: \"\\\\}\",\n            next:  \"start\"\n        }, {\n            token: \"string\",\n            regex: \";\",\n            next:  \"start\"\n        }, {\n            token: \"keyword\",\n            regex: \"(?:media|supports|document|charset|import|namespace|media|supports|document\"\n                + \"|page|font|keyframes|viewport|counter-style|font-feature-values\"\n                + \"|swash|ornaments|annotation|stylistic|styleset|character-variant)\"\n        }],\n\n        \"comments\" : [{\n            token: \"comment\", // multi line comment\n            regex: \"\\\\/\\\\*\",\n            push: [{\n                token : \"comment\",\n                regex : \"\\\\*\\\\/\",\n                next : \"pop\"\n            }, {\n                defaultToken : \"comment\"\n            }]\n        }],\n\n        \"ruleset\" : [{\n            regex : \"-(webkit|ms|moz|o)-\",\n            token : \"text\"\n        }, {\n            token : \"punctuation.operator\",\n            regex : \"[:;]\"\n        }, {\n            token : \"paren.rparen\",\n            regex : \"\\\\}\",\n            next : \"start\"\n        }, {\n            include : [\"strings\", \"url\", \"comments\"]\n        }, {\n            token : [\"constant.numeric\", \"keyword\"],\n            regex : \"(\" + numRe + \")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vm|vw|%)\"\n        }, {\n            token : \"constant.numeric\",\n            regex : numRe\n        }, {\n            token : \"constant.numeric\",  // hex6 color\n            regex : \"#[a-f0-9]{6}\"\n        }, {\n            token : \"constant.numeric\", // hex3 color\n            regex : \"#[a-f0-9]{3}\"\n        }, {\n            token : [\"punctuation\", \"entity.other.attribute-name.pseudo-element.css\"],\n            regex : pseudoElements\n        }, {\n            token : [\"punctuation\", \"entity.other.attribute-name.pseudo-class.css\"],\n            regex : pseudoClasses\n        }, {\n            include: \"url\"\n        }, {\n            token : keywordMapper,\n            regex : \"\\\\-?[a-zA-Z_][a-zA-Z0-9_\\\\-]*\"\n        }, {\n            caseInsensitive: true\n        }],\n\n        url: [{\n            token : \"support.function\",\n            regex : \"(?:url(:?-prefix)?|domain|regexp)\\\\(\",\n            push: [{\n                token : \"support.function\",\n                regex : \"\\\\)\",\n                next : \"pop\"\n            }, {\n                defaultToken: \"string\"\n            }]\n        }],\n\n        strings: [{\n            token : \"string.start\",\n            regex : \"'\",\n            push : [{\n                token : \"string.end\",\n                regex : \"'|$\",\n                next: \"pop\"\n            }, {\n                include : \"escapes\"\n            }, {\n                token : \"constant.language.escape\",\n                regex : /\\\\$/,\n                consumeLineEnd: true\n            }, {\n                defaultToken: \"string\"\n            }]\n        }, {\n            token : \"string.start\",\n            regex : '\"',\n            push : [{\n                token : \"string.end\",\n                regex : '\"|$',\n                next: \"pop\"\n            }, {\n                include : \"escapes\"\n            }, {\n                token : \"constant.language.escape\",\n                regex : /\\\\$/,\n                consumeLineEnd: true\n            }, {\n                defaultToken: \"string\"\n            }]\n        }],\n        escapes: [{\n            token : \"constant.language.escape\",\n            regex : /\\\\([a-fA-F\\d]{1,6}|[^a-fA-F\\d])/\n        }]\n\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(CssHighlightRules, TextHighlightRules);\n\nexports.CssHighlightRules = CssHighlightRules;\n\n});\n\nace.define(\"ace/mode/css_completions\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar propertyMap = {\n    \"background\": {\"#$0\": 1},\n    \"background-color\": {\"#$0\": 1, \"transparent\": 1, \"fixed\": 1},\n    \"background-image\": {\"url('/$0')\": 1},\n    \"background-repeat\": {\"repeat\": 1, \"repeat-x\": 1, \"repeat-y\": 1, \"no-repeat\": 1, \"inherit\": 1},\n    \"background-position\": {\"bottom\":2, \"center\":2, \"left\":2, \"right\":2, \"top\":2, \"inherit\":2},\n    \"background-attachment\": {\"scroll\": 1, \"fixed\": 1},\n    \"background-size\": {\"cover\": 1, \"contain\": 1},\n    \"background-clip\": {\"border-box\": 1, \"padding-box\": 1, \"content-box\": 1},\n    \"background-origin\": {\"border-box\": 1, \"padding-box\": 1, \"content-box\": 1},\n    \"border\": {\"solid $0\": 1, \"dashed $0\": 1, \"dotted $0\": 1, \"#$0\": 1},\n    \"border-color\": {\"#$0\": 1},\n    \"border-style\": {\"solid\":2, \"dashed\":2, \"dotted\":2, \"double\":2, \"groove\":2, \"hidden\":2, \"inherit\":2, \"inset\":2, \"none\":2, \"outset\":2, \"ridged\":2},\n    \"border-collapse\": {\"collapse\": 1, \"separate\": 1},\n    \"bottom\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"clear\": {\"left\": 1, \"right\": 1, \"both\": 1, \"none\": 1},\n    \"color\": {\"#$0\": 1, \"rgb(#$00,0,0)\": 1},\n    \"cursor\": {\"default\": 1, \"pointer\": 1, \"move\": 1, \"text\": 1, \"wait\": 1, \"help\": 1, \"progress\": 1, \"n-resize\": 1, \"ne-resize\": 1, \"e-resize\": 1, \"se-resize\": 1, \"s-resize\": 1, \"sw-resize\": 1, \"w-resize\": 1, \"nw-resize\": 1},\n    \"display\": {\"none\": 1, \"block\": 1, \"inline\": 1, \"inline-block\": 1, \"table-cell\": 1},\n    \"empty-cells\": {\"show\": 1, \"hide\": 1},\n    \"float\": {\"left\": 1, \"right\": 1, \"none\": 1},\n    \"font-family\": {\"Arial\":2,\"Comic Sans MS\":2,\"Consolas\":2,\"Courier New\":2,\"Courier\":2,\"Georgia\":2,\"Monospace\":2,\"Sans-Serif\":2, \"Segoe UI\":2,\"Tahoma\":2,\"Times New Roman\":2,\"Trebuchet MS\":2,\"Verdana\": 1},\n    \"font-size\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"font-weight\": {\"bold\": 1, \"normal\": 1},\n    \"font-style\": {\"italic\": 1, \"normal\": 1},\n    \"font-variant\": {\"normal\": 1, \"small-caps\": 1},\n    \"height\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"left\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"letter-spacing\": {\"normal\": 1},\n    \"line-height\": {\"normal\": 1},\n    \"list-style-type\": {\"none\": 1, \"disc\": 1, \"circle\": 1, \"square\": 1, \"decimal\": 1, \"decimal-leading-zero\": 1, \"lower-roman\": 1, \"upper-roman\": 1, \"lower-greek\": 1, \"lower-latin\": 1, \"upper-latin\": 1, \"georgian\": 1, \"lower-alpha\": 1, \"upper-alpha\": 1},\n    \"margin\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-right\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-left\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-top\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-bottom\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"max-height\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"max-width\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"min-height\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"min-width\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"overflow\": {\"hidden\": 1, \"visible\": 1, \"auto\": 1, \"scroll\": 1},\n    \"overflow-x\": {\"hidden\": 1, \"visible\": 1, \"auto\": 1, \"scroll\": 1},\n    \"overflow-y\": {\"hidden\": 1, \"visible\": 1, \"auto\": 1, \"scroll\": 1},\n    \"padding\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-top\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-right\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-bottom\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-left\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"page-break-after\": {\"auto\": 1, \"always\": 1, \"avoid\": 1, \"left\": 1, \"right\": 1},\n    \"page-break-before\": {\"auto\": 1, \"always\": 1, \"avoid\": 1, \"left\": 1, \"right\": 1},\n    \"position\": {\"absolute\": 1, \"relative\": 1, \"fixed\": 1, \"static\": 1},\n    \"right\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"table-layout\": {\"fixed\": 1, \"auto\": 1},\n    \"text-decoration\": {\"none\": 1, \"underline\": 1, \"line-through\": 1, \"blink\": 1},\n    \"text-align\": {\"left\": 1, \"right\": 1, \"center\": 1, \"justify\": 1},\n    \"text-transform\": {\"capitalize\": 1, \"uppercase\": 1, \"lowercase\": 1, \"none\": 1},\n    \"top\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"vertical-align\": {\"top\": 1, \"bottom\": 1},\n    \"visibility\": {\"hidden\": 1, \"visible\": 1},\n    \"white-space\": {\"nowrap\": 1, \"normal\": 1, \"pre\": 1, \"pre-line\": 1, \"pre-wrap\": 1},\n    \"width\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"word-spacing\": {\"normal\": 1},\n    \"filter\": {\"alpha(opacity=$0100)\": 1},\n\n    \"text-shadow\": {\"$02px 2px 2px #777\": 1},\n    \"text-overflow\": {\"ellipsis-word\": 1, \"clip\": 1, \"ellipsis\": 1},\n    \"-moz-border-radius\": 1,\n    \"-moz-border-radius-topright\": 1,\n    \"-moz-border-radius-bottomright\": 1,\n    \"-moz-border-radius-topleft\": 1,\n    \"-moz-border-radius-bottomleft\": 1,\n    \"-webkit-border-radius\": 1,\n    \"-webkit-border-top-right-radius\": 1,\n    \"-webkit-border-top-left-radius\": 1,\n    \"-webkit-border-bottom-right-radius\": 1,\n    \"-webkit-border-bottom-left-radius\": 1,\n    \"-moz-box-shadow\": 1,\n    \"-webkit-box-shadow\": 1,\n    \"transform\": {\"rotate($00deg)\": 1, \"skew($00deg)\": 1},\n    \"-moz-transform\": {\"rotate($00deg)\": 1, \"skew($00deg)\": 1},\n    \"-webkit-transform\": {\"rotate($00deg)\": 1, \"skew($00deg)\": 1 }\n};\n\nvar CssCompletions = function() {\n\n};\n\n(function() {\n\n    this.completionsDefined = false;\n\n    this.defineCompletions = function() {\n        if (document) {\n            var style = document.createElement('c').style;\n\n            for (var i in style) {\n                if (typeof style[i] !== 'string')\n                    continue;\n\n                var name = i.replace(/[A-Z]/g, function(x) {\n                    return '-' + x.toLowerCase();\n                });\n\n                if (!propertyMap.hasOwnProperty(name))\n                    propertyMap[name] = 1;\n            }\n        }\n\n        this.completionsDefined = true;\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        if (!this.completionsDefined) {\n            this.defineCompletions();\n        }\n\n        if (state==='ruleset' || session.$mode.$id == \"ace/mode/scss\") {\n            var line = session.getLine(pos.row).substr(0, pos.column);\n            if (/:[^;]+$/.test(line)) {\n                /([\\w\\-]+):[^:]*$/.test(line);\n\n                return this.getPropertyValueCompletions(state, session, pos, prefix);\n            } else {\n                return this.getPropertyCompletions(state, session, pos, prefix);\n            }\n        }\n\n        return [];\n    };\n\n    this.getPropertyCompletions = function(state, session, pos, prefix) {\n        var properties = Object.keys(propertyMap);\n        return properties.map(function(property){\n            return {\n                caption: property,\n                snippet: property + ': $0;',\n                meta: \"property\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getPropertyValueCompletions = function(state, session, pos, prefix) {\n        var line = session.getLine(pos.row).substr(0, pos.column);\n        var property = (/([\\w\\-]+):[^:]*$/.exec(line) || {})[1];\n\n        if (!property)\n            return [];\n        var values = [];\n        if (property in propertyMap && typeof propertyMap[property] === \"object\") {\n            values = Object.keys(propertyMap[property]);\n        }\n        return values.map(function(value){\n            return {\n                caption: value,\n                snippet: value,\n                meta: \"property value\",\n                score: 1000000\n            };\n        });\n    };\n\n}).call(CssCompletions.prototype);\n\nexports.CssCompletions = CssCompletions;\n});\n\nace.define(\"ace/mode/behaviour/css\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/mode/behaviour/cstyle\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar CstyleBehaviour = require(\"./cstyle\").CstyleBehaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\nvar CssBehaviour = function () {\n\n    this.inherit(CstyleBehaviour);\n\n    this.add(\"colon\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === ':' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            if (token && token.value.match(/\\s+/)) {\n                token = iterator.stepBackward();\n            }\n            if (token && token.type === 'support.type') {\n                var line = session.doc.getLine(cursor.row);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                if (rightChar === ':') {\n                    return {\n                       text: '',\n                       selection: [1, 1]\n                    };\n                }\n                if (/^(\\s+[^;]|\\s*$)/.test(line.substring(cursor.column))) {\n                    return {\n                       text: ':;',\n                       selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"colon\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected === ':') {\n            var cursor = editor.getCursorPosition();\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            if (token && token.value.match(/\\s+/)) {\n                token = iterator.stepBackward();\n            }\n            if (token && token.type === 'support.type') {\n                var line = session.doc.getLine(range.start.row);\n                var rightChar = line.substring(range.end.column, range.end.column + 1);\n                if (rightChar === ';') {\n                    range.end.column ++;\n                    return range;\n                }\n            }\n        }\n    });\n\n    this.add(\"semicolon\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === ';' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === ';') {\n                return {\n                   text: '',\n                   selection: [1, 1]\n                };\n            }\n        }\n    });\n\n    this.add(\"!important\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === '!' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n\n            if (/^\\s*(;|}|$)/.test(line.substring(cursor.column))) {\n                return {\n                    text: '!important',\n                    selection: [10, 10]\n                };\n            }\n        }\n    });\n\n};\noop.inherits(CssBehaviour, CstyleBehaviour);\n\nexports.CssBehaviour = CssBehaviour;\n});\n\nace.define(\"ace/mode/css\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/css_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/worker/worker_client\",\"ace/mode/css_completions\",\"ace/mode/behaviour/css\",\"ace/mode/folding/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar CssHighlightRules = require(\"./css_highlight_rules\").CssHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar CssCompletions = require(\"./css_completions\").CssCompletions;\nvar CssBehaviour = require(\"./behaviour/css\").CssBehaviour;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = CssHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CssBehaviour();\n    this.$completer = new CssCompletions();\n    this.foldingRules = new CStyleFoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.foldingRules = \"cStyle\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        var match = line.match(/^.*\\{\\s*$/);\n        if (match) {\n            indent += tab;\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        return this.$completer.getCompletions(state, session, pos, prefix);\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/css_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n\n        worker.on(\"annotate\", function(e) {\n            session.setAnnotations(e.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n    this.$id = \"ace/mode/css\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n\n});\n\nace.define(\"ace/mode/xml_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar XmlHighlightRules = function(normalize) {\n    var tagRegex = \"[_:a-zA-Z\\xc0-\\uffff][-_:.a-zA-Z0-9\\xc0-\\uffff]*\";\n\n    this.$rules = {\n        start : [\n            {token : \"string.cdata.xml\", regex : \"<\\\\!\\\\[CDATA\\\\[\", next : \"cdata\"},\n            {\n                token : [\"punctuation.instruction.xml\", \"keyword.instruction.xml\"],\n                regex : \"(<\\\\?)(\" + tagRegex + \")\", next : \"processing_instruction\"\n            },\n            {token : \"comment.start.xml\", regex : \"<\\\\!--\", next : \"comment\"},\n            {\n                token : [\"xml-pe.doctype.xml\", \"xml-pe.doctype.xml\"],\n                regex : \"(<\\\\!)(DOCTYPE)(?=[\\\\s])\", next : \"doctype\", caseInsensitive: true\n            },\n            {include : \"tag\"},\n            {token : \"text.end-tag-open.xml\", regex: \"</\"},\n            {token : \"text.tag-open.xml\", regex: \"<\"},\n            {include : \"reference\"},\n            {defaultToken : \"text.xml\"}\n        ],\n\n        processing_instruction : [{\n            token : \"entity.other.attribute-name.decl-attribute-name.xml\",\n            regex : tagRegex\n        }, {\n            token : \"keyword.operator.decl-attribute-equals.xml\",\n            regex : \"=\"\n        }, {\n            include: \"whitespace\"\n        }, {\n            include: \"string\"\n        }, {\n            token : \"punctuation.xml-decl.xml\",\n            regex : \"\\\\?>\",\n            next : \"start\"\n        }],\n\n        doctype : [\n            {include : \"whitespace\"},\n            {include : \"string\"},\n            {token : \"xml-pe.doctype.xml\", regex : \">\", next : \"start\"},\n            {token : \"xml-pe.xml\", regex : \"[-_a-zA-Z0-9:]+\"},\n            {token : \"punctuation.int-subset\", regex : \"\\\\[\", push : \"int_subset\"}\n        ],\n\n        int_subset : [{\n            token : \"text.xml\",\n            regex : \"\\\\s+\"\n        }, {\n            token: \"punctuation.int-subset.xml\",\n            regex: \"]\",\n            next: \"pop\"\n        }, {\n            token : [\"punctuation.markup-decl.xml\", \"keyword.markup-decl.xml\"],\n            regex : \"(<\\\\!)(\" + tagRegex + \")\",\n            push : [{\n                token : \"text\",\n                regex : \"\\\\s+\"\n            },\n            {\n                token : \"punctuation.markup-decl.xml\",\n                regex : \">\",\n                next : \"pop\"\n            },\n            {include : \"string\"}]\n        }],\n\n        cdata : [\n            {token : \"string.cdata.xml\", regex : \"\\\\]\\\\]>\", next : \"start\"},\n            {token : \"text.xml\", regex : \"\\\\s+\"},\n            {token : \"text.xml\", regex : \"(?:[^\\\\]]|\\\\](?!\\\\]>))+\"}\n        ],\n\n        comment : [\n            {token : \"comment.end.xml\", regex : \"-->\", next : \"start\"},\n            {defaultToken : \"comment.xml\"}\n        ],\n\n        reference : [{\n            token : \"constant.language.escape.reference.xml\",\n            regex : \"(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\\\.-]+;)\"\n        }],\n\n        attr_reference : [{\n            token : \"constant.language.escape.reference.attribute-value.xml\",\n            regex : \"(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\\\.-]+;)\"\n        }],\n\n        tag : [{\n            token : [\"meta.tag.punctuation.tag-open.xml\", \"meta.tag.punctuation.end-tag-open.xml\", \"meta.tag.tag-name.xml\"],\n            regex : \"(?:(<)|(</))((?:\" + tagRegex + \":)?\" + tagRegex + \")\",\n            next: [\n                {include : \"attributes\"},\n                {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\", next : \"start\"}\n            ]\n        }],\n\n        tag_whitespace : [\n            {token : \"text.tag-whitespace.xml\", regex : \"\\\\s+\"}\n        ],\n        whitespace : [\n            {token : \"text.whitespace.xml\", regex : \"\\\\s+\"}\n        ],\n        string: [{\n            token : \"string.xml\",\n            regex : \"'\",\n            push : [\n                {token : \"string.xml\", regex: \"'\", next: \"pop\"},\n                {defaultToken : \"string.xml\"}\n            ]\n        }, {\n            token : \"string.xml\",\n            regex : '\"',\n            push : [\n                {token : \"string.xml\", regex: '\"', next: \"pop\"},\n                {defaultToken : \"string.xml\"}\n            ]\n        }],\n\n        attributes: [{\n            token : \"entity.other.attribute-name.xml\",\n            regex : tagRegex\n        }, {\n            token : \"keyword.operator.attribute-equals.xml\",\n            regex : \"=\"\n        }, {\n            include: \"tag_whitespace\"\n        }, {\n            include: \"attribute_value\"\n        }],\n\n        attribute_value: [{\n            token : \"string.attribute-value.xml\",\n            regex : \"'\",\n            push : [\n                {token : \"string.attribute-value.xml\", regex: \"'\", next: \"pop\"},\n                {include : \"attr_reference\"},\n                {defaultToken : \"string.attribute-value.xml\"}\n            ]\n        }, {\n            token : \"string.attribute-value.xml\",\n            regex : '\"',\n            push : [\n                {token : \"string.attribute-value.xml\", regex: '\"', next: \"pop\"},\n                {include : \"attr_reference\"},\n                {defaultToken : \"string.attribute-value.xml\"}\n            ]\n        }]\n    };\n\n    if (this.constructor === XmlHighlightRules)\n        this.normalizeRules();\n};\n\n\n(function() {\n\n    this.embedTagRules = function(HighlightRules, prefix, tag){\n        this.$rules.tag.unshift({\n            token : [\"meta.tag.punctuation.tag-open.xml\", \"meta.tag.\" + tag + \".tag-name.xml\"],\n            regex : \"(<)(\" + tag + \"(?=\\\\s|>|$))\",\n            next: [\n                {include : \"attributes\"},\n                {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\", next : prefix + \"start\"}\n            ]\n        });\n\n        this.$rules[tag + \"-end\"] = [\n            {include : \"attributes\"},\n            {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\",  next: \"start\",\n                onMatch : function(value, currentState, stack) {\n                    stack.splice(0);\n                    return this.token;\n            }}\n        ];\n\n        this.embedRules(HighlightRules, prefix, [{\n            token: [\"meta.tag.punctuation.end-tag-open.xml\", \"meta.tag.\" + tag + \".tag-name.xml\"],\n            regex : \"(</)(\" + tag + \"(?=\\\\s|>|$))\",\n            next: tag + \"-end\"\n        }, {\n            token: \"string.cdata.xml\",\n            regex : \"<\\\\!\\\\[CDATA\\\\[\"\n        }, {\n            token: \"string.cdata.xml\",\n            regex : \"\\\\]\\\\]>\"\n        }]);\n    };\n\n}).call(TextHighlightRules.prototype);\n\noop.inherits(XmlHighlightRules, TextHighlightRules);\n\nexports.XmlHighlightRules = XmlHighlightRules;\n});\n\nace.define(\"ace/mode/html_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/css_highlight_rules\",\"ace/mode/javascript_highlight_rules\",\"ace/mode/xml_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar CssHighlightRules = require(\"./css_highlight_rules\").CssHighlightRules;\nvar JavaScriptHighlightRules = require(\"./javascript_highlight_rules\").JavaScriptHighlightRules;\nvar XmlHighlightRules = require(\"./xml_highlight_rules\").XmlHighlightRules;\n\nvar tagMap = lang.createMap({\n    a           : 'anchor',\n    button \t    : 'form',\n    form        : 'form',\n    img         : 'image',\n    input       : 'form',\n    label       : 'form',\n    option      : 'form',\n    script      : 'script',\n    select      : 'form',\n    textarea    : 'form',\n    style       : 'style',\n    table       : 'table',\n    tbody       : 'table',\n    td          : 'table',\n    tfoot       : 'table',\n    th          : 'table',\n    tr          : 'table'\n});\n\nvar HtmlHighlightRules = function() {\n    XmlHighlightRules.call(this);\n\n    this.addRules({\n        attributes: [{\n            include : \"tag_whitespace\"\n        }, {\n            token : \"entity.other.attribute-name.xml\",\n            regex : \"[-_a-zA-Z0-9:.]+\"\n        }, {\n            token : \"keyword.operator.attribute-equals.xml\",\n            regex : \"=\",\n            push : [{\n                include: \"tag_whitespace\"\n            }, {\n                token : \"string.unquoted.attribute-value.html\",\n                regex : \"[^<>='\\\"`\\\\s]+\",\n                next : \"pop\"\n            }, {\n                token : \"empty\",\n                regex : \"\",\n                next : \"pop\"\n            }]\n        }, {\n            include : \"attribute_value\"\n        }],\n        tag: [{\n            token : function(start, tag) {\n                var group = tagMap[tag];\n                return [\"meta.tag.punctuation.\" + (start == \"<\" ? \"\" : \"end-\") + \"tag-open.xml\",\n                    \"meta.tag\" + (group ? \".\" + group : \"\") + \".tag-name.xml\"];\n            },\n            regex : \"(</?)([-_a-zA-Z0-9:.]+)\",\n            next: \"tag_stuff\"\n        }],\n        tag_stuff: [\n            {include : \"attributes\"},\n            {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\", next : \"start\"}\n        ]\n    });\n\n    this.embedTagRules(CssHighlightRules, \"css-\", \"style\");\n    this.embedTagRules(new JavaScriptHighlightRules({jsx: false}).getRules(), \"js-\", \"script\");\n\n    if (this.constructor === HtmlHighlightRules)\n        this.normalizeRules();\n};\n\noop.inherits(HtmlHighlightRules, XmlHighlightRules);\n\nexports.HtmlHighlightRules = HtmlHighlightRules;\n});\n\nace.define(\"ace/mode/behaviour/xml\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\n\nfunction is(token, type) {\n    return token && token.type.lastIndexOf(type + \".xml\") > -1;\n}\n\nvar XmlBehaviour = function () {\n\n    this.add(\"string_dquotes\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '\"' || text == \"'\") {\n            var quote = text;\n            var selected = session.doc.getTextRange(editor.getSelectionRange());\n            if (selected !== \"\" && selected !== \"'\" && selected != '\"' && editor.getWrapBehavioursEnabled()) {\n                return {\n                    text: quote + selected + quote,\n                    selection: false\n                };\n            }\n\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n\n            if (rightChar == quote && (is(token, \"attribute-value\") || is(token, \"string\"))) {\n                return {\n                    text: \"\",\n                    selection: [1, 1]\n                };\n            }\n\n            if (!token)\n                token = iterator.stepBackward();\n\n            if (!token)\n                return;\n\n            while (is(token, \"tag-whitespace\") || is(token, \"whitespace\")) {\n                token = iterator.stepBackward();\n            }\n            var rightSpace = !rightChar || rightChar.match(/\\s/);\n            if (is(token, \"attribute-equals\") && (rightSpace || rightChar == '>') || (is(token, \"decl-attribute-equals\") && (rightSpace || rightChar == '?'))) {\n                return {\n                    text: quote + quote,\n                    selection: [1, 1]\n                };\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && (selected == '\"' || selected == \"'\")) {\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"autoclosing\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '>') {\n            var position = editor.getSelectionRange().start;\n            var iterator = new TokenIterator(session, position.row, position.column);\n            var token = iterator.getCurrentToken() || iterator.stepBackward();\n            if (!token || !(is(token, \"tag-name\") || is(token, \"tag-whitespace\") || is(token, \"attribute-name\") || is(token, \"attribute-equals\") || is(token, \"attribute-value\")))\n                return;\n            if (is(token, \"reference.attribute-value\"))\n                return;\n            if (is(token, \"attribute-value\")) {\n                var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;\n                if (position.column < tokenEndColumn)\n                    return;\n                if (position.column == tokenEndColumn) {\n                    var nextToken = iterator.stepForward();\n                    if (nextToken && is(nextToken, \"attribute-value\"))\n                        return;\n                    iterator.stepBackward();\n                }\n            }\n            \n            if (/^\\s*>/.test(session.getLine(position.row).slice(position.column)))\n                return;\n            while (!is(token, \"tag-name\")) {\n                token = iterator.stepBackward();\n                if (token.value == \"<\") {\n                    token = iterator.stepForward();\n                    break;\n                }\n            }\n\n            var tokenRow = iterator.getCurrentTokenRow();\n            var tokenColumn = iterator.getCurrentTokenColumn();\n            if (is(iterator.stepBackward(), \"end-tag-open\"))\n                return;\n\n            var element = token.value;\n            if (tokenRow == position.row)\n                element = element.substring(0, position.column - tokenColumn);\n\n            if (this.voidElements.hasOwnProperty(element.toLowerCase()))\n                 return;\n\n            return {\n               text: \">\" + \"</\" + element + \">\",\n               selection: [1, 1]\n            };\n        }\n    });\n\n    this.add(\"autoindent\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == \"\\n\") {\n            var cursor = editor.getCursorPosition();\n            var line = session.getLine(cursor.row);\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n\n            if (token && token.type.indexOf(\"tag-close\") !== -1) {\n                if (token.value == \"/>\")\n                    return;\n                while (token && token.type.indexOf(\"tag-name\") === -1) {\n                    token = iterator.stepBackward();\n                }\n\n                if (!token) {\n                    return;\n                }\n\n                var tag = token.value;\n                var row = iterator.getCurrentTokenRow();\n                token = iterator.stepBackward();\n                if (!token || token.type.indexOf(\"end-tag\") !== -1) {\n                    return;\n                }\n\n                if (this.voidElements && !this.voidElements[tag]) {\n                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);\n                    var line = session.getLine(row);\n                    var nextIndent = this.$getIndent(line);\n                    var indent = nextIndent + session.getTabString();\n\n                    if (nextToken && nextToken.value === \"</\") {\n                        return {\n                            text: \"\\n\" + indent + \"\\n\" + nextIndent,\n                            selection: [1, indent.length, 1, indent.length]\n                        };\n                    } else {\n                        return {\n                            text: \"\\n\" + indent\n                        };\n                    }\n                }\n            }\n        }\n    });\n\n};\n\noop.inherits(XmlBehaviour, Behaviour);\n\nexports.XmlBehaviour = XmlBehaviour;\n});\n\nace.define(\"ace/mode/folding/mixed\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(defaultMode, subModes) {\n    this.defaultMode = defaultMode;\n    this.subModes = subModes;\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n\n    this.$getMode = function(state) {\n        if (typeof state != \"string\") \n            state = state[0];\n        for (var key in this.subModes) {\n            if (state.indexOf(key) === 0)\n                return this.subModes[key];\n        }\n        return null;\n    };\n    \n    this.$tryMode = function(state, session, foldStyle, row) {\n        var mode = this.$getMode(state);\n        return (mode ? mode.getFoldWidget(session, foldStyle, row) : \"\");\n    };\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        return (\n            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||\n            this.$tryMode(session.getState(row), session, foldStyle, row) ||\n            this.defaultMode.getFoldWidget(session, foldStyle, row)\n        );\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var mode = this.$getMode(session.getState(row-1));\n        \n        if (!mode || !mode.getFoldWidget(session, foldStyle, row))\n            mode = this.$getMode(session.getState(row));\n        \n        if (!mode || !mode.getFoldWidget(session, foldStyle, row))\n            mode = this.defaultMode;\n        \n        return mode.getFoldWidgetRange(session, foldStyle, row);\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/folding/xml\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/range\",\"ace/mode/folding/fold_mode\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar lang = require(\"../../lib/lang\");\nvar Range = require(\"../../range\").Range;\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\nvar FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {\n    BaseFoldMode.call(this);\n    this.voidElements = voidElements || {};\n    this.optionalEndTags = oop.mixin({}, this.voidElements);\n    if (optionalEndTags)\n        oop.mixin(this.optionalEndTags, optionalEndTags);\n    \n};\noop.inherits(FoldMode, BaseFoldMode);\n\nvar Tag = function() {\n    this.tagName = \"\";\n    this.closing = false;\n    this.selfClosing = false;\n    this.start = {row: 0, column: 0};\n    this.end = {row: 0, column: 0};\n};\n\nfunction is(token, type) {\n    return token.type.lastIndexOf(type + \".xml\") > -1;\n}\n\n(function() {\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var tag = this._getFirstTagInLine(session, row);\n\n        if (!tag)\n            return this.getCommentFoldWidget(session, row);\n\n        if (tag.closing || (!tag.tagName && tag.selfClosing))\n            return foldStyle == \"markbeginend\" ? \"end\" : \"\";\n\n        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))\n            return \"\";\n\n        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))\n            return \"\";\n\n        return \"start\";\n    };\n    \n    this.getCommentFoldWidget = function(session, row) {\n        if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))\n            return \"start\";\n        return \"\";\n    };\n    this._getFirstTagInLine = function(session, row) {\n        var tokens = session.getTokens(row);\n        var tag = new Tag();\n\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (is(token, \"tag-open\")) {\n                tag.end.column = tag.start.column + token.value.length;\n                tag.closing = is(token, \"end-tag-open\");\n                token = tokens[++i];\n                if (!token)\n                    return null;\n                tag.tagName = token.value;\n                tag.end.column += token.value.length;\n                for (i++; i < tokens.length; i++) {\n                    token = tokens[i];\n                    tag.end.column += token.value.length;\n                    if (is(token, \"tag-close\")) {\n                        tag.selfClosing = token.value == '/>';\n                        break;\n                    }\n                }\n                return tag;\n            } else if (is(token, \"tag-close\")) {\n                tag.selfClosing = token.value == '/>';\n                return tag;\n            }\n            tag.start.column += token.value.length;\n        }\n\n        return null;\n    };\n\n    this._findEndTagInLine = function(session, row, tagName, startColumn) {\n        var tokens = session.getTokens(row);\n        var column = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            column += token.value.length;\n            if (column < startColumn)\n                continue;\n            if (is(token, \"end-tag-open\")) {\n                token = tokens[i + 1];\n                if (token && token.value == tagName)\n                    return true;\n            }\n        }\n        return false;\n    };\n    this._readTagForward = function(iterator) {\n        var token = iterator.getCurrentToken();\n        if (!token)\n            return null;\n\n        var tag = new Tag();\n        do {\n            if (is(token, \"tag-open\")) {\n                tag.closing = is(token, \"end-tag-open\");\n                tag.start.row = iterator.getCurrentTokenRow();\n                tag.start.column = iterator.getCurrentTokenColumn();\n            } else if (is(token, \"tag-name\")) {\n                tag.tagName = token.value;\n            } else if (is(token, \"tag-close\")) {\n                tag.selfClosing = token.value == \"/>\";\n                tag.end.row = iterator.getCurrentTokenRow();\n                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;\n                iterator.stepForward();\n                return tag;\n            }\n        } while(token = iterator.stepForward());\n\n        return null;\n    };\n    \n    this._readTagBackward = function(iterator) {\n        var token = iterator.getCurrentToken();\n        if (!token)\n            return null;\n\n        var tag = new Tag();\n        do {\n            if (is(token, \"tag-open\")) {\n                tag.closing = is(token, \"end-tag-open\");\n                tag.start.row = iterator.getCurrentTokenRow();\n                tag.start.column = iterator.getCurrentTokenColumn();\n                iterator.stepBackward();\n                return tag;\n            } else if (is(token, \"tag-name\")) {\n                tag.tagName = token.value;\n            } else if (is(token, \"tag-close\")) {\n                tag.selfClosing = token.value == \"/>\";\n                tag.end.row = iterator.getCurrentTokenRow();\n                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;\n            }\n        } while(token = iterator.stepBackward());\n\n        return null;\n    };\n    \n    this._pop = function(stack, tag) {\n        while (stack.length) {\n            \n            var top = stack[stack.length-1];\n            if (!tag || top.tagName == tag.tagName) {\n                return stack.pop();\n            }\n            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {\n                stack.pop();\n                continue;\n            } else {\n                return null;\n            }\n        }\n    };\n    \n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var firstTag = this._getFirstTagInLine(session, row);\n        \n        if (!firstTag) {\n            return this.getCommentFoldWidget(session, row)\n                && session.getCommentFoldRange(row, session.getLine(row).length);\n        }\n        \n        var isBackward = firstTag.closing || firstTag.selfClosing;\n        var stack = [];\n        var tag;\n        \n        if (!isBackward) {\n            var iterator = new TokenIterator(session, row, firstTag.start.column);\n            var start = {\n                row: row,\n                column: firstTag.start.column + firstTag.tagName.length + 2\n            };\n            if (firstTag.start.row == firstTag.end.row)\n                start.column = firstTag.end.column;\n            while (tag = this._readTagForward(iterator)) {\n                if (tag.selfClosing) {\n                    if (!stack.length) {\n                        tag.start.column += tag.tagName.length + 2;\n                        tag.end.column -= 2;\n                        return Range.fromPoints(tag.start, tag.end);\n                    } else\n                        continue;\n                }\n                \n                if (tag.closing) {\n                    this._pop(stack, tag);\n                    if (stack.length == 0)\n                        return Range.fromPoints(start, tag.start);\n                }\n                else {\n                    stack.push(tag);\n                }\n            }\n        }\n        else {\n            var iterator = new TokenIterator(session, row, firstTag.end.column);\n            var end = {\n                row: row,\n                column: firstTag.start.column\n            };\n            \n            while (tag = this._readTagBackward(iterator)) {\n                if (tag.selfClosing) {\n                    if (!stack.length) {\n                        tag.start.column += tag.tagName.length + 2;\n                        tag.end.column -= 2;\n                        return Range.fromPoints(tag.start, tag.end);\n                    } else\n                        continue;\n                }\n                \n                if (!tag.closing) {\n                    this._pop(stack, tag);\n                    if (stack.length == 0) {\n                        tag.start.column += tag.tagName.length + 2;\n                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)\n                            tag.start.column = tag.end.column;\n                        return Range.fromPoints(tag.start, end);\n                    }\n                }\n                else {\n                    stack.push(tag);\n                }\n            }\n        }\n        \n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/folding/html\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/mixed\",\"ace/mode/folding/xml\",\"ace/mode/folding/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar MixedFoldMode = require(\"./mixed\").FoldMode;\nvar XmlFoldMode = require(\"./xml\").FoldMode;\nvar CStyleFoldMode = require(\"./cstyle\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(voidElements, optionalTags) {\n    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {\n        \"js-\": new CStyleFoldMode(),\n        \"css-\": new CStyleFoldMode()\n    });\n};\n\noop.inherits(FoldMode, MixedFoldMode);\n\n});\n\nace.define(\"ace/mode/html_completions\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\n\nvar commonAttributes = [\n    \"accesskey\",\n    \"class\",\n    \"contenteditable\",\n    \"contextmenu\",\n    \"dir\",\n    \"draggable\",\n    \"dropzone\",\n    \"hidden\",\n    \"id\",\n    \"inert\",\n    \"itemid\",\n    \"itemprop\",\n    \"itemref\",\n    \"itemscope\",\n    \"itemtype\",\n    \"lang\",\n    \"spellcheck\",\n    \"style\",\n    \"tabindex\",\n    \"title\",\n    \"translate\"\n];\n\nvar eventAttributes = [\n    \"onabort\",\n    \"onblur\",\n    \"oncancel\",\n    \"oncanplay\",\n    \"oncanplaythrough\",\n    \"onchange\",\n    \"onclick\",\n    \"onclose\",\n    \"oncontextmenu\",\n    \"oncuechange\",\n    \"ondblclick\",\n    \"ondrag\",\n    \"ondragend\",\n    \"ondragenter\",\n    \"ondragleave\",\n    \"ondragover\",\n    \"ondragstart\",\n    \"ondrop\",\n    \"ondurationchange\",\n    \"onemptied\",\n    \"onended\",\n    \"onerror\",\n    \"onfocus\",\n    \"oninput\",\n    \"oninvalid\",\n    \"onkeydown\",\n    \"onkeypress\",\n    \"onkeyup\",\n    \"onload\",\n    \"onloadeddata\",\n    \"onloadedmetadata\",\n    \"onloadstart\",\n    \"onmousedown\",\n    \"onmousemove\",\n    \"onmouseout\",\n    \"onmouseover\",\n    \"onmouseup\",\n    \"onmousewheel\",\n    \"onpause\",\n    \"onplay\",\n    \"onplaying\",\n    \"onprogress\",\n    \"onratechange\",\n    \"onreset\",\n    \"onscroll\",\n    \"onseeked\",\n    \"onseeking\",\n    \"onselect\",\n    \"onshow\",\n    \"onstalled\",\n    \"onsubmit\",\n    \"onsuspend\",\n    \"ontimeupdate\",\n    \"onvolumechange\",\n    \"onwaiting\"\n];\n\nvar globalAttributes = commonAttributes.concat(eventAttributes);\n\nvar attributeMap = {\n    \"a\": {\"href\": 1, \"target\": {\"_blank\": 1, \"top\": 1}, \"ping\": 1, \"rel\": {\"nofollow\": 1, \"alternate\": 1, \"author\": 1, \"bookmark\": 1, \"help\": 1, \"license\": 1, \"next\": 1, \"noreferrer\": 1, \"prefetch\": 1, \"prev\": 1, \"search\": 1, \"tag\": 1}, \"media\": 1, \"hreflang\": 1, \"type\": 1},\n    \"abbr\": {},\n    \"address\": {},\n    \"area\": {\"shape\": 1, \"coords\": 1, \"href\": 1, \"hreflang\": 1, \"alt\": 1, \"target\": 1, \"media\": 1, \"rel\": 1, \"ping\": 1, \"type\": 1},\n    \"article\": {\"pubdate\": 1},\n    \"aside\": {},\n    \"audio\": {\"src\": 1, \"autobuffer\": 1, \"autoplay\": {\"autoplay\": 1}, \"loop\": {\"loop\": 1}, \"controls\": {\"controls\": 1}, \"muted\": {\"muted\": 1}, \"preload\": {\"auto\": 1, \"metadata\": 1, \"none\": 1 }},\n    \"b\": {},\n    \"base\": {\"href\": 1, \"target\": 1},\n    \"bdi\": {},\n    \"bdo\": {},\n    \"blockquote\": {\"cite\": 1},\n    \"body\": {\"onafterprint\": 1, \"onbeforeprint\": 1, \"onbeforeunload\": 1, \"onhashchange\": 1, \"onmessage\": 1, \"onoffline\": 1, \"onpopstate\": 1, \"onredo\": 1, \"onresize\": 1, \"onstorage\": 1, \"onundo\": 1, \"onunload\": 1},\n    \"br\": {},\n    \"button\": {\"autofocus\": 1, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"formaction\": 1, \"formenctype\": 1, \"formmethod\": 1, \"formnovalidate\": 1, \"formtarget\": 1, \"name\": 1, \"value\": 1, \"type\": {\"button\": 1, \"submit\": 1}},\n    \"canvas\": {\"width\": 1, \"height\": 1},\n    \"caption\": {},\n    \"cite\": {},\n    \"code\": {},\n    \"col\": {\"span\": 1},\n    \"colgroup\": {\"span\": 1},\n    \"command\": {\"type\": 1, \"label\": 1, \"icon\": 1, \"disabled\": 1, \"checked\": 1, \"radiogroup\": 1, \"command\": 1},\n    \"data\": {},\n    \"datalist\": {},\n    \"dd\": {},\n    \"del\": {\"cite\": 1, \"datetime\": 1},\n    \"details\": {\"open\": 1},\n    \"dfn\": {},\n    \"dialog\": {\"open\": 1},\n    \"div\": {},\n    \"dl\": {},\n    \"dt\": {},\n    \"em\": {},\n    \"embed\": {\"src\": 1, \"height\": 1, \"width\": 1, \"type\": 1},\n    \"fieldset\": {\"disabled\": 1, \"form\": 1, \"name\": 1},\n    \"figcaption\": {},\n    \"figure\": {},\n    \"footer\": {},\n    \"form\": {\"accept-charset\": 1, \"action\": 1, \"autocomplete\": 1, \"enctype\": {\"multipart/form-data\": 1, \"application/x-www-form-urlencoded\": 1}, \"method\": {\"get\": 1, \"post\": 1}, \"name\": 1, \"novalidate\": 1, \"target\": {\"_blank\": 1, \"top\": 1}},\n    \"h1\": {},\n    \"h2\": {},\n    \"h3\": {},\n    \"h4\": {},\n    \"h5\": {},\n    \"h6\": {},\n    \"head\": {},\n    \"header\": {},\n    \"hr\": {},\n    \"html\": {\"manifest\": 1},\n    \"i\": {},\n    \"iframe\": {\"name\": 1, \"src\": 1, \"height\": 1, \"width\": 1, \"sandbox\": {\"allow-same-origin\": 1, \"allow-top-navigation\": 1, \"allow-forms\": 1, \"allow-scripts\": 1}, \"seamless\": {\"seamless\": 1}},\n    \"img\": {\"alt\": 1, \"src\": 1, \"height\": 1, \"width\": 1, \"usemap\": 1, \"ismap\": 1},\n    \"input\": {\n        \"type\": {\"text\": 1, \"password\": 1, \"hidden\": 1, \"checkbox\": 1, \"submit\": 1, \"radio\": 1, \"file\": 1, \"button\": 1, \"reset\": 1, \"image\": 31, \"color\": 1, \"date\": 1, \"datetime\": 1, \"datetime-local\": 1, \"email\": 1, \"month\": 1, \"number\": 1, \"range\": 1, \"search\": 1, \"tel\": 1, \"time\": 1, \"url\": 1, \"week\": 1},\n        \"accept\": 1, \"alt\": 1, \"autocomplete\": {\"on\": 1, \"off\": 1}, \"autofocus\": {\"autofocus\": 1}, \"checked\": {\"checked\": 1}, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"formaction\": 1, \"formenctype\": {\"application/x-www-form-urlencoded\": 1, \"multipart/form-data\": 1, \"text/plain\": 1}, \"formmethod\": {\"get\": 1, \"post\": 1}, \"formnovalidate\": {\"formnovalidate\": 1}, \"formtarget\": {\"_blank\": 1, \"_self\": 1, \"_parent\": 1, \"_top\": 1}, \"height\": 1, \"list\": 1, \"max\": 1, \"maxlength\": 1, \"min\": 1, \"multiple\": {\"multiple\": 1}, \"name\": 1, \"pattern\": 1, \"placeholder\": 1, \"readonly\": {\"readonly\": 1}, \"required\": {\"required\": 1}, \"size\": 1, \"src\": 1, \"step\": 1, \"width\": 1, \"files\": 1, \"value\": 1},\n    \"ins\": {\"cite\": 1, \"datetime\": 1},\n    \"kbd\": {},\n    \"keygen\": {\"autofocus\": 1, \"challenge\": {\"challenge\": 1}, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"keytype\": {\"rsa\": 1, \"dsa\": 1, \"ec\": 1}, \"name\": 1},\n    \"label\": {\"form\": 1, \"for\": 1},\n    \"legend\": {},\n    \"li\": {\"value\": 1},\n    \"link\": {\"href\": 1, \"hreflang\": 1, \"rel\": {\"stylesheet\": 1, \"icon\": 1}, \"media\": {\"all\": 1, \"screen\": 1, \"print\": 1}, \"type\": {\"text/css\": 1, \"image/png\": 1, \"image/jpeg\": 1, \"image/gif\": 1}, \"sizes\": 1},\n    \"main\": {},\n    \"map\": {\"name\": 1},\n    \"mark\": {},\n    \"math\": {},\n    \"menu\": {\"type\": 1, \"label\": 1},\n    \"meta\": {\"http-equiv\": {\"content-type\": 1}, \"name\": {\"description\": 1, \"keywords\": 1}, \"content\": {\"text/html; charset=UTF-8\": 1}, \"charset\": 1},\n    \"meter\": {\"value\": 1, \"min\": 1, \"max\": 1, \"low\": 1, \"high\": 1, \"optimum\": 1},\n    \"nav\": {},\n    \"noscript\": {\"href\": 1},\n    \"object\": {\"param\": 1, \"data\": 1, \"type\": 1, \"height\" : 1, \"width\": 1, \"usemap\": 1, \"name\": 1, \"form\": 1, \"classid\": 1},\n    \"ol\": {\"start\": 1, \"reversed\": 1},\n    \"optgroup\": {\"disabled\": 1, \"label\": 1},\n    \"option\": {\"disabled\": 1, \"selected\": 1, \"label\": 1, \"value\": 1},\n    \"output\": {\"for\": 1, \"form\": 1, \"name\": 1},\n    \"p\": {},\n    \"param\": {\"name\": 1, \"value\": 1},\n    \"pre\": {},\n    \"progress\": {\"value\": 1, \"max\": 1},\n    \"q\": {\"cite\": 1},\n    \"rp\": {},\n    \"rt\": {},\n    \"ruby\": {},\n    \"s\": {},\n    \"samp\": {},\n    \"script\": {\"charset\": 1, \"type\": {\"text/javascript\": 1}, \"src\": 1, \"defer\": 1, \"async\": 1},\n    \"select\": {\"autofocus\": 1, \"disabled\": 1, \"form\": 1, \"multiple\": {\"multiple\": 1}, \"name\": 1, \"size\": 1, \"readonly\":{\"readonly\": 1}},\n    \"small\": {},\n    \"source\": {\"src\": 1, \"type\": 1, \"media\": 1},\n    \"span\": {},\n    \"strong\": {},\n    \"style\": {\"type\": 1, \"media\": {\"all\": 1, \"screen\": 1, \"print\": 1}, \"scoped\": 1},\n    \"sub\": {},\n    \"sup\": {},\n    \"svg\": {},\n    \"table\": {\"summary\": 1},\n    \"tbody\": {},\n    \"td\": {\"headers\": 1, \"rowspan\": 1, \"colspan\": 1},\n    \"textarea\": {\"autofocus\": {\"autofocus\": 1}, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"maxlength\": 1, \"name\": 1, \"placeholder\": 1, \"readonly\": {\"readonly\": 1}, \"required\": {\"required\": 1}, \"rows\": 1, \"cols\": 1, \"wrap\": {\"on\": 1, \"off\": 1, \"hard\": 1, \"soft\": 1}},\n    \"tfoot\": {},\n    \"th\": {\"headers\": 1, \"rowspan\": 1, \"colspan\": 1, \"scope\": 1},\n    \"thead\": {},\n    \"time\": {\"datetime\": 1},\n    \"title\": {},\n    \"tr\": {},\n    \"track\": {\"kind\": 1, \"src\": 1, \"srclang\": 1, \"label\": 1, \"default\": 1},\n    \"section\": {},\n    \"summary\": {},\n    \"u\": {},\n    \"ul\": {},\n    \"var\": {},\n    \"video\": {\"src\": 1, \"autobuffer\": 1, \"autoplay\": {\"autoplay\": 1}, \"loop\": {\"loop\": 1}, \"controls\": {\"controls\": 1}, \"width\": 1, \"height\": 1, \"poster\": 1, \"muted\": {\"muted\": 1}, \"preload\": {\"auto\": 1, \"metadata\": 1, \"none\": 1}},\n    \"wbr\": {}\n};\n\nvar elements = Object.keys(attributeMap);\n\nfunction is(token, type) {\n    return token.type.lastIndexOf(type + \".xml\") > -1;\n}\n\nfunction findTagName(session, pos) {\n    var iterator = new TokenIterator(session, pos.row, pos.column);\n    var token = iterator.getCurrentToken();\n    while (token && !is(token, \"tag-name\")){\n        token = iterator.stepBackward();\n    }\n    if (token)\n        return token.value;\n}\n\nfunction findAttributeName(session, pos) {\n    var iterator = new TokenIterator(session, pos.row, pos.column);\n    var token = iterator.getCurrentToken();\n    while (token && !is(token, \"attribute-name\")){\n        token = iterator.stepBackward();\n    }\n    if (token)\n        return token.value;\n}\n\nvar HtmlCompletions = function() {\n\n};\n\n(function() {\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        var token = session.getTokenAt(pos.row, pos.column);\n\n        if (!token)\n            return [];\n        if (is(token, \"tag-name\") || is(token, \"tag-open\") || is(token, \"end-tag-open\"))\n            return this.getTagCompletions(state, session, pos, prefix);\n        if (is(token, \"tag-whitespace\") || is(token, \"attribute-name\"))\n            return this.getAttributeCompletions(state, session, pos, prefix);\n        if (is(token, \"attribute-value\"))\n            return this.getAttributeValueCompletions(state, session, pos, prefix);\n        var line = session.getLine(pos.row).substr(0, pos.column);\n        if (/&[a-z]*$/i.test(line))\n            return this.getHTMLEntityCompletions(state, session, pos, prefix);\n\n        return [];\n    };\n\n    this.getTagCompletions = function(state, session, pos, prefix) {\n        return elements.map(function(element){\n            return {\n                value: element,\n                meta: \"tag\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getAttributeCompletions = function(state, session, pos, prefix) {\n        var tagName = findTagName(session, pos);\n        if (!tagName)\n            return [];\n        var attributes = globalAttributes;\n        if (tagName in attributeMap) {\n            attributes = attributes.concat(Object.keys(attributeMap[tagName]));\n        }\n        return attributes.map(function(attribute){\n            return {\n                caption: attribute,\n                snippet: attribute + '=\"$0\"',\n                meta: \"attribute\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getAttributeValueCompletions = function(state, session, pos, prefix) {\n        var tagName = findTagName(session, pos);\n        var attributeName = findAttributeName(session, pos);\n        \n        if (!tagName)\n            return [];\n        var values = [];\n        if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === \"object\") {\n            values = Object.keys(attributeMap[tagName][attributeName]);\n        }\n        return values.map(function(value){\n            return {\n                caption: value,\n                snippet: value,\n                meta: \"attribute value\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getHTMLEntityCompletions = function(state, session, pos, prefix) {\n        var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];\n\n        return values.map(function(value){\n            return {\n                caption: value,\n                snippet: value,\n                meta: \"html entity\",\n                score: 1000000\n            };\n        });\n    };\n\n}).call(HtmlCompletions.prototype);\n\nexports.HtmlCompletions = HtmlCompletions;\n});\n\nace.define(\"ace/mode/html\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text\",\"ace/mode/javascript\",\"ace/mode/css\",\"ace/mode/html_highlight_rules\",\"ace/mode/behaviour/xml\",\"ace/mode/folding/html\",\"ace/mode/html_completions\",\"ace/worker/worker_client\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextMode = require(\"./text\").Mode;\nvar JavaScriptMode = require(\"./javascript\").Mode;\nvar CssMode = require(\"./css\").Mode;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\nvar XmlBehaviour = require(\"./behaviour/xml\").XmlBehaviour;\nvar HtmlFoldMode = require(\"./folding/html\").FoldMode;\nvar HtmlCompletions = require(\"./html_completions\").HtmlCompletions;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar voidElements = [\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"menuitem\", \"param\", \"source\", \"track\", \"wbr\"];\nvar optionalEndTags = [\"li\", \"dt\", \"dd\", \"p\", \"rt\", \"rp\", \"optgroup\", \"option\", \"colgroup\", \"td\", \"th\"];\n\nvar Mode = function(options) {\n    this.fragmentContext = options && options.fragmentContext;\n    this.HighlightRules = HtmlHighlightRules;\n    this.$behaviour = new XmlBehaviour();\n    this.$completer = new HtmlCompletions();\n    \n    this.createModeDelegates({\n        \"js-\": JavaScriptMode,\n        \"css-\": CssMode\n    });\n    \n    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.blockComment = {start: \"<!--\", end: \"-->\"};\n\n    this.voidElements = lang.arrayToMap(voidElements);\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$getIndent(line);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return false;\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        return this.$completer.getCompletions(state, session, pos, prefix);\n    };\n\n    this.createWorker = function(session) {\n        if (this.constructor != Mode)\n            return;\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/html_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n\n        if (this.fragmentContext)\n            worker.call(\"setOptions\", [{context: this.fragmentContext}]);\n\n        worker.on(\"error\", function(e) {\n            session.setAnnotations(e.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n    this.$id = \"ace/mode/html\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});                (function() {\n                    ace.require([\"ace/mode/html\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/ace-builds/src-noconflict/mode-html.js?");

/***/ }),

/***/ "./node_modules/ace-builds/src-noconflict/mode-markdown.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/mode-markdown.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {ace.define(\"ace/mode/doc_comment_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar DocCommentHighlightRules = function() {\n    this.$rules = {\n        \"start\" : [ {\n            token : \"comment.doc.tag\",\n            regex : \"@[\\\\w\\\\d_]+\" // TODO: fix email addresses\n        }, \n        DocCommentHighlightRules.getTagRule(),\n        {\n            defaultToken : \"comment.doc\",\n            caseInsensitive: true\n        }]\n    };\n};\n\noop.inherits(DocCommentHighlightRules, TextHighlightRules);\n\nDocCommentHighlightRules.getTagRule = function(start) {\n    return {\n        token : \"comment.doc.tag.storage.type\",\n        regex : \"\\\\b(?:TODO|FIXME|XXX|HACK)\\\\b\"\n    };\n};\n\nDocCommentHighlightRules.getStartRule = function(start) {\n    return {\n        token : \"comment.doc\", // doc comment\n        regex : \"\\\\/\\\\*(?=\\\\*)\",\n        next  : start\n    };\n};\n\nDocCommentHighlightRules.getEndRule = function (start) {\n    return {\n        token : \"comment.doc\", // closing comment\n        regex : \"\\\\*\\\\/\",\n        next  : start\n    };\n};\n\n\nexports.DocCommentHighlightRules = DocCommentHighlightRules;\n\n});\n\nace.define(\"ace/mode/javascript_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/doc_comment_highlight_rules\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar DocCommentHighlightRules = require(\"./doc_comment_highlight_rules\").DocCommentHighlightRules;\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar identifierRe = \"[a-zA-Z\\\\$_\\u00a1-\\uffff][a-zA-Z\\\\d\\\\$_\\u00a1-\\uffff]*\";\n\nvar JavaScriptHighlightRules = function(options) {\n    var keywordMapper = this.createKeywordMapper({\n        \"variable.language\":\n            \"Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|\"  + // Constructors\n            \"Namespace|QName|XML|XMLList|\"                                             + // E4X\n            \"ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|\"   +\n            \"Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|\"                    +\n            \"Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|\"   + // Errors\n            \"SyntaxError|TypeError|URIError|\"                                          +\n            \"decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|\" + // Non-constructor functions\n            \"isNaN|parseFloat|parseInt|\"                                               +\n            \"JSON|Math|\"                                                               + // Other\n            \"this|arguments|prototype|window|document\"                                 , // Pseudo\n        \"keyword\":\n            \"const|yield|import|get|set|async|await|\" +\n            \"break|case|catch|continue|default|delete|do|else|finally|for|function|\" +\n            \"if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|\" +\n            \"__parent__|__count__|escape|unescape|with|__proto__|\" +\n            \"class|enum|extends|super|export|implements|private|public|interface|package|protected|static\",\n        \"storage.type\":\n            \"const|let|var|function\",\n        \"constant.language\":\n            \"null|Infinity|NaN|undefined\",\n        \"support.function\":\n            \"alert\",\n        \"constant.language.boolean\": \"true|false\"\n    }, \"identifier\");\n    var kwBeforeRe = \"case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void\";\n\n    var escapedRe = \"\\\\\\\\(?:x[0-9a-fA-F]{2}|\" + // hex\n        \"u[0-9a-fA-F]{4}|\" + // unicode\n        \"u{[0-9a-fA-F]{1,6}}|\" + // es6 unicode\n        \"[0-2][0-7]{0,2}|\" + // oct\n        \"3[0-7][0-7]?|\" + // oct\n        \"[4-7][0-7]?|\" + //oct\n        \".)\";\n\n    this.$rules = {\n        \"no_regex\" : [\n            DocCommentHighlightRules.getStartRule(\"doc-start\"),\n            comments(\"no_regex\"),\n            {\n                token : \"string\",\n                regex : \"'(?=.)\",\n                next  : \"qstring\"\n            }, {\n                token : \"string\",\n                regex : '\"(?=.)',\n                next  : \"qqstring\"\n            }, {\n                token : \"constant.numeric\", // hexadecimal, octal and binary\n                regex : /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\\b/\n            }, {\n                token : \"constant.numeric\", // decimal integers and floats\n                regex : /(?:\\d\\d*(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+\\b)?/\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"support.function\",\n                    \"punctuation.operator\", \"entity.name.function\", \"text\",\"keyword.operator\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(prototype)(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"entity.name.function\", \"text\",\n                    \"keyword.operator\", \"text\", \"storage.type\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"entity.name.function\", \"text\", \"keyword.operator\", \"text\", \"storage.type\",\n                    \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"entity.name.function\", \"text\",\n                    \"keyword.operator\", \"text\",\n                    \"storage.type\", \"text\", \"entity.name.function\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(\\\\s+)(\\\\w+)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"storage.type\", \"text\", \"entity.name.function\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(function)(\\\\s+)(\" + identifierRe + \")(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"entity.name.function\", \"text\", \"punctuation.operator\",\n                    \"text\", \"storage.type\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\s*)(:)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : [\n                    \"text\", \"text\", \"storage.type\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(:)(\\\\s*)(function)(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : \"keyword\",\n                regex : \"from(?=\\\\s*('|\\\"))\"\n            }, {\n                token : \"keyword\",\n                regex : \"(?:\" + kwBeforeRe + \")\\\\b\",\n                next : \"start\"\n            }, {\n                token : [\"support.constant\"],\n                regex : /that\\b/\n            }, {\n                token : [\"storage.type\", \"punctuation.operator\", \"support.function.firebug\"],\n                regex : /(console)(\\.)(warn|info|log|error|time|trace|timeEnd|assert)\\b/\n            }, {\n                token : keywordMapper,\n                regex : identifierRe\n            }, {\n                token : \"punctuation.operator\",\n                regex : /[.](?![.])/,\n                next  : \"property\"\n            }, {\n                token : \"storage.type\",\n                regex : /=>/,\n                next  : \"start\"\n            }, {\n                token : \"keyword.operator\",\n                regex : /--|\\+\\+|\\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\\|\\||\\?:|[!$%&*+\\-~\\/^]=?/,\n                next  : \"start\"\n            }, {\n                token : \"punctuation.operator\",\n                regex : /[?:,;.]/,\n                next  : \"start\"\n            }, {\n                token : \"paren.lparen\",\n                regex : /[\\[({]/,\n                next  : \"start\"\n            }, {\n                token : \"paren.rparen\",\n                regex : /[\\])}]/\n            }, {\n                token: \"comment\",\n                regex: /^#!.*$/\n            }\n        ],\n        property: [{\n                token : \"text\",\n                regex : \"\\\\s+\"\n            }, {\n                token : [\n                    \"storage.type\", \"punctuation.operator\", \"entity.name.function\", \"text\",\n                    \"keyword.operator\", \"text\",\n                    \"storage.type\", \"text\", \"entity.name.function\", \"text\", \"paren.lparen\"\n                ],\n                regex : \"(\" + identifierRe + \")(\\\\.)(\" + identifierRe +\")(\\\\s*)(=)(\\\\s*)(function)(?:(\\\\s+)(\\\\w+))?(\\\\s*)(\\\\()\",\n                next: \"function_arguments\"\n            }, {\n                token : \"punctuation.operator\",\n                regex : /[.](?![.])/\n            }, {\n                token : \"support.function\",\n                regex : /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\\b(?=\\()/\n            }, {\n                token : \"support.function.dom\",\n                regex : /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\\b(?=\\()/\n            }, {\n                token :  \"support.constant\",\n                regex : /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\\b/\n            }, {\n                token : \"identifier\",\n                regex : identifierRe\n            }, {\n                regex: \"\",\n                token: \"empty\",\n                next: \"no_regex\"\n            }\n        ],\n        \"start\": [\n            DocCommentHighlightRules.getStartRule(\"doc-start\"),\n            comments(\"start\"),\n            {\n                token: \"string.regexp\",\n                regex: \"\\\\/\",\n                next: \"regex\"\n            }, {\n                token : \"text\",\n                regex : \"\\\\s+|^$\",\n                next : \"start\"\n            }, {\n                token: \"empty\",\n                regex: \"\",\n                next: \"no_regex\"\n            }\n        ],\n        \"regex\": [\n            {\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"string.regexp\",\n                regex: \"/[sxngimy]*\",\n                next: \"no_regex\"\n            }, {\n                token : \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {\n                token : \"constant.language.escape\",\n                regex: /\\(\\?[:=!]|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token : \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                next: \"regex_character_class\"\n            }, {\n                token: \"empty\",\n                regex: \"$\",\n                next: \"no_regex\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"regex\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                token: \"empty\",\n                regex: \"$\",\n                next: \"no_regex\"\n            }, {\n                defaultToken: \"string.regexp.charachterclass\"\n            }\n        ],\n        \"function_arguments\": [\n            {\n                token: \"variable.parameter\",\n                regex: identifierRe\n            }, {\n                token: \"punctuation.operator\",\n                regex: \"[, ]+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: \"$\"\n            }, {\n                token: \"empty\",\n                regex: \"\",\n                next: \"no_regex\"\n            }\n        ],\n        \"qqstring\" : [\n            {\n                token : \"constant.language.escape\",\n                regex : escapedRe\n            }, {\n                token : \"string\",\n                regex : \"\\\\\\\\$\",\n                consumeLineEnd  : true\n            }, {\n                token : \"string\",\n                regex : '\"|$',\n                next  : \"no_regex\"\n            }, {\n                defaultToken: \"string\"\n            }\n        ],\n        \"qstring\" : [\n            {\n                token : \"constant.language.escape\",\n                regex : escapedRe\n            }, {\n                token : \"string\",\n                regex : \"\\\\\\\\$\",\n                consumeLineEnd  : true\n            }, {\n                token : \"string\",\n                regex : \"'|$\",\n                next  : \"no_regex\"\n            }, {\n                defaultToken: \"string\"\n            }\n        ]\n    };\n\n\n    if (!options || !options.noES6) {\n        this.$rules.no_regex.unshift({\n            regex: \"[{}]\", onMatch: function(val, state, stack) {\n                this.next = val == \"{\" ? this.nextState : \"\";\n                if (val == \"{\" && stack.length) {\n                    stack.unshift(\"start\", state);\n                }\n                else if (val == \"}\" && stack.length) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    if (this.next.indexOf(\"string\") != -1 || this.next.indexOf(\"jsx\") != -1)\n                        return \"paren.quasi.end\";\n                }\n                return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\n            },\n            nextState: \"start\"\n        }, {\n            token : \"string.quasi.start\",\n            regex : /`/,\n            push  : [{\n                token : \"constant.language.escape\",\n                regex : escapedRe\n            }, {\n                token : \"paren.quasi.start\",\n                regex : /\\${/,\n                push  : \"start\"\n            }, {\n                token : \"string.quasi.end\",\n                regex : /`/,\n                next  : \"pop\"\n            }, {\n                defaultToken: \"string.quasi\"\n            }]\n        });\n\n        if (!options || options.jsx != false)\n            JSX.call(this);\n    }\n\n    this.embedRules(DocCommentHighlightRules, \"doc-\",\n        [ DocCommentHighlightRules.getEndRule(\"no_regex\") ]);\n\n    this.normalizeRules();\n};\n\noop.inherits(JavaScriptHighlightRules, TextHighlightRules);\n\nfunction JSX() {\n    var tagRegex = identifierRe.replace(\"\\\\d\", \"\\\\d\\\\-\");\n    var jsxTag = {\n        onMatch : function(val, state, stack) {\n            var offset = val.charAt(1) == \"/\" ? 2 : 1;\n            if (offset == 1) {\n                if (state != this.nextState)\n                    stack.unshift(this.next, this.nextState, 0);\n                else\n                    stack.unshift(this.next);\n                stack[2]++;\n            } else if (offset == 2) {\n                if (state == this.nextState) {\n                    stack[1]--;\n                    if (!stack[1] || stack[1] < 0) {\n                        stack.shift();\n                        stack.shift();\n                    }\n                }\n            }\n            return [{\n                type: \"meta.tag.punctuation.\" + (offset == 1 ? \"\" : \"end-\") + \"tag-open.xml\",\n                value: val.slice(0, offset)\n            }, {\n                type: \"meta.tag.tag-name.xml\",\n                value: val.substr(offset)\n            }];\n        },\n        regex : \"</?\" + tagRegex + \"\",\n        next: \"jsxAttributes\",\n        nextState: \"jsx\"\n    };\n    this.$rules.start.unshift(jsxTag);\n    var jsxJsRule = {\n        regex: \"{\",\n        token: \"paren.quasi.start\",\n        push: \"start\"\n    };\n    this.$rules.jsx = [\n        jsxJsRule,\n        jsxTag,\n        {include : \"reference\"},\n        {defaultToken: \"string\"}\n    ];\n    this.$rules.jsxAttributes = [{\n        token : \"meta.tag.punctuation.tag-close.xml\",\n        regex : \"/?>\",\n        onMatch : function(value, currentState, stack) {\n            if (currentState == stack[0])\n                stack.shift();\n            if (value.length == 2) {\n                if (stack[0] == this.nextState)\n                    stack[1]--;\n                if (!stack[1] || stack[1] < 0) {\n                    stack.splice(0, 2);\n                }\n            }\n            this.next = stack[0] || \"start\";\n            return [{type: this.token, value: value}];\n        },\n        nextState: \"jsx\"\n    },\n    jsxJsRule,\n    comments(\"jsxAttributes\"),\n    {\n        token : \"entity.other.attribute-name.xml\",\n        regex : tagRegex\n    }, {\n        token : \"keyword.operator.attribute-equals.xml\",\n        regex : \"=\"\n    }, {\n        token : \"text.tag-whitespace.xml\",\n        regex : \"\\\\s+\"\n    }, {\n        token : \"string.attribute-value.xml\",\n        regex : \"'\",\n        stateName : \"jsx_attr_q\",\n        push : [\n            {token : \"string.attribute-value.xml\", regex: \"'\", next: \"pop\"},\n            {include : \"reference\"},\n            {defaultToken : \"string.attribute-value.xml\"}\n        ]\n    }, {\n        token : \"string.attribute-value.xml\",\n        regex : '\"',\n        stateName : \"jsx_attr_qq\",\n        push : [\n            {token : \"string.attribute-value.xml\", regex: '\"', next: \"pop\"},\n            {include : \"reference\"},\n            {defaultToken : \"string.attribute-value.xml\"}\n        ]\n    },\n    jsxTag\n    ];\n    this.$rules.reference = [{\n        token : \"constant.language.escape.reference.xml\",\n        regex : \"(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\\\.-]+;)\"\n    }];\n}\n\nfunction comments(next) {\n    return [\n        {\n            token : \"comment\", // multi line comment\n            regex : /\\/\\*/,\n            next: [\n                DocCommentHighlightRules.getTagRule(),\n                {token : \"comment\", regex : \"\\\\*\\\\/\", next : next || \"pop\"},\n                {defaultToken : \"comment\", caseInsensitive: true}\n            ]\n        }, {\n            token : \"comment\",\n            regex : \"\\\\/\\\\/\",\n            next: [\n                DocCommentHighlightRules.getTagRule(),\n                {token : \"comment\", regex : \"$|^\", next : next || \"pop\"},\n                {defaultToken : \"comment\", caseInsensitive: true}\n            ]\n        }\n    ];\n}\nexports.JavaScriptHighlightRules = JavaScriptHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/range\",\"ace/mode/folding/fold_mode\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Range = require(\"../../range\").Range;\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(commentRegex) {\n    if (commentRegex) {\n        this.foldingStartMarker = new RegExp(\n            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n        );\n        this.foldingStopMarker = new RegExp(\n            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n        );\n    }\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    \n    this.foldingStartMarker = /([\\{\\[\\(])[^\\}\\]\\)]*$|^\\s*(\\/\\*)/;\n    this.foldingStopMarker = /^[^\\[\\{\\(]*([\\}\\]\\)])|^[\\s\\*]*(\\*\\/)/;\n    this.singleLineBlockCommentRe= /^\\s*(\\/\\*).*\\*\\/\\s*$/;\n    this.tripleStarBlockCommentRe = /^\\s*(\\/\\*\\*\\*).*\\*\\/\\s*$/;\n    this.startRegionRe = /^\\s*(\\/\\*|\\/\\/)#?region\\b/;\n    this._getFoldWidgetBase = this.getFoldWidget;\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n    \n        if (this.singleLineBlockCommentRe.test(line)) {\n            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))\n                return \"\";\n        }\n    \n        var fw = this._getFoldWidgetBase(session, foldStyle, row);\n    \n        if (!fw && this.startRegionRe.test(line))\n            return \"start\"; // lineCommentRegionStart\n    \n        return fw;\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n        var line = session.getLine(row);\n        \n        if (this.startRegionRe.test(line))\n            return this.getCommentRegionBlock(session, line, row);\n        \n        var match = line.match(this.foldingStartMarker);\n        if (match) {\n            var i = match.index;\n\n            if (match[1])\n                return this.openingBracketBlock(session, match[1], row, i);\n                \n            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n            \n            if (range && !range.isMultiLine()) {\n                if (forceMultiline) {\n                    range = this.getSectionRange(session, row);\n                } else if (foldStyle != \"all\")\n                    range = null;\n            }\n            \n            return range;\n        }\n\n        if (foldStyle === \"markbegin\")\n            return;\n\n        var match = line.match(this.foldingStopMarker);\n        if (match) {\n            var i = match.index + match[0].length;\n\n            if (match[1])\n                return this.closingBracketBlock(session, match[1], row, i);\n\n            return session.getCommentFoldRange(row, i, -1);\n        }\n    };\n    \n    this.getSectionRange = function(session, row) {\n        var line = session.getLine(row);\n        var startIndent = line.search(/\\S/);\n        var startRow = row;\n        var startColumn = line.length;\n        row = row + 1;\n        var endRow = row;\n        var maxRow = session.getLength();\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var indent = line.search(/\\S/);\n            if (indent === -1)\n                continue;\n            if  (startIndent > indent)\n                break;\n            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n            \n            if (subRange) {\n                if (subRange.start.row <= startRow) {\n                    break;\n                } else if (subRange.isMultiLine()) {\n                    row = subRange.end.row;\n                } else if (startIndent == indent) {\n                    break;\n                }\n            }\n            endRow = row;\n        }\n        \n        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n    };\n    this.getCommentRegionBlock = function(session, line, row) {\n        var startColumn = line.search(/\\s*$/);\n        var maxRow = session.getLength();\n        var startRow = row;\n        \n        var re = /^\\s*(?:\\/\\*|\\/\\/|--)#?(end)?region\\b/;\n        var depth = 1;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var m = re.exec(line);\n            if (!m) continue;\n            if (m[1]) depth--;\n            else depth++;\n\n            if (!depth) break;\n        }\n\n        var endRow = row;\n        if (endRow > startRow) {\n            return new Range(startRow, startColumn, endRow, line.length);\n        }\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/javascript\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/javascript_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/worker/worker_client\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar JavaScriptHighlightRules = require(\"./javascript_highlight_rules\").JavaScriptHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = JavaScriptHighlightRules;\n    \n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n    this.foldingRules = new CStyleFoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.lineCommentStart = \"//\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n    this.$quotes = {'\"': '\"', \"'\": \"'\", \"`\": \"`\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        var endState = tokenizedLine.state;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\" || state == \"no_regex\") {\n            var match = line.match(/^.*(?:\\bcase\\b.*:|[\\{\\(\\[])\\s*$/);\n            if (match) {\n                indent += tab;\n            }\n        } else if (state == \"doc-start\") {\n            if (endState == \"start\" || endState == \"no_regex\") {\n                return \"\";\n            }\n            var match = line.match(/^\\s*(\\/?)\\*/);\n            if (match) {\n                if (match[1]) {\n                    indent += \" \";\n                }\n                indent += \"* \";\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/javascript_worker\", \"JavaScriptWorker\");\n        worker.attachToDocument(session.getDocument());\n\n        worker.on(\"annotate\", function(results) {\n            session.setAnnotations(results.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n    this.$id = \"ace/mode/javascript\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/mode/xml_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar XmlHighlightRules = function(normalize) {\n    var tagRegex = \"[_:a-zA-Z\\xc0-\\uffff][-_:.a-zA-Z0-9\\xc0-\\uffff]*\";\n\n    this.$rules = {\n        start : [\n            {token : \"string.cdata.xml\", regex : \"<\\\\!\\\\[CDATA\\\\[\", next : \"cdata\"},\n            {\n                token : [\"punctuation.instruction.xml\", \"keyword.instruction.xml\"],\n                regex : \"(<\\\\?)(\" + tagRegex + \")\", next : \"processing_instruction\"\n            },\n            {token : \"comment.start.xml\", regex : \"<\\\\!--\", next : \"comment\"},\n            {\n                token : [\"xml-pe.doctype.xml\", \"xml-pe.doctype.xml\"],\n                regex : \"(<\\\\!)(DOCTYPE)(?=[\\\\s])\", next : \"doctype\", caseInsensitive: true\n            },\n            {include : \"tag\"},\n            {token : \"text.end-tag-open.xml\", regex: \"</\"},\n            {token : \"text.tag-open.xml\", regex: \"<\"},\n            {include : \"reference\"},\n            {defaultToken : \"text.xml\"}\n        ],\n\n        processing_instruction : [{\n            token : \"entity.other.attribute-name.decl-attribute-name.xml\",\n            regex : tagRegex\n        }, {\n            token : \"keyword.operator.decl-attribute-equals.xml\",\n            regex : \"=\"\n        }, {\n            include: \"whitespace\"\n        }, {\n            include: \"string\"\n        }, {\n            token : \"punctuation.xml-decl.xml\",\n            regex : \"\\\\?>\",\n            next : \"start\"\n        }],\n\n        doctype : [\n            {include : \"whitespace\"},\n            {include : \"string\"},\n            {token : \"xml-pe.doctype.xml\", regex : \">\", next : \"start\"},\n            {token : \"xml-pe.xml\", regex : \"[-_a-zA-Z0-9:]+\"},\n            {token : \"punctuation.int-subset\", regex : \"\\\\[\", push : \"int_subset\"}\n        ],\n\n        int_subset : [{\n            token : \"text.xml\",\n            regex : \"\\\\s+\"\n        }, {\n            token: \"punctuation.int-subset.xml\",\n            regex: \"]\",\n            next: \"pop\"\n        }, {\n            token : [\"punctuation.markup-decl.xml\", \"keyword.markup-decl.xml\"],\n            regex : \"(<\\\\!)(\" + tagRegex + \")\",\n            push : [{\n                token : \"text\",\n                regex : \"\\\\s+\"\n            },\n            {\n                token : \"punctuation.markup-decl.xml\",\n                regex : \">\",\n                next : \"pop\"\n            },\n            {include : \"string\"}]\n        }],\n\n        cdata : [\n            {token : \"string.cdata.xml\", regex : \"\\\\]\\\\]>\", next : \"start\"},\n            {token : \"text.xml\", regex : \"\\\\s+\"},\n            {token : \"text.xml\", regex : \"(?:[^\\\\]]|\\\\](?!\\\\]>))+\"}\n        ],\n\n        comment : [\n            {token : \"comment.end.xml\", regex : \"-->\", next : \"start\"},\n            {defaultToken : \"comment.xml\"}\n        ],\n\n        reference : [{\n            token : \"constant.language.escape.reference.xml\",\n            regex : \"(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\\\.-]+;)\"\n        }],\n\n        attr_reference : [{\n            token : \"constant.language.escape.reference.attribute-value.xml\",\n            regex : \"(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\\\.-]+;)\"\n        }],\n\n        tag : [{\n            token : [\"meta.tag.punctuation.tag-open.xml\", \"meta.tag.punctuation.end-tag-open.xml\", \"meta.tag.tag-name.xml\"],\n            regex : \"(?:(<)|(</))((?:\" + tagRegex + \":)?\" + tagRegex + \")\",\n            next: [\n                {include : \"attributes\"},\n                {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\", next : \"start\"}\n            ]\n        }],\n\n        tag_whitespace : [\n            {token : \"text.tag-whitespace.xml\", regex : \"\\\\s+\"}\n        ],\n        whitespace : [\n            {token : \"text.whitespace.xml\", regex : \"\\\\s+\"}\n        ],\n        string: [{\n            token : \"string.xml\",\n            regex : \"'\",\n            push : [\n                {token : \"string.xml\", regex: \"'\", next: \"pop\"},\n                {defaultToken : \"string.xml\"}\n            ]\n        }, {\n            token : \"string.xml\",\n            regex : '\"',\n            push : [\n                {token : \"string.xml\", regex: '\"', next: \"pop\"},\n                {defaultToken : \"string.xml\"}\n            ]\n        }],\n\n        attributes: [{\n            token : \"entity.other.attribute-name.xml\",\n            regex : tagRegex\n        }, {\n            token : \"keyword.operator.attribute-equals.xml\",\n            regex : \"=\"\n        }, {\n            include: \"tag_whitespace\"\n        }, {\n            include: \"attribute_value\"\n        }],\n\n        attribute_value: [{\n            token : \"string.attribute-value.xml\",\n            regex : \"'\",\n            push : [\n                {token : \"string.attribute-value.xml\", regex: \"'\", next: \"pop\"},\n                {include : \"attr_reference\"},\n                {defaultToken : \"string.attribute-value.xml\"}\n            ]\n        }, {\n            token : \"string.attribute-value.xml\",\n            regex : '\"',\n            push : [\n                {token : \"string.attribute-value.xml\", regex: '\"', next: \"pop\"},\n                {include : \"attr_reference\"},\n                {defaultToken : \"string.attribute-value.xml\"}\n            ]\n        }]\n    };\n\n    if (this.constructor === XmlHighlightRules)\n        this.normalizeRules();\n};\n\n\n(function() {\n\n    this.embedTagRules = function(HighlightRules, prefix, tag){\n        this.$rules.tag.unshift({\n            token : [\"meta.tag.punctuation.tag-open.xml\", \"meta.tag.\" + tag + \".tag-name.xml\"],\n            regex : \"(<)(\" + tag + \"(?=\\\\s|>|$))\",\n            next: [\n                {include : \"attributes\"},\n                {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\", next : prefix + \"start\"}\n            ]\n        });\n\n        this.$rules[tag + \"-end\"] = [\n            {include : \"attributes\"},\n            {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\",  next: \"start\",\n                onMatch : function(value, currentState, stack) {\n                    stack.splice(0);\n                    return this.token;\n            }}\n        ];\n\n        this.embedRules(HighlightRules, prefix, [{\n            token: [\"meta.tag.punctuation.end-tag-open.xml\", \"meta.tag.\" + tag + \".tag-name.xml\"],\n            regex : \"(</)(\" + tag + \"(?=\\\\s|>|$))\",\n            next: tag + \"-end\"\n        }, {\n            token: \"string.cdata.xml\",\n            regex : \"<\\\\!\\\\[CDATA\\\\[\"\n        }, {\n            token: \"string.cdata.xml\",\n            regex : \"\\\\]\\\\]>\"\n        }]);\n    };\n\n}).call(TextHighlightRules.prototype);\n\noop.inherits(XmlHighlightRules, TextHighlightRules);\n\nexports.XmlHighlightRules = XmlHighlightRules;\n});\n\nace.define(\"ace/mode/behaviour/xml\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar lang = require(\"../../lib/lang\");\n\nfunction is(token, type) {\n    return token && token.type.lastIndexOf(type + \".xml\") > -1;\n}\n\nvar XmlBehaviour = function () {\n\n    this.add(\"string_dquotes\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '\"' || text == \"'\") {\n            var quote = text;\n            var selected = session.doc.getTextRange(editor.getSelectionRange());\n            if (selected !== \"\" && selected !== \"'\" && selected != '\"' && editor.getWrapBehavioursEnabled()) {\n                return {\n                    text: quote + selected + quote,\n                    selection: false\n                };\n            }\n\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n\n            if (rightChar == quote && (is(token, \"attribute-value\") || is(token, \"string\"))) {\n                return {\n                    text: \"\",\n                    selection: [1, 1]\n                };\n            }\n\n            if (!token)\n                token = iterator.stepBackward();\n\n            if (!token)\n                return;\n\n            while (is(token, \"tag-whitespace\") || is(token, \"whitespace\")) {\n                token = iterator.stepBackward();\n            }\n            var rightSpace = !rightChar || rightChar.match(/\\s/);\n            if (is(token, \"attribute-equals\") && (rightSpace || rightChar == '>') || (is(token, \"decl-attribute-equals\") && (rightSpace || rightChar == '?'))) {\n                return {\n                    text: quote + quote,\n                    selection: [1, 1]\n                };\n            }\n        }\n    });\n\n    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && (selected == '\"' || selected == \"'\")) {\n            var line = session.doc.getLine(range.start.row);\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n            if (rightChar == selected) {\n                range.end.column++;\n                return range;\n            }\n        }\n    });\n\n    this.add(\"autoclosing\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == '>') {\n            var position = editor.getSelectionRange().start;\n            var iterator = new TokenIterator(session, position.row, position.column);\n            var token = iterator.getCurrentToken() || iterator.stepBackward();\n            if (!token || !(is(token, \"tag-name\") || is(token, \"tag-whitespace\") || is(token, \"attribute-name\") || is(token, \"attribute-equals\") || is(token, \"attribute-value\")))\n                return;\n            if (is(token, \"reference.attribute-value\"))\n                return;\n            if (is(token, \"attribute-value\")) {\n                var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;\n                if (position.column < tokenEndColumn)\n                    return;\n                if (position.column == tokenEndColumn) {\n                    var nextToken = iterator.stepForward();\n                    if (nextToken && is(nextToken, \"attribute-value\"))\n                        return;\n                    iterator.stepBackward();\n                }\n            }\n            \n            if (/^\\s*>/.test(session.getLine(position.row).slice(position.column)))\n                return;\n            while (!is(token, \"tag-name\")) {\n                token = iterator.stepBackward();\n                if (token.value == \"<\") {\n                    token = iterator.stepForward();\n                    break;\n                }\n            }\n\n            var tokenRow = iterator.getCurrentTokenRow();\n            var tokenColumn = iterator.getCurrentTokenColumn();\n            if (is(iterator.stepBackward(), \"end-tag-open\"))\n                return;\n\n            var element = token.value;\n            if (tokenRow == position.row)\n                element = element.substring(0, position.column - tokenColumn);\n\n            if (this.voidElements.hasOwnProperty(element.toLowerCase()))\n                 return;\n\n            return {\n               text: \">\" + \"</\" + element + \">\",\n               selection: [1, 1]\n            };\n        }\n    });\n\n    this.add(\"autoindent\", \"insertion\", function (state, action, editor, session, text) {\n        if (text == \"\\n\") {\n            var cursor = editor.getCursorPosition();\n            var line = session.getLine(cursor.row);\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n\n            if (token && token.type.indexOf(\"tag-close\") !== -1) {\n                if (token.value == \"/>\")\n                    return;\n                while (token && token.type.indexOf(\"tag-name\") === -1) {\n                    token = iterator.stepBackward();\n                }\n\n                if (!token) {\n                    return;\n                }\n\n                var tag = token.value;\n                var row = iterator.getCurrentTokenRow();\n                token = iterator.stepBackward();\n                if (!token || token.type.indexOf(\"end-tag\") !== -1) {\n                    return;\n                }\n\n                if (this.voidElements && !this.voidElements[tag]) {\n                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);\n                    var line = session.getLine(row);\n                    var nextIndent = this.$getIndent(line);\n                    var indent = nextIndent + session.getTabString();\n\n                    if (nextToken && nextToken.value === \"</\") {\n                        return {\n                            text: \"\\n\" + indent + \"\\n\" + nextIndent,\n                            selection: [1, indent.length, 1, indent.length]\n                        };\n                    } else {\n                        return {\n                            text: \"\\n\" + indent\n                        };\n                    }\n                }\n            }\n        }\n    });\n\n};\n\noop.inherits(XmlBehaviour, Behaviour);\n\nexports.XmlBehaviour = XmlBehaviour;\n});\n\nace.define(\"ace/mode/folding/xml\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/range\",\"ace/mode/folding/fold_mode\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar lang = require(\"../../lib/lang\");\nvar Range = require(\"../../range\").Range;\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\nvar FoldMode = exports.FoldMode = function(voidElements, optionalEndTags) {\n    BaseFoldMode.call(this);\n    this.voidElements = voidElements || {};\n    this.optionalEndTags = oop.mixin({}, this.voidElements);\n    if (optionalEndTags)\n        oop.mixin(this.optionalEndTags, optionalEndTags);\n    \n};\noop.inherits(FoldMode, BaseFoldMode);\n\nvar Tag = function() {\n    this.tagName = \"\";\n    this.closing = false;\n    this.selfClosing = false;\n    this.start = {row: 0, column: 0};\n    this.end = {row: 0, column: 0};\n};\n\nfunction is(token, type) {\n    return token.type.lastIndexOf(type + \".xml\") > -1;\n}\n\n(function() {\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var tag = this._getFirstTagInLine(session, row);\n\n        if (!tag)\n            return this.getCommentFoldWidget(session, row);\n\n        if (tag.closing || (!tag.tagName && tag.selfClosing))\n            return foldStyle == \"markbeginend\" ? \"end\" : \"\";\n\n        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))\n            return \"\";\n\n        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))\n            return \"\";\n\n        return \"start\";\n    };\n    \n    this.getCommentFoldWidget = function(session, row) {\n        if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))\n            return \"start\";\n        return \"\";\n    };\n    this._getFirstTagInLine = function(session, row) {\n        var tokens = session.getTokens(row);\n        var tag = new Tag();\n\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (is(token, \"tag-open\")) {\n                tag.end.column = tag.start.column + token.value.length;\n                tag.closing = is(token, \"end-tag-open\");\n                token = tokens[++i];\n                if (!token)\n                    return null;\n                tag.tagName = token.value;\n                tag.end.column += token.value.length;\n                for (i++; i < tokens.length; i++) {\n                    token = tokens[i];\n                    tag.end.column += token.value.length;\n                    if (is(token, \"tag-close\")) {\n                        tag.selfClosing = token.value == '/>';\n                        break;\n                    }\n                }\n                return tag;\n            } else if (is(token, \"tag-close\")) {\n                tag.selfClosing = token.value == '/>';\n                return tag;\n            }\n            tag.start.column += token.value.length;\n        }\n\n        return null;\n    };\n\n    this._findEndTagInLine = function(session, row, tagName, startColumn) {\n        var tokens = session.getTokens(row);\n        var column = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            column += token.value.length;\n            if (column < startColumn)\n                continue;\n            if (is(token, \"end-tag-open\")) {\n                token = tokens[i + 1];\n                if (token && token.value == tagName)\n                    return true;\n            }\n        }\n        return false;\n    };\n    this._readTagForward = function(iterator) {\n        var token = iterator.getCurrentToken();\n        if (!token)\n            return null;\n\n        var tag = new Tag();\n        do {\n            if (is(token, \"tag-open\")) {\n                tag.closing = is(token, \"end-tag-open\");\n                tag.start.row = iterator.getCurrentTokenRow();\n                tag.start.column = iterator.getCurrentTokenColumn();\n            } else if (is(token, \"tag-name\")) {\n                tag.tagName = token.value;\n            } else if (is(token, \"tag-close\")) {\n                tag.selfClosing = token.value == \"/>\";\n                tag.end.row = iterator.getCurrentTokenRow();\n                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;\n                iterator.stepForward();\n                return tag;\n            }\n        } while(token = iterator.stepForward());\n\n        return null;\n    };\n    \n    this._readTagBackward = function(iterator) {\n        var token = iterator.getCurrentToken();\n        if (!token)\n            return null;\n\n        var tag = new Tag();\n        do {\n            if (is(token, \"tag-open\")) {\n                tag.closing = is(token, \"end-tag-open\");\n                tag.start.row = iterator.getCurrentTokenRow();\n                tag.start.column = iterator.getCurrentTokenColumn();\n                iterator.stepBackward();\n                return tag;\n            } else if (is(token, \"tag-name\")) {\n                tag.tagName = token.value;\n            } else if (is(token, \"tag-close\")) {\n                tag.selfClosing = token.value == \"/>\";\n                tag.end.row = iterator.getCurrentTokenRow();\n                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;\n            }\n        } while(token = iterator.stepBackward());\n\n        return null;\n    };\n    \n    this._pop = function(stack, tag) {\n        while (stack.length) {\n            \n            var top = stack[stack.length-1];\n            if (!tag || top.tagName == tag.tagName) {\n                return stack.pop();\n            }\n            else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {\n                stack.pop();\n                continue;\n            } else {\n                return null;\n            }\n        }\n    };\n    \n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var firstTag = this._getFirstTagInLine(session, row);\n        \n        if (!firstTag) {\n            return this.getCommentFoldWidget(session, row)\n                && session.getCommentFoldRange(row, session.getLine(row).length);\n        }\n        \n        var isBackward = firstTag.closing || firstTag.selfClosing;\n        var stack = [];\n        var tag;\n        \n        if (!isBackward) {\n            var iterator = new TokenIterator(session, row, firstTag.start.column);\n            var start = {\n                row: row,\n                column: firstTag.start.column + firstTag.tagName.length + 2\n            };\n            if (firstTag.start.row == firstTag.end.row)\n                start.column = firstTag.end.column;\n            while (tag = this._readTagForward(iterator)) {\n                if (tag.selfClosing) {\n                    if (!stack.length) {\n                        tag.start.column += tag.tagName.length + 2;\n                        tag.end.column -= 2;\n                        return Range.fromPoints(tag.start, tag.end);\n                    } else\n                        continue;\n                }\n                \n                if (tag.closing) {\n                    this._pop(stack, tag);\n                    if (stack.length == 0)\n                        return Range.fromPoints(start, tag.start);\n                }\n                else {\n                    stack.push(tag);\n                }\n            }\n        }\n        else {\n            var iterator = new TokenIterator(session, row, firstTag.end.column);\n            var end = {\n                row: row,\n                column: firstTag.start.column\n            };\n            \n            while (tag = this._readTagBackward(iterator)) {\n                if (tag.selfClosing) {\n                    if (!stack.length) {\n                        tag.start.column += tag.tagName.length + 2;\n                        tag.end.column -= 2;\n                        return Range.fromPoints(tag.start, tag.end);\n                    } else\n                        continue;\n                }\n                \n                if (!tag.closing) {\n                    this._pop(stack, tag);\n                    if (stack.length == 0) {\n                        tag.start.column += tag.tagName.length + 2;\n                        if (tag.start.row == tag.end.row && tag.start.column < tag.end.column)\n                            tag.start.column = tag.end.column;\n                        return Range.fromPoints(tag.start, end);\n                    }\n                }\n                else {\n                    stack.push(tag);\n                }\n            }\n        }\n        \n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/xml\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text\",\"ace/mode/xml_highlight_rules\",\"ace/mode/behaviour/xml\",\"ace/mode/folding/xml\",\"ace/worker/worker_client\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextMode = require(\"./text\").Mode;\nvar XmlHighlightRules = require(\"./xml_highlight_rules\").XmlHighlightRules;\nvar XmlBehaviour = require(\"./behaviour/xml\").XmlBehaviour;\nvar XmlFoldMode = require(\"./folding/xml\").FoldMode;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\n\nvar Mode = function() {\n   this.HighlightRules = XmlHighlightRules;\n   this.$behaviour = new XmlBehaviour();\n   this.foldingRules = new XmlFoldMode();\n};\n\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.voidElements = lang.arrayToMap([]);\n\n    this.blockComment = {start: \"<!--\", end: \"-->\"};\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/xml_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n\n        worker.on(\"error\", function(e) {\n            session.setAnnotations(e.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n    \n    this.$id = \"ace/mode/xml\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/mode/css_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar supportType = exports.supportType = \"align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|max-zoom|min-height|min-width|min-zoom|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|user-select|user-zoom|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index\";\nvar supportFunction = exports.supportFunction = \"rgb|rgba|url|attr|counter|counters\";\nvar supportConstant = exports.supportConstant = \"absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero|zoom\";\nvar supportConstantColor = exports.supportConstantColor = \"aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen\";\nvar supportConstantFonts = exports.supportConstantFonts = \"arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace\";\n\nvar numRe = exports.numRe = \"\\\\-?(?:(?:[0-9]+(?:\\\\.[0-9]+)?)|(?:\\\\.[0-9]+))\";\nvar pseudoElements = exports.pseudoElements = \"(\\\\:+)\\\\b(after|before|first-letter|first-line|moz-selection|selection)\\\\b\";\nvar pseudoClasses  = exports.pseudoClasses =  \"(:)\\\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\\\b\";\n\nvar CssHighlightRules = function() {\n\n    var keywordMapper = this.createKeywordMapper({\n        \"support.function\": supportFunction,\n        \"support.constant\": supportConstant,\n        \"support.type\": supportType,\n        \"support.constant.color\": supportConstantColor,\n        \"support.constant.fonts\": supportConstantFonts\n    }, \"text\", true);\n\n    this.$rules = {\n        \"start\" : [{\n            include : [\"strings\", \"url\", \"comments\"]\n        }, {\n            token: \"paren.lparen\",\n            regex: \"\\\\{\",\n            next:  \"ruleset\"\n        }, {\n            token: \"paren.rparen\",\n            regex: \"\\\\}\"\n        }, {\n            token: \"string\",\n            regex: \"@(?!viewport)\",\n            next:  \"media\"\n        }, {\n            token: \"keyword\",\n            regex: \"#[a-z0-9-_]+\"\n        }, {\n            token: \"keyword\",\n            regex: \"%\"\n        }, {\n            token: \"variable\",\n            regex: \"\\\\.[a-z0-9-_]+\"\n        }, {\n            token: \"string\",\n            regex: \":[a-z0-9-_]+\"\n        }, {\n            token : \"constant.numeric\",\n            regex : numRe\n        }, {\n            token: \"constant\",\n            regex: \"[a-z0-9-_]+\"\n        }, {\n            caseInsensitive: true\n        }],\n\n        \"media\": [{\n            include : [\"strings\", \"url\", \"comments\"]\n        }, {\n            token: \"paren.lparen\",\n            regex: \"\\\\{\",\n            next:  \"start\"\n        }, {\n            token: \"paren.rparen\",\n            regex: \"\\\\}\",\n            next:  \"start\"\n        }, {\n            token: \"string\",\n            regex: \";\",\n            next:  \"start\"\n        }, {\n            token: \"keyword\",\n            regex: \"(?:media|supports|document|charset|import|namespace|media|supports|document\"\n                + \"|page|font|keyframes|viewport|counter-style|font-feature-values\"\n                + \"|swash|ornaments|annotation|stylistic|styleset|character-variant)\"\n        }],\n\n        \"comments\" : [{\n            token: \"comment\", // multi line comment\n            regex: \"\\\\/\\\\*\",\n            push: [{\n                token : \"comment\",\n                regex : \"\\\\*\\\\/\",\n                next : \"pop\"\n            }, {\n                defaultToken : \"comment\"\n            }]\n        }],\n\n        \"ruleset\" : [{\n            regex : \"-(webkit|ms|moz|o)-\",\n            token : \"text\"\n        }, {\n            token : \"punctuation.operator\",\n            regex : \"[:;]\"\n        }, {\n            token : \"paren.rparen\",\n            regex : \"\\\\}\",\n            next : \"start\"\n        }, {\n            include : [\"strings\", \"url\", \"comments\"]\n        }, {\n            token : [\"constant.numeric\", \"keyword\"],\n            regex : \"(\" + numRe + \")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vm|vw|%)\"\n        }, {\n            token : \"constant.numeric\",\n            regex : numRe\n        }, {\n            token : \"constant.numeric\",  // hex6 color\n            regex : \"#[a-f0-9]{6}\"\n        }, {\n            token : \"constant.numeric\", // hex3 color\n            regex : \"#[a-f0-9]{3}\"\n        }, {\n            token : [\"punctuation\", \"entity.other.attribute-name.pseudo-element.css\"],\n            regex : pseudoElements\n        }, {\n            token : [\"punctuation\", \"entity.other.attribute-name.pseudo-class.css\"],\n            regex : pseudoClasses\n        }, {\n            include: \"url\"\n        }, {\n            token : keywordMapper,\n            regex : \"\\\\-?[a-zA-Z_][a-zA-Z0-9_\\\\-]*\"\n        }, {\n            caseInsensitive: true\n        }],\n\n        url: [{\n            token : \"support.function\",\n            regex : \"(?:url(:?-prefix)?|domain|regexp)\\\\(\",\n            push: [{\n                token : \"support.function\",\n                regex : \"\\\\)\",\n                next : \"pop\"\n            }, {\n                defaultToken: \"string\"\n            }]\n        }],\n\n        strings: [{\n            token : \"string.start\",\n            regex : \"'\",\n            push : [{\n                token : \"string.end\",\n                regex : \"'|$\",\n                next: \"pop\"\n            }, {\n                include : \"escapes\"\n            }, {\n                token : \"constant.language.escape\",\n                regex : /\\\\$/,\n                consumeLineEnd: true\n            }, {\n                defaultToken: \"string\"\n            }]\n        }, {\n            token : \"string.start\",\n            regex : '\"',\n            push : [{\n                token : \"string.end\",\n                regex : '\"|$',\n                next: \"pop\"\n            }, {\n                include : \"escapes\"\n            }, {\n                token : \"constant.language.escape\",\n                regex : /\\\\$/,\n                consumeLineEnd: true\n            }, {\n                defaultToken: \"string\"\n            }]\n        }],\n        escapes: [{\n            token : \"constant.language.escape\",\n            regex : /\\\\([a-fA-F\\d]{1,6}|[^a-fA-F\\d])/\n        }]\n\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(CssHighlightRules, TextHighlightRules);\n\nexports.CssHighlightRules = CssHighlightRules;\n\n});\n\nace.define(\"ace/mode/css_completions\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nvar propertyMap = {\n    \"background\": {\"#$0\": 1},\n    \"background-color\": {\"#$0\": 1, \"transparent\": 1, \"fixed\": 1},\n    \"background-image\": {\"url('/$0')\": 1},\n    \"background-repeat\": {\"repeat\": 1, \"repeat-x\": 1, \"repeat-y\": 1, \"no-repeat\": 1, \"inherit\": 1},\n    \"background-position\": {\"bottom\":2, \"center\":2, \"left\":2, \"right\":2, \"top\":2, \"inherit\":2},\n    \"background-attachment\": {\"scroll\": 1, \"fixed\": 1},\n    \"background-size\": {\"cover\": 1, \"contain\": 1},\n    \"background-clip\": {\"border-box\": 1, \"padding-box\": 1, \"content-box\": 1},\n    \"background-origin\": {\"border-box\": 1, \"padding-box\": 1, \"content-box\": 1},\n    \"border\": {\"solid $0\": 1, \"dashed $0\": 1, \"dotted $0\": 1, \"#$0\": 1},\n    \"border-color\": {\"#$0\": 1},\n    \"border-style\": {\"solid\":2, \"dashed\":2, \"dotted\":2, \"double\":2, \"groove\":2, \"hidden\":2, \"inherit\":2, \"inset\":2, \"none\":2, \"outset\":2, \"ridged\":2},\n    \"border-collapse\": {\"collapse\": 1, \"separate\": 1},\n    \"bottom\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"clear\": {\"left\": 1, \"right\": 1, \"both\": 1, \"none\": 1},\n    \"color\": {\"#$0\": 1, \"rgb(#$00,0,0)\": 1},\n    \"cursor\": {\"default\": 1, \"pointer\": 1, \"move\": 1, \"text\": 1, \"wait\": 1, \"help\": 1, \"progress\": 1, \"n-resize\": 1, \"ne-resize\": 1, \"e-resize\": 1, \"se-resize\": 1, \"s-resize\": 1, \"sw-resize\": 1, \"w-resize\": 1, \"nw-resize\": 1},\n    \"display\": {\"none\": 1, \"block\": 1, \"inline\": 1, \"inline-block\": 1, \"table-cell\": 1},\n    \"empty-cells\": {\"show\": 1, \"hide\": 1},\n    \"float\": {\"left\": 1, \"right\": 1, \"none\": 1},\n    \"font-family\": {\"Arial\":2,\"Comic Sans MS\":2,\"Consolas\":2,\"Courier New\":2,\"Courier\":2,\"Georgia\":2,\"Monospace\":2,\"Sans-Serif\":2, \"Segoe UI\":2,\"Tahoma\":2,\"Times New Roman\":2,\"Trebuchet MS\":2,\"Verdana\": 1},\n    \"font-size\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"font-weight\": {\"bold\": 1, \"normal\": 1},\n    \"font-style\": {\"italic\": 1, \"normal\": 1},\n    \"font-variant\": {\"normal\": 1, \"small-caps\": 1},\n    \"height\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"left\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"letter-spacing\": {\"normal\": 1},\n    \"line-height\": {\"normal\": 1},\n    \"list-style-type\": {\"none\": 1, \"disc\": 1, \"circle\": 1, \"square\": 1, \"decimal\": 1, \"decimal-leading-zero\": 1, \"lower-roman\": 1, \"upper-roman\": 1, \"lower-greek\": 1, \"lower-latin\": 1, \"upper-latin\": 1, \"georgian\": 1, \"lower-alpha\": 1, \"upper-alpha\": 1},\n    \"margin\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-right\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-left\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-top\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"margin-bottom\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"max-height\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"max-width\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"min-height\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"min-width\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"overflow\": {\"hidden\": 1, \"visible\": 1, \"auto\": 1, \"scroll\": 1},\n    \"overflow-x\": {\"hidden\": 1, \"visible\": 1, \"auto\": 1, \"scroll\": 1},\n    \"overflow-y\": {\"hidden\": 1, \"visible\": 1, \"auto\": 1, \"scroll\": 1},\n    \"padding\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-top\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-right\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-bottom\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"padding-left\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"page-break-after\": {\"auto\": 1, \"always\": 1, \"avoid\": 1, \"left\": 1, \"right\": 1},\n    \"page-break-before\": {\"auto\": 1, \"always\": 1, \"avoid\": 1, \"left\": 1, \"right\": 1},\n    \"position\": {\"absolute\": 1, \"relative\": 1, \"fixed\": 1, \"static\": 1},\n    \"right\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"table-layout\": {\"fixed\": 1, \"auto\": 1},\n    \"text-decoration\": {\"none\": 1, \"underline\": 1, \"line-through\": 1, \"blink\": 1},\n    \"text-align\": {\"left\": 1, \"right\": 1, \"center\": 1, \"justify\": 1},\n    \"text-transform\": {\"capitalize\": 1, \"uppercase\": 1, \"lowercase\": 1, \"none\": 1},\n    \"top\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"vertical-align\": {\"top\": 1, \"bottom\": 1},\n    \"visibility\": {\"hidden\": 1, \"visible\": 1},\n    \"white-space\": {\"nowrap\": 1, \"normal\": 1, \"pre\": 1, \"pre-line\": 1, \"pre-wrap\": 1},\n    \"width\": {\"px\": 1, \"em\": 1, \"%\": 1},\n    \"word-spacing\": {\"normal\": 1},\n    \"filter\": {\"alpha(opacity=$0100)\": 1},\n\n    \"text-shadow\": {\"$02px 2px 2px #777\": 1},\n    \"text-overflow\": {\"ellipsis-word\": 1, \"clip\": 1, \"ellipsis\": 1},\n    \"-moz-border-radius\": 1,\n    \"-moz-border-radius-topright\": 1,\n    \"-moz-border-radius-bottomright\": 1,\n    \"-moz-border-radius-topleft\": 1,\n    \"-moz-border-radius-bottomleft\": 1,\n    \"-webkit-border-radius\": 1,\n    \"-webkit-border-top-right-radius\": 1,\n    \"-webkit-border-top-left-radius\": 1,\n    \"-webkit-border-bottom-right-radius\": 1,\n    \"-webkit-border-bottom-left-radius\": 1,\n    \"-moz-box-shadow\": 1,\n    \"-webkit-box-shadow\": 1,\n    \"transform\": {\"rotate($00deg)\": 1, \"skew($00deg)\": 1},\n    \"-moz-transform\": {\"rotate($00deg)\": 1, \"skew($00deg)\": 1},\n    \"-webkit-transform\": {\"rotate($00deg)\": 1, \"skew($00deg)\": 1 }\n};\n\nvar CssCompletions = function() {\n\n};\n\n(function() {\n\n    this.completionsDefined = false;\n\n    this.defineCompletions = function() {\n        if (document) {\n            var style = document.createElement('c').style;\n\n            for (var i in style) {\n                if (typeof style[i] !== 'string')\n                    continue;\n\n                var name = i.replace(/[A-Z]/g, function(x) {\n                    return '-' + x.toLowerCase();\n                });\n\n                if (!propertyMap.hasOwnProperty(name))\n                    propertyMap[name] = 1;\n            }\n        }\n\n        this.completionsDefined = true;\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        if (!this.completionsDefined) {\n            this.defineCompletions();\n        }\n\n        if (state==='ruleset' || session.$mode.$id == \"ace/mode/scss\") {\n            var line = session.getLine(pos.row).substr(0, pos.column);\n            if (/:[^;]+$/.test(line)) {\n                /([\\w\\-]+):[^:]*$/.test(line);\n\n                return this.getPropertyValueCompletions(state, session, pos, prefix);\n            } else {\n                return this.getPropertyCompletions(state, session, pos, prefix);\n            }\n        }\n\n        return [];\n    };\n\n    this.getPropertyCompletions = function(state, session, pos, prefix) {\n        var properties = Object.keys(propertyMap);\n        return properties.map(function(property){\n            return {\n                caption: property,\n                snippet: property + ': $0;',\n                meta: \"property\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getPropertyValueCompletions = function(state, session, pos, prefix) {\n        var line = session.getLine(pos.row).substr(0, pos.column);\n        var property = (/([\\w\\-]+):[^:]*$/.exec(line) || {})[1];\n\n        if (!property)\n            return [];\n        var values = [];\n        if (property in propertyMap && typeof propertyMap[property] === \"object\") {\n            values = Object.keys(propertyMap[property]);\n        }\n        return values.map(function(value){\n            return {\n                caption: value,\n                snippet: value,\n                meta: \"property value\",\n                score: 1000000\n            };\n        });\n    };\n\n}).call(CssCompletions.prototype);\n\nexports.CssCompletions = CssCompletions;\n});\n\nace.define(\"ace/mode/behaviour/css\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/mode/behaviour/cstyle\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar Behaviour = require(\"../behaviour\").Behaviour;\nvar CstyleBehaviour = require(\"./cstyle\").CstyleBehaviour;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\nvar CssBehaviour = function () {\n\n    this.inherit(CstyleBehaviour);\n\n    this.add(\"colon\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === ':' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            if (token && token.value.match(/\\s+/)) {\n                token = iterator.stepBackward();\n            }\n            if (token && token.type === 'support.type') {\n                var line = session.doc.getLine(cursor.row);\n                var rightChar = line.substring(cursor.column, cursor.column + 1);\n                if (rightChar === ':') {\n                    return {\n                       text: '',\n                       selection: [1, 1]\n                    };\n                }\n                if (/^(\\s+[^;]|\\s*$)/.test(line.substring(cursor.column))) {\n                    return {\n                       text: ':;',\n                       selection: [1, 1]\n                    };\n                }\n            }\n        }\n    });\n\n    this.add(\"colon\", \"deletion\", function (state, action, editor, session, range) {\n        var selected = session.doc.getTextRange(range);\n        if (!range.isMultiLine() && selected === ':') {\n            var cursor = editor.getCursorPosition();\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n            var token = iterator.getCurrentToken();\n            if (token && token.value.match(/\\s+/)) {\n                token = iterator.stepBackward();\n            }\n            if (token && token.type === 'support.type') {\n                var line = session.doc.getLine(range.start.row);\n                var rightChar = line.substring(range.end.column, range.end.column + 1);\n                if (rightChar === ';') {\n                    range.end.column ++;\n                    return range;\n                }\n            }\n        }\n    });\n\n    this.add(\"semicolon\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === ';' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\n            if (rightChar === ';') {\n                return {\n                   text: '',\n                   selection: [1, 1]\n                };\n            }\n        }\n    });\n\n    this.add(\"!important\", \"insertion\", function (state, action, editor, session, text) {\n        if (text === '!' && editor.selection.isEmpty()) {\n            var cursor = editor.getCursorPosition();\n            var line = session.doc.getLine(cursor.row);\n\n            if (/^\\s*(;|}|$)/.test(line.substring(cursor.column))) {\n                return {\n                    text: '!important',\n                    selection: [10, 10]\n                };\n            }\n        }\n    });\n\n};\noop.inherits(CssBehaviour, CstyleBehaviour);\n\nexports.CssBehaviour = CssBehaviour;\n});\n\nace.define(\"ace/mode/css\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/css_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/worker/worker_client\",\"ace/mode/css_completions\",\"ace/mode/behaviour/css\",\"ace/mode/folding/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar CssHighlightRules = require(\"./css_highlight_rules\").CssHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar CssCompletions = require(\"./css_completions\").CssCompletions;\nvar CssBehaviour = require(\"./behaviour/css\").CssBehaviour;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = CssHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CssBehaviour();\n    this.$completer = new CssCompletions();\n    this.foldingRules = new CStyleFoldMode();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.foldingRules = \"cStyle\";\n    this.blockComment = {start: \"/*\", end: \"*/\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        var match = line.match(/^.*\\{\\s*$/);\n        if (match) {\n            indent += tab;\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        return this.$completer.getCompletions(state, session, pos, prefix);\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/css_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n\n        worker.on(\"annotate\", function(e) {\n            session.setAnnotations(e.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n    this.$id = \"ace/mode/css\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n\n});\n\nace.define(\"ace/mode/html_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/css_highlight_rules\",\"ace/mode/javascript_highlight_rules\",\"ace/mode/xml_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar CssHighlightRules = require(\"./css_highlight_rules\").CssHighlightRules;\nvar JavaScriptHighlightRules = require(\"./javascript_highlight_rules\").JavaScriptHighlightRules;\nvar XmlHighlightRules = require(\"./xml_highlight_rules\").XmlHighlightRules;\n\nvar tagMap = lang.createMap({\n    a           : 'anchor',\n    button \t    : 'form',\n    form        : 'form',\n    img         : 'image',\n    input       : 'form',\n    label       : 'form',\n    option      : 'form',\n    script      : 'script',\n    select      : 'form',\n    textarea    : 'form',\n    style       : 'style',\n    table       : 'table',\n    tbody       : 'table',\n    td          : 'table',\n    tfoot       : 'table',\n    th          : 'table',\n    tr          : 'table'\n});\n\nvar HtmlHighlightRules = function() {\n    XmlHighlightRules.call(this);\n\n    this.addRules({\n        attributes: [{\n            include : \"tag_whitespace\"\n        }, {\n            token : \"entity.other.attribute-name.xml\",\n            regex : \"[-_a-zA-Z0-9:.]+\"\n        }, {\n            token : \"keyword.operator.attribute-equals.xml\",\n            regex : \"=\",\n            push : [{\n                include: \"tag_whitespace\"\n            }, {\n                token : \"string.unquoted.attribute-value.html\",\n                regex : \"[^<>='\\\"`\\\\s]+\",\n                next : \"pop\"\n            }, {\n                token : \"empty\",\n                regex : \"\",\n                next : \"pop\"\n            }]\n        }, {\n            include : \"attribute_value\"\n        }],\n        tag: [{\n            token : function(start, tag) {\n                var group = tagMap[tag];\n                return [\"meta.tag.punctuation.\" + (start == \"<\" ? \"\" : \"end-\") + \"tag-open.xml\",\n                    \"meta.tag\" + (group ? \".\" + group : \"\") + \".tag-name.xml\"];\n            },\n            regex : \"(</?)([-_a-zA-Z0-9:.]+)\",\n            next: \"tag_stuff\"\n        }],\n        tag_stuff: [\n            {include : \"attributes\"},\n            {token : \"meta.tag.punctuation.tag-close.xml\", regex : \"/?>\", next : \"start\"}\n        ]\n    });\n\n    this.embedTagRules(CssHighlightRules, \"css-\", \"style\");\n    this.embedTagRules(new JavaScriptHighlightRules({jsx: false}).getRules(), \"js-\", \"script\");\n\n    if (this.constructor === HtmlHighlightRules)\n        this.normalizeRules();\n};\n\noop.inherits(HtmlHighlightRules, XmlHighlightRules);\n\nexports.HtmlHighlightRules = HtmlHighlightRules;\n});\n\nace.define(\"ace/mode/folding/mixed\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(defaultMode, subModes) {\n    this.defaultMode = defaultMode;\n    this.subModes = subModes;\n};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n\n    this.$getMode = function(state) {\n        if (typeof state != \"string\") \n            state = state[0];\n        for (var key in this.subModes) {\n            if (state.indexOf(key) === 0)\n                return this.subModes[key];\n        }\n        return null;\n    };\n    \n    this.$tryMode = function(state, session, foldStyle, row) {\n        var mode = this.$getMode(state);\n        return (mode ? mode.getFoldWidget(session, foldStyle, row) : \"\");\n    };\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        return (\n            this.$tryMode(session.getState(row-1), session, foldStyle, row) ||\n            this.$tryMode(session.getState(row), session, foldStyle, row) ||\n            this.defaultMode.getFoldWidget(session, foldStyle, row)\n        );\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var mode = this.$getMode(session.getState(row-1));\n        \n        if (!mode || !mode.getFoldWidget(session, foldStyle, row))\n            mode = this.$getMode(session.getState(row));\n        \n        if (!mode || !mode.getFoldWidget(session, foldStyle, row))\n            mode = this.defaultMode;\n        \n        return mode.getFoldWidgetRange(session, foldStyle, row);\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/folding/html\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/mixed\",\"ace/mode/folding/xml\",\"ace/mode/folding/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar MixedFoldMode = require(\"./mixed\").FoldMode;\nvar XmlFoldMode = require(\"./xml\").FoldMode;\nvar CStyleFoldMode = require(\"./cstyle\").FoldMode;\n\nvar FoldMode = exports.FoldMode = function(voidElements, optionalTags) {\n    MixedFoldMode.call(this, new XmlFoldMode(voidElements, optionalTags), {\n        \"js-\": new CStyleFoldMode(),\n        \"css-\": new CStyleFoldMode()\n    });\n};\n\noop.inherits(FoldMode, MixedFoldMode);\n\n});\n\nace.define(\"ace/mode/html_completions\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\n\nvar commonAttributes = [\n    \"accesskey\",\n    \"class\",\n    \"contenteditable\",\n    \"contextmenu\",\n    \"dir\",\n    \"draggable\",\n    \"dropzone\",\n    \"hidden\",\n    \"id\",\n    \"inert\",\n    \"itemid\",\n    \"itemprop\",\n    \"itemref\",\n    \"itemscope\",\n    \"itemtype\",\n    \"lang\",\n    \"spellcheck\",\n    \"style\",\n    \"tabindex\",\n    \"title\",\n    \"translate\"\n];\n\nvar eventAttributes = [\n    \"onabort\",\n    \"onblur\",\n    \"oncancel\",\n    \"oncanplay\",\n    \"oncanplaythrough\",\n    \"onchange\",\n    \"onclick\",\n    \"onclose\",\n    \"oncontextmenu\",\n    \"oncuechange\",\n    \"ondblclick\",\n    \"ondrag\",\n    \"ondragend\",\n    \"ondragenter\",\n    \"ondragleave\",\n    \"ondragover\",\n    \"ondragstart\",\n    \"ondrop\",\n    \"ondurationchange\",\n    \"onemptied\",\n    \"onended\",\n    \"onerror\",\n    \"onfocus\",\n    \"oninput\",\n    \"oninvalid\",\n    \"onkeydown\",\n    \"onkeypress\",\n    \"onkeyup\",\n    \"onload\",\n    \"onloadeddata\",\n    \"onloadedmetadata\",\n    \"onloadstart\",\n    \"onmousedown\",\n    \"onmousemove\",\n    \"onmouseout\",\n    \"onmouseover\",\n    \"onmouseup\",\n    \"onmousewheel\",\n    \"onpause\",\n    \"onplay\",\n    \"onplaying\",\n    \"onprogress\",\n    \"onratechange\",\n    \"onreset\",\n    \"onscroll\",\n    \"onseeked\",\n    \"onseeking\",\n    \"onselect\",\n    \"onshow\",\n    \"onstalled\",\n    \"onsubmit\",\n    \"onsuspend\",\n    \"ontimeupdate\",\n    \"onvolumechange\",\n    \"onwaiting\"\n];\n\nvar globalAttributes = commonAttributes.concat(eventAttributes);\n\nvar attributeMap = {\n    \"a\": {\"href\": 1, \"target\": {\"_blank\": 1, \"top\": 1}, \"ping\": 1, \"rel\": {\"nofollow\": 1, \"alternate\": 1, \"author\": 1, \"bookmark\": 1, \"help\": 1, \"license\": 1, \"next\": 1, \"noreferrer\": 1, \"prefetch\": 1, \"prev\": 1, \"search\": 1, \"tag\": 1}, \"media\": 1, \"hreflang\": 1, \"type\": 1},\n    \"abbr\": {},\n    \"address\": {},\n    \"area\": {\"shape\": 1, \"coords\": 1, \"href\": 1, \"hreflang\": 1, \"alt\": 1, \"target\": 1, \"media\": 1, \"rel\": 1, \"ping\": 1, \"type\": 1},\n    \"article\": {\"pubdate\": 1},\n    \"aside\": {},\n    \"audio\": {\"src\": 1, \"autobuffer\": 1, \"autoplay\": {\"autoplay\": 1}, \"loop\": {\"loop\": 1}, \"controls\": {\"controls\": 1}, \"muted\": {\"muted\": 1}, \"preload\": {\"auto\": 1, \"metadata\": 1, \"none\": 1 }},\n    \"b\": {},\n    \"base\": {\"href\": 1, \"target\": 1},\n    \"bdi\": {},\n    \"bdo\": {},\n    \"blockquote\": {\"cite\": 1},\n    \"body\": {\"onafterprint\": 1, \"onbeforeprint\": 1, \"onbeforeunload\": 1, \"onhashchange\": 1, \"onmessage\": 1, \"onoffline\": 1, \"onpopstate\": 1, \"onredo\": 1, \"onresize\": 1, \"onstorage\": 1, \"onundo\": 1, \"onunload\": 1},\n    \"br\": {},\n    \"button\": {\"autofocus\": 1, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"formaction\": 1, \"formenctype\": 1, \"formmethod\": 1, \"formnovalidate\": 1, \"formtarget\": 1, \"name\": 1, \"value\": 1, \"type\": {\"button\": 1, \"submit\": 1}},\n    \"canvas\": {\"width\": 1, \"height\": 1},\n    \"caption\": {},\n    \"cite\": {},\n    \"code\": {},\n    \"col\": {\"span\": 1},\n    \"colgroup\": {\"span\": 1},\n    \"command\": {\"type\": 1, \"label\": 1, \"icon\": 1, \"disabled\": 1, \"checked\": 1, \"radiogroup\": 1, \"command\": 1},\n    \"data\": {},\n    \"datalist\": {},\n    \"dd\": {},\n    \"del\": {\"cite\": 1, \"datetime\": 1},\n    \"details\": {\"open\": 1},\n    \"dfn\": {},\n    \"dialog\": {\"open\": 1},\n    \"div\": {},\n    \"dl\": {},\n    \"dt\": {},\n    \"em\": {},\n    \"embed\": {\"src\": 1, \"height\": 1, \"width\": 1, \"type\": 1},\n    \"fieldset\": {\"disabled\": 1, \"form\": 1, \"name\": 1},\n    \"figcaption\": {},\n    \"figure\": {},\n    \"footer\": {},\n    \"form\": {\"accept-charset\": 1, \"action\": 1, \"autocomplete\": 1, \"enctype\": {\"multipart/form-data\": 1, \"application/x-www-form-urlencoded\": 1}, \"method\": {\"get\": 1, \"post\": 1}, \"name\": 1, \"novalidate\": 1, \"target\": {\"_blank\": 1, \"top\": 1}},\n    \"h1\": {},\n    \"h2\": {},\n    \"h3\": {},\n    \"h4\": {},\n    \"h5\": {},\n    \"h6\": {},\n    \"head\": {},\n    \"header\": {},\n    \"hr\": {},\n    \"html\": {\"manifest\": 1},\n    \"i\": {},\n    \"iframe\": {\"name\": 1, \"src\": 1, \"height\": 1, \"width\": 1, \"sandbox\": {\"allow-same-origin\": 1, \"allow-top-navigation\": 1, \"allow-forms\": 1, \"allow-scripts\": 1}, \"seamless\": {\"seamless\": 1}},\n    \"img\": {\"alt\": 1, \"src\": 1, \"height\": 1, \"width\": 1, \"usemap\": 1, \"ismap\": 1},\n    \"input\": {\n        \"type\": {\"text\": 1, \"password\": 1, \"hidden\": 1, \"checkbox\": 1, \"submit\": 1, \"radio\": 1, \"file\": 1, \"button\": 1, \"reset\": 1, \"image\": 31, \"color\": 1, \"date\": 1, \"datetime\": 1, \"datetime-local\": 1, \"email\": 1, \"month\": 1, \"number\": 1, \"range\": 1, \"search\": 1, \"tel\": 1, \"time\": 1, \"url\": 1, \"week\": 1},\n        \"accept\": 1, \"alt\": 1, \"autocomplete\": {\"on\": 1, \"off\": 1}, \"autofocus\": {\"autofocus\": 1}, \"checked\": {\"checked\": 1}, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"formaction\": 1, \"formenctype\": {\"application/x-www-form-urlencoded\": 1, \"multipart/form-data\": 1, \"text/plain\": 1}, \"formmethod\": {\"get\": 1, \"post\": 1}, \"formnovalidate\": {\"formnovalidate\": 1}, \"formtarget\": {\"_blank\": 1, \"_self\": 1, \"_parent\": 1, \"_top\": 1}, \"height\": 1, \"list\": 1, \"max\": 1, \"maxlength\": 1, \"min\": 1, \"multiple\": {\"multiple\": 1}, \"name\": 1, \"pattern\": 1, \"placeholder\": 1, \"readonly\": {\"readonly\": 1}, \"required\": {\"required\": 1}, \"size\": 1, \"src\": 1, \"step\": 1, \"width\": 1, \"files\": 1, \"value\": 1},\n    \"ins\": {\"cite\": 1, \"datetime\": 1},\n    \"kbd\": {},\n    \"keygen\": {\"autofocus\": 1, \"challenge\": {\"challenge\": 1}, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"keytype\": {\"rsa\": 1, \"dsa\": 1, \"ec\": 1}, \"name\": 1},\n    \"label\": {\"form\": 1, \"for\": 1},\n    \"legend\": {},\n    \"li\": {\"value\": 1},\n    \"link\": {\"href\": 1, \"hreflang\": 1, \"rel\": {\"stylesheet\": 1, \"icon\": 1}, \"media\": {\"all\": 1, \"screen\": 1, \"print\": 1}, \"type\": {\"text/css\": 1, \"image/png\": 1, \"image/jpeg\": 1, \"image/gif\": 1}, \"sizes\": 1},\n    \"main\": {},\n    \"map\": {\"name\": 1},\n    \"mark\": {},\n    \"math\": {},\n    \"menu\": {\"type\": 1, \"label\": 1},\n    \"meta\": {\"http-equiv\": {\"content-type\": 1}, \"name\": {\"description\": 1, \"keywords\": 1}, \"content\": {\"text/html; charset=UTF-8\": 1}, \"charset\": 1},\n    \"meter\": {\"value\": 1, \"min\": 1, \"max\": 1, \"low\": 1, \"high\": 1, \"optimum\": 1},\n    \"nav\": {},\n    \"noscript\": {\"href\": 1},\n    \"object\": {\"param\": 1, \"data\": 1, \"type\": 1, \"height\" : 1, \"width\": 1, \"usemap\": 1, \"name\": 1, \"form\": 1, \"classid\": 1},\n    \"ol\": {\"start\": 1, \"reversed\": 1},\n    \"optgroup\": {\"disabled\": 1, \"label\": 1},\n    \"option\": {\"disabled\": 1, \"selected\": 1, \"label\": 1, \"value\": 1},\n    \"output\": {\"for\": 1, \"form\": 1, \"name\": 1},\n    \"p\": {},\n    \"param\": {\"name\": 1, \"value\": 1},\n    \"pre\": {},\n    \"progress\": {\"value\": 1, \"max\": 1},\n    \"q\": {\"cite\": 1},\n    \"rp\": {},\n    \"rt\": {},\n    \"ruby\": {},\n    \"s\": {},\n    \"samp\": {},\n    \"script\": {\"charset\": 1, \"type\": {\"text/javascript\": 1}, \"src\": 1, \"defer\": 1, \"async\": 1},\n    \"select\": {\"autofocus\": 1, \"disabled\": 1, \"form\": 1, \"multiple\": {\"multiple\": 1}, \"name\": 1, \"size\": 1, \"readonly\":{\"readonly\": 1}},\n    \"small\": {},\n    \"source\": {\"src\": 1, \"type\": 1, \"media\": 1},\n    \"span\": {},\n    \"strong\": {},\n    \"style\": {\"type\": 1, \"media\": {\"all\": 1, \"screen\": 1, \"print\": 1}, \"scoped\": 1},\n    \"sub\": {},\n    \"sup\": {},\n    \"svg\": {},\n    \"table\": {\"summary\": 1},\n    \"tbody\": {},\n    \"td\": {\"headers\": 1, \"rowspan\": 1, \"colspan\": 1},\n    \"textarea\": {\"autofocus\": {\"autofocus\": 1}, \"disabled\": {\"disabled\": 1}, \"form\": 1, \"maxlength\": 1, \"name\": 1, \"placeholder\": 1, \"readonly\": {\"readonly\": 1}, \"required\": {\"required\": 1}, \"rows\": 1, \"cols\": 1, \"wrap\": {\"on\": 1, \"off\": 1, \"hard\": 1, \"soft\": 1}},\n    \"tfoot\": {},\n    \"th\": {\"headers\": 1, \"rowspan\": 1, \"colspan\": 1, \"scope\": 1},\n    \"thead\": {},\n    \"time\": {\"datetime\": 1},\n    \"title\": {},\n    \"tr\": {},\n    \"track\": {\"kind\": 1, \"src\": 1, \"srclang\": 1, \"label\": 1, \"default\": 1},\n    \"section\": {},\n    \"summary\": {},\n    \"u\": {},\n    \"ul\": {},\n    \"var\": {},\n    \"video\": {\"src\": 1, \"autobuffer\": 1, \"autoplay\": {\"autoplay\": 1}, \"loop\": {\"loop\": 1}, \"controls\": {\"controls\": 1}, \"width\": 1, \"height\": 1, \"poster\": 1, \"muted\": {\"muted\": 1}, \"preload\": {\"auto\": 1, \"metadata\": 1, \"none\": 1}},\n    \"wbr\": {}\n};\n\nvar elements = Object.keys(attributeMap);\n\nfunction is(token, type) {\n    return token.type.lastIndexOf(type + \".xml\") > -1;\n}\n\nfunction findTagName(session, pos) {\n    var iterator = new TokenIterator(session, pos.row, pos.column);\n    var token = iterator.getCurrentToken();\n    while (token && !is(token, \"tag-name\")){\n        token = iterator.stepBackward();\n    }\n    if (token)\n        return token.value;\n}\n\nfunction findAttributeName(session, pos) {\n    var iterator = new TokenIterator(session, pos.row, pos.column);\n    var token = iterator.getCurrentToken();\n    while (token && !is(token, \"attribute-name\")){\n        token = iterator.stepBackward();\n    }\n    if (token)\n        return token.value;\n}\n\nvar HtmlCompletions = function() {\n\n};\n\n(function() {\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        var token = session.getTokenAt(pos.row, pos.column);\n\n        if (!token)\n            return [];\n        if (is(token, \"tag-name\") || is(token, \"tag-open\") || is(token, \"end-tag-open\"))\n            return this.getTagCompletions(state, session, pos, prefix);\n        if (is(token, \"tag-whitespace\") || is(token, \"attribute-name\"))\n            return this.getAttributeCompletions(state, session, pos, prefix);\n        if (is(token, \"attribute-value\"))\n            return this.getAttributeValueCompletions(state, session, pos, prefix);\n        var line = session.getLine(pos.row).substr(0, pos.column);\n        if (/&[a-z]*$/i.test(line))\n            return this.getHTMLEntityCompletions(state, session, pos, prefix);\n\n        return [];\n    };\n\n    this.getTagCompletions = function(state, session, pos, prefix) {\n        return elements.map(function(element){\n            return {\n                value: element,\n                meta: \"tag\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getAttributeCompletions = function(state, session, pos, prefix) {\n        var tagName = findTagName(session, pos);\n        if (!tagName)\n            return [];\n        var attributes = globalAttributes;\n        if (tagName in attributeMap) {\n            attributes = attributes.concat(Object.keys(attributeMap[tagName]));\n        }\n        return attributes.map(function(attribute){\n            return {\n                caption: attribute,\n                snippet: attribute + '=\"$0\"',\n                meta: \"attribute\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getAttributeValueCompletions = function(state, session, pos, prefix) {\n        var tagName = findTagName(session, pos);\n        var attributeName = findAttributeName(session, pos);\n        \n        if (!tagName)\n            return [];\n        var values = [];\n        if (tagName in attributeMap && attributeName in attributeMap[tagName] && typeof attributeMap[tagName][attributeName] === \"object\") {\n            values = Object.keys(attributeMap[tagName][attributeName]);\n        }\n        return values.map(function(value){\n            return {\n                caption: value,\n                snippet: value,\n                meta: \"attribute value\",\n                score: 1000000\n            };\n        });\n    };\n\n    this.getHTMLEntityCompletions = function(state, session, pos, prefix) {\n        var values = ['Aacute;', 'aacute;', 'Acirc;', 'acirc;', 'acute;', 'AElig;', 'aelig;', 'Agrave;', 'agrave;', 'alefsym;', 'Alpha;', 'alpha;', 'amp;', 'and;', 'ang;', 'Aring;', 'aring;', 'asymp;', 'Atilde;', 'atilde;', 'Auml;', 'auml;', 'bdquo;', 'Beta;', 'beta;', 'brvbar;', 'bull;', 'cap;', 'Ccedil;', 'ccedil;', 'cedil;', 'cent;', 'Chi;', 'chi;', 'circ;', 'clubs;', 'cong;', 'copy;', 'crarr;', 'cup;', 'curren;', 'Dagger;', 'dagger;', 'dArr;', 'darr;', 'deg;', 'Delta;', 'delta;', 'diams;', 'divide;', 'Eacute;', 'eacute;', 'Ecirc;', 'ecirc;', 'Egrave;', 'egrave;', 'empty;', 'emsp;', 'ensp;', 'Epsilon;', 'epsilon;', 'equiv;', 'Eta;', 'eta;', 'ETH;', 'eth;', 'Euml;', 'euml;', 'euro;', 'exist;', 'fnof;', 'forall;', 'frac12;', 'frac14;', 'frac34;', 'frasl;', 'Gamma;', 'gamma;', 'ge;', 'gt;', 'hArr;', 'harr;', 'hearts;', 'hellip;', 'Iacute;', 'iacute;', 'Icirc;', 'icirc;', 'iexcl;', 'Igrave;', 'igrave;', 'image;', 'infin;', 'int;', 'Iota;', 'iota;', 'iquest;', 'isin;', 'Iuml;', 'iuml;', 'Kappa;', 'kappa;', 'Lambda;', 'lambda;', 'lang;', 'laquo;', 'lArr;', 'larr;', 'lceil;', 'ldquo;', 'le;', 'lfloor;', 'lowast;', 'loz;', 'lrm;', 'lsaquo;', 'lsquo;', 'lt;', 'macr;', 'mdash;', 'micro;', 'middot;', 'minus;', 'Mu;', 'mu;', 'nabla;', 'nbsp;', 'ndash;', 'ne;', 'ni;', 'not;', 'notin;', 'nsub;', 'Ntilde;', 'ntilde;', 'Nu;', 'nu;', 'Oacute;', 'oacute;', 'Ocirc;', 'ocirc;', 'OElig;', 'oelig;', 'Ograve;', 'ograve;', 'oline;', 'Omega;', 'omega;', 'Omicron;', 'omicron;', 'oplus;', 'or;', 'ordf;', 'ordm;', 'Oslash;', 'oslash;', 'Otilde;', 'otilde;', 'otimes;', 'Ouml;', 'ouml;', 'para;', 'part;', 'permil;', 'perp;', 'Phi;', 'phi;', 'Pi;', 'pi;', 'piv;', 'plusmn;', 'pound;', 'Prime;', 'prime;', 'prod;', 'prop;', 'Psi;', 'psi;', 'quot;', 'radic;', 'rang;', 'raquo;', 'rArr;', 'rarr;', 'rceil;', 'rdquo;', 'real;', 'reg;', 'rfloor;', 'Rho;', 'rho;', 'rlm;', 'rsaquo;', 'rsquo;', 'sbquo;', 'Scaron;', 'scaron;', 'sdot;', 'sect;', 'shy;', 'Sigma;', 'sigma;', 'sigmaf;', 'sim;', 'spades;', 'sub;', 'sube;', 'sum;', 'sup;', 'sup1;', 'sup2;', 'sup3;', 'supe;', 'szlig;', 'Tau;', 'tau;', 'there4;', 'Theta;', 'theta;', 'thetasym;', 'thinsp;', 'THORN;', 'thorn;', 'tilde;', 'times;', 'trade;', 'Uacute;', 'uacute;', 'uArr;', 'uarr;', 'Ucirc;', 'ucirc;', 'Ugrave;', 'ugrave;', 'uml;', 'upsih;', 'Upsilon;', 'upsilon;', 'Uuml;', 'uuml;', 'weierp;', 'Xi;', 'xi;', 'Yacute;', 'yacute;', 'yen;', 'Yuml;', 'yuml;', 'Zeta;', 'zeta;', 'zwj;', 'zwnj;'];\n\n        return values.map(function(value){\n            return {\n                caption: value,\n                snippet: value,\n                meta: \"html entity\",\n                score: 1000000\n            };\n        });\n    };\n\n}).call(HtmlCompletions.prototype);\n\nexports.HtmlCompletions = HtmlCompletions;\n});\n\nace.define(\"ace/mode/html\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text\",\"ace/mode/javascript\",\"ace/mode/css\",\"ace/mode/html_highlight_rules\",\"ace/mode/behaviour/xml\",\"ace/mode/folding/html\",\"ace/mode/html_completions\",\"ace/worker/worker_client\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextMode = require(\"./text\").Mode;\nvar JavaScriptMode = require(\"./javascript\").Mode;\nvar CssMode = require(\"./css\").Mode;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\nvar XmlBehaviour = require(\"./behaviour/xml\").XmlBehaviour;\nvar HtmlFoldMode = require(\"./folding/html\").FoldMode;\nvar HtmlCompletions = require(\"./html_completions\").HtmlCompletions;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar voidElements = [\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"menuitem\", \"param\", \"source\", \"track\", \"wbr\"];\nvar optionalEndTags = [\"li\", \"dt\", \"dd\", \"p\", \"rt\", \"rp\", \"optgroup\", \"option\", \"colgroup\", \"td\", \"th\"];\n\nvar Mode = function(options) {\n    this.fragmentContext = options && options.fragmentContext;\n    this.HighlightRules = HtmlHighlightRules;\n    this.$behaviour = new XmlBehaviour();\n    this.$completer = new HtmlCompletions();\n    \n    this.createModeDelegates({\n        \"js-\": JavaScriptMode,\n        \"css-\": CssMode\n    });\n    \n    this.foldingRules = new HtmlFoldMode(this.voidElements, lang.arrayToMap(optionalEndTags));\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n    this.blockComment = {start: \"<!--\", end: \"-->\"};\n\n    this.voidElements = lang.arrayToMap(voidElements);\n\n    this.getNextLineIndent = function(state, line, tab) {\n        return this.$getIndent(line);\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return false;\n    };\n\n    this.getCompletions = function(state, session, pos, prefix) {\n        return this.$completer.getCompletions(state, session, pos, prefix);\n    };\n\n    this.createWorker = function(session) {\n        if (this.constructor != Mode)\n            return;\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/html_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n\n        if (this.fragmentContext)\n            worker.call(\"setOptions\", [{context: this.fragmentContext}]);\n\n        worker.on(\"error\", function(e) {\n            session.setAnnotations(e.data);\n        });\n\n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n\n        return worker;\n    };\n\n    this.$id = \"ace/mode/html\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/mode/markdown_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/config\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text_highlight_rules\",\"ace/mode/html_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar modes = require(\"../config\").$modes;\n\nvar oop = require(\"../lib/oop\");\nvar lang = require(\"../lib/lang\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar HtmlHighlightRules = require(\"./html_highlight_rules\").HtmlHighlightRules;\n\nvar escaped = function(ch) {\n    return \"(?:[^\" + lang.escapeRegExp(ch) + \"\\\\\\\\]|\\\\\\\\.)*\";\n};\n\nvar MarkdownHighlightRules = function() {\n    HtmlHighlightRules.call(this);\n    var codeBlockStartRule = {\n        token : \"support.function\",\n        regex : /^\\s*(```+[^`]*|~~~+[^~]*)$/,\n        onMatch: function(value, state, stack, line) {\n            var m = value.match(/^(\\s*)([`~]+)(.*)/);\n            var language = /[\\w-]+|$/.exec(m[3])[0];\n            if (!modes[language])\n                language = \"\";\n            stack.unshift(\"githubblock\", [], [m[1], m[2], language], state);\n            return this.token;\n        },\n        next  : \"githubblock\"\n    };\n    var codeBlockRules = [{\n        token : \"support.function\",\n        regex : \".*\",\n        onMatch: function(value, state, stack, line) {\n            var embedState = stack[1];\n            var indent = stack[2][0];\n            var endMarker = stack[2][1];\n            var language = stack[2][2];\n            \n            var m = /^(\\s*)(`+|~+)\\s*$/.exec(value);\n            if (\n                m && m[1].length < indent.length + 3\n                && m[2].length >= endMarker.length && m[2][0] == endMarker[0]\n            ) {\n                stack.splice(0, 3);\n                this.next = stack.shift();\n                return this.token;\n            }\n            this.next = \"\";\n            if (language && modes[language]) {\n                var data = modes[language].getTokenizer().getLineTokens(value, embedState.slice(0));\n                stack[1] = data.state;\n                return data.tokens;\n            }\n            return this.token;\n        }\n    }];\n\n    this.$rules[\"start\"].unshift({\n        token : \"empty_line\",\n        regex : '^$',\n        next: \"allowBlock\"\n    }, { // h1\n        token: \"markup.heading.1\",\n        regex: \"^=+(?=\\\\s*$)\"\n    }, { // h2\n        token: \"markup.heading.2\",\n        regex: \"^\\\\-+(?=\\\\s*$)\"\n    }, {\n        token : function(value) {\n            return \"markup.heading.\" + value.length;\n        },\n        regex : /^#{1,6}(?=\\s|$)/,\n        next : \"header\"\n    },\n    codeBlockStartRule,\n    { // block quote\n        token : \"string.blockquote\",\n        regex : \"^\\\\s*>\\\\s*(?:[*+-]|\\\\d+\\\\.)?\\\\s+\",\n        next  : \"blockquote\"\n    }, { // HR * - _\n        token : \"constant\",\n        regex : \"^ {0,3}(?:(?:\\\\* ?){3,}|(?:\\\\- ?){3,}|(?:\\\\_ ?){3,})\\\\s*$\",\n        next: \"allowBlock\"\n    }, { // list\n        token : \"markup.list\",\n        regex : \"^\\\\s{0,3}(?:[*+-]|\\\\d+\\\\.)\\\\s+\",\n        next  : \"listblock-start\"\n    }, {\n        include : \"basic\"\n    });\n\n    this.addRules({\n        \"basic\" : [{\n            token : \"constant.language.escape\",\n            regex : /\\\\[\\\\`*_{}\\[\\]()#+\\-.!]/\n        }, { // code span `\n            token : \"support.function\",\n            regex : \"(`+)(.*?[^`])(\\\\1)\"\n        }, { // reference\n            token : [\"text\", \"constant\", \"text\", \"url\", \"string\", \"text\"],\n            regex : \"^([ ]{0,3}\\\\[)([^\\\\]]+)(\\\\]:\\\\s*)([^ ]+)(\\\\s*(?:[\\\"][^\\\"]+[\\\"])?(\\\\s*))$\"\n        }, { // link by reference\n            token : [\"text\", \"string\", \"text\", \"constant\", \"text\"],\n            regex : \"(\\\\[)(\" + escaped(\"]\") + \")(\\\\]\\\\s*\\\\[)(\"+ escaped(\"]\") + \")(\\\\])\"\n        }, { // link by url\n            token : [\"text\", \"string\", \"text\", \"markup.underline\", \"string\", \"text\"],\n            regex : \"(\\\\!?\\\\[)(\" +                                        // [\n                    escaped(\"]\") +                                    // link text or alt text\n                    \")(\\\\]\\\\()\"+                                      // ](\n                    '((?:[^\\\\)\\\\s\\\\\\\\]|\\\\\\\\.|\\\\s(?=[^\"]))*)' +        // href or image\n                    '(\\\\s*\"' +  escaped('\"') + '\"\\\\s*)?' +            // \"title\"\n                    \"(\\\\))\"                                           // )\n        }, { // strong ** __\n            token : \"string.strong\",\n            regex : \"([*]{2}|[_]{2}(?=\\\\S))(.*?\\\\S[*_]*)(\\\\1)\"\n        }, { // emphasis * _\n            token : \"string.emphasis\",\n            regex : \"([*]|[_](?=\\\\S))(.*?\\\\S[*_]*)(\\\\1)\"\n        }, { //\n            token : [\"text\", \"url\", \"text\"],\n            regex : \"(<)(\"+\n                      \"(?:https?|ftp|dict):[^'\\\">\\\\s]+\"+\n                      \"|\"+\n                      \"(?:mailto:)?[-.\\\\w]+\\\\@[-a-z0-9]+(?:\\\\.[-a-z0-9]+)*\\\\.[a-z]+\"+\n                    \")(>)\"\n        }],\n        \"allowBlock\": [\n            {token : \"support.function\", regex : \"^ {4}.+\", next : \"allowBlock\"},\n            {token : \"empty_line\", regex : '^$', next: \"allowBlock\"},\n            {token : \"empty\", regex : \"\", next : \"start\"}\n        ],\n\n        \"header\" : [{\n            regex: \"$\",\n            next : \"start\"\n        }, {\n            include: \"basic\"\n        }, {\n            defaultToken : \"heading\"\n        } ],\n\n        \"listblock-start\" : [{\n            token : \"support.variable\",\n            regex : /(?:\\[[ x]\\])?/,\n            next  : \"listblock\"\n        }],\n\n        \"listblock\" : [ { // Lists only escape on completely blank lines.\n            token : \"empty_line\",\n            regex : \"^$\",\n            next  : \"start\"\n        }, { // list\n            token : \"markup.list\",\n            regex : \"^\\\\s{0,3}(?:[*+-]|\\\\d+\\\\.)\\\\s+\",\n            next  : \"listblock-start\"\n        }, {\n            include : \"basic\", noEscape: true\n        },\n        codeBlockStartRule,\n        {\n            defaultToken : \"list\" //do not use markup.list to allow stling leading `*` differntly\n        } ],\n\n        \"blockquote\" : [ { // Blockquotes only escape on blank lines.\n            token : \"empty_line\",\n            regex : \"^\\\\s*$\",\n            next  : \"start\"\n        }, { // block quote\n            token : \"string.blockquote\",\n            regex : \"^\\\\s*>\\\\s*(?:[*+-]|\\\\d+\\\\.)?\\\\s+\",\n            next  : \"blockquote\"\n        }, {\n            include : \"basic\", noEscape: true\n        }, {\n            defaultToken : \"string.blockquote\"\n        } ],\n\n        \"githubblock\" : codeBlockRules\n    });\n\n    this.normalizeRules();\n};\noop.inherits(MarkdownHighlightRules, TextHighlightRules);\n\nexports.MarkdownHighlightRules = MarkdownHighlightRules;\n});\n\nace.define(\"ace/mode/folding/markdown\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.foldingStartMarker = /^(?:[=-]+\\s*$|#{1,6} |`{3})/;\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (!this.foldingStartMarker.test(line))\n            return \"\";\n\n        if (line[0] == \"`\") {\n            if (session.bgTokenizer.getState(row) == \"start\")\n                return \"end\";\n            return \"start\";\n        }\n\n        return \"start\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        if (!line.match(this.foldingStartMarker))\n            return;\n\n        if (line[0] == \"`\") {\n            if (session.bgTokenizer.getState(row) !== \"start\") {\n                while (++row < maxRow) {\n                    line = session.getLine(row);\n                    if (line[0] == \"`\" & line.substring(0, 3) == \"```\")\n                        break;\n                }\n                return new Range(startRow, startColumn, row, 0);\n            } else {\n                while (row -- > 0) {\n                    line = session.getLine(row);\n                    if (line[0] == \"`\" & line.substring(0, 3) == \"```\")\n                        break;\n                }\n                return new Range(row, line.length, startRow, 0);\n            }\n        }\n\n        var token;\n        function isHeading(row) {\n            token = session.getTokens(row)[0];\n            return token && token.type.lastIndexOf(heading, 0) === 0;\n        }\n\n        var heading = \"markup.heading\";\n        function getLevel() {\n            var ch = token.value[0];\n            if (ch == \"=\") return 6;\n            if (ch == \"-\") return 5;\n            return 7 - token.value.search(/[^#]|$/);\n        }\n\n        if (isHeading(row)) {\n            var startHeadingLevel = getLevel();\n            while (++row < maxRow) {\n                if (!isHeading(row))\n                    continue;\n                var level = getLevel();\n                if (level >= startHeadingLevel)\n                    break;\n            }\n\n            endRow = row - (!token || [\"=\", \"-\"].indexOf(token.value[0]) == -1 ? 1 : 2);\n\n            if (endRow > startRow) {\n                while (endRow > startRow && /^\\s*$/.test(session.getLine(endRow)))\n                    endRow--;\n            }\n\n            if (endRow > startRow) {\n                var endColumn = session.getLine(endRow).length;\n                return new Range(startRow, startColumn, endRow, endColumn);\n            }\n        }\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/sh_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar reservedKeywords = exports.reservedKeywords = (\n        '!|{|}|case|do|done|elif|else|'+\n        'esac|fi|for|if|in|then|until|while|'+\n        '&|;|export|local|read|typeset|unset|'+\n        'elif|select|set|function|declare|readonly'\n    );\n\nvar languageConstructs = exports.languageConstructs = (\n    '[|]|alias|bg|bind|break|builtin|'+\n     'cd|command|compgen|complete|continue|'+\n     'dirs|disown|echo|enable|eval|exec|'+\n     'exit|fc|fg|getopts|hash|help|history|'+\n     'jobs|kill|let|logout|popd|printf|pushd|'+\n     'pwd|return|set|shift|shopt|source|'+\n     'suspend|test|times|trap|type|ulimit|'+\n     'umask|unalias|wait'\n);\n\nvar ShHighlightRules = function() {\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": reservedKeywords,\n        \"support.function.builtin\": languageConstructs,\n        \"invalid.deprecated\": \"debugger\"\n    }, \"identifier\");\n\n    var integer = \"(?:(?:[1-9]\\\\d*)|(?:0))\";\n\n    var fraction = \"(?:\\\\.\\\\d+)\";\n    var intPart = \"(?:\\\\d+)\";\n    var pointFloat = \"(?:(?:\" + intPart + \"?\" + fraction + \")|(?:\" + intPart + \"\\\\.))\";\n    var exponentFloat = \"(?:(?:\" + pointFloat + \"|\" +  intPart + \")\" + \")\";\n    var floatNumber = \"(?:\" + exponentFloat + \"|\" + pointFloat + \")\";\n    var fileDescriptor = \"(?:&\" + intPart + \")\";\n\n    var variableName = \"[a-zA-Z_][a-zA-Z0-9_]*\";\n    var variable = \"(?:\" + variableName + \"(?==))\";\n\n    var builtinVariable = \"(?:\\\\$(?:SHLVL|\\\\$|\\\\!|\\\\?))\";\n\n    var func = \"(?:\" + variableName + \"\\\\s*\\\\(\\\\))\";\n\n    this.$rules = {\n        \"start\" : [{\n            token : \"constant\",\n            regex : /\\\\./\n        }, {\n            token : [\"text\", \"comment\"],\n            regex : /(^|\\s)(#.*)$/\n        }, {\n            token : \"string.start\",\n            regex : '\"',\n            push : [{\n                token : \"constant.language.escape\",\n                regex : /\\\\(?:[$`\"\\\\]|$)/\n            }, {\n                include : \"variables\"\n            }, {\n                token : \"keyword.operator\",\n                regex : /`/ // TODO highlight `\n            }, {\n                token : \"string.end\",\n                regex : '\"',\n                next: \"pop\"\n            }, {\n                defaultToken: \"string\"\n            }]\n        }, {\n            token : \"string\",\n            regex : \"\\\\$'\",\n            push : [{\n                token : \"constant.language.escape\",\n                regex : /\\\\(?:[abeEfnrtv\\\\'\"]|x[a-fA-F\\d]{1,2}|u[a-fA-F\\d]{4}([a-fA-F\\d]{4})?|c.|\\d{1,3})/\n            }, {\n                token : \"string\",\n                regex : \"'\",\n                next: \"pop\"\n            }, {\n                defaultToken: \"string\"\n            }]\n        }, {\n            regex : \"<<<\",\n            token : \"keyword.operator\"\n        }, {\n            stateName: \"heredoc\",\n            regex : \"(<<-?)(\\\\s*)(['\\\"`]?)([\\\\w\\\\-]+)(['\\\"`]?)\",\n            onMatch : function(value, currentState, stack) {\n                var next = value[2] == '-' ? \"indentedHeredoc\" : \"heredoc\";\n                var tokens = value.split(this.splitRegex);\n                stack.push(next, tokens[4]);\n                return [\n                    {type:\"constant\", value: tokens[1]},\n                    {type:\"text\", value: tokens[2]},\n                    {type:\"string\", value: tokens[3]},\n                    {type:\"support.class\", value: tokens[4]},\n                    {type:\"string\", value: tokens[5]}\n                ];\n            },\n            rules: {\n                heredoc: [{\n                    onMatch:  function(value, currentState, stack) {\n                        if (value === stack[1]) {\n                            stack.shift();\n                            stack.shift();\n                            this.next = stack[0] || \"start\";\n                            return \"support.class\";\n                        }\n                        this.next = \"\";\n                        return \"string\";\n                    },\n                    regex: \".*$\",\n                    next: \"start\"\n                }],\n                indentedHeredoc: [{\n                    token: \"string\",\n                    regex: \"^\\t+\"\n                }, {\n                    onMatch:  function(value, currentState, stack) {\n                        if (value === stack[1]) {\n                            stack.shift();\n                            stack.shift();\n                            this.next = stack[0] || \"start\";\n                            return \"support.class\";\n                        }\n                        this.next = \"\";\n                        return \"string\";\n                    },\n                    regex: \".*$\",\n                    next: \"start\"\n                }]\n            }\n        }, {\n            regex : \"$\",\n            token : \"empty\",\n            next : function(currentState, stack) {\n                if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                    return stack[0];\n                return currentState;\n            }\n        }, {\n            token : [\"keyword\", \"text\", \"text\", \"text\", \"variable\"],\n            regex : /(declare|local|readonly)(\\s+)(?:(-[fixar]+)(\\s+))?([a-zA-Z_][a-zA-Z0-9_]*\\b)/\n        }, {\n            token : \"variable.language\",\n            regex : builtinVariable\n        }, {\n            token : \"variable\",\n            regex : variable\n        }, {\n            include : \"variables\"\n        }, {\n            token : \"support.function\",\n            regex : func\n        }, {\n            token : \"support.function\",\n            regex : fileDescriptor\n        }, {\n            token : \"string\",           // ' string\n            start : \"'\", end : \"'\"\n        }, {\n            token : \"constant.numeric\", // float\n            regex : floatNumber\n        }, {\n            token : \"constant.numeric\", // integer\n            regex : integer + \"\\\\b\"\n        }, {\n            token : keywordMapper,\n            regex : \"[a-zA-Z_][a-zA-Z0-9_]*\\\\b\"\n        }, {\n            token : \"keyword.operator\",\n            regex : \"\\\\+|\\\\-|\\\\*|\\\\*\\\\*|\\\\/|\\\\/\\\\/|~|<|>|<=|=>|=|!=|[%&|`]\"\n        }, {\n            token : \"punctuation.operator\",\n            regex : \";\"\n        }, {\n            token : \"paren.lparen\",\n            regex : \"[\\\\[\\\\(\\\\{]\"\n        }, {\n            token : \"paren.rparen\",\n            regex : \"[\\\\]]\"\n        }, {\n            token : \"paren.rparen\",\n            regex : \"[\\\\)\\\\}]\",\n            next : \"pop\"\n        }],\n        variables: [{\n            token : \"variable\",\n            regex : /(\\$)(\\w+)/\n        }, {\n            token : [\"variable\", \"paren.lparen\"],\n            regex : /(\\$)(\\()/,\n            push : \"start\"\n        }, {\n            token : [\"variable\", \"paren.lparen\", \"keyword.operator\", \"variable\", \"keyword.operator\"],\n            regex : /(\\$)(\\{)([#!]?)(\\w+|[*@#?\\-$!0_])(:[?+\\-=]?|##?|%%?|,,?\\/|\\^\\^?)?/,\n            push : \"start\"\n        }, {\n            token : \"variable\",\n            regex : /\\$[*@#?\\-$!0_]/\n        }, {\n            token : [\"variable\", \"paren.lparen\"],\n            regex : /(\\$)(\\{)/,\n            push : \"start\"\n        }]\n    };\n    \n    this.normalizeRules();\n};\n\noop.inherits(ShHighlightRules, TextHighlightRules);\n\nexports.ShHighlightRules = ShHighlightRules;\n});\n\nace.define(\"ace/mode/sh\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/sh_highlight_rules\",\"ace/range\",\"ace/mode/folding/cstyle\",\"ace/mode/behaviour/cstyle\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar ShHighlightRules = require(\"./sh_highlight_rules\").ShHighlightRules;\nvar Range = require(\"../range\").Range;\nvar CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\n\nvar Mode = function() {\n    this.HighlightRules = ShHighlightRules;\n    this.foldingRules = new CStyleFoldMode();\n    this.$behaviour = new CstyleBehaviour();\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n   \n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length-1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[:]\\s*$/);\n            if (match) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    var outdents = {\n        \"pass\": 1,\n        \"return\": 1,\n        \"raise\": 1,\n        \"break\": 1,\n        \"continue\": 1\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        if (input !== \"\\r\\n\" && input !== \"\\r\" && input !== \"\\n\")\n            return false;\n\n        var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;\n\n        if (!tokens)\n            return false;\n        do {\n            var last = tokens.pop();\n        } while (last && (last.type == \"comment\" || (last.type == \"text\" && last.value.match(/^\\s+$/))));\n\n        if (!last)\n            return false;\n\n        return (last.type == \"keyword\" && outdents[last.value]);\n    };\n\n    this.autoOutdent = function(state, doc, row) {\n\n        row += 1;\n        var indent = this.$getIndent(doc.getLine(row));\n        var tab = doc.getTabString();\n        if (indent.slice(-tab.length) == tab)\n            doc.remove(new Range(row, indent.length-tab.length, row, indent.length));\n    };\n\n    this.$id = \"ace/mode/sh\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n\nace.define(\"ace/mode/markdown\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/javascript\",\"ace/mode/xml\",\"ace/mode/html\",\"ace/mode/markdown_highlight_rules\",\"ace/mode/folding/markdown\",\"ace/mode/javascript\",\"ace/mode/html\",\"ace/mode/sh\",\"ace/mode/sh\",\"ace/mode/xml\",\"ace/mode/css\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar JavaScriptMode = require(\"./javascript\").Mode;\nvar XmlMode = require(\"./xml\").Mode;\nvar HtmlMode = require(\"./html\").Mode;\nvar MarkdownHighlightRules = require(\"./markdown_highlight_rules\").MarkdownHighlightRules;\nvar MarkdownFoldMode = require(\"./folding/markdown\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = MarkdownHighlightRules;\n\n    this.createModeDelegates({\n        javascript: require(\"./javascript\").Mode,\n        html: require(\"./html\").Mode,\n        bash: require(\"./sh\").Mode,\n        sh: require(\"./sh\").Mode,\n        xml: require(\"./xml\").Mode,\n        css: require(\"./css\").Mode\n    });\n\n    this.foldingRules = new MarkdownFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.type = \"text\";\n    this.blockComment = {start: \"<!--\", end: \"-->\"};\n    this.$quotes = {'\"': '\"', \"`\": \"`\"};\n\n    this.getNextLineIndent = function(state, line, tab) {\n        if (state == \"listblock\") {\n            var match = /^(\\s*)(?:([-+*])|(\\d+)\\.)(\\s+)/.exec(line);\n            if (!match)\n                return \"\";\n            var marker = match[2];\n            if (!marker)\n                marker = parseInt(match[3], 10) + 1 + \".\";\n            return match[1] + marker + match[4];\n        } else {\n            return this.$getIndent(line);\n        }\n    };\n    this.$id = \"ace/mode/markdown\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});                (function() {\n                    ace.require([\"ace/mode/markdown\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/ace-builds/src-noconflict/mode-markdown.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/jquery-form/dist/jquery.form.min.js":
/*!**********************************************************!*\
  !*** ./node_modules/jquery-form/dist/jquery.form.min.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery Form Plugin\n * version: 4.2.2\n * Requires jQuery v1.7.2 or later\n * Project repository: https://github.com/jquery-form/form\n\n * Copyright 2017 Kevin Morris\n * Copyright 2006 M. Alsup\n\n * Dual licensed under the LGPL-2.1+ or MIT licenses\n * https://github.com/jquery-form/form#license\n\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n */\n!function(e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(function(e){\"use strict\";function t(t){var r=t.data;t.isDefaultPrevented()||(t.preventDefault(),e(t.target).closest(\"form\").ajaxSubmit(r))}function r(t){var r=t.target,a=e(r);if(!a.is(\"[type=submit],[type=image]\")){var n=a.closest(\"[type=submit]\");if(0===n.length)return;r=n[0]}var i=r.form;if(i.clk=r,\"image\"===r.type)if(void 0!==t.offsetX)i.clk_x=t.offsetX,i.clk_y=t.offsetY;else if(\"function\"==typeof e.fn.offset){var o=a.offset();i.clk_x=t.pageX-o.left,i.clk_y=t.pageY-o.top}else i.clk_x=t.pageX-r.offsetLeft,i.clk_y=t.pageY-r.offsetTop;setTimeout(function(){i.clk=i.clk_x=i.clk_y=null},100)}function a(){if(e.fn.ajaxSubmit.debug){var t=\"[jquery.form] \"+Array.prototype.join.call(arguments,\"\");window.console&&window.console.log?window.console.log(t):window.opera&&window.opera.postError&&window.opera.postError(t)}}var n=/\\r?\\n/g,i={};i.fileapi=void 0!==e('<input type=\"file\">').get(0).files,i.formdata=void 0!==window.FormData;var o=!!e.fn.prop;e.fn.attr2=function(){if(!o)return this.attr.apply(this,arguments);var e=this.prop.apply(this,arguments);return e&&e.jquery||\"string\"==typeof e?e:this.attr.apply(this,arguments)},e.fn.ajaxSubmit=function(t,r,n,s){function u(r){var a,n,i=e.param(r,t.traditional).split(\"&\"),o=i.length,s=[];for(a=0;a<o;a++)i[a]=i[a].replace(/\\+/g,\" \"),n=i[a].split(\"=\"),s.push([decodeURIComponent(n[0]),decodeURIComponent(n[1])]);return s}function c(r){function n(e){var t=null;try{e.contentWindow&&(t=e.contentWindow.document)}catch(e){a(\"cannot get iframe.contentWindow document: \"+e)}if(t)return t;try{t=e.contentDocument?e.contentDocument:e.document}catch(r){a(\"cannot get iframe.contentDocument: \"+r),t=e.document}return t}function i(){function t(){try{var e=n(v).readyState;a(\"state = \"+e),e&&\"uninitialized\"===e.toLowerCase()&&setTimeout(t,50)}catch(e){a(\"Server abort: \",e,\" (\",e.name,\")\"),s(L),j&&clearTimeout(j),j=void 0}}var r=p.attr2(\"target\"),i=p.attr2(\"action\"),o=p.attr(\"enctype\")||p.attr(\"encoding\")||\"multipart/form-data\";w.setAttribute(\"target\",m),l&&!/post/i.test(l)||w.setAttribute(\"method\",\"POST\"),i!==f.url&&w.setAttribute(\"action\",f.url),f.skipEncodingOverride||l&&!/post/i.test(l)||p.attr({encoding:\"multipart/form-data\",enctype:\"multipart/form-data\"}),f.timeout&&(j=setTimeout(function(){T=!0,s(A)},f.timeout));var u=[];try{if(f.extraData)for(var c in f.extraData)f.extraData.hasOwnProperty(c)&&(e.isPlainObject(f.extraData[c])&&f.extraData[c].hasOwnProperty(\"name\")&&f.extraData[c].hasOwnProperty(\"value\")?u.push(e('<input type=\"hidden\" name=\"'+f.extraData[c].name+'\">',k).val(f.extraData[c].value).appendTo(w)[0]):u.push(e('<input type=\"hidden\" name=\"'+c+'\">',k).val(f.extraData[c]).appendTo(w)[0]));f.iframeTarget||h.appendTo(D),v.attachEvent?v.attachEvent(\"onload\",s):v.addEventListener(\"load\",s,!1),setTimeout(t,15);try{w.submit()}catch(e){document.createElement(\"form\").submit.apply(w)}}finally{w.setAttribute(\"action\",i),w.setAttribute(\"enctype\",o),r?w.setAttribute(\"target\",r):p.removeAttr(\"target\"),e(u).remove()}}function s(t){if(!x.aborted&&!X){if((O=n(v))||(a(\"cannot access response document\"),t=L),t===A&&x)return x.abort(\"timeout\"),void S.reject(x,\"timeout\");if(t===L&&x)return x.abort(\"server abort\"),void S.reject(x,\"error\",\"server abort\");if(O&&O.location.href!==f.iframeSrc||T){v.detachEvent?v.detachEvent(\"onload\",s):v.removeEventListener(\"load\",s,!1);var r,i=\"success\";try{if(T)throw\"timeout\";var o=\"xml\"===f.dataType||O.XMLDocument||e.isXMLDoc(O);if(a(\"isXml=\"+o),!o&&window.opera&&(null===O.body||!O.body.innerHTML)&&--C)return a(\"requeing onLoad callback, DOM not available\"),void setTimeout(s,250);var u=O.body?O.body:O.documentElement;x.responseText=u?u.innerHTML:null,x.responseXML=O.XMLDocument?O.XMLDocument:O,o&&(f.dataType=\"xml\"),x.getResponseHeader=function(e){return{\"content-type\":f.dataType}[e.toLowerCase()]},u&&(x.status=Number(u.getAttribute(\"status\"))||x.status,x.statusText=u.getAttribute(\"statusText\")||x.statusText);var c=(f.dataType||\"\").toLowerCase(),l=/(json|script|text)/.test(c);if(l||f.textarea){var p=O.getElementsByTagName(\"textarea\")[0];if(p)x.responseText=p.value,x.status=Number(p.getAttribute(\"status\"))||x.status,x.statusText=p.getAttribute(\"statusText\")||x.statusText;else if(l){var m=O.getElementsByTagName(\"pre\")[0],g=O.getElementsByTagName(\"body\")[0];m?x.responseText=m.textContent?m.textContent:m.innerText:g&&(x.responseText=g.textContent?g.textContent:g.innerText)}}else\"xml\"===c&&!x.responseXML&&x.responseText&&(x.responseXML=q(x.responseText));try{M=N(x,c,f)}catch(e){i=\"parsererror\",x.error=r=e||i}}catch(e){a(\"error caught: \",e),i=\"error\",x.error=r=e||i}x.aborted&&(a(\"upload aborted\"),i=null),x.status&&(i=x.status>=200&&x.status<300||304===x.status?\"success\":\"error\"),\"success\"===i?(f.success&&f.success.call(f.context,M,\"success\",x),S.resolve(x.responseText,\"success\",x),d&&e.event.trigger(\"ajaxSuccess\",[x,f])):i&&(void 0===r&&(r=x.statusText),f.error&&f.error.call(f.context,x,i,r),S.reject(x,\"error\",r),d&&e.event.trigger(\"ajaxError\",[x,f,r])),d&&e.event.trigger(\"ajaxComplete\",[x,f]),d&&!--e.active&&e.event.trigger(\"ajaxStop\"),f.complete&&f.complete.call(f.context,x,i),X=!0,f.timeout&&clearTimeout(j),setTimeout(function(){f.iframeTarget?h.attr(\"src\",f.iframeSrc):h.remove(),x.responseXML=null},100)}}}var u,c,f,d,m,h,v,x,y,b,T,j,w=p[0],S=e.Deferred();if(S.abort=function(e){x.abort(e)},r)for(c=0;c<g.length;c++)u=e(g[c]),o?u.prop(\"disabled\",!1):u.removeAttr(\"disabled\");(f=e.extend(!0,{},e.ajaxSettings,t)).context=f.context||f,m=\"jqFormIO\"+(new Date).getTime();var k=w.ownerDocument,D=p.closest(\"body\");if(f.iframeTarget?(b=(h=e(f.iframeTarget,k)).attr2(\"name\"))?m=b:h.attr2(\"name\",m):(h=e('<iframe name=\"'+m+'\" src=\"'+f.iframeSrc+'\" />',k)).css({position:\"absolute\",top:\"-1000px\",left:\"-1000px\"}),v=h[0],x={aborted:0,responseText:null,responseXML:null,status:0,statusText:\"n/a\",getAllResponseHeaders:function(){},getResponseHeader:function(){},setRequestHeader:function(){},abort:function(t){var r=\"timeout\"===t?\"timeout\":\"aborted\";a(\"aborting upload... \"+r),this.aborted=1;try{v.contentWindow.document.execCommand&&v.contentWindow.document.execCommand(\"Stop\")}catch(e){}h.attr(\"src\",f.iframeSrc),x.error=r,f.error&&f.error.call(f.context,x,r,t),d&&e.event.trigger(\"ajaxError\",[x,f,r]),f.complete&&f.complete.call(f.context,x,r)}},(d=f.global)&&0==e.active++&&e.event.trigger(\"ajaxStart\"),d&&e.event.trigger(\"ajaxSend\",[x,f]),f.beforeSend&&!1===f.beforeSend.call(f.context,x,f))return f.global&&e.active--,S.reject(),S;if(x.aborted)return S.reject(),S;(y=w.clk)&&(b=y.name)&&!y.disabled&&(f.extraData=f.extraData||{},f.extraData[b]=y.value,\"image\"===y.type&&(f.extraData[b+\".x\"]=w.clk_x,f.extraData[b+\".y\"]=w.clk_y));var A=1,L=2,F=e(\"meta[name=csrf-token]\").attr(\"content\"),E=e(\"meta[name=csrf-param]\").attr(\"content\");E&&F&&(f.extraData=f.extraData||{},f.extraData[E]=F),f.forceSync?i():setTimeout(i,10);var M,O,X,C=50,q=e.parseXML||function(e,t){return window.ActiveXObject?((t=new ActiveXObject(\"Microsoft.XMLDOM\")).async=\"false\",t.loadXML(e)):t=(new DOMParser).parseFromString(e,\"text/xml\"),t&&t.documentElement&&\"parsererror\"!==t.documentElement.nodeName?t:null},_=e.parseJSON||function(e){return window.eval(\"(\"+e+\")\")},N=function(t,r,a){var n=t.getResponseHeader(\"content-type\")||\"\",i=(\"xml\"===r||!r)&&n.indexOf(\"xml\")>=0,o=i?t.responseXML:t.responseText;return i&&\"parsererror\"===o.documentElement.nodeName&&e.error&&e.error(\"parsererror\"),a&&a.dataFilter&&(o=a.dataFilter(o,r)),\"string\"==typeof o&&((\"json\"===r||!r)&&n.indexOf(\"json\")>=0?o=_(o):(\"script\"===r||!r)&&n.indexOf(\"javascript\")>=0&&e.globalEval(o)),o};return S}if(!this.length)return a(\"ajaxSubmit: skipping submit process - no element selected\"),this;var l,f,d,p=this;\"function\"==typeof t?t={success:t}:\"string\"==typeof t||!1===t&&arguments.length>0?(t={url:t,data:r,dataType:n},\"function\"==typeof s&&(t.success=s)):void 0===t&&(t={}),l=t.method||t.type||this.attr2(\"method\"),(d=(d=\"string\"==typeof(f=t.url||this.attr2(\"action\"))?e.trim(f):\"\")||window.location.href||\"\")&&(d=(d.match(/^([^#]+)/)||[])[1]),t=e.extend(!0,{url:d,success:e.ajaxSettings.success,type:l||e.ajaxSettings.type,iframeSrc:/^https/i.test(window.location.href||\"\")?\"javascript:false\":\"about:blank\"},t);var m={};if(this.trigger(\"form-pre-serialize\",[this,t,m]),m.veto)return a(\"ajaxSubmit: submit vetoed via form-pre-serialize trigger\"),this;if(t.beforeSerialize&&!1===t.beforeSerialize(this,t))return a(\"ajaxSubmit: submit aborted via beforeSerialize callback\"),this;var h=t.traditional;void 0===h&&(h=e.ajaxSettings.traditional);var v,g=[],x=this.formToArray(t.semantic,g,t.filtering);if(t.data){var y=e.isFunction(t.data)?t.data(x):t.data;t.extraData=y,v=e.param(y,h)}if(t.beforeSubmit&&!1===t.beforeSubmit(x,this,t))return a(\"ajaxSubmit: submit aborted via beforeSubmit callback\"),this;if(this.trigger(\"form-submit-validate\",[x,this,t,m]),m.veto)return a(\"ajaxSubmit: submit vetoed via form-submit-validate trigger\"),this;var b=e.param(x,h);v&&(b=b?b+\"&\"+v:v),\"GET\"===t.type.toUpperCase()?(t.url+=(t.url.indexOf(\"?\")>=0?\"&\":\"?\")+b,t.data=null):t.data=b;var T=[];if(t.resetForm&&T.push(function(){p.resetForm()}),t.clearForm&&T.push(function(){p.clearForm(t.includeHidden)}),!t.dataType&&t.target){var j=t.success||function(){};T.push(function(r,a,n){var i=arguments,o=t.replaceTarget?\"replaceWith\":\"html\";e(t.target)[o](r).each(function(){j.apply(this,i)})})}else t.success&&(e.isArray(t.success)?e.merge(T,t.success):T.push(t.success));if(t.success=function(e,r,a){for(var n=t.context||this,i=0,o=T.length;i<o;i++)T[i].apply(n,[e,r,a||p,p])},t.error){var w=t.error;t.error=function(e,r,a){var n=t.context||this;w.apply(n,[e,r,a,p])}}if(t.complete){var S=t.complete;t.complete=function(e,r){var a=t.context||this;S.apply(a,[e,r,p])}}var k=e(\"input[type=file]:enabled\",this).filter(function(){return\"\"!==e(this).val()}).length>0,D=\"multipart/form-data\",A=p.attr(\"enctype\")===D||p.attr(\"encoding\")===D,L=i.fileapi&&i.formdata;a(\"fileAPI :\"+L);var F,E=(k||A)&&!L;!1!==t.iframe&&(t.iframe||E)?t.closeKeepAlive?e.get(t.closeKeepAlive,function(){F=c(x)}):F=c(x):F=(k||A)&&L?function(r){for(var a=new FormData,n=0;n<r.length;n++)a.append(r[n].name,r[n].value);if(t.extraData){var i=u(t.extraData);for(n=0;n<i.length;n++)i[n]&&a.append(i[n][0],i[n][1])}t.data=null;var o=e.extend(!0,{},e.ajaxSettings,t,{contentType:!1,processData:!1,cache:!1,type:l||\"POST\"});t.uploadProgress&&(o.xhr=function(){var r=e.ajaxSettings.xhr();return r.upload&&r.upload.addEventListener(\"progress\",function(e){var r=0,a=e.loaded||e.position,n=e.total;e.lengthComputable&&(r=Math.ceil(a/n*100)),t.uploadProgress(e,a,n,r)},!1),r}),o.data=null;var s=o.beforeSend;return o.beforeSend=function(e,r){t.formData?r.data=t.formData:r.data=a,s&&s.call(this,e,r)},e.ajax(o)}(x):e.ajax(t),p.removeData(\"jqxhr\").data(\"jqxhr\",F);for(var M=0;M<g.length;M++)g[M]=null;return this.trigger(\"form-submit-notify\",[this,t]),this},e.fn.ajaxForm=function(n,i,o,s){if((\"string\"==typeof n||!1===n&&arguments.length>0)&&(n={url:n,data:i,dataType:o},\"function\"==typeof s&&(n.success=s)),n=n||{},n.delegation=n.delegation&&e.isFunction(e.fn.on),!n.delegation&&0===this.length){var u={s:this.selector,c:this.context};return!e.isReady&&u.s?(a(\"DOM not ready, queuing ajaxForm\"),e(function(){e(u.s,u.c).ajaxForm(n)}),this):(a(\"terminating; zero elements found by selector\"+(e.isReady?\"\":\" (DOM not ready)\")),this)}return n.delegation?(e(document).off(\"submit.form-plugin\",this.selector,t).off(\"click.form-plugin\",this.selector,r).on(\"submit.form-plugin\",this.selector,n,t).on(\"click.form-plugin\",this.selector,n,r),this):this.ajaxFormUnbind().on(\"submit.form-plugin\",n,t).on(\"click.form-plugin\",n,r)},e.fn.ajaxFormUnbind=function(){return this.off(\"submit.form-plugin click.form-plugin\")},e.fn.formToArray=function(t,r,a){var n=[];if(0===this.length)return n;var o,s=this[0],u=this.attr(\"id\"),c=t||void 0===s.elements?s.getElementsByTagName(\"*\"):s.elements;if(c&&(c=e.makeArray(c)),u&&(t||/(Edge|Trident)\\//.test(navigator.userAgent))&&(o=e(':input[form=\"'+u+'\"]').get()).length&&(c=(c||[]).concat(o)),!c||!c.length)return n;e.isFunction(a)&&(c=e.map(c,a));var l,f,d,p,m,h,v;for(l=0,h=c.length;l<h;l++)if(m=c[l],(d=m.name)&&!m.disabled)if(t&&s.clk&&\"image\"===m.type)s.clk===m&&(n.push({name:d,value:e(m).val(),type:m.type}),n.push({name:d+\".x\",value:s.clk_x},{name:d+\".y\",value:s.clk_y}));else if((p=e.fieldValue(m,!0))&&p.constructor===Array)for(r&&r.push(m),f=0,v=p.length;f<v;f++)n.push({name:d,value:p[f]});else if(i.fileapi&&\"file\"===m.type){r&&r.push(m);var g=m.files;if(g.length)for(f=0;f<g.length;f++)n.push({name:d,value:g[f],type:m.type});else n.push({name:d,value:\"\",type:m.type})}else null!==p&&void 0!==p&&(r&&r.push(m),n.push({name:d,value:p,type:m.type,required:m.required}));if(!t&&s.clk){var x=e(s.clk),y=x[0];(d=y.name)&&!y.disabled&&\"image\"===y.type&&(n.push({name:d,value:x.val()}),n.push({name:d+\".x\",value:s.clk_x},{name:d+\".y\",value:s.clk_y}))}return n},e.fn.formSerialize=function(t){return e.param(this.formToArray(t))},e.fn.fieldSerialize=function(t){var r=[];return this.each(function(){var a=this.name;if(a){var n=e.fieldValue(this,t);if(n&&n.constructor===Array)for(var i=0,o=n.length;i<o;i++)r.push({name:a,value:n[i]});else null!==n&&void 0!==n&&r.push({name:this.name,value:n})}}),e.param(r)},e.fn.fieldValue=function(t){for(var r=[],a=0,n=this.length;a<n;a++){var i=this[a],o=e.fieldValue(i,t);null===o||void 0===o||o.constructor===Array&&!o.length||(o.constructor===Array?e.merge(r,o):r.push(o))}return r},e.fieldValue=function(t,r){var a=t.name,i=t.type,o=t.tagName.toLowerCase();if(void 0===r&&(r=!0),r&&(!a||t.disabled||\"reset\"===i||\"button\"===i||(\"checkbox\"===i||\"radio\"===i)&&!t.checked||(\"submit\"===i||\"image\"===i)&&t.form&&t.form.clk!==t||\"select\"===o&&-1===t.selectedIndex))return null;if(\"select\"===o){var s=t.selectedIndex;if(s<0)return null;for(var u=[],c=t.options,l=\"select-one\"===i,f=l?s+1:c.length,d=l?s:0;d<f;d++){var p=c[d];if(p.selected&&!p.disabled){var m=p.value;if(m||(m=p.attributes&&p.attributes.value&&!p.attributes.value.specified?p.text:p.value),l)return m;u.push(m)}}return u}return e(t).val().replace(n,\"\\r\\n\")},e.fn.clearForm=function(t){return this.each(function(){e(\"input,select,textarea\",this).clearFields(t)})},e.fn.clearFields=e.fn.clearInputs=function(t){var r=/^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;return this.each(function(){var a=this.type,n=this.tagName.toLowerCase();r.test(a)||\"textarea\"===n?this.value=\"\":\"checkbox\"===a||\"radio\"===a?this.checked=!1:\"select\"===n?this.selectedIndex=-1:\"file\"===a?/MSIE/.test(navigator.userAgent)?e(this).replaceWith(e(this).clone(!0)):e(this).val(\"\"):t&&(!0===t&&/hidden/.test(a)||\"string\"==typeof t&&e(this).is(t))&&(this.value=\"\")})},e.fn.resetForm=function(){return this.each(function(){var t=e(this),r=this.tagName.toLowerCase();switch(r){case\"input\":this.checked=this.defaultChecked;case\"textarea\":return this.value=this.defaultValue,!0;case\"option\":case\"optgroup\":var a=t.parents(\"select\");return a.length&&a[0].multiple?\"option\"===r?this.selected=this.defaultSelected:t.find(\"option\").resetForm():a.resetForm(),!0;case\"select\":return t.find(\"option\").each(function(e){if(this.selected=this.defaultSelected,this.defaultSelected&&!t[0].multiple)return t[0].selectedIndex=e,!1}),!0;case\"label\":var n=e(t.attr(\"for\")),i=t.find(\"input,select,textarea\");return n[0]&&i.unshift(n[0]),i.resetForm(),!0;case\"form\":return(\"function\"==typeof this.reset||\"object\"==typeof this.reset&&!this.reset.nodeType)&&this.reset(),!0;default:return t.find(\"form,input,label,select,textarea\").resetForm(),!0}})},e.fn.enable=function(e){return void 0===e&&(e=!0),this.each(function(){this.disabled=!e})},e.fn.selected=function(t){return void 0===t&&(t=!0),this.each(function(){var r=this.type;if(\"checkbox\"===r||\"radio\"===r)this.checked=t;else if(\"option\"===this.tagName.toLowerCase()){var a=e(this).parent(\"select\");t&&a[0]&&\"select-one\"===a[0].type&&a.find(\"option\").selected(!1),this.selected=t}})},e.fn.ajaxSubmit.debug=!1});\n//# sourceMappingURL=jquery.form.min.js.map\n\n\n//# sourceURL=webpack:///./node_modules/jquery-form/dist/jquery.form.min.js?");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.4.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-05-01T21:04Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.4.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code, options ) {\n\t\tDOMEval( code, { nonce: options && options.nonce } );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.4\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2019-04-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t(nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\") ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 && rdescend.test( selector ) ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem.namespaceURI,\n\t\tdocElem = (elem.ownerDocument || elem).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( typeof elem.contentDocument !== \"undefined\" ) {\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t// Support: IE 9-11 only\n\t// Also use offsetWidth/offsetHeight for when box sizing is unreliable\n\t// We use getClientRects() to check for hidden/disconnected.\n\t// In those cases, the computed value can be trusted to be border-box\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\t\tval === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"gridArea\": true,\n\t\t\"gridColumn\": true,\n\t\t\"gridColumnEnd\": true,\n\t\t\"gridColumnStart\": true,\n\t\t\"gridRow\": true,\n\t\t\"gridRowEnd\": true,\n\t\t\"gridRowStart\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url, options ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n\n//# sourceURL=webpack:///./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/showdown/dist/showdown.js":
/*!************************************************!*\
  !*** ./node_modules/showdown/dist/showdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;/*! showdown v 1.9.1 - 02-11-2019 */\r\n(function(){\r\n/**\n * Created by Tivie on 13-07-2015.\n */\n\nfunction getDefaultOpts (simple) {\n  'use strict';\n\n  var defaultOptions = {\n    omitExtraWLInCodeBlocks: {\n      defaultValue: false,\n      describe: 'Omit the default extra whiteline added to code blocks',\n      type: 'boolean'\n    },\n    noHeaderId: {\n      defaultValue: false,\n      describe: 'Turn on/off generated header id',\n      type: 'boolean'\n    },\n    prefixHeaderId: {\n      defaultValue: false,\n      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \\'section-\\' prefix',\n      type: 'string'\n    },\n    rawPrefixHeaderId: {\n      defaultValue: false,\n      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the \" char is used in the prefix)',\n      type: 'boolean'\n    },\n    ghCompatibleHeaderId: {\n      defaultValue: false,\n      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',\n      type: 'boolean'\n    },\n    rawHeaderId: {\n      defaultValue: false,\n      describe: 'Remove only spaces, \\' and \" from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',\n      type: 'boolean'\n    },\n    headerLevelStart: {\n      defaultValue: false,\n      describe: 'The header blocks level start',\n      type: 'integer'\n    },\n    parseImgDimensions: {\n      defaultValue: false,\n      describe: 'Turn on/off image dimension parsing',\n      type: 'boolean'\n    },\n    simplifiedAutoLink: {\n      defaultValue: false,\n      describe: 'Turn on/off GFM autolink style',\n      type: 'boolean'\n    },\n    excludeTrailingPunctuationFromURLs: {\n      defaultValue: false,\n      describe: 'Excludes trailing punctuation from links generated with autoLinking',\n      type: 'boolean'\n    },\n    literalMidWordUnderscores: {\n      defaultValue: false,\n      describe: 'Parse midword underscores as literal underscores',\n      type: 'boolean'\n    },\n    literalMidWordAsterisks: {\n      defaultValue: false,\n      describe: 'Parse midword asterisks as literal asterisks',\n      type: 'boolean'\n    },\n    strikethrough: {\n      defaultValue: false,\n      describe: 'Turn on/off strikethrough support',\n      type: 'boolean'\n    },\n    tables: {\n      defaultValue: false,\n      describe: 'Turn on/off tables support',\n      type: 'boolean'\n    },\n    tablesHeaderId: {\n      defaultValue: false,\n      describe: 'Add an id to table headers',\n      type: 'boolean'\n    },\n    ghCodeBlocks: {\n      defaultValue: true,\n      describe: 'Turn on/off GFM fenced code blocks support',\n      type: 'boolean'\n    },\n    tasklists: {\n      defaultValue: false,\n      describe: 'Turn on/off GFM tasklist support',\n      type: 'boolean'\n    },\n    smoothLivePreview: {\n      defaultValue: false,\n      describe: 'Prevents weird effects in live previews due to incomplete input',\n      type: 'boolean'\n    },\n    smartIndentationFix: {\n      defaultValue: false,\n      description: 'Tries to smartly fix indentation in es6 strings',\n      type: 'boolean'\n    },\n    disableForced4SpacesIndentedSublists: {\n      defaultValue: false,\n      description: 'Disables the requirement of indenting nested sublists by 4 spaces',\n      type: 'boolean'\n    },\n    simpleLineBreaks: {\n      defaultValue: false,\n      description: 'Parses simple line breaks as <br> (GFM Style)',\n      type: 'boolean'\n    },\n    requireSpaceBeforeHeadingText: {\n      defaultValue: false,\n      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',\n      type: 'boolean'\n    },\n    ghMentions: {\n      defaultValue: false,\n      description: 'Enables github @mentions',\n      type: 'boolean'\n    },\n    ghMentionsLink: {\n      defaultValue: 'https://github.com/{u}',\n      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',\n      type: 'string'\n    },\n    encodeEmails: {\n      defaultValue: true,\n      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',\n      type: 'boolean'\n    },\n    openLinksInNewWindow: {\n      defaultValue: false,\n      description: 'Open all links in new windows',\n      type: 'boolean'\n    },\n    backslashEscapesHTMLTags: {\n      defaultValue: false,\n      description: 'Support for HTML Tag escaping. ex: \\<div>foo\\</div>',\n      type: 'boolean'\n    },\n    emoji: {\n      defaultValue: false,\n      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',\n      type: 'boolean'\n    },\n    underline: {\n      defaultValue: false,\n      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',\n      type: 'boolean'\n    },\n    completeHTMLDocument: {\n      defaultValue: false,\n      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',\n      type: 'boolean'\n    },\n    metadata: {\n      defaultValue: false,\n      description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',\n      type: 'boolean'\n    },\n    splitAdjacentBlockquotes: {\n      defaultValue: false,\n      description: 'Split adjacent blockquote blocks',\n      type: 'boolean'\n    }\n  };\n  if (simple === false) {\n    return JSON.parse(JSON.stringify(defaultOptions));\n  }\n  var ret = {};\n  for (var opt in defaultOptions) {\n    if (defaultOptions.hasOwnProperty(opt)) {\n      ret[opt] = defaultOptions[opt].defaultValue;\n    }\n  }\n  return ret;\n}\n\nfunction allOptionsOn () {\n  'use strict';\n  var options = getDefaultOpts(true),\n      ret = {};\n  for (var opt in options) {\n    if (options.hasOwnProperty(opt)) {\n      ret[opt] = true;\n    }\n  }\n  return ret;\n}\n\r\n/**\n * Created by Tivie on 06-01-2015.\n */\n\n// Private properties\nvar showdown = {},\n    parsers = {},\n    extensions = {},\n    globalOptions = getDefaultOpts(true),\n    setFlavor = 'vanilla',\n    flavor = {\n      github: {\n        omitExtraWLInCodeBlocks:              true,\n        simplifiedAutoLink:                   true,\n        excludeTrailingPunctuationFromURLs:   true,\n        literalMidWordUnderscores:            true,\n        strikethrough:                        true,\n        tables:                               true,\n        tablesHeaderId:                       true,\n        ghCodeBlocks:                         true,\n        tasklists:                            true,\n        disableForced4SpacesIndentedSublists: true,\n        simpleLineBreaks:                     true,\n        requireSpaceBeforeHeadingText:        true,\n        ghCompatibleHeaderId:                 true,\n        ghMentions:                           true,\n        backslashEscapesHTMLTags:             true,\n        emoji:                                true,\n        splitAdjacentBlockquotes:             true\n      },\n      original: {\n        noHeaderId:                           true,\n        ghCodeBlocks:                         false\n      },\n      ghost: {\n        omitExtraWLInCodeBlocks:              true,\n        parseImgDimensions:                   true,\n        simplifiedAutoLink:                   true,\n        excludeTrailingPunctuationFromURLs:   true,\n        literalMidWordUnderscores:            true,\n        strikethrough:                        true,\n        tables:                               true,\n        tablesHeaderId:                       true,\n        ghCodeBlocks:                         true,\n        tasklists:                            true,\n        smoothLivePreview:                    true,\n        simpleLineBreaks:                     true,\n        requireSpaceBeforeHeadingText:        true,\n        ghMentions:                           false,\n        encodeEmails:                         true\n      },\n      vanilla: getDefaultOpts(true),\n      allOn: allOptionsOn()\n    };\n\n/**\n * helper namespace\n * @type {{}}\n */\nshowdown.helper = {};\n\n/**\n * TODO LEGACY SUPPORT CODE\n * @type {{}}\n */\nshowdown.extensions = {};\n\n/**\n * Set a global option\n * @static\n * @param {string} key\n * @param {*} value\n * @returns {showdown}\n */\nshowdown.setOption = function (key, value) {\n  'use strict';\n  globalOptions[key] = value;\n  return this;\n};\n\n/**\n * Get a global option\n * @static\n * @param {string} key\n * @returns {*}\n */\nshowdown.getOption = function (key) {\n  'use strict';\n  return globalOptions[key];\n};\n\n/**\n * Get the global options\n * @static\n * @returns {{}}\n */\nshowdown.getOptions = function () {\n  'use strict';\n  return globalOptions;\n};\n\n/**\n * Reset global options to the default values\n * @static\n */\nshowdown.resetOptions = function () {\n  'use strict';\n  globalOptions = getDefaultOpts(true);\n};\n\n/**\n * Set the flavor showdown should use as default\n * @param {string} name\n */\nshowdown.setFlavor = function (name) {\n  'use strict';\n  if (!flavor.hasOwnProperty(name)) {\n    throw Error(name + ' flavor was not found');\n  }\n  showdown.resetOptions();\n  var preset = flavor[name];\n  setFlavor = name;\n  for (var option in preset) {\n    if (preset.hasOwnProperty(option)) {\n      globalOptions[option] = preset[option];\n    }\n  }\n};\n\n/**\n * Get the currently set flavor\n * @returns {string}\n */\nshowdown.getFlavor = function () {\n  'use strict';\n  return setFlavor;\n};\n\n/**\n * Get the options of a specified flavor. Returns undefined if the flavor was not found\n * @param {string} name Name of the flavor\n * @returns {{}|undefined}\n */\nshowdown.getFlavorOptions = function (name) {\n  'use strict';\n  if (flavor.hasOwnProperty(name)) {\n    return flavor[name];\n  }\n};\n\n/**\n * Get the default options\n * @static\n * @param {boolean} [simple=true]\n * @returns {{}}\n */\nshowdown.getDefaultOptions = function (simple) {\n  'use strict';\n  return getDefaultOpts(simple);\n};\n\n/**\n * Get or set a subParser\n *\n * subParser(name)       - Get a registered subParser\n * subParser(name, func) - Register a subParser\n * @static\n * @param {string} name\n * @param {function} [func]\n * @returns {*}\n */\nshowdown.subParser = function (name, func) {\n  'use strict';\n  if (showdown.helper.isString(name)) {\n    if (typeof func !== 'undefined') {\n      parsers[name] = func;\n    } else {\n      if (parsers.hasOwnProperty(name)) {\n        return parsers[name];\n      } else {\n        throw Error('SubParser named ' + name + ' not registered!');\n      }\n    }\n  }\n};\n\n/**\n * Gets or registers an extension\n * @static\n * @param {string} name\n * @param {object|function=} ext\n * @returns {*}\n */\nshowdown.extension = function (name, ext) {\n  'use strict';\n\n  if (!showdown.helper.isString(name)) {\n    throw Error('Extension \\'name\\' must be a string');\n  }\n\n  name = showdown.helper.stdExtName(name);\n\n  // Getter\n  if (showdown.helper.isUndefined(ext)) {\n    if (!extensions.hasOwnProperty(name)) {\n      throw Error('Extension named ' + name + ' is not registered!');\n    }\n    return extensions[name];\n\n    // Setter\n  } else {\n    // Expand extension if it's wrapped in a function\n    if (typeof ext === 'function') {\n      ext = ext();\n    }\n\n    // Ensure extension is an array\n    if (!showdown.helper.isArray(ext)) {\n      ext = [ext];\n    }\n\n    var validExtension = validate(ext, name);\n\n    if (validExtension.valid) {\n      extensions[name] = ext;\n    } else {\n      throw Error(validExtension.error);\n    }\n  }\n};\n\n/**\n * Gets all extensions registered\n * @returns {{}}\n */\nshowdown.getAllExtensions = function () {\n  'use strict';\n  return extensions;\n};\n\n/**\n * Remove an extension\n * @param {string} name\n */\nshowdown.removeExtension = function (name) {\n  'use strict';\n  delete extensions[name];\n};\n\n/**\n * Removes all extensions\n */\nshowdown.resetExtensions = function () {\n  'use strict';\n  extensions = {};\n};\n\n/**\n * Validate extension\n * @param {array} extension\n * @param {string} name\n * @returns {{valid: boolean, error: string}}\n */\nfunction validate (extension, name) {\n  'use strict';\n\n  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',\n      ret = {\n        valid: true,\n        error: ''\n      };\n\n  if (!showdown.helper.isArray(extension)) {\n    extension = [extension];\n  }\n\n  for (var i = 0; i < extension.length; ++i) {\n    var baseMsg = errMsg + ' sub-extension ' + i + ': ',\n        ext = extension[i];\n    if (typeof ext !== 'object') {\n      ret.valid = false;\n      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';\n      return ret;\n    }\n\n    if (!showdown.helper.isString(ext.type)) {\n      ret.valid = false;\n      ret.error = baseMsg + 'property \"type\" must be a string, but ' + typeof ext.type + ' given';\n      return ret;\n    }\n\n    var type = ext.type = ext.type.toLowerCase();\n\n    // normalize extension type\n    if (type === 'language') {\n      type = ext.type = 'lang';\n    }\n\n    if (type === 'html') {\n      type = ext.type = 'output';\n    }\n\n    if (type !== 'lang' && type !== 'output' && type !== 'listener') {\n      ret.valid = false;\n      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: \"lang/language\", \"output/html\" or \"listener\"';\n      return ret;\n    }\n\n    if (type === 'listener') {\n      if (showdown.helper.isUndefined(ext.listeners)) {\n        ret.valid = false;\n        ret.error = baseMsg + '. Extensions of type \"listener\" must have a property called \"listeners\"';\n        return ret;\n      }\n    } else {\n      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {\n        ret.valid = false;\n        ret.error = baseMsg + type + ' extensions must define either a \"regex\" property or a \"filter\" method';\n        return ret;\n      }\n    }\n\n    if (ext.listeners) {\n      if (typeof ext.listeners !== 'object') {\n        ret.valid = false;\n        ret.error = baseMsg + '\"listeners\" property must be an object but ' + typeof ext.listeners + ' given';\n        return ret;\n      }\n      for (var ln in ext.listeners) {\n        if (ext.listeners.hasOwnProperty(ln)) {\n          if (typeof ext.listeners[ln] !== 'function') {\n            ret.valid = false;\n            ret.error = baseMsg + '\"listeners\" property must be an hash of [event name]: [callback]. listeners.' + ln +\n              ' must be a function but ' + typeof ext.listeners[ln] + ' given';\n            return ret;\n          }\n        }\n      }\n    }\n\n    if (ext.filter) {\n      if (typeof ext.filter !== 'function') {\n        ret.valid = false;\n        ret.error = baseMsg + '\"filter\" must be a function, but ' + typeof ext.filter + ' given';\n        return ret;\n      }\n    } else if (ext.regex) {\n      if (showdown.helper.isString(ext.regex)) {\n        ext.regex = new RegExp(ext.regex, 'g');\n      }\n      if (!(ext.regex instanceof RegExp)) {\n        ret.valid = false;\n        ret.error = baseMsg + '\"regex\" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';\n        return ret;\n      }\n      if (showdown.helper.isUndefined(ext.replace)) {\n        ret.valid = false;\n        ret.error = baseMsg + '\"regex\" extensions must implement a replace string or function';\n        return ret;\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n * Validate extension\n * @param {object} ext\n * @returns {boolean}\n */\nshowdown.validateExtension = function (ext) {\n  'use strict';\n\n  var validateExtension = validate(ext, null);\n  if (!validateExtension.valid) {\n    console.warn(validateExtension.error);\n    return false;\n  }\n  return true;\n};\n\r\n/**\n * showdownjs helper functions\n */\n\nif (!showdown.hasOwnProperty('helper')) {\n  showdown.helper = {};\n}\n\n/**\n * Check if var is string\n * @static\n * @param {string} a\n * @returns {boolean}\n */\nshowdown.helper.isString = function (a) {\n  'use strict';\n  return (typeof a === 'string' || a instanceof String);\n};\n\n/**\n * Check if var is a function\n * @static\n * @param {*} a\n * @returns {boolean}\n */\nshowdown.helper.isFunction = function (a) {\n  'use strict';\n  var getType = {};\n  return a && getType.toString.call(a) === '[object Function]';\n};\n\n/**\n * isArray helper function\n * @static\n * @param {*} a\n * @returns {boolean}\n */\nshowdown.helper.isArray = function (a) {\n  'use strict';\n  return Array.isArray(a);\n};\n\n/**\n * Check if value is undefined\n * @static\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n */\nshowdown.helper.isUndefined = function (value) {\n  'use strict';\n  return typeof value === 'undefined';\n};\n\n/**\n * ForEach helper function\n * Iterates over Arrays and Objects (own properties only)\n * @static\n * @param {*} obj\n * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object\n */\nshowdown.helper.forEach = function (obj, callback) {\n  'use strict';\n  // check if obj is defined\n  if (showdown.helper.isUndefined(obj)) {\n    throw new Error('obj param is required');\n  }\n\n  if (showdown.helper.isUndefined(callback)) {\n    throw new Error('callback param is required');\n  }\n\n  if (!showdown.helper.isFunction(callback)) {\n    throw new Error('callback param must be a function/closure');\n  }\n\n  if (typeof obj.forEach === 'function') {\n    obj.forEach(callback);\n  } else if (showdown.helper.isArray(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      callback(obj[i], i, obj);\n    }\n  } else if (typeof (obj) === 'object') {\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        callback(obj[prop], prop, obj);\n      }\n    }\n  } else {\n    throw new Error('obj does not seem to be an array or an iterable object');\n  }\n};\n\n/**\n * Standardidize extension name\n * @static\n * @param {string} s extension name\n * @returns {string}\n */\nshowdown.helper.stdExtName = function (s) {\n  'use strict';\n  return s.replace(/[_?*+\\/\\\\.^-]/g, '').replace(/\\s/g, '').toLowerCase();\n};\n\nfunction escapeCharactersCallback (wholeMatch, m1) {\n  'use strict';\n  var charCodeToEscape = m1.charCodeAt(0);\n  return '¨E' + charCodeToEscape + 'E';\n}\n\n/**\n * Callback used to escape characters when passing through String.replace\n * @static\n * @param {string} wholeMatch\n * @param {string} m1\n * @returns {string}\n */\nshowdown.helper.escapeCharactersCallback = escapeCharactersCallback;\n\n/**\n * Escape characters in a string\n * @static\n * @param {string} text\n * @param {string} charsToEscape\n * @param {boolean} afterBackslash\n * @returns {XML|string|void|*}\n */\nshowdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {\n  'use strict';\n  // First we have to escape the escape characters so that\n  // we can build a character class out of them\n  var regexString = '([' + charsToEscape.replace(/([\\[\\]\\\\])/g, '\\\\$1') + '])';\n\n  if (afterBackslash) {\n    regexString = '\\\\\\\\' + regexString;\n  }\n\n  var regex = new RegExp(regexString, 'g');\n  text = text.replace(regex, escapeCharactersCallback);\n\n  return text;\n};\n\n/**\n * Unescape HTML entities\n * @param txt\n * @returns {string}\n */\nshowdown.helper.unescapeHTMLEntities = function (txt) {\n  'use strict';\n\n  return txt\n    .replace(/&quot;/g, '\"')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&');\n};\n\nvar rgxFindMatchPos = function (str, left, right, flags) {\n  'use strict';\n  var f = flags || '',\n      g = f.indexOf('g') > -1,\n      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),\n      l = new RegExp(left, f.replace(/g/g, '')),\n      pos = [],\n      t, s, m, start, end;\n\n  do {\n    t = 0;\n    while ((m = x.exec(str))) {\n      if (l.test(m[0])) {\n        if (!(t++)) {\n          s = x.lastIndex;\n          start = s - m[0].length;\n        }\n      } else if (t) {\n        if (!--t) {\n          end = m.index + m[0].length;\n          var obj = {\n            left: {start: start, end: s},\n            match: {start: s, end: m.index},\n            right: {start: m.index, end: end},\n            wholeMatch: {start: start, end: end}\n          };\n          pos.push(obj);\n          if (!g) {\n            return pos;\n          }\n        }\n      }\n    }\n  } while (t && (x.lastIndex = s));\n\n  return pos;\n};\n\n/**\n * matchRecursiveRegExp\n *\n * (c) 2007 Steven Levithan <stevenlevithan.com>\n * MIT License\n *\n * Accepts a string to search, a left and right format delimiter\n * as regex patterns, and optional regex flags. Returns an array\n * of matches, allowing nested instances of left/right delimiters.\n * Use the \"g\" flag to return all matches, otherwise only the\n * first is returned. Be careful to ensure that the left and\n * right format delimiters produce mutually exclusive matches.\n * Backreferences are not supported within the right delimiter\n * due to how it is internally combined with the left delimiter.\n * When matching strings whose format delimiters are unbalanced\n * to the left or right, the output is intentionally as a\n * conventional regex library with recursion support would\n * produce, e.g. \"<<x>\" and \"<x>>\" both produce [\"x\"] when using\n * \"<\" and \">\" as the delimiters (both strings contain a single,\n * balanced instance of \"<x>\").\n *\n * examples:\n * matchRecursiveRegExp(\"test\", \"\\\\(\", \"\\\\)\")\n * returns: []\n * matchRecursiveRegExp(\"<t<<e>><s>>t<>\", \"<\", \">\", \"g\")\n * returns: [\"t<<e>><s>\", \"\"]\n * matchRecursiveRegExp(\"<div id=\\\"x\\\">test</div>\", \"<div\\\\b[^>]*>\", \"</div>\", \"gi\")\n * returns: [\"test\"]\n */\nshowdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {\n  'use strict';\n\n  var matchPos = rgxFindMatchPos (str, left, right, flags),\n      results = [];\n\n  for (var i = 0; i < matchPos.length; ++i) {\n    results.push([\n      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\n      str.slice(matchPos[i].match.start, matchPos[i].match.end),\n      str.slice(matchPos[i].left.start, matchPos[i].left.end),\n      str.slice(matchPos[i].right.start, matchPos[i].right.end)\n    ]);\n  }\n  return results;\n};\n\n/**\n *\n * @param {string} str\n * @param {string|function} replacement\n * @param {string} left\n * @param {string} right\n * @param {string} flags\n * @returns {string}\n */\nshowdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {\n  'use strict';\n\n  if (!showdown.helper.isFunction(replacement)) {\n    var repStr = replacement;\n    replacement = function () {\n      return repStr;\n    };\n  }\n\n  var matchPos = rgxFindMatchPos(str, left, right, flags),\n      finalStr = str,\n      lng = matchPos.length;\n\n  if (lng > 0) {\n    var bits = [];\n    if (matchPos[0].wholeMatch.start !== 0) {\n      bits.push(str.slice(0, matchPos[0].wholeMatch.start));\n    }\n    for (var i = 0; i < lng; ++i) {\n      bits.push(\n        replacement(\n          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\n          str.slice(matchPos[i].match.start, matchPos[i].match.end),\n          str.slice(matchPos[i].left.start, matchPos[i].left.end),\n          str.slice(matchPos[i].right.start, matchPos[i].right.end)\n        )\n      );\n      if (i < lng - 1) {\n        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));\n      }\n    }\n    if (matchPos[lng - 1].wholeMatch.end < str.length) {\n      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));\n    }\n    finalStr = bits.join('');\n  }\n  return finalStr;\n};\n\n/**\n * Returns the index within the passed String object of the first occurrence of the specified regex,\n * starting the search at fromIndex. Returns -1 if the value is not found.\n *\n * @param {string} str string to search\n * @param {RegExp} regex Regular expression to search\n * @param {int} [fromIndex = 0] Index to start the search\n * @returns {Number}\n * @throws InvalidArgumentError\n */\nshowdown.helper.regexIndexOf = function (str, regex, fromIndex) {\n  'use strict';\n  if (!showdown.helper.isString(str)) {\n    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';\n  }\n  if (regex instanceof RegExp === false) {\n    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';\n  }\n  var indexOf = str.substring(fromIndex || 0).search(regex);\n  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;\n};\n\n/**\n * Splits the passed string object at the defined index, and returns an array composed of the two substrings\n * @param {string} str string to split\n * @param {int} index index to split string at\n * @returns {[string,string]}\n * @throws InvalidArgumentError\n */\nshowdown.helper.splitAtIndex = function (str, index) {\n  'use strict';\n  if (!showdown.helper.isString(str)) {\n    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';\n  }\n  return [str.substring(0, index), str.substring(index)];\n};\n\n/**\n * Obfuscate an e-mail address through the use of Character Entities,\n * transforming ASCII characters into their equivalent decimal or hex entities.\n *\n * Since it has a random component, subsequent calls to this function produce different results\n *\n * @param {string} mail\n * @returns {string}\n */\nshowdown.helper.encodeEmailAddress = function (mail) {\n  'use strict';\n  var encode = [\n    function (ch) {\n      return '&#' + ch.charCodeAt(0) + ';';\n    },\n    function (ch) {\n      return '&#x' + ch.charCodeAt(0).toString(16) + ';';\n    },\n    function (ch) {\n      return ch;\n    }\n  ];\n\n  mail = mail.replace(/./g, function (ch) {\n    if (ch === '@') {\n      // this *must* be encoded. I insist.\n      ch = encode[Math.floor(Math.random() * 2)](ch);\n    } else {\n      var r = Math.random();\n      // roughly 10% raw, 45% hex, 45% dec\n      ch = (\n        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)\n      );\n    }\n    return ch;\n  });\n\n  return mail;\n};\n\n/**\n *\n * @param str\n * @param targetLength\n * @param padString\n * @returns {string}\n */\nshowdown.helper.padEnd = function padEnd (str, targetLength, padString) {\n  'use strict';\n  /*jshint bitwise: false*/\n  // eslint-disable-next-line space-infix-ops\n  targetLength = targetLength>>0; //floor if number or convert non-number to 0;\n  /*jshint bitwise: true*/\n  padString = String(padString || ' ');\n  if (str.length > targetLength) {\n    return String(str);\n  } else {\n    targetLength = targetLength - str.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\n    }\n    return String(str) + padString.slice(0,targetLength);\n  }\n};\n\n/**\n * POLYFILLS\n */\n// use this instead of builtin is undefined for IE8 compatibility\nif (typeof console === 'undefined') {\n  console = {\n    warn: function (msg) {\n      'use strict';\n      alert(msg);\n    },\n    log: function (msg) {\n      'use strict';\n      alert(msg);\n    },\n    error: function (msg) {\n      'use strict';\n      throw msg;\n    }\n  };\n}\n\n/**\n * Common regexes.\n * We declare some common regexes to improve performance\n */\nshowdown.helper.regexes = {\n  asteriskDashAndColon: /([*_:~])/g\n};\n\n/**\n * EMOJIS LIST\n */\nshowdown.helper.emojis = {\n  '+1':'\\ud83d\\udc4d',\n  '-1':'\\ud83d\\udc4e',\n  '100':'\\ud83d\\udcaf',\n  '1234':'\\ud83d\\udd22',\n  '1st_place_medal':'\\ud83e\\udd47',\n  '2nd_place_medal':'\\ud83e\\udd48',\n  '3rd_place_medal':'\\ud83e\\udd49',\n  '8ball':'\\ud83c\\udfb1',\n  'a':'\\ud83c\\udd70\\ufe0f',\n  'ab':'\\ud83c\\udd8e',\n  'abc':'\\ud83d\\udd24',\n  'abcd':'\\ud83d\\udd21',\n  'accept':'\\ud83c\\ude51',\n  'aerial_tramway':'\\ud83d\\udea1',\n  'airplane':'\\u2708\\ufe0f',\n  'alarm_clock':'\\u23f0',\n  'alembic':'\\u2697\\ufe0f',\n  'alien':'\\ud83d\\udc7d',\n  'ambulance':'\\ud83d\\ude91',\n  'amphora':'\\ud83c\\udffa',\n  'anchor':'\\u2693\\ufe0f',\n  'angel':'\\ud83d\\udc7c',\n  'anger':'\\ud83d\\udca2',\n  'angry':'\\ud83d\\ude20',\n  'anguished':'\\ud83d\\ude27',\n  'ant':'\\ud83d\\udc1c',\n  'apple':'\\ud83c\\udf4e',\n  'aquarius':'\\u2652\\ufe0f',\n  'aries':'\\u2648\\ufe0f',\n  'arrow_backward':'\\u25c0\\ufe0f',\n  'arrow_double_down':'\\u23ec',\n  'arrow_double_up':'\\u23eb',\n  'arrow_down':'\\u2b07\\ufe0f',\n  'arrow_down_small':'\\ud83d\\udd3d',\n  'arrow_forward':'\\u25b6\\ufe0f',\n  'arrow_heading_down':'\\u2935\\ufe0f',\n  'arrow_heading_up':'\\u2934\\ufe0f',\n  'arrow_left':'\\u2b05\\ufe0f',\n  'arrow_lower_left':'\\u2199\\ufe0f',\n  'arrow_lower_right':'\\u2198\\ufe0f',\n  'arrow_right':'\\u27a1\\ufe0f',\n  'arrow_right_hook':'\\u21aa\\ufe0f',\n  'arrow_up':'\\u2b06\\ufe0f',\n  'arrow_up_down':'\\u2195\\ufe0f',\n  'arrow_up_small':'\\ud83d\\udd3c',\n  'arrow_upper_left':'\\u2196\\ufe0f',\n  'arrow_upper_right':'\\u2197\\ufe0f',\n  'arrows_clockwise':'\\ud83d\\udd03',\n  'arrows_counterclockwise':'\\ud83d\\udd04',\n  'art':'\\ud83c\\udfa8',\n  'articulated_lorry':'\\ud83d\\ude9b',\n  'artificial_satellite':'\\ud83d\\udef0',\n  'astonished':'\\ud83d\\ude32',\n  'athletic_shoe':'\\ud83d\\udc5f',\n  'atm':'\\ud83c\\udfe7',\n  'atom_symbol':'\\u269b\\ufe0f',\n  'avocado':'\\ud83e\\udd51',\n  'b':'\\ud83c\\udd71\\ufe0f',\n  'baby':'\\ud83d\\udc76',\n  'baby_bottle':'\\ud83c\\udf7c',\n  'baby_chick':'\\ud83d\\udc24',\n  'baby_symbol':'\\ud83d\\udebc',\n  'back':'\\ud83d\\udd19',\n  'bacon':'\\ud83e\\udd53',\n  'badminton':'\\ud83c\\udff8',\n  'baggage_claim':'\\ud83d\\udec4',\n  'baguette_bread':'\\ud83e\\udd56',\n  'balance_scale':'\\u2696\\ufe0f',\n  'balloon':'\\ud83c\\udf88',\n  'ballot_box':'\\ud83d\\uddf3',\n  'ballot_box_with_check':'\\u2611\\ufe0f',\n  'bamboo':'\\ud83c\\udf8d',\n  'banana':'\\ud83c\\udf4c',\n  'bangbang':'\\u203c\\ufe0f',\n  'bank':'\\ud83c\\udfe6',\n  'bar_chart':'\\ud83d\\udcca',\n  'barber':'\\ud83d\\udc88',\n  'baseball':'\\u26be\\ufe0f',\n  'basketball':'\\ud83c\\udfc0',\n  'basketball_man':'\\u26f9\\ufe0f',\n  'basketball_woman':'\\u26f9\\ufe0f&zwj;\\u2640\\ufe0f',\n  'bat':'\\ud83e\\udd87',\n  'bath':'\\ud83d\\udec0',\n  'bathtub':'\\ud83d\\udec1',\n  'battery':'\\ud83d\\udd0b',\n  'beach_umbrella':'\\ud83c\\udfd6',\n  'bear':'\\ud83d\\udc3b',\n  'bed':'\\ud83d\\udecf',\n  'bee':'\\ud83d\\udc1d',\n  'beer':'\\ud83c\\udf7a',\n  'beers':'\\ud83c\\udf7b',\n  'beetle':'\\ud83d\\udc1e',\n  'beginner':'\\ud83d\\udd30',\n  'bell':'\\ud83d\\udd14',\n  'bellhop_bell':'\\ud83d\\udece',\n  'bento':'\\ud83c\\udf71',\n  'biking_man':'\\ud83d\\udeb4',\n  'bike':'\\ud83d\\udeb2',\n  'biking_woman':'\\ud83d\\udeb4&zwj;\\u2640\\ufe0f',\n  'bikini':'\\ud83d\\udc59',\n  'biohazard':'\\u2623\\ufe0f',\n  'bird':'\\ud83d\\udc26',\n  'birthday':'\\ud83c\\udf82',\n  'black_circle':'\\u26ab\\ufe0f',\n  'black_flag':'\\ud83c\\udff4',\n  'black_heart':'\\ud83d\\udda4',\n  'black_joker':'\\ud83c\\udccf',\n  'black_large_square':'\\u2b1b\\ufe0f',\n  'black_medium_small_square':'\\u25fe\\ufe0f',\n  'black_medium_square':'\\u25fc\\ufe0f',\n  'black_nib':'\\u2712\\ufe0f',\n  'black_small_square':'\\u25aa\\ufe0f',\n  'black_square_button':'\\ud83d\\udd32',\n  'blonde_man':'\\ud83d\\udc71',\n  'blonde_woman':'\\ud83d\\udc71&zwj;\\u2640\\ufe0f',\n  'blossom':'\\ud83c\\udf3c',\n  'blowfish':'\\ud83d\\udc21',\n  'blue_book':'\\ud83d\\udcd8',\n  'blue_car':'\\ud83d\\ude99',\n  'blue_heart':'\\ud83d\\udc99',\n  'blush':'\\ud83d\\ude0a',\n  'boar':'\\ud83d\\udc17',\n  'boat':'\\u26f5\\ufe0f',\n  'bomb':'\\ud83d\\udca3',\n  'book':'\\ud83d\\udcd6',\n  'bookmark':'\\ud83d\\udd16',\n  'bookmark_tabs':'\\ud83d\\udcd1',\n  'books':'\\ud83d\\udcda',\n  'boom':'\\ud83d\\udca5',\n  'boot':'\\ud83d\\udc62',\n  'bouquet':'\\ud83d\\udc90',\n  'bowing_man':'\\ud83d\\ude47',\n  'bow_and_arrow':'\\ud83c\\udff9',\n  'bowing_woman':'\\ud83d\\ude47&zwj;\\u2640\\ufe0f',\n  'bowling':'\\ud83c\\udfb3',\n  'boxing_glove':'\\ud83e\\udd4a',\n  'boy':'\\ud83d\\udc66',\n  'bread':'\\ud83c\\udf5e',\n  'bride_with_veil':'\\ud83d\\udc70',\n  'bridge_at_night':'\\ud83c\\udf09',\n  'briefcase':'\\ud83d\\udcbc',\n  'broken_heart':'\\ud83d\\udc94',\n  'bug':'\\ud83d\\udc1b',\n  'building_construction':'\\ud83c\\udfd7',\n  'bulb':'\\ud83d\\udca1',\n  'bullettrain_front':'\\ud83d\\ude85',\n  'bullettrain_side':'\\ud83d\\ude84',\n  'burrito':'\\ud83c\\udf2f',\n  'bus':'\\ud83d\\ude8c',\n  'business_suit_levitating':'\\ud83d\\udd74',\n  'busstop':'\\ud83d\\ude8f',\n  'bust_in_silhouette':'\\ud83d\\udc64',\n  'busts_in_silhouette':'\\ud83d\\udc65',\n  'butterfly':'\\ud83e\\udd8b',\n  'cactus':'\\ud83c\\udf35',\n  'cake':'\\ud83c\\udf70',\n  'calendar':'\\ud83d\\udcc6',\n  'call_me_hand':'\\ud83e\\udd19',\n  'calling':'\\ud83d\\udcf2',\n  'camel':'\\ud83d\\udc2b',\n  'camera':'\\ud83d\\udcf7',\n  'camera_flash':'\\ud83d\\udcf8',\n  'camping':'\\ud83c\\udfd5',\n  'cancer':'\\u264b\\ufe0f',\n  'candle':'\\ud83d\\udd6f',\n  'candy':'\\ud83c\\udf6c',\n  'canoe':'\\ud83d\\udef6',\n  'capital_abcd':'\\ud83d\\udd20',\n  'capricorn':'\\u2651\\ufe0f',\n  'car':'\\ud83d\\ude97',\n  'card_file_box':'\\ud83d\\uddc3',\n  'card_index':'\\ud83d\\udcc7',\n  'card_index_dividers':'\\ud83d\\uddc2',\n  'carousel_horse':'\\ud83c\\udfa0',\n  'carrot':'\\ud83e\\udd55',\n  'cat':'\\ud83d\\udc31',\n  'cat2':'\\ud83d\\udc08',\n  'cd':'\\ud83d\\udcbf',\n  'chains':'\\u26d3',\n  'champagne':'\\ud83c\\udf7e',\n  'chart':'\\ud83d\\udcb9',\n  'chart_with_downwards_trend':'\\ud83d\\udcc9',\n  'chart_with_upwards_trend':'\\ud83d\\udcc8',\n  'checkered_flag':'\\ud83c\\udfc1',\n  'cheese':'\\ud83e\\uddc0',\n  'cherries':'\\ud83c\\udf52',\n  'cherry_blossom':'\\ud83c\\udf38',\n  'chestnut':'\\ud83c\\udf30',\n  'chicken':'\\ud83d\\udc14',\n  'children_crossing':'\\ud83d\\udeb8',\n  'chipmunk':'\\ud83d\\udc3f',\n  'chocolate_bar':'\\ud83c\\udf6b',\n  'christmas_tree':'\\ud83c\\udf84',\n  'church':'\\u26ea\\ufe0f',\n  'cinema':'\\ud83c\\udfa6',\n  'circus_tent':'\\ud83c\\udfaa',\n  'city_sunrise':'\\ud83c\\udf07',\n  'city_sunset':'\\ud83c\\udf06',\n  'cityscape':'\\ud83c\\udfd9',\n  'cl':'\\ud83c\\udd91',\n  'clamp':'\\ud83d\\udddc',\n  'clap':'\\ud83d\\udc4f',\n  'clapper':'\\ud83c\\udfac',\n  'classical_building':'\\ud83c\\udfdb',\n  'clinking_glasses':'\\ud83e\\udd42',\n  'clipboard':'\\ud83d\\udccb',\n  'clock1':'\\ud83d\\udd50',\n  'clock10':'\\ud83d\\udd59',\n  'clock1030':'\\ud83d\\udd65',\n  'clock11':'\\ud83d\\udd5a',\n  'clock1130':'\\ud83d\\udd66',\n  'clock12':'\\ud83d\\udd5b',\n  'clock1230':'\\ud83d\\udd67',\n  'clock130':'\\ud83d\\udd5c',\n  'clock2':'\\ud83d\\udd51',\n  'clock230':'\\ud83d\\udd5d',\n  'clock3':'\\ud83d\\udd52',\n  'clock330':'\\ud83d\\udd5e',\n  'clock4':'\\ud83d\\udd53',\n  'clock430':'\\ud83d\\udd5f',\n  'clock5':'\\ud83d\\udd54',\n  'clock530':'\\ud83d\\udd60',\n  'clock6':'\\ud83d\\udd55',\n  'clock630':'\\ud83d\\udd61',\n  'clock7':'\\ud83d\\udd56',\n  'clock730':'\\ud83d\\udd62',\n  'clock8':'\\ud83d\\udd57',\n  'clock830':'\\ud83d\\udd63',\n  'clock9':'\\ud83d\\udd58',\n  'clock930':'\\ud83d\\udd64',\n  'closed_book':'\\ud83d\\udcd5',\n  'closed_lock_with_key':'\\ud83d\\udd10',\n  'closed_umbrella':'\\ud83c\\udf02',\n  'cloud':'\\u2601\\ufe0f',\n  'cloud_with_lightning':'\\ud83c\\udf29',\n  'cloud_with_lightning_and_rain':'\\u26c8',\n  'cloud_with_rain':'\\ud83c\\udf27',\n  'cloud_with_snow':'\\ud83c\\udf28',\n  'clown_face':'\\ud83e\\udd21',\n  'clubs':'\\u2663\\ufe0f',\n  'cocktail':'\\ud83c\\udf78',\n  'coffee':'\\u2615\\ufe0f',\n  'coffin':'\\u26b0\\ufe0f',\n  'cold_sweat':'\\ud83d\\ude30',\n  'comet':'\\u2604\\ufe0f',\n  'computer':'\\ud83d\\udcbb',\n  'computer_mouse':'\\ud83d\\uddb1',\n  'confetti_ball':'\\ud83c\\udf8a',\n  'confounded':'\\ud83d\\ude16',\n  'confused':'\\ud83d\\ude15',\n  'congratulations':'\\u3297\\ufe0f',\n  'construction':'\\ud83d\\udea7',\n  'construction_worker_man':'\\ud83d\\udc77',\n  'construction_worker_woman':'\\ud83d\\udc77&zwj;\\u2640\\ufe0f',\n  'control_knobs':'\\ud83c\\udf9b',\n  'convenience_store':'\\ud83c\\udfea',\n  'cookie':'\\ud83c\\udf6a',\n  'cool':'\\ud83c\\udd92',\n  'policeman':'\\ud83d\\udc6e',\n  'copyright':'\\u00a9\\ufe0f',\n  'corn':'\\ud83c\\udf3d',\n  'couch_and_lamp':'\\ud83d\\udecb',\n  'couple':'\\ud83d\\udc6b',\n  'couple_with_heart_woman_man':'\\ud83d\\udc91',\n  'couple_with_heart_man_man':'\\ud83d\\udc68&zwj;\\u2764\\ufe0f&zwj;\\ud83d\\udc68',\n  'couple_with_heart_woman_woman':'\\ud83d\\udc69&zwj;\\u2764\\ufe0f&zwj;\\ud83d\\udc69',\n  'couplekiss_man_man':'\\ud83d\\udc68&zwj;\\u2764\\ufe0f&zwj;\\ud83d\\udc8b&zwj;\\ud83d\\udc68',\n  'couplekiss_man_woman':'\\ud83d\\udc8f',\n  'couplekiss_woman_woman':'\\ud83d\\udc69&zwj;\\u2764\\ufe0f&zwj;\\ud83d\\udc8b&zwj;\\ud83d\\udc69',\n  'cow':'\\ud83d\\udc2e',\n  'cow2':'\\ud83d\\udc04',\n  'cowboy_hat_face':'\\ud83e\\udd20',\n  'crab':'\\ud83e\\udd80',\n  'crayon':'\\ud83d\\udd8d',\n  'credit_card':'\\ud83d\\udcb3',\n  'crescent_moon':'\\ud83c\\udf19',\n  'cricket':'\\ud83c\\udfcf',\n  'crocodile':'\\ud83d\\udc0a',\n  'croissant':'\\ud83e\\udd50',\n  'crossed_fingers':'\\ud83e\\udd1e',\n  'crossed_flags':'\\ud83c\\udf8c',\n  'crossed_swords':'\\u2694\\ufe0f',\n  'crown':'\\ud83d\\udc51',\n  'cry':'\\ud83d\\ude22',\n  'crying_cat_face':'\\ud83d\\ude3f',\n  'crystal_ball':'\\ud83d\\udd2e',\n  'cucumber':'\\ud83e\\udd52',\n  'cupid':'\\ud83d\\udc98',\n  'curly_loop':'\\u27b0',\n  'currency_exchange':'\\ud83d\\udcb1',\n  'curry':'\\ud83c\\udf5b',\n  'custard':'\\ud83c\\udf6e',\n  'customs':'\\ud83d\\udec3',\n  'cyclone':'\\ud83c\\udf00',\n  'dagger':'\\ud83d\\udde1',\n  'dancer':'\\ud83d\\udc83',\n  'dancing_women':'\\ud83d\\udc6f',\n  'dancing_men':'\\ud83d\\udc6f&zwj;\\u2642\\ufe0f',\n  'dango':'\\ud83c\\udf61',\n  'dark_sunglasses':'\\ud83d\\udd76',\n  'dart':'\\ud83c\\udfaf',\n  'dash':'\\ud83d\\udca8',\n  'date':'\\ud83d\\udcc5',\n  'deciduous_tree':'\\ud83c\\udf33',\n  'deer':'\\ud83e\\udd8c',\n  'department_store':'\\ud83c\\udfec',\n  'derelict_house':'\\ud83c\\udfda',\n  'desert':'\\ud83c\\udfdc',\n  'desert_island':'\\ud83c\\udfdd',\n  'desktop_computer':'\\ud83d\\udda5',\n  'male_detective':'\\ud83d\\udd75\\ufe0f',\n  'diamond_shape_with_a_dot_inside':'\\ud83d\\udca0',\n  'diamonds':'\\u2666\\ufe0f',\n  'disappointed':'\\ud83d\\ude1e',\n  'disappointed_relieved':'\\ud83d\\ude25',\n  'dizzy':'\\ud83d\\udcab',\n  'dizzy_face':'\\ud83d\\ude35',\n  'do_not_litter':'\\ud83d\\udeaf',\n  'dog':'\\ud83d\\udc36',\n  'dog2':'\\ud83d\\udc15',\n  'dollar':'\\ud83d\\udcb5',\n  'dolls':'\\ud83c\\udf8e',\n  'dolphin':'\\ud83d\\udc2c',\n  'door':'\\ud83d\\udeaa',\n  'doughnut':'\\ud83c\\udf69',\n  'dove':'\\ud83d\\udd4a',\n  'dragon':'\\ud83d\\udc09',\n  'dragon_face':'\\ud83d\\udc32',\n  'dress':'\\ud83d\\udc57',\n  'dromedary_camel':'\\ud83d\\udc2a',\n  'drooling_face':'\\ud83e\\udd24',\n  'droplet':'\\ud83d\\udca7',\n  'drum':'\\ud83e\\udd41',\n  'duck':'\\ud83e\\udd86',\n  'dvd':'\\ud83d\\udcc0',\n  'e-mail':'\\ud83d\\udce7',\n  'eagle':'\\ud83e\\udd85',\n  'ear':'\\ud83d\\udc42',\n  'ear_of_rice':'\\ud83c\\udf3e',\n  'earth_africa':'\\ud83c\\udf0d',\n  'earth_americas':'\\ud83c\\udf0e',\n  'earth_asia':'\\ud83c\\udf0f',\n  'egg':'\\ud83e\\udd5a',\n  'eggplant':'\\ud83c\\udf46',\n  'eight_pointed_black_star':'\\u2734\\ufe0f',\n  'eight_spoked_asterisk':'\\u2733\\ufe0f',\n  'electric_plug':'\\ud83d\\udd0c',\n  'elephant':'\\ud83d\\udc18',\n  'email':'\\u2709\\ufe0f',\n  'end':'\\ud83d\\udd1a',\n  'envelope_with_arrow':'\\ud83d\\udce9',\n  'euro':'\\ud83d\\udcb6',\n  'european_castle':'\\ud83c\\udff0',\n  'european_post_office':'\\ud83c\\udfe4',\n  'evergreen_tree':'\\ud83c\\udf32',\n  'exclamation':'\\u2757\\ufe0f',\n  'expressionless':'\\ud83d\\ude11',\n  'eye':'\\ud83d\\udc41',\n  'eye_speech_bubble':'\\ud83d\\udc41&zwj;\\ud83d\\udde8',\n  'eyeglasses':'\\ud83d\\udc53',\n  'eyes':'\\ud83d\\udc40',\n  'face_with_head_bandage':'\\ud83e\\udd15',\n  'face_with_thermometer':'\\ud83e\\udd12',\n  'fist_oncoming':'\\ud83d\\udc4a',\n  'factory':'\\ud83c\\udfed',\n  'fallen_leaf':'\\ud83c\\udf42',\n  'family_man_woman_boy':'\\ud83d\\udc6a',\n  'family_man_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc66',\n  'family_man_boy_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc66&zwj;\\ud83d\\udc66',\n  'family_man_girl':'\\ud83d\\udc68&zwj;\\ud83d\\udc67',\n  'family_man_girl_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc66',\n  'family_man_girl_girl':'\\ud83d\\udc68&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc67',\n  'family_man_man_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc68&zwj;\\ud83d\\udc66',\n  'family_man_man_boy_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc68&zwj;\\ud83d\\udc66&zwj;\\ud83d\\udc66',\n  'family_man_man_girl':'\\ud83d\\udc68&zwj;\\ud83d\\udc68&zwj;\\ud83d\\udc67',\n  'family_man_man_girl_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc68&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc66',\n  'family_man_man_girl_girl':'\\ud83d\\udc68&zwj;\\ud83d\\udc68&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc67',\n  'family_man_woman_boy_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc66&zwj;\\ud83d\\udc66',\n  'family_man_woman_girl':'\\ud83d\\udc68&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc67',\n  'family_man_woman_girl_boy':'\\ud83d\\udc68&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc66',\n  'family_man_woman_girl_girl':'\\ud83d\\udc68&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc67',\n  'family_woman_boy':'\\ud83d\\udc69&zwj;\\ud83d\\udc66',\n  'family_woman_boy_boy':'\\ud83d\\udc69&zwj;\\ud83d\\udc66&zwj;\\ud83d\\udc66',\n  'family_woman_girl':'\\ud83d\\udc69&zwj;\\ud83d\\udc67',\n  'family_woman_girl_boy':'\\ud83d\\udc69&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc66',\n  'family_woman_girl_girl':'\\ud83d\\udc69&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc67',\n  'family_woman_woman_boy':'\\ud83d\\udc69&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc66',\n  'family_woman_woman_boy_boy':'\\ud83d\\udc69&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc66&zwj;\\ud83d\\udc66',\n  'family_woman_woman_girl':'\\ud83d\\udc69&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc67',\n  'family_woman_woman_girl_boy':'\\ud83d\\udc69&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc66',\n  'family_woman_woman_girl_girl':'\\ud83d\\udc69&zwj;\\ud83d\\udc69&zwj;\\ud83d\\udc67&zwj;\\ud83d\\udc67',\n  'fast_forward':'\\u23e9',\n  'fax':'\\ud83d\\udce0',\n  'fearful':'\\ud83d\\ude28',\n  'feet':'\\ud83d\\udc3e',\n  'female_detective':'\\ud83d\\udd75\\ufe0f&zwj;\\u2640\\ufe0f',\n  'ferris_wheel':'\\ud83c\\udfa1',\n  'ferry':'\\u26f4',\n  'field_hockey':'\\ud83c\\udfd1',\n  'file_cabinet':'\\ud83d\\uddc4',\n  'file_folder':'\\ud83d\\udcc1',\n  'film_projector':'\\ud83d\\udcfd',\n  'film_strip':'\\ud83c\\udf9e',\n  'fire':'\\ud83d\\udd25',\n  'fire_engine':'\\ud83d\\ude92',\n  'fireworks':'\\ud83c\\udf86',\n  'first_quarter_moon':'\\ud83c\\udf13',\n  'first_quarter_moon_with_face':'\\ud83c\\udf1b',\n  'fish':'\\ud83d\\udc1f',\n  'fish_cake':'\\ud83c\\udf65',\n  'fishing_pole_and_fish':'\\ud83c\\udfa3',\n  'fist_raised':'\\u270a',\n  'fist_left':'\\ud83e\\udd1b',\n  'fist_right':'\\ud83e\\udd1c',\n  'flags':'\\ud83c\\udf8f',\n  'flashlight':'\\ud83d\\udd26',\n  'fleur_de_lis':'\\u269c\\ufe0f',\n  'flight_arrival':'\\ud83d\\udeec',\n  'flight_departure':'\\ud83d\\udeeb',\n  'floppy_disk':'\\ud83d\\udcbe',\n  'flower_playing_cards':'\\ud83c\\udfb4',\n  'flushed':'\\ud83d\\ude33',\n  'fog':'\\ud83c\\udf2b',\n  'foggy':'\\ud83c\\udf01',\n  'football':'\\ud83c\\udfc8',\n  'footprints':'\\ud83d\\udc63',\n  'fork_and_knife':'\\ud83c\\udf74',\n  'fountain':'\\u26f2\\ufe0f',\n  'fountain_pen':'\\ud83d\\udd8b',\n  'four_leaf_clover':'\\ud83c\\udf40',\n  'fox_face':'\\ud83e\\udd8a',\n  'framed_picture':'\\ud83d\\uddbc',\n  'free':'\\ud83c\\udd93',\n  'fried_egg':'\\ud83c\\udf73',\n  'fried_shrimp':'\\ud83c\\udf64',\n  'fries':'\\ud83c\\udf5f',\n  'frog':'\\ud83d\\udc38',\n  'frowning':'\\ud83d\\ude26',\n  'frowning_face':'\\u2639\\ufe0f',\n  'frowning_man':'\\ud83d\\ude4d&zwj;\\u2642\\ufe0f',\n  'frowning_woman':'\\ud83d\\ude4d',\n  'middle_finger':'\\ud83d\\udd95',\n  'fuelpump':'\\u26fd\\ufe0f',\n  'full_moon':'\\ud83c\\udf15',\n  'full_moon_with_face':'\\ud83c\\udf1d',\n  'funeral_urn':'\\u26b1\\ufe0f',\n  'game_die':'\\ud83c\\udfb2',\n  'gear':'\\u2699\\ufe0f',\n  'gem':'\\ud83d\\udc8e',\n  'gemini':'\\u264a\\ufe0f',\n  'ghost':'\\ud83d\\udc7b',\n  'gift':'\\ud83c\\udf81',\n  'gift_heart':'\\ud83d\\udc9d',\n  'girl':'\\ud83d\\udc67',\n  'globe_with_meridians':'\\ud83c\\udf10',\n  'goal_net':'\\ud83e\\udd45',\n  'goat':'\\ud83d\\udc10',\n  'golf':'\\u26f3\\ufe0f',\n  'golfing_man':'\\ud83c\\udfcc\\ufe0f',\n  'golfing_woman':'\\ud83c\\udfcc\\ufe0f&zwj;\\u2640\\ufe0f',\n  'gorilla':'\\ud83e\\udd8d',\n  'grapes':'\\ud83c\\udf47',\n  'green_apple':'\\ud83c\\udf4f',\n  'green_book':'\\ud83d\\udcd7',\n  'green_heart':'\\ud83d\\udc9a',\n  'green_salad':'\\ud83e\\udd57',\n  'grey_exclamation':'\\u2755',\n  'grey_question':'\\u2754',\n  'grimacing':'\\ud83d\\ude2c',\n  'grin':'\\ud83d\\ude01',\n  'grinning':'\\ud83d\\ude00',\n  'guardsman':'\\ud83d\\udc82',\n  'guardswoman':'\\ud83d\\udc82&zwj;\\u2640\\ufe0f',\n  'guitar':'\\ud83c\\udfb8',\n  'gun':'\\ud83d\\udd2b',\n  'haircut_woman':'\\ud83d\\udc87',\n  'haircut_man':'\\ud83d\\udc87&zwj;\\u2642\\ufe0f',\n  'hamburger':'\\ud83c\\udf54',\n  'hammer':'\\ud83d\\udd28',\n  'hammer_and_pick':'\\u2692',\n  'hammer_and_wrench':'\\ud83d\\udee0',\n  'hamster':'\\ud83d\\udc39',\n  'hand':'\\u270b',\n  'handbag':'\\ud83d\\udc5c',\n  'handshake':'\\ud83e\\udd1d',\n  'hankey':'\\ud83d\\udca9',\n  'hatched_chick':'\\ud83d\\udc25',\n  'hatching_chick':'\\ud83d\\udc23',\n  'headphones':'\\ud83c\\udfa7',\n  'hear_no_evil':'\\ud83d\\ude49',\n  'heart':'\\u2764\\ufe0f',\n  'heart_decoration':'\\ud83d\\udc9f',\n  'heart_eyes':'\\ud83d\\ude0d',\n  'heart_eyes_cat':'\\ud83d\\ude3b',\n  'heartbeat':'\\ud83d\\udc93',\n  'heartpulse':'\\ud83d\\udc97',\n  'hearts':'\\u2665\\ufe0f',\n  'heavy_check_mark':'\\u2714\\ufe0f',\n  'heavy_division_sign':'\\u2797',\n  'heavy_dollar_sign':'\\ud83d\\udcb2',\n  'heavy_heart_exclamation':'\\u2763\\ufe0f',\n  'heavy_minus_sign':'\\u2796',\n  'heavy_multiplication_x':'\\u2716\\ufe0f',\n  'heavy_plus_sign':'\\u2795',\n  'helicopter':'\\ud83d\\ude81',\n  'herb':'\\ud83c\\udf3f',\n  'hibiscus':'\\ud83c\\udf3a',\n  'high_brightness':'\\ud83d\\udd06',\n  'high_heel':'\\ud83d\\udc60',\n  'hocho':'\\ud83d\\udd2a',\n  'hole':'\\ud83d\\udd73',\n  'honey_pot':'\\ud83c\\udf6f',\n  'horse':'\\ud83d\\udc34',\n  'horse_racing':'\\ud83c\\udfc7',\n  'hospital':'\\ud83c\\udfe5',\n  'hot_pepper':'\\ud83c\\udf36',\n  'hotdog':'\\ud83c\\udf2d',\n  'hotel':'\\ud83c\\udfe8',\n  'hotsprings':'\\u2668\\ufe0f',\n  'hourglass':'\\u231b\\ufe0f',\n  'hourglass_flowing_sand':'\\u23f3',\n  'house':'\\ud83c\\udfe0',\n  'house_with_garden':'\\ud83c\\udfe1',\n  'houses':'\\ud83c\\udfd8',\n  'hugs':'\\ud83e\\udd17',\n  'hushed':'\\ud83d\\ude2f',\n  'ice_cream':'\\ud83c\\udf68',\n  'ice_hockey':'\\ud83c\\udfd2',\n  'ice_skate':'\\u26f8',\n  'icecream':'\\ud83c\\udf66',\n  'id':'\\ud83c\\udd94',\n  'ideograph_advantage':'\\ud83c\\ude50',\n  'imp':'\\ud83d\\udc7f',\n  'inbox_tray':'\\ud83d\\udce5',\n  'incoming_envelope':'\\ud83d\\udce8',\n  'tipping_hand_woman':'\\ud83d\\udc81',\n  'information_source':'\\u2139\\ufe0f',\n  'innocent':'\\ud83d\\ude07',\n  'interrobang':'\\u2049\\ufe0f',\n  'iphone':'\\ud83d\\udcf1',\n  'izakaya_lantern':'\\ud83c\\udfee',\n  'jack_o_lantern':'\\ud83c\\udf83',\n  'japan':'\\ud83d\\uddfe',\n  'japanese_castle':'\\ud83c\\udfef',\n  'japanese_goblin':'\\ud83d\\udc7a',\n  'japanese_ogre':'\\ud83d\\udc79',\n  'jeans':'\\ud83d\\udc56',\n  'joy':'\\ud83d\\ude02',\n  'joy_cat':'\\ud83d\\ude39',\n  'joystick':'\\ud83d\\udd79',\n  'kaaba':'\\ud83d\\udd4b',\n  'key':'\\ud83d\\udd11',\n  'keyboard':'\\u2328\\ufe0f',\n  'keycap_ten':'\\ud83d\\udd1f',\n  'kick_scooter':'\\ud83d\\udef4',\n  'kimono':'\\ud83d\\udc58',\n  'kiss':'\\ud83d\\udc8b',\n  'kissing':'\\ud83d\\ude17',\n  'kissing_cat':'\\ud83d\\ude3d',\n  'kissing_closed_eyes':'\\ud83d\\ude1a',\n  'kissing_heart':'\\ud83d\\ude18',\n  'kissing_smiling_eyes':'\\ud83d\\ude19',\n  'kiwi_fruit':'\\ud83e\\udd5d',\n  'koala':'\\ud83d\\udc28',\n  'koko':'\\ud83c\\ude01',\n  'label':'\\ud83c\\udff7',\n  'large_blue_circle':'\\ud83d\\udd35',\n  'large_blue_diamond':'\\ud83d\\udd37',\n  'large_orange_diamond':'\\ud83d\\udd36',\n  'last_quarter_moon':'\\ud83c\\udf17',\n  'last_quarter_moon_with_face':'\\ud83c\\udf1c',\n  'latin_cross':'\\u271d\\ufe0f',\n  'laughing':'\\ud83d\\ude06',\n  'leaves':'\\ud83c\\udf43',\n  'ledger':'\\ud83d\\udcd2',\n  'left_luggage':'\\ud83d\\udec5',\n  'left_right_arrow':'\\u2194\\ufe0f',\n  'leftwards_arrow_with_hook':'\\u21a9\\ufe0f',\n  'lemon':'\\ud83c\\udf4b',\n  'leo':'\\u264c\\ufe0f',\n  'leopard':'\\ud83d\\udc06',\n  'level_slider':'\\ud83c\\udf9a',\n  'libra':'\\u264e\\ufe0f',\n  'light_rail':'\\ud83d\\ude88',\n  'link':'\\ud83d\\udd17',\n  'lion':'\\ud83e\\udd81',\n  'lips':'\\ud83d\\udc44',\n  'lipstick':'\\ud83d\\udc84',\n  'lizard':'\\ud83e\\udd8e',\n  'lock':'\\ud83d\\udd12',\n  'lock_with_ink_pen':'\\ud83d\\udd0f',\n  'lollipop':'\\ud83c\\udf6d',\n  'loop':'\\u27bf',\n  'loud_sound':'\\ud83d\\udd0a',\n  'loudspeaker':'\\ud83d\\udce2',\n  'love_hotel':'\\ud83c\\udfe9',\n  'love_letter':'\\ud83d\\udc8c',\n  'low_brightness':'\\ud83d\\udd05',\n  'lying_face':'\\ud83e\\udd25',\n  'm':'\\u24c2\\ufe0f',\n  'mag':'\\ud83d\\udd0d',\n  'mag_right':'\\ud83d\\udd0e',\n  'mahjong':'\\ud83c\\udc04\\ufe0f',\n  'mailbox':'\\ud83d\\udceb',\n  'mailbox_closed':'\\ud83d\\udcea',\n  'mailbox_with_mail':'\\ud83d\\udcec',\n  'mailbox_with_no_mail':'\\ud83d\\udced',\n  'man':'\\ud83d\\udc68',\n  'man_artist':'\\ud83d\\udc68&zwj;\\ud83c\\udfa8',\n  'man_astronaut':'\\ud83d\\udc68&zwj;\\ud83d\\ude80',\n  'man_cartwheeling':'\\ud83e\\udd38&zwj;\\u2642\\ufe0f',\n  'man_cook':'\\ud83d\\udc68&zwj;\\ud83c\\udf73',\n  'man_dancing':'\\ud83d\\udd7a',\n  'man_facepalming':'\\ud83e\\udd26&zwj;\\u2642\\ufe0f',\n  'man_factory_worker':'\\ud83d\\udc68&zwj;\\ud83c\\udfed',\n  'man_farmer':'\\ud83d\\udc68&zwj;\\ud83c\\udf3e',\n  'man_firefighter':'\\ud83d\\udc68&zwj;\\ud83d\\ude92',\n  'man_health_worker':'\\ud83d\\udc68&zwj;\\u2695\\ufe0f',\n  'man_in_tuxedo':'\\ud83e\\udd35',\n  'man_judge':'\\ud83d\\udc68&zwj;\\u2696\\ufe0f',\n  'man_juggling':'\\ud83e\\udd39&zwj;\\u2642\\ufe0f',\n  'man_mechanic':'\\ud83d\\udc68&zwj;\\ud83d\\udd27',\n  'man_office_worker':'\\ud83d\\udc68&zwj;\\ud83d\\udcbc',\n  'man_pilot':'\\ud83d\\udc68&zwj;\\u2708\\ufe0f',\n  'man_playing_handball':'\\ud83e\\udd3e&zwj;\\u2642\\ufe0f',\n  'man_playing_water_polo':'\\ud83e\\udd3d&zwj;\\u2642\\ufe0f',\n  'man_scientist':'\\ud83d\\udc68&zwj;\\ud83d\\udd2c',\n  'man_shrugging':'\\ud83e\\udd37&zwj;\\u2642\\ufe0f',\n  'man_singer':'\\ud83d\\udc68&zwj;\\ud83c\\udfa4',\n  'man_student':'\\ud83d\\udc68&zwj;\\ud83c\\udf93',\n  'man_teacher':'\\ud83d\\udc68&zwj;\\ud83c\\udfeb',\n  'man_technologist':'\\ud83d\\udc68&zwj;\\ud83d\\udcbb',\n  'man_with_gua_pi_mao':'\\ud83d\\udc72',\n  'man_with_turban':'\\ud83d\\udc73',\n  'tangerine':'\\ud83c\\udf4a',\n  'mans_shoe':'\\ud83d\\udc5e',\n  'mantelpiece_clock':'\\ud83d\\udd70',\n  'maple_leaf':'\\ud83c\\udf41',\n  'martial_arts_uniform':'\\ud83e\\udd4b',\n  'mask':'\\ud83d\\ude37',\n  'massage_woman':'\\ud83d\\udc86',\n  'massage_man':'\\ud83d\\udc86&zwj;\\u2642\\ufe0f',\n  'meat_on_bone':'\\ud83c\\udf56',\n  'medal_military':'\\ud83c\\udf96',\n  'medal_sports':'\\ud83c\\udfc5',\n  'mega':'\\ud83d\\udce3',\n  'melon':'\\ud83c\\udf48',\n  'memo':'\\ud83d\\udcdd',\n  'men_wrestling':'\\ud83e\\udd3c&zwj;\\u2642\\ufe0f',\n  'menorah':'\\ud83d\\udd4e',\n  'mens':'\\ud83d\\udeb9',\n  'metal':'\\ud83e\\udd18',\n  'metro':'\\ud83d\\ude87',\n  'microphone':'\\ud83c\\udfa4',\n  'microscope':'\\ud83d\\udd2c',\n  'milk_glass':'\\ud83e\\udd5b',\n  'milky_way':'\\ud83c\\udf0c',\n  'minibus':'\\ud83d\\ude90',\n  'minidisc':'\\ud83d\\udcbd',\n  'mobile_phone_off':'\\ud83d\\udcf4',\n  'money_mouth_face':'\\ud83e\\udd11',\n  'money_with_wings':'\\ud83d\\udcb8',\n  'moneybag':'\\ud83d\\udcb0',\n  'monkey':'\\ud83d\\udc12',\n  'monkey_face':'\\ud83d\\udc35',\n  'monorail':'\\ud83d\\ude9d',\n  'moon':'\\ud83c\\udf14',\n  'mortar_board':'\\ud83c\\udf93',\n  'mosque':'\\ud83d\\udd4c',\n  'motor_boat':'\\ud83d\\udee5',\n  'motor_scooter':'\\ud83d\\udef5',\n  'motorcycle':'\\ud83c\\udfcd',\n  'motorway':'\\ud83d\\udee3',\n  'mount_fuji':'\\ud83d\\uddfb',\n  'mountain':'\\u26f0',\n  'mountain_biking_man':'\\ud83d\\udeb5',\n  'mountain_biking_woman':'\\ud83d\\udeb5&zwj;\\u2640\\ufe0f',\n  'mountain_cableway':'\\ud83d\\udea0',\n  'mountain_railway':'\\ud83d\\ude9e',\n  'mountain_snow':'\\ud83c\\udfd4',\n  'mouse':'\\ud83d\\udc2d',\n  'mouse2':'\\ud83d\\udc01',\n  'movie_camera':'\\ud83c\\udfa5',\n  'moyai':'\\ud83d\\uddff',\n  'mrs_claus':'\\ud83e\\udd36',\n  'muscle':'\\ud83d\\udcaa',\n  'mushroom':'\\ud83c\\udf44',\n  'musical_keyboard':'\\ud83c\\udfb9',\n  'musical_note':'\\ud83c\\udfb5',\n  'musical_score':'\\ud83c\\udfbc',\n  'mute':'\\ud83d\\udd07',\n  'nail_care':'\\ud83d\\udc85',\n  'name_badge':'\\ud83d\\udcdb',\n  'national_park':'\\ud83c\\udfde',\n  'nauseated_face':'\\ud83e\\udd22',\n  'necktie':'\\ud83d\\udc54',\n  'negative_squared_cross_mark':'\\u274e',\n  'nerd_face':'\\ud83e\\udd13',\n  'neutral_face':'\\ud83d\\ude10',\n  'new':'\\ud83c\\udd95',\n  'new_moon':'\\ud83c\\udf11',\n  'new_moon_with_face':'\\ud83c\\udf1a',\n  'newspaper':'\\ud83d\\udcf0',\n  'newspaper_roll':'\\ud83d\\uddde',\n  'next_track_button':'\\u23ed',\n  'ng':'\\ud83c\\udd96',\n  'no_good_man':'\\ud83d\\ude45&zwj;\\u2642\\ufe0f',\n  'no_good_woman':'\\ud83d\\ude45',\n  'night_with_stars':'\\ud83c\\udf03',\n  'no_bell':'\\ud83d\\udd15',\n  'no_bicycles':'\\ud83d\\udeb3',\n  'no_entry':'\\u26d4\\ufe0f',\n  'no_entry_sign':'\\ud83d\\udeab',\n  'no_mobile_phones':'\\ud83d\\udcf5',\n  'no_mouth':'\\ud83d\\ude36',\n  'no_pedestrians':'\\ud83d\\udeb7',\n  'no_smoking':'\\ud83d\\udead',\n  'non-potable_water':'\\ud83d\\udeb1',\n  'nose':'\\ud83d\\udc43',\n  'notebook':'\\ud83d\\udcd3',\n  'notebook_with_decorative_cover':'\\ud83d\\udcd4',\n  'notes':'\\ud83c\\udfb6',\n  'nut_and_bolt':'\\ud83d\\udd29',\n  'o':'\\u2b55\\ufe0f',\n  'o2':'\\ud83c\\udd7e\\ufe0f',\n  'ocean':'\\ud83c\\udf0a',\n  'octopus':'\\ud83d\\udc19',\n  'oden':'\\ud83c\\udf62',\n  'office':'\\ud83c\\udfe2',\n  'oil_drum':'\\ud83d\\udee2',\n  'ok':'\\ud83c\\udd97',\n  'ok_hand':'\\ud83d\\udc4c',\n  'ok_man':'\\ud83d\\ude46&zwj;\\u2642\\ufe0f',\n  'ok_woman':'\\ud83d\\ude46',\n  'old_key':'\\ud83d\\udddd',\n  'older_man':'\\ud83d\\udc74',\n  'older_woman':'\\ud83d\\udc75',\n  'om':'\\ud83d\\udd49',\n  'on':'\\ud83d\\udd1b',\n  'oncoming_automobile':'\\ud83d\\ude98',\n  'oncoming_bus':'\\ud83d\\ude8d',\n  'oncoming_police_car':'\\ud83d\\ude94',\n  'oncoming_taxi':'\\ud83d\\ude96',\n  'open_file_folder':'\\ud83d\\udcc2',\n  'open_hands':'\\ud83d\\udc50',\n  'open_mouth':'\\ud83d\\ude2e',\n  'open_umbrella':'\\u2602\\ufe0f',\n  'ophiuchus':'\\u26ce',\n  'orange_book':'\\ud83d\\udcd9',\n  'orthodox_cross':'\\u2626\\ufe0f',\n  'outbox_tray':'\\ud83d\\udce4',\n  'owl':'\\ud83e\\udd89',\n  'ox':'\\ud83d\\udc02',\n  'package':'\\ud83d\\udce6',\n  'page_facing_up':'\\ud83d\\udcc4',\n  'page_with_curl':'\\ud83d\\udcc3',\n  'pager':'\\ud83d\\udcdf',\n  'paintbrush':'\\ud83d\\udd8c',\n  'palm_tree':'\\ud83c\\udf34',\n  'pancakes':'\\ud83e\\udd5e',\n  'panda_face':'\\ud83d\\udc3c',\n  'paperclip':'\\ud83d\\udcce',\n  'paperclips':'\\ud83d\\udd87',\n  'parasol_on_ground':'\\u26f1',\n  'parking':'\\ud83c\\udd7f\\ufe0f',\n  'part_alternation_mark':'\\u303d\\ufe0f',\n  'partly_sunny':'\\u26c5\\ufe0f',\n  'passenger_ship':'\\ud83d\\udef3',\n  'passport_control':'\\ud83d\\udec2',\n  'pause_button':'\\u23f8',\n  'peace_symbol':'\\u262e\\ufe0f',\n  'peach':'\\ud83c\\udf51',\n  'peanuts':'\\ud83e\\udd5c',\n  'pear':'\\ud83c\\udf50',\n  'pen':'\\ud83d\\udd8a',\n  'pencil2':'\\u270f\\ufe0f',\n  'penguin':'\\ud83d\\udc27',\n  'pensive':'\\ud83d\\ude14',\n  'performing_arts':'\\ud83c\\udfad',\n  'persevere':'\\ud83d\\ude23',\n  'person_fencing':'\\ud83e\\udd3a',\n  'pouting_woman':'\\ud83d\\ude4e',\n  'phone':'\\u260e\\ufe0f',\n  'pick':'\\u26cf',\n  'pig':'\\ud83d\\udc37',\n  'pig2':'\\ud83d\\udc16',\n  'pig_nose':'\\ud83d\\udc3d',\n  'pill':'\\ud83d\\udc8a',\n  'pineapple':'\\ud83c\\udf4d',\n  'ping_pong':'\\ud83c\\udfd3',\n  'pisces':'\\u2653\\ufe0f',\n  'pizza':'\\ud83c\\udf55',\n  'place_of_worship':'\\ud83d\\uded0',\n  'plate_with_cutlery':'\\ud83c\\udf7d',\n  'play_or_pause_button':'\\u23ef',\n  'point_down':'\\ud83d\\udc47',\n  'point_left':'\\ud83d\\udc48',\n  'point_right':'\\ud83d\\udc49',\n  'point_up':'\\u261d\\ufe0f',\n  'point_up_2':'\\ud83d\\udc46',\n  'police_car':'\\ud83d\\ude93',\n  'policewoman':'\\ud83d\\udc6e&zwj;\\u2640\\ufe0f',\n  'poodle':'\\ud83d\\udc29',\n  'popcorn':'\\ud83c\\udf7f',\n  'post_office':'\\ud83c\\udfe3',\n  'postal_horn':'\\ud83d\\udcef',\n  'postbox':'\\ud83d\\udcee',\n  'potable_water':'\\ud83d\\udeb0',\n  'potato':'\\ud83e\\udd54',\n  'pouch':'\\ud83d\\udc5d',\n  'poultry_leg':'\\ud83c\\udf57',\n  'pound':'\\ud83d\\udcb7',\n  'rage':'\\ud83d\\ude21',\n  'pouting_cat':'\\ud83d\\ude3e',\n  'pouting_man':'\\ud83d\\ude4e&zwj;\\u2642\\ufe0f',\n  'pray':'\\ud83d\\ude4f',\n  'prayer_beads':'\\ud83d\\udcff',\n  'pregnant_woman':'\\ud83e\\udd30',\n  'previous_track_button':'\\u23ee',\n  'prince':'\\ud83e\\udd34',\n  'princess':'\\ud83d\\udc78',\n  'printer':'\\ud83d\\udda8',\n  'purple_heart':'\\ud83d\\udc9c',\n  'purse':'\\ud83d\\udc5b',\n  'pushpin':'\\ud83d\\udccc',\n  'put_litter_in_its_place':'\\ud83d\\udeae',\n  'question':'\\u2753',\n  'rabbit':'\\ud83d\\udc30',\n  'rabbit2':'\\ud83d\\udc07',\n  'racehorse':'\\ud83d\\udc0e',\n  'racing_car':'\\ud83c\\udfce',\n  'radio':'\\ud83d\\udcfb',\n  'radio_button':'\\ud83d\\udd18',\n  'radioactive':'\\u2622\\ufe0f',\n  'railway_car':'\\ud83d\\ude83',\n  'railway_track':'\\ud83d\\udee4',\n  'rainbow':'\\ud83c\\udf08',\n  'rainbow_flag':'\\ud83c\\udff3\\ufe0f&zwj;\\ud83c\\udf08',\n  'raised_back_of_hand':'\\ud83e\\udd1a',\n  'raised_hand_with_fingers_splayed':'\\ud83d\\udd90',\n  'raised_hands':'\\ud83d\\ude4c',\n  'raising_hand_woman':'\\ud83d\\ude4b',\n  'raising_hand_man':'\\ud83d\\ude4b&zwj;\\u2642\\ufe0f',\n  'ram':'\\ud83d\\udc0f',\n  'ramen':'\\ud83c\\udf5c',\n  'rat':'\\ud83d\\udc00',\n  'record_button':'\\u23fa',\n  'recycle':'\\u267b\\ufe0f',\n  'red_circle':'\\ud83d\\udd34',\n  'registered':'\\u00ae\\ufe0f',\n  'relaxed':'\\u263a\\ufe0f',\n  'relieved':'\\ud83d\\ude0c',\n  'reminder_ribbon':'\\ud83c\\udf97',\n  'repeat':'\\ud83d\\udd01',\n  'repeat_one':'\\ud83d\\udd02',\n  'rescue_worker_helmet':'\\u26d1',\n  'restroom':'\\ud83d\\udebb',\n  'revolving_hearts':'\\ud83d\\udc9e',\n  'rewind':'\\u23ea',\n  'rhinoceros':'\\ud83e\\udd8f',\n  'ribbon':'\\ud83c\\udf80',\n  'rice':'\\ud83c\\udf5a',\n  'rice_ball':'\\ud83c\\udf59',\n  'rice_cracker':'\\ud83c\\udf58',\n  'rice_scene':'\\ud83c\\udf91',\n  'right_anger_bubble':'\\ud83d\\uddef',\n  'ring':'\\ud83d\\udc8d',\n  'robot':'\\ud83e\\udd16',\n  'rocket':'\\ud83d\\ude80',\n  'rofl':'\\ud83e\\udd23',\n  'roll_eyes':'\\ud83d\\ude44',\n  'roller_coaster':'\\ud83c\\udfa2',\n  'rooster':'\\ud83d\\udc13',\n  'rose':'\\ud83c\\udf39',\n  'rosette':'\\ud83c\\udff5',\n  'rotating_light':'\\ud83d\\udea8',\n  'round_pushpin':'\\ud83d\\udccd',\n  'rowing_man':'\\ud83d\\udea3',\n  'rowing_woman':'\\ud83d\\udea3&zwj;\\u2640\\ufe0f',\n  'rugby_football':'\\ud83c\\udfc9',\n  'running_man':'\\ud83c\\udfc3',\n  'running_shirt_with_sash':'\\ud83c\\udfbd',\n  'running_woman':'\\ud83c\\udfc3&zwj;\\u2640\\ufe0f',\n  'sa':'\\ud83c\\ude02\\ufe0f',\n  'sagittarius':'\\u2650\\ufe0f',\n  'sake':'\\ud83c\\udf76',\n  'sandal':'\\ud83d\\udc61',\n  'santa':'\\ud83c\\udf85',\n  'satellite':'\\ud83d\\udce1',\n  'saxophone':'\\ud83c\\udfb7',\n  'school':'\\ud83c\\udfeb',\n  'school_satchel':'\\ud83c\\udf92',\n  'scissors':'\\u2702\\ufe0f',\n  'scorpion':'\\ud83e\\udd82',\n  'scorpius':'\\u264f\\ufe0f',\n  'scream':'\\ud83d\\ude31',\n  'scream_cat':'\\ud83d\\ude40',\n  'scroll':'\\ud83d\\udcdc',\n  'seat':'\\ud83d\\udcba',\n  'secret':'\\u3299\\ufe0f',\n  'see_no_evil':'\\ud83d\\ude48',\n  'seedling':'\\ud83c\\udf31',\n  'selfie':'\\ud83e\\udd33',\n  'shallow_pan_of_food':'\\ud83e\\udd58',\n  'shamrock':'\\u2618\\ufe0f',\n  'shark':'\\ud83e\\udd88',\n  'shaved_ice':'\\ud83c\\udf67',\n  'sheep':'\\ud83d\\udc11',\n  'shell':'\\ud83d\\udc1a',\n  'shield':'\\ud83d\\udee1',\n  'shinto_shrine':'\\u26e9',\n  'ship':'\\ud83d\\udea2',\n  'shirt':'\\ud83d\\udc55',\n  'shopping':'\\ud83d\\udecd',\n  'shopping_cart':'\\ud83d\\uded2',\n  'shower':'\\ud83d\\udebf',\n  'shrimp':'\\ud83e\\udd90',\n  'signal_strength':'\\ud83d\\udcf6',\n  'six_pointed_star':'\\ud83d\\udd2f',\n  'ski':'\\ud83c\\udfbf',\n  'skier':'\\u26f7',\n  'skull':'\\ud83d\\udc80',\n  'skull_and_crossbones':'\\u2620\\ufe0f',\n  'sleeping':'\\ud83d\\ude34',\n  'sleeping_bed':'\\ud83d\\udecc',\n  'sleepy':'\\ud83d\\ude2a',\n  'slightly_frowning_face':'\\ud83d\\ude41',\n  'slightly_smiling_face':'\\ud83d\\ude42',\n  'slot_machine':'\\ud83c\\udfb0',\n  'small_airplane':'\\ud83d\\udee9',\n  'small_blue_diamond':'\\ud83d\\udd39',\n  'small_orange_diamond':'\\ud83d\\udd38',\n  'small_red_triangle':'\\ud83d\\udd3a',\n  'small_red_triangle_down':'\\ud83d\\udd3b',\n  'smile':'\\ud83d\\ude04',\n  'smile_cat':'\\ud83d\\ude38',\n  'smiley':'\\ud83d\\ude03',\n  'smiley_cat':'\\ud83d\\ude3a',\n  'smiling_imp':'\\ud83d\\ude08',\n  'smirk':'\\ud83d\\ude0f',\n  'smirk_cat':'\\ud83d\\ude3c',\n  'smoking':'\\ud83d\\udeac',\n  'snail':'\\ud83d\\udc0c',\n  'snake':'\\ud83d\\udc0d',\n  'sneezing_face':'\\ud83e\\udd27',\n  'snowboarder':'\\ud83c\\udfc2',\n  'snowflake':'\\u2744\\ufe0f',\n  'snowman':'\\u26c4\\ufe0f',\n  'snowman_with_snow':'\\u2603\\ufe0f',\n  'sob':'\\ud83d\\ude2d',\n  'soccer':'\\u26bd\\ufe0f',\n  'soon':'\\ud83d\\udd1c',\n  'sos':'\\ud83c\\udd98',\n  'sound':'\\ud83d\\udd09',\n  'space_invader':'\\ud83d\\udc7e',\n  'spades':'\\u2660\\ufe0f',\n  'spaghetti':'\\ud83c\\udf5d',\n  'sparkle':'\\u2747\\ufe0f',\n  'sparkler':'\\ud83c\\udf87',\n  'sparkles':'\\u2728',\n  'sparkling_heart':'\\ud83d\\udc96',\n  'speak_no_evil':'\\ud83d\\ude4a',\n  'speaker':'\\ud83d\\udd08',\n  'speaking_head':'\\ud83d\\udde3',\n  'speech_balloon':'\\ud83d\\udcac',\n  'speedboat':'\\ud83d\\udea4',\n  'spider':'\\ud83d\\udd77',\n  'spider_web':'\\ud83d\\udd78',\n  'spiral_calendar':'\\ud83d\\uddd3',\n  'spiral_notepad':'\\ud83d\\uddd2',\n  'spoon':'\\ud83e\\udd44',\n  'squid':'\\ud83e\\udd91',\n  'stadium':'\\ud83c\\udfdf',\n  'star':'\\u2b50\\ufe0f',\n  'star2':'\\ud83c\\udf1f',\n  'star_and_crescent':'\\u262a\\ufe0f',\n  'star_of_david':'\\u2721\\ufe0f',\n  'stars':'\\ud83c\\udf20',\n  'station':'\\ud83d\\ude89',\n  'statue_of_liberty':'\\ud83d\\uddfd',\n  'steam_locomotive':'\\ud83d\\ude82',\n  'stew':'\\ud83c\\udf72',\n  'stop_button':'\\u23f9',\n  'stop_sign':'\\ud83d\\uded1',\n  'stopwatch':'\\u23f1',\n  'straight_ruler':'\\ud83d\\udccf',\n  'strawberry':'\\ud83c\\udf53',\n  'stuck_out_tongue':'\\ud83d\\ude1b',\n  'stuck_out_tongue_closed_eyes':'\\ud83d\\ude1d',\n  'stuck_out_tongue_winking_eye':'\\ud83d\\ude1c',\n  'studio_microphone':'\\ud83c\\udf99',\n  'stuffed_flatbread':'\\ud83e\\udd59',\n  'sun_behind_large_cloud':'\\ud83c\\udf25',\n  'sun_behind_rain_cloud':'\\ud83c\\udf26',\n  'sun_behind_small_cloud':'\\ud83c\\udf24',\n  'sun_with_face':'\\ud83c\\udf1e',\n  'sunflower':'\\ud83c\\udf3b',\n  'sunglasses':'\\ud83d\\ude0e',\n  'sunny':'\\u2600\\ufe0f',\n  'sunrise':'\\ud83c\\udf05',\n  'sunrise_over_mountains':'\\ud83c\\udf04',\n  'surfing_man':'\\ud83c\\udfc4',\n  'surfing_woman':'\\ud83c\\udfc4&zwj;\\u2640\\ufe0f',\n  'sushi':'\\ud83c\\udf63',\n  'suspension_railway':'\\ud83d\\ude9f',\n  'sweat':'\\ud83d\\ude13',\n  'sweat_drops':'\\ud83d\\udca6',\n  'sweat_smile':'\\ud83d\\ude05',\n  'sweet_potato':'\\ud83c\\udf60',\n  'swimming_man':'\\ud83c\\udfca',\n  'swimming_woman':'\\ud83c\\udfca&zwj;\\u2640\\ufe0f',\n  'symbols':'\\ud83d\\udd23',\n  'synagogue':'\\ud83d\\udd4d',\n  'syringe':'\\ud83d\\udc89',\n  'taco':'\\ud83c\\udf2e',\n  'tada':'\\ud83c\\udf89',\n  'tanabata_tree':'\\ud83c\\udf8b',\n  'taurus':'\\u2649\\ufe0f',\n  'taxi':'\\ud83d\\ude95',\n  'tea':'\\ud83c\\udf75',\n  'telephone_receiver':'\\ud83d\\udcde',\n  'telescope':'\\ud83d\\udd2d',\n  'tennis':'\\ud83c\\udfbe',\n  'tent':'\\u26fa\\ufe0f',\n  'thermometer':'\\ud83c\\udf21',\n  'thinking':'\\ud83e\\udd14',\n  'thought_balloon':'\\ud83d\\udcad',\n  'ticket':'\\ud83c\\udfab',\n  'tickets':'\\ud83c\\udf9f',\n  'tiger':'\\ud83d\\udc2f',\n  'tiger2':'\\ud83d\\udc05',\n  'timer_clock':'\\u23f2',\n  'tipping_hand_man':'\\ud83d\\udc81&zwj;\\u2642\\ufe0f',\n  'tired_face':'\\ud83d\\ude2b',\n  'tm':'\\u2122\\ufe0f',\n  'toilet':'\\ud83d\\udebd',\n  'tokyo_tower':'\\ud83d\\uddfc',\n  'tomato':'\\ud83c\\udf45',\n  'tongue':'\\ud83d\\udc45',\n  'top':'\\ud83d\\udd1d',\n  'tophat':'\\ud83c\\udfa9',\n  'tornado':'\\ud83c\\udf2a',\n  'trackball':'\\ud83d\\uddb2',\n  'tractor':'\\ud83d\\ude9c',\n  'traffic_light':'\\ud83d\\udea5',\n  'train':'\\ud83d\\ude8b',\n  'train2':'\\ud83d\\ude86',\n  'tram':'\\ud83d\\ude8a',\n  'triangular_flag_on_post':'\\ud83d\\udea9',\n  'triangular_ruler':'\\ud83d\\udcd0',\n  'trident':'\\ud83d\\udd31',\n  'triumph':'\\ud83d\\ude24',\n  'trolleybus':'\\ud83d\\ude8e',\n  'trophy':'\\ud83c\\udfc6',\n  'tropical_drink':'\\ud83c\\udf79',\n  'tropical_fish':'\\ud83d\\udc20',\n  'truck':'\\ud83d\\ude9a',\n  'trumpet':'\\ud83c\\udfba',\n  'tulip':'\\ud83c\\udf37',\n  'tumbler_glass':'\\ud83e\\udd43',\n  'turkey':'\\ud83e\\udd83',\n  'turtle':'\\ud83d\\udc22',\n  'tv':'\\ud83d\\udcfa',\n  'twisted_rightwards_arrows':'\\ud83d\\udd00',\n  'two_hearts':'\\ud83d\\udc95',\n  'two_men_holding_hands':'\\ud83d\\udc6c',\n  'two_women_holding_hands':'\\ud83d\\udc6d',\n  'u5272':'\\ud83c\\ude39',\n  'u5408':'\\ud83c\\ude34',\n  'u55b6':'\\ud83c\\ude3a',\n  'u6307':'\\ud83c\\ude2f\\ufe0f',\n  'u6708':'\\ud83c\\ude37\\ufe0f',\n  'u6709':'\\ud83c\\ude36',\n  'u6e80':'\\ud83c\\ude35',\n  'u7121':'\\ud83c\\ude1a\\ufe0f',\n  'u7533':'\\ud83c\\ude38',\n  'u7981':'\\ud83c\\ude32',\n  'u7a7a':'\\ud83c\\ude33',\n  'umbrella':'\\u2614\\ufe0f',\n  'unamused':'\\ud83d\\ude12',\n  'underage':'\\ud83d\\udd1e',\n  'unicorn':'\\ud83e\\udd84',\n  'unlock':'\\ud83d\\udd13',\n  'up':'\\ud83c\\udd99',\n  'upside_down_face':'\\ud83d\\ude43',\n  'v':'\\u270c\\ufe0f',\n  'vertical_traffic_light':'\\ud83d\\udea6',\n  'vhs':'\\ud83d\\udcfc',\n  'vibration_mode':'\\ud83d\\udcf3',\n  'video_camera':'\\ud83d\\udcf9',\n  'video_game':'\\ud83c\\udfae',\n  'violin':'\\ud83c\\udfbb',\n  'virgo':'\\u264d\\ufe0f',\n  'volcano':'\\ud83c\\udf0b',\n  'volleyball':'\\ud83c\\udfd0',\n  'vs':'\\ud83c\\udd9a',\n  'vulcan_salute':'\\ud83d\\udd96',\n  'walking_man':'\\ud83d\\udeb6',\n  'walking_woman':'\\ud83d\\udeb6&zwj;\\u2640\\ufe0f',\n  'waning_crescent_moon':'\\ud83c\\udf18',\n  'waning_gibbous_moon':'\\ud83c\\udf16',\n  'warning':'\\u26a0\\ufe0f',\n  'wastebasket':'\\ud83d\\uddd1',\n  'watch':'\\u231a\\ufe0f',\n  'water_buffalo':'\\ud83d\\udc03',\n  'watermelon':'\\ud83c\\udf49',\n  'wave':'\\ud83d\\udc4b',\n  'wavy_dash':'\\u3030\\ufe0f',\n  'waxing_crescent_moon':'\\ud83c\\udf12',\n  'wc':'\\ud83d\\udebe',\n  'weary':'\\ud83d\\ude29',\n  'wedding':'\\ud83d\\udc92',\n  'weight_lifting_man':'\\ud83c\\udfcb\\ufe0f',\n  'weight_lifting_woman':'\\ud83c\\udfcb\\ufe0f&zwj;\\u2640\\ufe0f',\n  'whale':'\\ud83d\\udc33',\n  'whale2':'\\ud83d\\udc0b',\n  'wheel_of_dharma':'\\u2638\\ufe0f',\n  'wheelchair':'\\u267f\\ufe0f',\n  'white_check_mark':'\\u2705',\n  'white_circle':'\\u26aa\\ufe0f',\n  'white_flag':'\\ud83c\\udff3\\ufe0f',\n  'white_flower':'\\ud83d\\udcae',\n  'white_large_square':'\\u2b1c\\ufe0f',\n  'white_medium_small_square':'\\u25fd\\ufe0f',\n  'white_medium_square':'\\u25fb\\ufe0f',\n  'white_small_square':'\\u25ab\\ufe0f',\n  'white_square_button':'\\ud83d\\udd33',\n  'wilted_flower':'\\ud83e\\udd40',\n  'wind_chime':'\\ud83c\\udf90',\n  'wind_face':'\\ud83c\\udf2c',\n  'wine_glass':'\\ud83c\\udf77',\n  'wink':'\\ud83d\\ude09',\n  'wolf':'\\ud83d\\udc3a',\n  'woman':'\\ud83d\\udc69',\n  'woman_artist':'\\ud83d\\udc69&zwj;\\ud83c\\udfa8',\n  'woman_astronaut':'\\ud83d\\udc69&zwj;\\ud83d\\ude80',\n  'woman_cartwheeling':'\\ud83e\\udd38&zwj;\\u2640\\ufe0f',\n  'woman_cook':'\\ud83d\\udc69&zwj;\\ud83c\\udf73',\n  'woman_facepalming':'\\ud83e\\udd26&zwj;\\u2640\\ufe0f',\n  'woman_factory_worker':'\\ud83d\\udc69&zwj;\\ud83c\\udfed',\n  'woman_farmer':'\\ud83d\\udc69&zwj;\\ud83c\\udf3e',\n  'woman_firefighter':'\\ud83d\\udc69&zwj;\\ud83d\\ude92',\n  'woman_health_worker':'\\ud83d\\udc69&zwj;\\u2695\\ufe0f',\n  'woman_judge':'\\ud83d\\udc69&zwj;\\u2696\\ufe0f',\n  'woman_juggling':'\\ud83e\\udd39&zwj;\\u2640\\ufe0f',\n  'woman_mechanic':'\\ud83d\\udc69&zwj;\\ud83d\\udd27',\n  'woman_office_worker':'\\ud83d\\udc69&zwj;\\ud83d\\udcbc',\n  'woman_pilot':'\\ud83d\\udc69&zwj;\\u2708\\ufe0f',\n  'woman_playing_handball':'\\ud83e\\udd3e&zwj;\\u2640\\ufe0f',\n  'woman_playing_water_polo':'\\ud83e\\udd3d&zwj;\\u2640\\ufe0f',\n  'woman_scientist':'\\ud83d\\udc69&zwj;\\ud83d\\udd2c',\n  'woman_shrugging':'\\ud83e\\udd37&zwj;\\u2640\\ufe0f',\n  'woman_singer':'\\ud83d\\udc69&zwj;\\ud83c\\udfa4',\n  'woman_student':'\\ud83d\\udc69&zwj;\\ud83c\\udf93',\n  'woman_teacher':'\\ud83d\\udc69&zwj;\\ud83c\\udfeb',\n  'woman_technologist':'\\ud83d\\udc69&zwj;\\ud83d\\udcbb',\n  'woman_with_turban':'\\ud83d\\udc73&zwj;\\u2640\\ufe0f',\n  'womans_clothes':'\\ud83d\\udc5a',\n  'womans_hat':'\\ud83d\\udc52',\n  'women_wrestling':'\\ud83e\\udd3c&zwj;\\u2640\\ufe0f',\n  'womens':'\\ud83d\\udeba',\n  'world_map':'\\ud83d\\uddfa',\n  'worried':'\\ud83d\\ude1f',\n  'wrench':'\\ud83d\\udd27',\n  'writing_hand':'\\u270d\\ufe0f',\n  'x':'\\u274c',\n  'yellow_heart':'\\ud83d\\udc9b',\n  'yen':'\\ud83d\\udcb4',\n  'yin_yang':'\\u262f\\ufe0f',\n  'yum':'\\ud83d\\ude0b',\n  'zap':'\\u26a1\\ufe0f',\n  'zipper_mouth_face':'\\ud83e\\udd10',\n  'zzz':'\\ud83d\\udca4',\n\n  /* special emojis :P */\n  'octocat':  '<img alt=\":octocat:\" height=\"20\" width=\"20\" align=\"absmiddle\" src=\"https://assets-cdn.github.com/images/icons/emoji/octocat.png\">',\n  'showdown': '<span style=\"font-family: \\'Anonymous Pro\\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;\">S</span>'\n};\n\r\n/**\n * Created by Estevao on 31-05-2015.\n */\n\n/**\n * Showdown Converter class\n * @class\n * @param {object} [converterOptions]\n * @returns {Converter}\n */\nshowdown.Converter = function (converterOptions) {\n  'use strict';\n\n  var\n      /**\n       * Options used by this converter\n       * @private\n       * @type {{}}\n       */\n      options = {},\n\n      /**\n       * Language extensions used by this converter\n       * @private\n       * @type {Array}\n       */\n      langExtensions = [],\n\n      /**\n       * Output modifiers extensions used by this converter\n       * @private\n       * @type {Array}\n       */\n      outputModifiers = [],\n\n      /**\n       * Event listeners\n       * @private\n       * @type {{}}\n       */\n      listeners = {},\n\n      /**\n       * The flavor set in this converter\n       */\n      setConvFlavor = setFlavor,\n\n      /**\n       * Metadata of the document\n       * @type {{parsed: {}, raw: string, format: string}}\n       */\n      metadata = {\n        parsed: {},\n        raw: '',\n        format: ''\n      };\n\n  _constructor();\n\n  /**\n   * Converter constructor\n   * @private\n   */\n  function _constructor () {\n    converterOptions = converterOptions || {};\n\n    for (var gOpt in globalOptions) {\n      if (globalOptions.hasOwnProperty(gOpt)) {\n        options[gOpt] = globalOptions[gOpt];\n      }\n    }\n\n    // Merge options\n    if (typeof converterOptions === 'object') {\n      for (var opt in converterOptions) {\n        if (converterOptions.hasOwnProperty(opt)) {\n          options[opt] = converterOptions[opt];\n        }\n      }\n    } else {\n      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +\n      ' was passed instead.');\n    }\n\n    if (options.extensions) {\n      showdown.helper.forEach(options.extensions, _parseExtension);\n    }\n  }\n\n  /**\n   * Parse extension\n   * @param {*} ext\n   * @param {string} [name='']\n   * @private\n   */\n  function _parseExtension (ext, name) {\n\n    name = name || null;\n    // If it's a string, the extension was previously loaded\n    if (showdown.helper.isString(ext)) {\n      ext = showdown.helper.stdExtName(ext);\n      name = ext;\n\n      // LEGACY_SUPPORT CODE\n      if (showdown.extensions[ext]) {\n        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +\n          'Please inform the developer that the extension should be updated!');\n        legacyExtensionLoading(showdown.extensions[ext], ext);\n        return;\n        // END LEGACY SUPPORT CODE\n\n      } else if (!showdown.helper.isUndefined(extensions[ext])) {\n        ext = extensions[ext];\n\n      } else {\n        throw Error('Extension \"' + ext + '\" could not be loaded. It was either not found or is not a valid extension.');\n      }\n    }\n\n    if (typeof ext === 'function') {\n      ext = ext();\n    }\n\n    if (!showdown.helper.isArray(ext)) {\n      ext = [ext];\n    }\n\n    var validExt = validate(ext, name);\n    if (!validExt.valid) {\n      throw Error(validExt.error);\n    }\n\n    for (var i = 0; i < ext.length; ++i) {\n      switch (ext[i].type) {\n\n        case 'lang':\n          langExtensions.push(ext[i]);\n          break;\n\n        case 'output':\n          outputModifiers.push(ext[i]);\n          break;\n      }\n      if (ext[i].hasOwnProperty('listeners')) {\n        for (var ln in ext[i].listeners) {\n          if (ext[i].listeners.hasOwnProperty(ln)) {\n            listen(ln, ext[i].listeners[ln]);\n          }\n        }\n      }\n    }\n\n  }\n\n  /**\n   * LEGACY_SUPPORT\n   * @param {*} ext\n   * @param {string} name\n   */\n  function legacyExtensionLoading (ext, name) {\n    if (typeof ext === 'function') {\n      ext = ext(new showdown.Converter());\n    }\n    if (!showdown.helper.isArray(ext)) {\n      ext = [ext];\n    }\n    var valid = validate(ext, name);\n\n    if (!valid.valid) {\n      throw Error(valid.error);\n    }\n\n    for (var i = 0; i < ext.length; ++i) {\n      switch (ext[i].type) {\n        case 'lang':\n          langExtensions.push(ext[i]);\n          break;\n        case 'output':\n          outputModifiers.push(ext[i]);\n          break;\n        default:// should never reach here\n          throw Error('Extension loader error: Type unrecognized!!!');\n      }\n    }\n  }\n\n  /**\n   * Listen to an event\n   * @param {string} name\n   * @param {function} callback\n   */\n  function listen (name, callback) {\n    if (!showdown.helper.isString(name)) {\n      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');\n    }\n\n    if (typeof callback !== 'function') {\n      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');\n    }\n\n    if (!listeners.hasOwnProperty(name)) {\n      listeners[name] = [];\n    }\n    listeners[name].push(callback);\n  }\n\n  function rTrimInputText (text) {\n    var rsp = text.match(/^\\s*/)[0].length,\n        rgx = new RegExp('^\\\\s{0,' + rsp + '}', 'gm');\n    return text.replace(rgx, '');\n  }\n\n  /**\n   * Dispatch an event\n   * @private\n   * @param {string} evtName Event name\n   * @param {string} text Text\n   * @param {{}} options Converter Options\n   * @param {{}} globals\n   * @returns {string}\n   */\n  this._dispatch = function dispatch (evtName, text, options, globals) {\n    if (listeners.hasOwnProperty(evtName)) {\n      for (var ei = 0; ei < listeners[evtName].length; ++ei) {\n        var nText = listeners[evtName][ei](evtName, text, this, options, globals);\n        if (nText && typeof nText !== 'undefined') {\n          text = nText;\n        }\n      }\n    }\n    return text;\n  };\n\n  /**\n   * Listen to an event\n   * @param {string} name\n   * @param {function} callback\n   * @returns {showdown.Converter}\n   */\n  this.listen = function (name, callback) {\n    listen(name, callback);\n    return this;\n  };\n\n  /**\n   * Converts a markdown string into HTML\n   * @param {string} text\n   * @returns {*}\n   */\n  this.makeHtml = function (text) {\n    //check if text is not falsy\n    if (!text) {\n      return text;\n    }\n\n    var globals = {\n      gHtmlBlocks:     [],\n      gHtmlMdBlocks:   [],\n      gHtmlSpans:      [],\n      gUrls:           {},\n      gTitles:         {},\n      gDimensions:     {},\n      gListLevel:      0,\n      hashLinkCounts:  {},\n      langExtensions:  langExtensions,\n      outputModifiers: outputModifiers,\n      converter:       this,\n      ghCodeBlocks:    [],\n      metadata: {\n        parsed: {},\n        raw: '',\n        format: ''\n      }\n    };\n\n    // This lets us use ¨ trema as an escape char to avoid md5 hashes\n    // The choice of character is arbitrary; anything that isn't\n    // magic in Markdown will work.\n    text = text.replace(/¨/g, '¨T');\n\n    // Replace $ with ¨D\n    // RegExp interprets $ as a special character\n    // when it's in a replacement string\n    text = text.replace(/\\$/g, '¨D');\n\n    // Standardize line endings\n    text = text.replace(/\\r\\n/g, '\\n'); // DOS to Unix\n    text = text.replace(/\\r/g, '\\n'); // Mac to Unix\n\n    // Stardardize line spaces\n    text = text.replace(/\\u00A0/g, '&nbsp;');\n\n    if (options.smartIndentationFix) {\n      text = rTrimInputText(text);\n    }\n\n    // Make sure text begins and ends with a couple of newlines:\n    text = '\\n\\n' + text + '\\n\\n';\n\n    // detab\n    text = showdown.subParser('detab')(text, options, globals);\n\n    /**\n     * Strip any lines consisting only of spaces and tabs.\n     * This makes subsequent regexs easier to write, because we can\n     * match consecutive blank lines with /\\n+/ instead of something\n     * contorted like /[ \\t]*\\n+/\n     */\n    text = text.replace(/^[ \\t]+$/mg, '');\n\n    //run languageExtensions\n    showdown.helper.forEach(langExtensions, function (ext) {\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\n    });\n\n    // run the sub parsers\n    text = showdown.subParser('metadata')(text, options, globals);\n    text = showdown.subParser('hashPreCodeTags')(text, options, globals);\n    text = showdown.subParser('githubCodeBlocks')(text, options, globals);\n    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\n    text = showdown.subParser('hashCodeTags')(text, options, globals);\n    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);\n    text = showdown.subParser('blockGamut')(text, options, globals);\n    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);\n    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);\n\n    // attacklab: Restore dollar signs\n    text = text.replace(/¨D/g, '$$');\n\n    // attacklab: Restore tremas\n    text = text.replace(/¨T/g, '¨');\n\n    // render a complete html document instead of a partial if the option is enabled\n    text = showdown.subParser('completeHTMLDocument')(text, options, globals);\n\n    // Run output modifiers\n    showdown.helper.forEach(outputModifiers, function (ext) {\n      text = showdown.subParser('runExtension')(ext, text, options, globals);\n    });\n\n    // update metadata\n    metadata = globals.metadata;\n    return text;\n  };\n\n  /**\n   * Converts an HTML string into a markdown string\n   * @param src\n   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.\n   * @returns {string}\n   */\n  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {\n\n    // replace \\r\\n with \\n\n    src = src.replace(/\\r\\n/g, '\\n');\n    src = src.replace(/\\r/g, '\\n'); // old macs\n\n    // due to an edge case, we need to find this: > <\n    // to prevent removing of non silent white spaces\n    // ex: <em>this is</em> <strong>sparta</strong>\n    src = src.replace(/>[ \\t]+</, '>¨NBSP;<');\n\n    if (!HTMLParser) {\n      if (window && window.document) {\n        HTMLParser = window.document;\n      } else {\n        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');\n      }\n    }\n\n    var doc = HTMLParser.createElement('div');\n    doc.innerHTML = src;\n\n    var globals = {\n      preList: substitutePreCodeTags(doc)\n    };\n\n    // remove all newlines and collapse spaces\n    clean(doc);\n\n    // some stuff, like accidental reference links must now be escaped\n    // TODO\n    // doc.innerHTML = doc.innerHTML.replace(/\\[[\\S\\t ]]/);\n\n    var nodes = doc.childNodes,\n        mdDoc = '';\n\n    for (var i = 0; i < nodes.length; i++) {\n      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);\n    }\n\n    function clean (node) {\n      for (var n = 0; n < node.childNodes.length; ++n) {\n        var child = node.childNodes[n];\n        if (child.nodeType === 3) {\n          if (!/\\S/.test(child.nodeValue)) {\n            node.removeChild(child);\n            --n;\n          } else {\n            child.nodeValue = child.nodeValue.split('\\n').join(' ');\n            child.nodeValue = child.nodeValue.replace(/(\\s)+/g, '$1');\n          }\n        } else if (child.nodeType === 1) {\n          clean(child);\n        }\n      }\n    }\n\n    // find all pre tags and replace contents with placeholder\n    // we need this so that we can remove all indentation from html\n    // to ease up parsing\n    function substitutePreCodeTags (doc) {\n\n      var pres = doc.querySelectorAll('pre'),\n          presPH = [];\n\n      for (var i = 0; i < pres.length; ++i) {\n\n        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {\n          var content = pres[i].firstChild.innerHTML.trim(),\n              language = pres[i].firstChild.getAttribute('data-language') || '';\n\n          // if data-language attribute is not defined, then we look for class language-*\n          if (language === '') {\n            var classes = pres[i].firstChild.className.split(' ');\n            for (var c = 0; c < classes.length; ++c) {\n              var matches = classes[c].match(/^language-(.+)$/);\n              if (matches !== null) {\n                language = matches[1];\n                break;\n              }\n            }\n          }\n\n          // unescape html entities in content\n          content = showdown.helper.unescapeHTMLEntities(content);\n\n          presPH.push(content);\n          pres[i].outerHTML = '<precode language=\"' + language + '\" precodenum=\"' + i.toString() + '\"></precode>';\n        } else {\n          presPH.push(pres[i].innerHTML);\n          pres[i].innerHTML = '';\n          pres[i].setAttribute('prenum', i.toString());\n        }\n      }\n      return presPH;\n    }\n\n    return mdDoc;\n  };\n\n  /**\n   * Set an option of this Converter instance\n   * @param {string} key\n   * @param {*} value\n   */\n  this.setOption = function (key, value) {\n    options[key] = value;\n  };\n\n  /**\n   * Get the option of this Converter instance\n   * @param {string} key\n   * @returns {*}\n   */\n  this.getOption = function (key) {\n    return options[key];\n  };\n\n  /**\n   * Get the options of this Converter instance\n   * @returns {{}}\n   */\n  this.getOptions = function () {\n    return options;\n  };\n\n  /**\n   * Add extension to THIS converter\n   * @param {{}} extension\n   * @param {string} [name=null]\n   */\n  this.addExtension = function (extension, name) {\n    name = name || null;\n    _parseExtension(extension, name);\n  };\n\n  /**\n   * Use a global registered extension with THIS converter\n   * @param {string} extensionName Name of the previously registered extension\n   */\n  this.useExtension = function (extensionName) {\n    _parseExtension(extensionName);\n  };\n\n  /**\n   * Set the flavor THIS converter should use\n   * @param {string} name\n   */\n  this.setFlavor = function (name) {\n    if (!flavor.hasOwnProperty(name)) {\n      throw Error(name + ' flavor was not found');\n    }\n    var preset = flavor[name];\n    setConvFlavor = name;\n    for (var option in preset) {\n      if (preset.hasOwnProperty(option)) {\n        options[option] = preset[option];\n      }\n    }\n  };\n\n  /**\n   * Get the currently set flavor of this converter\n   * @returns {string}\n   */\n  this.getFlavor = function () {\n    return setConvFlavor;\n  };\n\n  /**\n   * Remove an extension from THIS converter.\n   * Note: This is a costly operation. It's better to initialize a new converter\n   * and specify the extensions you wish to use\n   * @param {Array} extension\n   */\n  this.removeExtension = function (extension) {\n    if (!showdown.helper.isArray(extension)) {\n      extension = [extension];\n    }\n    for (var a = 0; a < extension.length; ++a) {\n      var ext = extension[a];\n      for (var i = 0; i < langExtensions.length; ++i) {\n        if (langExtensions[i] === ext) {\n          langExtensions[i].splice(i, 1);\n        }\n      }\n      for (var ii = 0; ii < outputModifiers.length; ++i) {\n        if (outputModifiers[ii] === ext) {\n          outputModifiers[ii].splice(i, 1);\n        }\n      }\n    }\n  };\n\n  /**\n   * Get all extension of THIS converter\n   * @returns {{language: Array, output: Array}}\n   */\n  this.getAllExtensions = function () {\n    return {\n      language: langExtensions,\n      output: outputModifiers\n    };\n  };\n\n  /**\n   * Get the metadata of the previously parsed document\n   * @param raw\n   * @returns {string|{}}\n   */\n  this.getMetadata = function (raw) {\n    if (raw) {\n      return metadata.raw;\n    } else {\n      return metadata.parsed;\n    }\n  };\n\n  /**\n   * Get the metadata format of the previously parsed document\n   * @returns {string}\n   */\n  this.getMetadataFormat = function () {\n    return metadata.format;\n  };\n\n  /**\n   * Private: set a single key, value metadata pair\n   * @param {string} key\n   * @param {string} value\n   */\n  this._setMetadataPair = function (key, value) {\n    metadata.parsed[key] = value;\n  };\n\n  /**\n   * Private: set metadata format\n   * @param {string} format\n   */\n  this._setMetadataFormat = function (format) {\n    metadata.format = format;\n  };\n\n  /**\n   * Private: set metadata raw text\n   * @param {string} raw\n   */\n  this._setMetadataRaw = function (raw) {\n    metadata.raw = raw;\n  };\n};\n\r\n/**\n * Turn Markdown link shortcuts into XHTML <a> tags.\n */\nshowdown.subParser('anchors', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('anchors.before', text, options, globals);\n\n  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {\n    if (showdown.helper.isUndefined(title)) {\n      title = '';\n    }\n    linkId = linkId.toLowerCase();\n\n    // Special case for explicit empty url\n    if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\n      url = '';\n    } else if (!url) {\n      if (!linkId) {\n        // lower-case and turn embedded newlines into spaces\n        linkId = linkText.toLowerCase().replace(/ ?\\n/g, ' ');\n      }\n      url = '#' + linkId;\n\n      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {\n        url = globals.gUrls[linkId];\n        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {\n          title = globals.gTitles[linkId];\n        }\n      } else {\n        return wholeMatch;\n      }\n    }\n\n    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance\n    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n\n    var result = '<a href=\"' + url + '\"';\n\n    if (title !== '' && title !== null) {\n      title = title.replace(/\"/g, '&quot;');\n      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance\n      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n      result += ' title=\"' + title + '\"';\n    }\n\n    // optionLinksInNewWindow only applies\n    // to external links. Hash links (#) open in same page\n    if (options.openLinksInNewWindow && !/^#/.test(url)) {\n      // escaped _\n      result += ' rel=\"noopener noreferrer\" target=\"¨E95Eblank\"';\n    }\n\n    result += '>' + linkText + '</a>';\n\n    return result;\n  };\n\n  // First, handle reference-style links: [link text] [id]\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)] ?(?:\\n *)?\\[(.*?)]()()()()/g, writeAnchorTag);\n\n  // Next, inline-style links: [link text](url \"optional title\")\n  // cases with crazy urls like ./image/cat1).png\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<([^>]*)>(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\n    writeAnchorTag);\n\n  // normal cases\n  text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\n    writeAnchorTag);\n\n  // handle reference-style shortcuts: [link text]\n  // These must come last in case you've also got [link test][1]\n  // or [link test](/foo)\n  text = text.replace(/\\[([^\\[\\]]+)]()()()()()/g, writeAnchorTag);\n\n  // Lastly handle GithubMentions if option is enabled\n  if (options.ghMentions) {\n    text = text.replace(/(^|\\s)(\\\\)?(@([a-z\\d]+(?:[a-z\\d.-]+?[a-z\\d]+)*))/gmi, function (wm, st, escape, mentions, username) {\n      if (escape === '\\\\') {\n        return st + mentions;\n      }\n\n      //check if options.ghMentionsLink is a string\n      if (!showdown.helper.isString(options.ghMentionsLink)) {\n        throw new Error('ghMentionsLink option must be a string');\n      }\n      var lnk = options.ghMentionsLink.replace(/\\{u}/g, username),\n          target = '';\n      if (options.openLinksInNewWindow) {\n        target = ' rel=\"noopener noreferrer\" target=\"¨E95Eblank\"';\n      }\n      return st + '<a href=\"' + lnk + '\"' + target + '>' + mentions + '</a>';\n    });\n  }\n\n  text = globals.converter._dispatch('anchors.after', text, options, globals);\n  return text;\n});\n\r\n// url allowed chars [a-z\\d_.~:/?#[]@!$&'()*+,;=-]\n\nvar simpleURLRegex  = /([*~_]+|\\b)(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+?\\.[^'\">\\s]+?)()(\\1)?(?=\\s|$)(?![\"<>])/gi,\n    simpleURLRegex2 = /([*~_]+|\\b)(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+?)([.!?,()\\[\\]])?(\\1)?(?=\\s|$)(?![\"<>])/gi,\n    delimUrlRegex   = /()<(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+)()>()/gi,\n    simpleMailRegex = /(^|\\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)(?=$|\\s)/gmi,\n    delimMailRegex  = /<()(?:mailto:)?([-.\\w]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\n\n    replaceLink = function (options) {\n      'use strict';\n      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {\n        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n        var lnkTxt = link,\n            append = '',\n            target = '',\n            lmc    = leadingMagicChars || '',\n            tmc    = trailingMagicChars || '';\n        if (/^www\\./i.test(link)) {\n          link = link.replace(/^www\\./i, 'http://www.');\n        }\n        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {\n          append = trailingPunctuation;\n        }\n        if (options.openLinksInNewWindow) {\n          target = ' rel=\"noopener noreferrer\" target=\"¨E95Eblank\"';\n        }\n        return lmc + '<a href=\"' + link + '\"' + target + '>' + lnkTxt + '</a>' + append + tmc;\n      };\n    },\n\n    replaceMail = function (options, globals) {\n      'use strict';\n      return function (wholeMatch, b, mail) {\n        var href = 'mailto:';\n        b = b || '';\n        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);\n        if (options.encodeEmails) {\n          href = showdown.helper.encodeEmailAddress(href + mail);\n          mail = showdown.helper.encodeEmailAddress(mail);\n        } else {\n          href = href + mail;\n        }\n        return b + '<a href=\"' + href + '\">' + mail + '</a>';\n      };\n    };\n\nshowdown.subParser('autoLinks', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('autoLinks.before', text, options, globals);\n\n  text = text.replace(delimUrlRegex, replaceLink(options));\n  text = text.replace(delimMailRegex, replaceMail(options, globals));\n\n  text = globals.converter._dispatch('autoLinks.after', text, options, globals);\n\n  return text;\n});\n\nshowdown.subParser('simplifiedAutoLinks', function (text, options, globals) {\n  'use strict';\n\n  if (!options.simplifiedAutoLink) {\n    return text;\n  }\n\n  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);\n\n  if (options.excludeTrailingPunctuationFromURLs) {\n    text = text.replace(simpleURLRegex2, replaceLink(options));\n  } else {\n    text = text.replace(simpleURLRegex, replaceLink(options));\n  }\n  text = text.replace(simpleMailRegex, replaceMail(options, globals));\n\n  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);\n\n  return text;\n});\n\r\n/**\n * These are all the transformations that form block-level\n * tags like paragraphs, headers, and list items.\n */\nshowdown.subParser('blockGamut', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('blockGamut.before', text, options, globals);\n\n  // we parse blockquotes first so that we can have headings and hrs\n  // inside blockquotes\n  text = showdown.subParser('blockQuotes')(text, options, globals);\n  text = showdown.subParser('headers')(text, options, globals);\n\n  // Do Horizontal Rules:\n  text = showdown.subParser('horizontalRule')(text, options, globals);\n\n  text = showdown.subParser('lists')(text, options, globals);\n  text = showdown.subParser('codeBlocks')(text, options, globals);\n  text = showdown.subParser('tables')(text, options, globals);\n\n  // We already ran _HashHTMLBlocks() before, in Markdown(), but that\n  // was to escape raw HTML in the original Markdown source. This time,\n  // we're escaping the markup we've just created, so that we don't wrap\n  // <p> tags around block-level tags.\n  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);\n  text = showdown.subParser('paragraphs')(text, options, globals);\n\n  text = globals.converter._dispatch('blockGamut.after', text, options, globals);\n\n  return text;\n});\n\r\nshowdown.subParser('blockQuotes', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);\n\n  // add a couple extra lines after the text and endtext mark\n  text = text + '\\n\\n';\n\n  var rgx = /(^ {0,3}>[ \\t]?.+\\n(.+\\n)*\\n*)+/gm;\n\n  if (options.splitAdjacentBlockquotes) {\n    rgx = /^ {0,3}>[\\s\\S]*?(?:\\n\\n)/gm;\n  }\n\n  text = text.replace(rgx, function (bq) {\n    // attacklab: hack around Konqueror 3.5.4 bug:\n    // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n    bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, ''); // trim one level of quoting\n\n    // attacklab: clean up hack\n    bq = bq.replace(/¨0/g, '');\n\n    bq = bq.replace(/^[ \\t]+$/gm, ''); // trim whitespace-only lines\n    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);\n    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse\n\n    bq = bq.replace(/(^|\\n)/g, '$1  ');\n    // These leading spaces screw with <pre> content, so we need to fix that:\n    bq = bq.replace(/(\\s*<pre>[^\\r]+?<\\/pre>)/gm, function (wholeMatch, m1) {\n      var pre = m1;\n      // attacklab: hack around Konqueror 3.5.4 bug:\n      pre = pre.replace(/^  /mg, '¨0');\n      pre = pre.replace(/¨0/g, '');\n      return pre;\n    });\n\n    return showdown.subParser('hashBlock')('<blockquote>\\n' + bq + '\\n</blockquote>', options, globals);\n  });\n\n  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Process Markdown `<pre><code>` blocks.\n */\nshowdown.subParser('codeBlocks', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);\n\n  // sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n  text += '¨0';\n\n  var pattern = /(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=¨0))/g;\n  text = text.replace(pattern, function (wholeMatch, m1, m2) {\n    var codeblock = m1,\n        nextChar = m2,\n        end = '\\n';\n\n    codeblock = showdown.subParser('outdent')(codeblock, options, globals);\n    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);\n    codeblock = showdown.subParser('detab')(codeblock, options, globals);\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing newlines\n\n    if (options.omitExtraWLInCodeBlocks) {\n      end = '';\n    }\n\n    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';\n\n    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;\n  });\n\n  // strip sentinel\n  text = text.replace(/¨0/, '');\n\n  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);\n  return text;\n});\n\r\n/**\n *\n *   *  Backtick quotes are used for <code></code> spans.\n *\n *   *  You can use multiple backticks as the delimiters if you want to\n *     include literal backticks in the code span. So, this input:\n *\n *         Just type ``foo `bar` baz`` at the prompt.\n *\n *       Will translate to:\n *\n *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\n *\n *    There's no arbitrary limit to the number of backticks you\n *    can use as delimters. If you need three consecutive backticks\n *    in your code, use four for delimiters, etc.\n *\n *  *  You can use spaces to get literal backticks at the edges:\n *\n *         ... type `` `bar` `` ...\n *\n *       Turns to:\n *\n *         ... type <code>`bar`</code> ...\n */\nshowdown.subParser('codeSpans', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('codeSpans.before', text, options, globals);\n\n  if (typeof text === 'undefined') {\n    text = '';\n  }\n  text = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\n    function (wholeMatch, m1, m2, m3) {\n      var c = m3;\n      c = c.replace(/^([ \\t]*)/g, '');\t// leading whitespace\n      c = c.replace(/[ \\t]*$/g, '');\t// trailing whitespace\n      c = showdown.subParser('encodeCode')(c, options, globals);\n      c = m1 + '<code>' + c + '</code>';\n      c = showdown.subParser('hashHTMLSpans')(c, options, globals);\n      return c;\n    }\n  );\n\n  text = globals.converter._dispatch('codeSpans.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Create a full HTML document from the processed markdown\n */\nshowdown.subParser('completeHTMLDocument', function (text, options, globals) {\n  'use strict';\n\n  if (!options.completeHTMLDocument) {\n    return text;\n  }\n\n  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);\n\n  var doctype = 'html',\n      doctypeParsed = '<!DOCTYPE HTML>\\n',\n      title = '',\n      charset = '<meta charset=\"utf-8\">\\n',\n      lang = '',\n      metadata = '';\n\n  if (typeof globals.metadata.parsed.doctype !== 'undefined') {\n    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\\n';\n    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();\n    if (doctype === 'html' || doctype === 'html5') {\n      charset = '<meta charset=\"utf-8\">';\n    }\n  }\n\n  for (var meta in globals.metadata.parsed) {\n    if (globals.metadata.parsed.hasOwnProperty(meta)) {\n      switch (meta.toLowerCase()) {\n        case 'doctype':\n          break;\n\n        case 'title':\n          title = '<title>' +  globals.metadata.parsed.title + '</title>\\n';\n          break;\n\n        case 'charset':\n          if (doctype === 'html' || doctype === 'html5') {\n            charset = '<meta charset=\"' + globals.metadata.parsed.charset + '\">\\n';\n          } else {\n            charset = '<meta name=\"charset\" content=\"' + globals.metadata.parsed.charset + '\">\\n';\n          }\n          break;\n\n        case 'language':\n        case 'lang':\n          lang = ' lang=\"' + globals.metadata.parsed[meta] + '\"';\n          metadata += '<meta name=\"' + meta + '\" content=\"' + globals.metadata.parsed[meta] + '\">\\n';\n          break;\n\n        default:\n          metadata += '<meta name=\"' + meta + '\" content=\"' + globals.metadata.parsed[meta] + '\">\\n';\n      }\n    }\n  }\n\n  text = doctypeParsed + '<html' + lang + '>\\n<head>\\n' + title + charset + metadata + '</head>\\n<body>\\n' + text.trim() + '\\n</body>\\n</html>';\n\n  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Convert all tabs to spaces\n */\nshowdown.subParser('detab', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('detab.before', text, options, globals);\n\n  // expand first n-1 tabs\n  text = text.replace(/\\t(?=\\t)/g, '    '); // g_tab_width\n\n  // replace the nth with two sentinels\n  text = text.replace(/\\t/g, '¨A¨B');\n\n  // use the sentinel to anchor our regex so it doesn't explode\n  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {\n    var leadingText = m1,\n        numSpaces = 4 - leadingText.length % 4;  // g_tab_width\n\n    // there *must* be a better way to do this:\n    for (var i = 0; i < numSpaces; i++) {\n      leadingText += ' ';\n    }\n\n    return leadingText;\n  });\n\n  // clean up sentinels\n  text = text.replace(/¨A/g, '    ');  // g_tab_width\n  text = text.replace(/¨B/g, '');\n\n  text = globals.converter._dispatch('detab.after', text, options, globals);\n  return text;\n});\n\r\nshowdown.subParser('ellipsis', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('ellipsis.before', text, options, globals);\n\n  text = text.replace(/\\.\\.\\./g, '…');\n\n  text = globals.converter._dispatch('ellipsis.after', text, options, globals);\n\n  return text;\n});\n\r\n/**\n * Turn emoji codes into emojis\n *\n * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis\n */\nshowdown.subParser('emoji', function (text, options, globals) {\n  'use strict';\n\n  if (!options.emoji) {\n    return text;\n  }\n\n  text = globals.converter._dispatch('emoji.before', text, options, globals);\n\n  var emojiRgx = /:([\\S]+?):/g;\n\n  text = text.replace(emojiRgx, function (wm, emojiCode) {\n    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {\n      return showdown.helper.emojis[emojiCode];\n    }\n    return wm;\n  });\n\n  text = globals.converter._dispatch('emoji.after', text, options, globals);\n\n  return text;\n});\n\r\n/**\n * Smart processing for ampersands and angle brackets that need to be encoded.\n */\nshowdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);\n\n  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\n  // http://bumppo.net/projects/amputator/\n  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, '&amp;');\n\n  // Encode naked <'s\n  text = text.replace(/<(?![a-z\\/?$!])/gi, '&lt;');\n\n  // Encode <\n  text = text.replace(/</g, '&lt;');\n\n  // Encode >\n  text = text.replace(/>/g, '&gt;');\n\n  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Returns the string, with after processing the following backslash escape sequences.\n *\n * attacklab: The polite way to do this is with the new escapeCharacters() function:\n *\n *    text = escapeCharacters(text,\"\\\\\",true);\n *    text = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\n *\n * ...but we're sidestepping its use of the (slow) RegExp constructor\n * as an optimization for Firefox.  This function gets called a LOT.\n */\nshowdown.subParser('encodeBackslashEscapes', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);\n\n  text = text.replace(/\\\\(\\\\)/g, showdown.helper.escapeCharactersCallback);\n  text = text.replace(/\\\\([`*_{}\\[\\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);\n\n  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Encode/escape certain characters inside Markdown code runs.\n * The point is that in code, these characters are literals,\n * and lose their special Markdown meanings.\n */\nshowdown.subParser('encodeCode', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('encodeCode.before', text, options, globals);\n\n  // Encode all ampersands; HTML entities are not\n  // entities within a Markdown code span.\n  text = text\n    .replace(/&/g, '&amp;')\n  // Do the angle bracket song and dance:\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n  // Now, escape characters that are magic in Markdown:\n    .replace(/([*_{}\\[\\]\\\\=~-])/g, showdown.helper.escapeCharactersCallback);\n\n  text = globals.converter._dispatch('encodeCode.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Within tags -- meaning between < and > -- encode [\\ ` * _ ~ =] so they\n * don't conflict with their use in Markdown for code, italics and strong.\n */\nshowdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);\n\n  // Build a regex to find HTML tags.\n  var tags     = /<\\/?[a-z\\d_:-]+(?:[\\s]+[\\s\\S]+?)?>/gi,\n      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;\n\n  text = text.replace(tags, function (wholeMatch) {\n    return wholeMatch\n      .replace(/(.)<\\/?code>(?=.)/g, '$1`')\n      .replace(/([\\\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);\n  });\n\n  text = text.replace(comments, function (wholeMatch) {\n    return wholeMatch\n      .replace(/([\\\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);\n  });\n\n  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Handle github codeblocks prior to running HashHTML so that\n * HTML contained within the codeblock gets escaped properly\n * Example:\n * ```ruby\n *     def hello_world(x)\n *       puts \"Hello, #{x}\"\n *     end\n * ```\n */\nshowdown.subParser('githubCodeBlocks', function (text, options, globals) {\n  'use strict';\n\n  // early exit if option is not enabled\n  if (!options.ghCodeBlocks) {\n    return text;\n  }\n\n  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);\n\n  text += '¨0';\n\n  text = text.replace(/(?:^|\\n)(?: {0,3})(```+|~~~+)(?: *)([^\\s`~]*)\\n([\\s\\S]*?)\\n(?: {0,3})\\1/g, function (wholeMatch, delim, language, codeblock) {\n    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\\n';\n\n    // First parse the github code block\n    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);\n    codeblock = showdown.subParser('detab')(codeblock, options, globals);\n    codeblock = codeblock.replace(/^\\n+/g, ''); // trim leading newlines\n    codeblock = codeblock.replace(/\\n+$/g, ''); // trim trailing whitespace\n\n    codeblock = '<pre><code' + (language ? ' class=\"' + language + ' language-' + language + '\"' : '') + '>' + codeblock + end + '</code></pre>';\n\n    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);\n\n    // Since GHCodeblocks can be false positives, we need to\n    // store the primitive text and the parsed text in a global var,\n    // and then return a token\n    return '\\n\\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\\n\\n';\n  });\n\n  // attacklab: strip sentinel\n  text = text.replace(/¨0/, '');\n\n  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);\n});\n\r\nshowdown.subParser('hashBlock', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('hashBlock.before', text, options, globals);\n  text = text.replace(/(^\\n+|\\n+$)/g, '');\n  text = '\\n\\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\\n\\n';\n  text = globals.converter._dispatch('hashBlock.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Hash and escape <code> elements that should not be parsed as markdown\n */\nshowdown.subParser('hashCodeTags', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);\n\n  var repFunc = function (wholeMatch, match, left, right) {\n    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;\n    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';\n  };\n\n  // Hash naked <code>\n  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\\\b[^>]*>', '</code>', 'gim');\n\n  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);\n  return text;\n});\n\r\nshowdown.subParser('hashElement', function (text, options, globals) {\n  'use strict';\n\n  return function (wholeMatch, m1) {\n    var blockText = m1;\n\n    // Undo double lines\n    blockText = blockText.replace(/\\n\\n/g, '\\n');\n    blockText = blockText.replace(/^\\n/, '');\n\n    // strip trailing blank lines\n    blockText = blockText.replace(/\\n+$/g, '');\n\n    // Replace the element text with a marker (\"¨KxK\" where x is its key)\n    blockText = '\\n\\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\\n\\n';\n\n    return blockText;\n  };\n});\n\r\nshowdown.subParser('hashHTMLBlocks', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);\n\n  var blockTags = [\n        'pre',\n        'div',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'blockquote',\n        'table',\n        'dl',\n        'ol',\n        'ul',\n        'script',\n        'noscript',\n        'form',\n        'fieldset',\n        'iframe',\n        'math',\n        'style',\n        'section',\n        'header',\n        'footer',\n        'nav',\n        'article',\n        'aside',\n        'address',\n        'audio',\n        'canvas',\n        'figure',\n        'hgroup',\n        'output',\n        'video',\n        'p'\n      ],\n      repFunc = function (wholeMatch, match, left, right) {\n        var txt = wholeMatch;\n        // check if this html element is marked as markdown\n        // if so, it's contents should be parsed as markdown\n        if (left.search(/\\bmarkdown\\b/) !== -1) {\n          txt = left + globals.converter.makeHtml(match) + right;\n        }\n        return '\\n\\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\\n\\n';\n      };\n\n  if (options.backslashEscapesHTMLTags) {\n    // encode backslash escaped HTML tags\n    text = text.replace(/\\\\<(\\/?[^>]+?)>/g, function (wm, inside) {\n      return '&lt;' + inside + '&gt;';\n    });\n  }\n\n  // hash HTML Blocks\n  for (var i = 0; i < blockTags.length; ++i) {\n\n    var opTagPos,\n        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\\\b[^>]*>)', 'im'),\n        patLeft  = '<' + blockTags[i] + '\\\\b[^>]*>',\n        patRight = '</' + blockTags[i] + '>';\n    // 1. Look for the first position of the first opening HTML tag in the text\n    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {\n\n      // if the HTML tag is \\ escaped, we need to escape it and break\n\n\n      //2. Split the text in that position\n      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),\n          //3. Match recursively\n          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');\n\n      // prevent an infinite loop\n      if (newSubText1 === subTexts[1]) {\n        break;\n      }\n      text = subTexts[0].concat(newSubText1);\n    }\n  }\n  // HR SPECIAL CASE\n  text = text.replace(/(\\n {0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,\n    showdown.subParser('hashElement')(text, options, globals));\n\n  // Special case for standalone HTML comments\n  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {\n    return '\\n\\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\\n\\n';\n  }, '^ {0,3}<!--', '-->', 'gm');\n\n  // PHP and ASP-style processor instructions (<?...?> and <%...%>)\n  text = text.replace(/(?:\\n\\n)( {0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,\n    showdown.subParser('hashElement')(text, options, globals));\n\n  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Hash span elements that should not be parsed as markdown\n */\nshowdown.subParser('hashHTMLSpans', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);\n\n  function hashHTMLSpan (html) {\n    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';\n  }\n\n  // Hash Self Closing tags\n  text = text.replace(/<[^>]+?\\/>/gi, function (wm) {\n    return hashHTMLSpan(wm);\n  });\n\n  // Hash tags without properties\n  text = text.replace(/<([^>]+?)>[\\s\\S]*?<\\/\\1>/g, function (wm) {\n    return hashHTMLSpan(wm);\n  });\n\n  // Hash tags with properties\n  text = text.replace(/<([^>]+?)\\s[^>]+?>[\\s\\S]*?<\\/\\1>/g, function (wm) {\n    return hashHTMLSpan(wm);\n  });\n\n  // Hash self closing tags without />\n  text = text.replace(/<[^>]+?>/gi, function (wm) {\n    return hashHTMLSpan(wm);\n  });\n\n  /*showdown.helper.matchRecursiveRegExp(text, '<code\\\\b[^>]*>', '</code>', 'gi');*/\n\n  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);\n  return text;\n});\n\n/**\n * Unhash HTML spans\n */\nshowdown.subParser('unhashHTMLSpans', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);\n\n  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {\n    var repText = globals.gHtmlSpans[i],\n        // limiter to prevent infinite loop (assume 10 as limit for recurse)\n        limit = 0;\n\n    while (/¨C(\\d+)C/.test(repText)) {\n      var num = RegExp.$1;\n      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);\n      if (limit === 10) {\n        console.error('maximum nesting of 10 spans reached!!!');\n        break;\n      }\n      ++limit;\n    }\n    text = text.replace('¨C' + i + 'C', repText);\n  }\n\n  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Hash and escape <pre><code> elements that should not be parsed as markdown\n */\nshowdown.subParser('hashPreCodeTags', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);\n\n  var repFunc = function (wholeMatch, match, left, right) {\n    // encode html entities\n    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;\n    return '\\n\\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\\n\\n';\n  };\n\n  // Hash <pre><code>\n  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\\\b[^>]*>\\\\s*<code\\\\b[^>]*>', '^ {0,3}</code>\\\\s*</pre>', 'gim');\n\n  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);\n  return text;\n});\n\r\nshowdown.subParser('headers', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('headers.before', text, options, globals);\n\n  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),\n\n      // Set text-style headers:\n      //\tHeader 1\n      //\t========\n      //\n      //\tHeader 2\n      //\t--------\n      //\n      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n={2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\n      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \\t]*\\n-{2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm;\n\n  text = text.replace(setextRegexH1, function (wholeMatch, m1) {\n\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\n        hLevel = headerLevelStart,\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\n  });\n\n  text = text.replace(setextRegexH2, function (matchFound, m1) {\n    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m1) + '\"',\n        hLevel = headerLevelStart + 1,\n        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';\n    return showdown.subParser('hashBlock')(hashBlock, options, globals);\n  });\n\n  // atx-style headers:\n  //  # Header 1\n  //  ## Header 2\n  //  ## Header 2 with closing hashes ##\n  //  ...\n  //  ###### Header 6\n  //\n  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \\t]+(.+?)[ \\t]*#*\\n+/gm : /^(#{1,6})[ \\t]*(.+?)[ \\t]*#*\\n+/gm;\n\n  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {\n    var hText = m2;\n    if (options.customizedHeaderId) {\n      hText = m2.replace(/\\s?\\{([^{]+?)}\\s*$/, '');\n    }\n\n    var span = showdown.subParser('spanGamut')(hText, options, globals),\n        hID = (options.noHeaderId) ? '' : ' id=\"' + headerId(m2) + '\"',\n        hLevel = headerLevelStart - 1 + m1.length,\n        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';\n\n    return showdown.subParser('hashBlock')(header, options, globals);\n  });\n\n  function headerId (m) {\n    var title,\n        prefix;\n\n    // It is separate from other options to allow combining prefix and customized\n    if (options.customizedHeaderId) {\n      var match = m.match(/\\{([^{]+?)}\\s*$/);\n      if (match && match[1]) {\n        m = match[1];\n      }\n    }\n\n    title = m;\n\n    // Prefix id to prevent causing inadvertent pre-existing style matches.\n    if (showdown.helper.isString(options.prefixHeaderId)) {\n      prefix = options.prefixHeaderId;\n    } else if (options.prefixHeaderId === true) {\n      prefix = 'section-';\n    } else {\n      prefix = '';\n    }\n\n    if (!options.rawPrefixHeaderId) {\n      title = prefix + title;\n    }\n\n    if (options.ghCompatibleHeaderId) {\n      title = title\n        .replace(/ /g, '-')\n        // replace previously escaped chars (&, ¨ and $)\n        .replace(/&amp;/g, '')\n        .replace(/¨T/g, '')\n        .replace(/¨D/g, '')\n        // replace rest of the chars (&~$ are repeated as they might have been escaped)\n        // borrowed from github's redcarpet (some they should produce similar results)\n        .replace(/[&+$,\\/:;=?@\"#{}|^¨~\\[\\]`\\\\*)(%.!'<>]/g, '')\n        .toLowerCase();\n    } else if (options.rawHeaderId) {\n      title = title\n        .replace(/ /g, '-')\n        // replace previously escaped chars (&, ¨ and $)\n        .replace(/&amp;/g, '&')\n        .replace(/¨T/g, '¨')\n        .replace(/¨D/g, '$')\n        // replace \" and '\n        .replace(/[\"']/g, '-')\n        .toLowerCase();\n    } else {\n      title = title\n        .replace(/[^\\w]/g, '')\n        .toLowerCase();\n    }\n\n    if (options.rawPrefixHeaderId) {\n      title = prefix + title;\n    }\n\n    if (globals.hashLinkCounts[title]) {\n      title = title + '-' + (globals.hashLinkCounts[title]++);\n    } else {\n      globals.hashLinkCounts[title] = 1;\n    }\n    return title;\n  }\n\n  text = globals.converter._dispatch('headers.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Turn Markdown link shortcuts into XHTML <a> tags.\n */\nshowdown.subParser('horizontalRule', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);\n\n  var key = showdown.subParser('hashBlock')('<hr />', options, globals);\n  text = text.replace(/^ {0,2}( ?-){3,}[ \\t]*$/gm, key);\n  text = text.replace(/^ {0,2}( ?\\*){3,}[ \\t]*$/gm, key);\n  text = text.replace(/^ {0,2}( ?_){3,}[ \\t]*$/gm, key);\n\n  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Turn Markdown image shortcuts into <img> tags.\n */\nshowdown.subParser('images', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('images.before', text, options, globals);\n\n  var inlineRegExp      = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:([\"'])([^\"]*?)\\6)?[ \\t]?\\)/g,\n      crazyRegExp       = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<([^>]*)>(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:(?:([\"'])([^\"]*?)\\6))?[ \\t]?\\)/g,\n      base64RegExp      = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<?(data:.+?\\/.+?;base64,[A-Za-z0-9+/=\\n]+?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:([\"'])([^\"]*?)\\6)?[ \\t]?\\)/g,\n      referenceRegExp   = /!\\[([^\\]]*?)] ?(?:\\n *)?\\[([\\s\\S]*?)]()()()()()/g,\n      refShortcutRegExp = /!\\[([^\\[\\]]+)]()()()()()/g;\n\n  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {\n    url = url.replace(/\\s/g, '');\n    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);\n  }\n\n  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {\n\n    var gUrls   = globals.gUrls,\n        gTitles = globals.gTitles,\n        gDims   = globals.gDimensions;\n\n    linkId = linkId.toLowerCase();\n\n    if (!title) {\n      title = '';\n    }\n    // Special case for explicit empty url\n    if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\n      url = '';\n\n    } else if (url === '' || url === null) {\n      if (linkId === '' || linkId === null) {\n        // lower-case and turn embedded newlines into spaces\n        linkId = altText.toLowerCase().replace(/ ?\\n/g, ' ');\n      }\n      url = '#' + linkId;\n\n      if (!showdown.helper.isUndefined(gUrls[linkId])) {\n        url = gUrls[linkId];\n        if (!showdown.helper.isUndefined(gTitles[linkId])) {\n          title = gTitles[linkId];\n        }\n        if (!showdown.helper.isUndefined(gDims[linkId])) {\n          width = gDims[linkId].width;\n          height = gDims[linkId].height;\n        }\n      } else {\n        return wholeMatch;\n      }\n    }\n\n    altText = altText\n      .replace(/\"/g, '&quot;')\n    //altText = showdown.helper.escapeCharacters(altText, '*_', false);\n      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n    //url = showdown.helper.escapeCharacters(url, '*_', false);\n    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n    var result = '<img src=\"' + url + '\" alt=\"' + altText + '\"';\n\n    if (title && showdown.helper.isString(title)) {\n      title = title\n        .replace(/\"/g, '&quot;')\n      //title = showdown.helper.escapeCharacters(title, '*_', false);\n        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n      result += ' title=\"' + title + '\"';\n    }\n\n    if (width && height) {\n      width  = (width === '*') ? 'auto' : width;\n      height = (height === '*') ? 'auto' : height;\n\n      result += ' width=\"' + width + '\"';\n      result += ' height=\"' + height + '\"';\n    }\n\n    result += ' />';\n\n    return result;\n  }\n\n  // First, handle reference-style labeled images: ![alt text][id]\n  text = text.replace(referenceRegExp, writeImageTag);\n\n  // Next, handle inline images:  ![alt text](url =<width>x<height> \"optional title\")\n\n  // base64 encoded images\n  text = text.replace(base64RegExp, writeImageTagBase64);\n\n  // cases with crazy urls like ./image/cat1).png\n  text = text.replace(crazyRegExp, writeImageTag);\n\n  // normal cases\n  text = text.replace(inlineRegExp, writeImageTag);\n\n  // handle reference-style shortcuts: ![img text]\n  text = text.replace(refShortcutRegExp, writeImageTag);\n\n  text = globals.converter._dispatch('images.after', text, options, globals);\n  return text;\n});\n\r\nshowdown.subParser('italicsAndBold', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);\n\n  // it's faster to have 3 separate regexes for each case than have just one\n  // because of backtracing, in some cases, it could lead to an exponential effect\n  // called \"catastrophic backtrace\". Ominous!\n\n  function parseInside (txt, left, right) {\n    /*\n    if (options.simplifiedAutoLink) {\n      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);\n    }\n    */\n    return left + txt + right;\n  }\n\n  // Parse underscores\n  if (options.literalMidWordUnderscores) {\n    text = text.replace(/\\b___(\\S[\\s\\S]*?)___\\b/g, function (wm, txt) {\n      return parseInside (txt, '<strong><em>', '</em></strong>');\n    });\n    text = text.replace(/\\b__(\\S[\\s\\S]*?)__\\b/g, function (wm, txt) {\n      return parseInside (txt, '<strong>', '</strong>');\n    });\n    text = text.replace(/\\b_(\\S[\\s\\S]*?)_\\b/g, function (wm, txt) {\n      return parseInside (txt, '<em>', '</em>');\n    });\n  } else {\n    text = text.replace(/___(\\S[\\s\\S]*?)___/g, function (wm, m) {\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;\n    });\n    text = text.replace(/__(\\S[\\s\\S]*?)__/g, function (wm, m) {\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;\n    });\n    text = text.replace(/_([^\\s_][\\s\\S]*?)_/g, function (wm, m) {\n      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)\n      return (/\\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;\n    });\n  }\n\n  // Now parse asterisks\n  if (options.literalMidWordAsterisks) {\n    text = text.replace(/([^*]|^)\\B\\*\\*\\*(\\S[\\s\\S]*?)\\*\\*\\*\\B(?!\\*)/g, function (wm, lead, txt) {\n      return parseInside (txt, lead + '<strong><em>', '</em></strong>');\n    });\n    text = text.replace(/([^*]|^)\\B\\*\\*(\\S[\\s\\S]*?)\\*\\*\\B(?!\\*)/g, function (wm, lead, txt) {\n      return parseInside (txt, lead + '<strong>', '</strong>');\n    });\n    text = text.replace(/([^*]|^)\\B\\*(\\S[\\s\\S]*?)\\*\\B(?!\\*)/g, function (wm, lead, txt) {\n      return parseInside (txt, lead + '<em>', '</em>');\n    });\n  } else {\n    text = text.replace(/\\*\\*\\*(\\S[\\s\\S]*?)\\*\\*\\*/g, function (wm, m) {\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;\n    });\n    text = text.replace(/\\*\\*(\\S[\\s\\S]*?)\\*\\*/g, function (wm, m) {\n      return (/\\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;\n    });\n    text = text.replace(/\\*([^\\s*][\\s\\S]*?)\\*/g, function (wm, m) {\n      // !/^\\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)\n      return (/\\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;\n    });\n  }\n\n\n  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Form HTML ordered (numbered) and unordered (bulleted) lists.\n */\nshowdown.subParser('lists', function (text, options, globals) {\n  'use strict';\n\n  /**\n   * Process the contents of a single ordered or unordered list, splitting it\n   * into individual list items.\n   * @param {string} listStr\n   * @param {boolean} trimTrailing\n   * @returns {string}\n   */\n  function processListItems (listStr, trimTrailing) {\n    // The $g_list_level global keeps track of when we're inside a list.\n    // Each time we enter a list, we increment it; when we leave a list,\n    // we decrement. If it's zero, we're not in a list anymore.\n    //\n    // We do this because when we're not inside a list, we want to treat\n    // something like this:\n    //\n    //    I recommend upgrading to version\n    //    8. Oops, now this line is treated\n    //    as a sub-list.\n    //\n    // As a single paragraph, despite the fact that the second line starts\n    // with a digit-period-space sequence.\n    //\n    // Whereas when we're inside a list (or sub-list), that line will be\n    // treated as the start of a sub-list. What a kludge, huh? This is\n    // an aspect of Markdown's syntax that's hard to parse perfectly\n    // without resorting to mind-reading. Perhaps the solution is to\n    // change the syntax rules such that sub-lists must start with a\n    // starting cardinal number; e.g. \"1.\" or \"a.\".\n    globals.gListLevel++;\n\n    // trim trailing blank lines:\n    listStr = listStr.replace(/\\n{2,}$/, '\\n');\n\n    // attacklab: add sentinel to emulate \\z\n    listStr += '¨0';\n\n    var rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(¨0| {0,3}([*+-]|\\d+[.])[ \\t]+))/gm,\n        isParagraphed = (/\\n[ \\t]*\\n(?!¨0)/.test(listStr));\n\n    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,\n    // which is a syntax breaking change\n    // activating this option reverts to old behavior\n    if (options.disableForced4SpacesIndentedSublists) {\n      rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(¨0|\\2([*+-]|\\d+[.])[ \\t]+))/gm;\n    }\n\n    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {\n      checked = (checked && checked.trim() !== '');\n\n      var item = showdown.subParser('outdent')(m4, options, globals),\n          bulletStyle = '';\n\n      // Support for github tasklists\n      if (taskbtn && options.tasklists) {\n        bulletStyle = ' class=\"task-list-item\" style=\"list-style-type: none;\"';\n        item = item.replace(/^[ \\t]*\\[(x|X| )?]/m, function () {\n          var otp = '<input type=\"checkbox\" disabled style=\"margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;\"';\n          if (checked) {\n            otp += ' checked';\n          }\n          otp += '>';\n          return otp;\n        });\n      }\n\n      // ISSUE #312\n      // This input: - - - a\n      // causes trouble to the parser, since it interprets it as:\n      // <ul><li><li><li>a</li></li></li></ul>\n      // instead of:\n      // <ul><li>- - a</li></ul>\n      // So, to prevent it, we will put a marker (¨A)in the beginning of the line\n      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser\n      item = item.replace(/^([-*+]|\\d\\.)[ \\t]+[\\S\\n ]*/g, function (wm2) {\n        return '¨A' + wm2;\n      });\n\n      // m1 - Leading line or\n      // Has a double return (multi paragraph) or\n      // Has sublist\n      if (m1 || (item.search(/\\n{2,}/) > -1)) {\n        item = showdown.subParser('githubCodeBlocks')(item, options, globals);\n        item = showdown.subParser('blockGamut')(item, options, globals);\n      } else {\n        // Recursion for sub-lists:\n        item = showdown.subParser('lists')(item, options, globals);\n        item = item.replace(/\\n$/, ''); // chomp(item)\n        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);\n\n        // Colapse double linebreaks\n        item = item.replace(/\\n\\n+/g, '\\n\\n');\n        if (isParagraphed) {\n          item = showdown.subParser('paragraphs')(item, options, globals);\n        } else {\n          item = showdown.subParser('spanGamut')(item, options, globals);\n        }\n      }\n\n      // now we need to remove the marker (¨A)\n      item = item.replace('¨A', '');\n      // we can finally wrap the line in list item tags\n      item =  '<li' + bulletStyle + '>' + item + '</li>\\n';\n\n      return item;\n    });\n\n    // attacklab: strip sentinel\n    listStr = listStr.replace(/¨0/g, '');\n\n    globals.gListLevel--;\n\n    if (trimTrailing) {\n      listStr = listStr.replace(/\\s+$/, '');\n    }\n\n    return listStr;\n  }\n\n  function styleStartNumber (list, listType) {\n    // check if ol and starts by a number different than 1\n    if (listType === 'ol') {\n      var res = list.match(/^ *(\\d+)\\./);\n      if (res && res[1] !== '1') {\n        return ' start=\"' + res[1] + '\"';\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Check and parse consecutive lists (better fix for issue #142)\n   * @param {string} list\n   * @param {string} listType\n   * @param {boolean} trimTrailing\n   * @returns {string}\n   */\n  function parseConsecutiveLists (list, listType, trimTrailing) {\n    // check if we caught 2 or more consecutive lists by mistake\n    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa\n    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\\d+\\.[ \\t]/gm : /^ {0,3}\\d+\\.[ \\t]/gm,\n        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \\t]/gm : /^ {0,3}[*+-][ \\t]/gm,\n        counterRxg = (listType === 'ul') ? olRgx : ulRgx,\n        result = '';\n\n    if (list.search(counterRxg) !== -1) {\n      (function parseCL (txt) {\n        var pos = txt.search(counterRxg),\n            style = styleStartNumber(list, listType);\n        if (pos !== -1) {\n          // slice\n          result += '\\n\\n<' + listType + style + '>\\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\\n';\n\n          // invert counterType and listType\n          listType = (listType === 'ul') ? 'ol' : 'ul';\n          counterRxg = (listType === 'ul') ? olRgx : ulRgx;\n\n          //recurse\n          parseCL(txt.slice(pos));\n        } else {\n          result += '\\n\\n<' + listType + style + '>\\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\\n';\n        }\n      })(list);\n    } else {\n      var style = styleStartNumber(list, listType);\n      result = '\\n\\n<' + listType + style + '>\\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\\n';\n    }\n\n    return result;\n  }\n\n  /** Start of list parsing **/\n  text = globals.converter._dispatch('lists.before', text, options, globals);\n  // add sentinel to hack around khtml/safari bug:\n  // http://bugs.webkit.org/show_bug.cgi?id=11231\n  text += '¨0';\n\n  if (globals.gListLevel) {\n    text = text.replace(/^(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(¨0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\n      function (wholeMatch, list, m2) {\n        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\n        return parseConsecutiveLists(list, listType, true);\n      }\n    );\n  } else {\n    text = text.replace(/(\\n\\n|^\\n?)(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(¨0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\n      function (wholeMatch, m1, list, m3) {\n        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';\n        return parseConsecutiveLists(list, listType, false);\n      }\n    );\n  }\n\n  // strip sentinel\n  text = text.replace(/¨0/, '');\n  text = globals.converter._dispatch('lists.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Parse metadata at the top of the document\n */\nshowdown.subParser('metadata', function (text, options, globals) {\n  'use strict';\n\n  if (!options.metadata) {\n    return text;\n  }\n\n  text = globals.converter._dispatch('metadata.before', text, options, globals);\n\n  function parseMetadataContents (content) {\n    // raw is raw so it's not changed in any way\n    globals.metadata.raw = content;\n\n    // escape chars forbidden in html attributes\n    // double quotes\n    content = content\n      // ampersand first\n      .replace(/&/g, '&amp;')\n      // double quotes\n      .replace(/\"/g, '&quot;');\n\n    content = content.replace(/\\n {4}/g, ' ');\n    content.replace(/^([\\S ]+): +([\\s\\S]+?)$/gm, function (wm, key, value) {\n      globals.metadata.parsed[key] = value;\n      return '';\n    });\n  }\n\n  text = text.replace(/^\\s*«««+(\\S*?)\\n([\\s\\S]+?)\\n»»»+\\n/, function (wholematch, format, content) {\n    parseMetadataContents(content);\n    return '¨M';\n  });\n\n  text = text.replace(/^\\s*---+(\\S*?)\\n([\\s\\S]+?)\\n---+\\n/, function (wholematch, format, content) {\n    if (format) {\n      globals.metadata.format = format;\n    }\n    parseMetadataContents(content);\n    return '¨M';\n  });\n\n  text = text.replace(/¨M/g, '');\n\n  text = globals.converter._dispatch('metadata.after', text, options, globals);\n  return text;\n});\n\r\n/**\n * Remove one level of line-leading tabs or spaces\n */\nshowdown.subParser('outdent', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('outdent.before', text, options, globals);\n\n  // attacklab: hack around Konqueror 3.5.4 bug:\n  // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n  text = text.replace(/^(\\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width\n\n  // attacklab: clean up hack\n  text = text.replace(/¨0/g, '');\n\n  text = globals.converter._dispatch('outdent.after', text, options, globals);\n  return text;\n});\n\r\n/**\n *\n */\nshowdown.subParser('paragraphs', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('paragraphs.before', text, options, globals);\n  // Strip leading and trailing lines:\n  text = text.replace(/^\\n+/g, '');\n  text = text.replace(/\\n+$/g, '');\n\n  var grafs = text.split(/\\n{2,}/g),\n      grafsOut = [],\n      end = grafs.length; // Wrap <p> tags\n\n  for (var i = 0; i < end; i++) {\n    var str = grafs[i];\n    // if this is an HTML marker, copy it\n    if (str.search(/¨(K|G)(\\d+)\\1/g) >= 0) {\n      grafsOut.push(str);\n\n    // test for presence of characters to prevent empty lines being parsed\n    // as paragraphs (resulting in undesired extra empty paragraphs)\n    } else if (str.search(/\\S/) >= 0) {\n      str = showdown.subParser('spanGamut')(str, options, globals);\n      str = str.replace(/^([ \\t]*)/g, '<p>');\n      str += '</p>';\n      grafsOut.push(str);\n    }\n  }\n\n  /** Unhashify HTML blocks */\n  end = grafsOut.length;\n  for (i = 0; i < end; i++) {\n    var blockText = '',\n        grafsOutIt = grafsOut[i],\n        codeFlag = false;\n    // if this is a marker for an html block...\n    // use RegExp.test instead of string.search because of QML bug\n    while (/¨(K|G)(\\d+)\\1/.test(grafsOutIt)) {\n      var delim = RegExp.$1,\n          num   = RegExp.$2;\n\n      if (delim === 'K') {\n        blockText = globals.gHtmlBlocks[num];\n      } else {\n        // we need to check if ghBlock is a false positive\n        if (codeFlag) {\n          // use encoded version of all text\n          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);\n        } else {\n          blockText = globals.ghCodeBlocks[num].codeblock;\n        }\n      }\n      blockText = blockText.replace(/\\$/g, '$$$$'); // Escape any dollar signs\n\n      grafsOutIt = grafsOutIt.replace(/(\\n\\n)?¨(K|G)\\d+\\2(\\n\\n)?/, blockText);\n      // Check if grafsOutIt is a pre->code\n      if (/^<pre\\b[^>]*>\\s*<code\\b[^>]*>/.test(grafsOutIt)) {\n        codeFlag = true;\n      }\n    }\n    grafsOut[i] = grafsOutIt;\n  }\n  text = grafsOut.join('\\n');\n  // Strip leading and trailing lines:\n  text = text.replace(/^\\n+/g, '');\n  text = text.replace(/\\n+$/g, '');\n  return globals.converter._dispatch('paragraphs.after', text, options, globals);\n});\n\r\n/**\n * Run extension\n */\nshowdown.subParser('runExtension', function (ext, text, options, globals) {\n  'use strict';\n\n  if (ext.filter) {\n    text = ext.filter(text, globals.converter, options);\n\n  } else if (ext.regex) {\n    // TODO remove this when old extension loading mechanism is deprecated\n    var re = ext.regex;\n    if (!(re instanceof RegExp)) {\n      re = new RegExp(re, 'g');\n    }\n    text = text.replace(re, ext.replace);\n  }\n\n  return text;\n});\n\r\n/**\n * These are all the transformations that occur *within* block-level\n * tags like paragraphs, headers, and list items.\n */\nshowdown.subParser('spanGamut', function (text, options, globals) {\n  'use strict';\n\n  text = globals.converter._dispatch('spanGamut.before', text, options, globals);\n  text = showdown.subParser('codeSpans')(text, options, globals);\n  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);\n  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);\n\n  // Process anchor and image tags. Images must come first,\n  // because ![foo][f] looks like an anchor.\n  text = showdown.subParser('images')(text, options, globals);\n  text = showdown.subParser('anchors')(text, options, globals);\n\n  // Make links out of things like `<http://example.com/>`\n  // Must come after anchors, because you can use < and >\n  // delimiters in inline links like [this](<url>).\n  text = showdown.subParser('autoLinks')(text, options, globals);\n  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);\n  text = showdown.subParser('emoji')(text, options, globals);\n  text = showdown.subParser('underline')(text, options, globals);\n  text = showdown.subParser('italicsAndBold')(text, options, globals);\n  text = showdown.subParser('strikethrough')(text, options, globals);\n  text = showdown.subParser('ellipsis')(text, options, globals);\n\n  // we need to hash HTML tags inside spans\n  text = showdown.subParser('hashHTMLSpans')(text, options, globals);\n\n  // now we encode amps and angles\n  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);\n\n  // Do hard breaks\n  if (options.simpleLineBreaks) {\n    // GFM style hard breaks\n    // only add line breaks if the text does not contain a block (special case for lists)\n    if (!/\\n\\n¨K/.test(text)) {\n      text = text.replace(/\\n+/g, '<br />\\n');\n    }\n  } else {\n    // Vanilla hard breaks\n    text = text.replace(/  +\\n/g, '<br />\\n');\n  }\n\n  text = globals.converter._dispatch('spanGamut.after', text, options, globals);\n  return text;\n});\n\r\nshowdown.subParser('strikethrough', function (text, options, globals) {\n  'use strict';\n\n  function parseInside (txt) {\n    if (options.simplifiedAutoLink) {\n      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);\n    }\n    return '<del>' + txt + '</del>';\n  }\n\n  if (options.strikethrough) {\n    text = globals.converter._dispatch('strikethrough.before', text, options, globals);\n    text = text.replace(/(?:~){2}([\\s\\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });\n    text = globals.converter._dispatch('strikethrough.after', text, options, globals);\n  }\n\n  return text;\n});\n\r\n/**\n * Strips link definitions from text, stores the URLs and titles in\n * hash references.\n * Link defs are in the form: ^[id]: url \"optional title\"\n */\nshowdown.subParser('stripLinkDefinitions', function (text, options, globals) {\n  'use strict';\n\n  var regex       = /^ {0,3}\\[(.+)]:[ \\t]*\\n?[ \\t]*<?([^>\\s]+)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n+|(?=¨0))/gm,\n      base64Regex = /^ {0,3}\\[(.+)]:[ \\t]*\\n?[ \\t]*<?(data:.+?\\/.+?;base64,[A-Za-z0-9+/=\\n]+?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n\\n|(?=¨0)|(?=\\n\\[))/gm;\n\n  // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n  text += '¨0';\n\n  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {\n    linkId = linkId.toLowerCase();\n    if (url.match(/^data:.+?\\/.+?;base64,/)) {\n      // remove newlines\n      globals.gUrls[linkId] = url.replace(/\\s/g, '');\n    } else {\n      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive\n    }\n\n    if (blankLines) {\n      // Oops, found blank lines, so it's not a title.\n      // Put back the parenthetical statement we stole.\n      return blankLines + title;\n\n    } else {\n      if (title) {\n        globals.gTitles[linkId] = title.replace(/\"|'/g, '&quot;');\n      }\n      if (options.parseImgDimensions && width && height) {\n        globals.gDimensions[linkId] = {\n          width:  width,\n          height: height\n        };\n      }\n    }\n    // Completely remove the definition from the text\n    return '';\n  };\n\n  // first we try to find base64 link references\n  text = text.replace(base64Regex, replaceFunc);\n\n  text = text.replace(regex, replaceFunc);\n\n  // attacklab: strip sentinel\n  text = text.replace(/¨0/, '');\n\n  return text;\n});\n\r\nshowdown.subParser('tables', function (text, options, globals) {\n  'use strict';\n\n  if (!options.tables) {\n    return text;\n  }\n\n  var tableRgx       = /^ {0,3}\\|?.+\\|.+\\n {0,3}\\|?[ \\t]*:?[ \\t]*(?:[-=]){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*:?[ \\t]*(?:[-=]){2,}[\\s\\S]+?(?:\\n\\n|¨0)/gm,\n      //singeColTblRgx = /^ {0,3}\\|.+\\|\\n {0,3}\\|[ \\t]*:?[ \\t]*(?:[-=]){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*\\n(?: {0,3}\\|.+\\|\\n)+(?:\\n\\n|¨0)/gm;\n      singeColTblRgx = /^ {0,3}\\|.+\\|[ \\t]*\\n {0,3}\\|[ \\t]*:?[ \\t]*(?:[-=]){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*\\n( {0,3}\\|.+\\|[ \\t]*\\n)*(?:\\n|¨0)/gm;\n\n  function parseStyles (sLine) {\n    if (/^:[ \\t]*--*$/.test(sLine)) {\n      return ' style=\"text-align:left;\"';\n    } else if (/^--*[ \\t]*:[ \\t]*$/.test(sLine)) {\n      return ' style=\"text-align:right;\"';\n    } else if (/^:[ \\t]*--*[ \\t]*:$/.test(sLine)) {\n      return ' style=\"text-align:center;\"';\n    } else {\n      return '';\n    }\n  }\n\n  function parseHeaders (header, style) {\n    var id = '';\n    header = header.trim();\n    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility\n    if (options.tablesHeaderId || options.tableHeaderId) {\n      id = ' id=\"' + header.replace(/ /g, '_').toLowerCase() + '\"';\n    }\n    header = showdown.subParser('spanGamut')(header, options, globals);\n\n    return '<th' + id + style + '>' + header + '</th>\\n';\n  }\n\n  function parseCells (cell, style) {\n    var subText = showdown.subParser('spanGamut')(cell, options, globals);\n    return '<td' + style + '>' + subText + '</td>\\n';\n  }\n\n  function buildTable (headers, cells) {\n    var tb = '<table>\\n<thead>\\n<tr>\\n',\n        tblLgn = headers.length;\n\n    for (var i = 0; i < tblLgn; ++i) {\n      tb += headers[i];\n    }\n    tb += '</tr>\\n</thead>\\n<tbody>\\n';\n\n    for (i = 0; i < cells.length; ++i) {\n      tb += '<tr>\\n';\n      for (var ii = 0; ii < tblLgn; ++ii) {\n        tb += cells[i][ii];\n      }\n      tb += '</tr>\\n';\n    }\n    tb += '</tbody>\\n</table>\\n';\n    return tb;\n  }\n\n  function parseTable (rawTable) {\n    var i, tableLines = rawTable.split('\\n');\n\n    for (i = 0; i < tableLines.length; ++i) {\n      // strip wrong first and last column if wrapped tables are used\n      if (/^ {0,3}\\|/.test(tableLines[i])) {\n        tableLines[i] = tableLines[i].replace(/^ {0,3}\\|/, '');\n      }\n      if (/\\|[ \\t]*$/.test(tableLines[i])) {\n        tableLines[i] = tableLines[i].replace(/\\|[ \\t]*$/, '');\n      }\n      // parse code spans first, but we only support one line code spans\n      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);\n    }\n\n    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),\n        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),\n        rawCells = [],\n        headers = [],\n        styles = [],\n        cells = [];\n\n    tableLines.shift();\n    tableLines.shift();\n\n    for (i = 0; i < tableLines.length; ++i) {\n      if (tableLines[i].trim() === '') {\n        continue;\n      }\n      rawCells.push(\n        tableLines[i]\n          .split('|')\n          .map(function (s) {\n            return s.trim();\n          })\n      );\n    }\n\n    if (rawHeaders.length < rawStyles.length) {\n      return rawTable;\n    }\n\n    for (i = 0; i < rawStyles.length; ++i) {\n      styles.push(parseStyles(rawStyles[i]));\n    }\n\n    for (i = 0; i < rawHeaders.length; ++i) {\n      if (showdown.helper.isUndefined(styles[i])) {\n        styles[i] = '';\n      }\n      headers.push(parseHeaders(rawHeaders[i], styles[i]));\n    }\n\n    for (i = 0; i < rawCells.length; ++i) {\n      var row = [];\n      for (var ii = 0; ii < headers.length; ++ii) {\n        if (showdown.helper.isUndefined(rawCells[i][ii])) {\n\n        }\n        row.push(parseCells(rawCells[i][ii], styles[ii]));\n      }\n      cells.push(row);\n    }\n\n    return buildTable(headers, cells);\n  }\n\n  text = globals.converter._dispatch('tables.before', text, options, globals);\n\n  // find escaped pipe characters\n  text = text.replace(/\\\\(\\|)/g, showdown.helper.escapeCharactersCallback);\n\n  // parse multi column tables\n  text = text.replace(tableRgx, parseTable);\n\n  // parse one column tables\n  text = text.replace(singeColTblRgx, parseTable);\n\n  text = globals.converter._dispatch('tables.after', text, options, globals);\n\n  return text;\n});\n\r\nshowdown.subParser('underline', function (text, options, globals) {\n  'use strict';\n\n  if (!options.underline) {\n    return text;\n  }\n\n  text = globals.converter._dispatch('underline.before', text, options, globals);\n\n  if (options.literalMidWordUnderscores) {\n    text = text.replace(/\\b___(\\S[\\s\\S]*?)___\\b/g, function (wm, txt) {\n      return '<u>' + txt + '</u>';\n    });\n    text = text.replace(/\\b__(\\S[\\s\\S]*?)__\\b/g, function (wm, txt) {\n      return '<u>' + txt + '</u>';\n    });\n  } else {\n    text = text.replace(/___(\\S[\\s\\S]*?)___/g, function (wm, m) {\n      return (/\\S$/.test(m)) ? '<u>' + m + '</u>' : wm;\n    });\n    text = text.replace(/__(\\S[\\s\\S]*?)__/g, function (wm, m) {\n      return (/\\S$/.test(m)) ? '<u>' + m + '</u>' : wm;\n    });\n  }\n\n  // escape remaining underscores to prevent them being parsed by italic and bold\n  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);\n\n  text = globals.converter._dispatch('underline.after', text, options, globals);\n\n  return text;\n});\n\r\n/**\n * Swap back in all the special characters we've hidden.\n */\nshowdown.subParser('unescapeSpecialChars', function (text, options, globals) {\n  'use strict';\n  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);\n\n  text = text.replace(/¨E(\\d+)E/g, function (wholeMatch, m1) {\n    var charCodeToReplace = parseInt(m1);\n    return String.fromCharCode(charCodeToReplace);\n  });\n\n  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);\n  return text;\n});\n\r\nshowdown.subParser('makeMarkdown.blockquote', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasChildNodes()) {\n    var children = node.childNodes,\n        childrenLength = children.length;\n\n    for (var i = 0; i < childrenLength; ++i) {\n      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);\n\n      if (innerTxt === '') {\n        continue;\n      }\n      txt += innerTxt;\n    }\n  }\n  // cleanup\n  txt = txt.trim();\n  txt = '> ' + txt.split('\\n').join('\\n> ');\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.codeBlock', function (node, globals) {\n  'use strict';\n\n  var lang = node.getAttribute('language'),\n      num  = node.getAttribute('precodenum');\n  return '```' + lang + '\\n' + globals.preList[num] + '\\n```';\n});\n\r\nshowdown.subParser('makeMarkdown.codeSpan', function (node) {\n  'use strict';\n\n  return '`' + node.innerHTML + '`';\n});\n\r\nshowdown.subParser('makeMarkdown.emphasis', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasChildNodes()) {\n    txt += '*';\n    var children = node.childNodes,\n        childrenLength = children.length;\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n    }\n    txt += '*';\n  }\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {\n  'use strict';\n\n  var headerMark = new Array(headerLevel + 1).join('#'),\n      txt = '';\n\n  if (node.hasChildNodes()) {\n    txt = headerMark + ' ';\n    var children = node.childNodes,\n        childrenLength = children.length;\n\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n    }\n  }\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.hr', function () {\n  'use strict';\n\n  return '---';\n});\n\r\nshowdown.subParser('makeMarkdown.image', function (node) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasAttribute('src')) {\n    txt += '![' + node.getAttribute('alt') + '](';\n    txt += '<' + node.getAttribute('src') + '>';\n    if (node.hasAttribute('width') && node.hasAttribute('height')) {\n      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');\n    }\n\n    if (node.hasAttribute('title')) {\n      txt += ' \"' + node.getAttribute('title') + '\"';\n    }\n    txt += ')';\n  }\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.links', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasChildNodes() && node.hasAttribute('href')) {\n    var children = node.childNodes,\n        childrenLength = children.length;\n    txt = '[';\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n    }\n    txt += '](';\n    txt += '<' + node.getAttribute('href') + '>';\n    if (node.hasAttribute('title')) {\n      txt += ' \"' + node.getAttribute('title') + '\"';\n    }\n    txt += ')';\n  }\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.list', function (node, globals, type) {\n  'use strict';\n\n  var txt = '';\n  if (!node.hasChildNodes()) {\n    return '';\n  }\n  var listItems       = node.childNodes,\n      listItemsLenght = listItems.length,\n      listNum = node.getAttribute('start') || 1;\n\n  for (var i = 0; i < listItemsLenght; ++i) {\n    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {\n      continue;\n    }\n\n    // define the bullet to use in list\n    var bullet = '';\n    if (type === 'ol') {\n      bullet = listNum.toString() + '. ';\n    } else {\n      bullet = '- ';\n    }\n\n    // parse list item\n    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);\n    ++listNum;\n  }\n\n  // add comment at the end to prevent consecutive lists to be parsed as one\n  txt += '\\n<!-- -->\\n';\n  return txt.trim();\n});\n\r\nshowdown.subParser('makeMarkdown.listItem', function (node, globals) {\n  'use strict';\n\n  var listItemTxt = '';\n\n  var children = node.childNodes,\n      childrenLenght = children.length;\n\n  for (var i = 0; i < childrenLenght; ++i) {\n    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n  }\n  // if it's only one liner, we need to add a newline at the end\n  if (!/\\n$/.test(listItemTxt)) {\n    listItemTxt += '\\n';\n  } else {\n    // it's multiparagraph, so we need to indent\n    listItemTxt = listItemTxt\n      .split('\\n')\n      .join('\\n    ')\n      .replace(/^ {4}$/gm, '')\n      .replace(/\\n\\n+/g, '\\n\\n');\n  }\n\n  return listItemTxt;\n});\n\r\n\n\nshowdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {\n  'use strict';\n\n  spansOnly = spansOnly || false;\n\n  var txt = '';\n\n  // edge case of text without wrapper paragraph\n  if (node.nodeType === 3) {\n    return showdown.subParser('makeMarkdown.txt')(node, globals);\n  }\n\n  // HTML comment\n  if (node.nodeType === 8) {\n    return '<!--' + node.data + '-->\\n\\n';\n  }\n\n  // process only node elements\n  if (node.nodeType !== 1) {\n    return '';\n  }\n\n  var tagName = node.tagName.toLowerCase();\n\n  switch (tagName) {\n\n    //\n    // BLOCKS\n    //\n    case 'h1':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\\n\\n'; }\n      break;\n    case 'h2':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\\n\\n'; }\n      break;\n    case 'h3':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\\n\\n'; }\n      break;\n    case 'h4':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\\n\\n'; }\n      break;\n    case 'h5':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\\n\\n'; }\n      break;\n    case 'h6':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\\n\\n'; }\n      break;\n\n    case 'p':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\\n\\n'; }\n      break;\n\n    case 'blockquote':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\\n\\n'; }\n      break;\n\n    case 'hr':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\\n\\n'; }\n      break;\n\n    case 'ol':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\\n\\n'; }\n      break;\n\n    case 'ul':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\\n\\n'; }\n      break;\n\n    case 'precode':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\\n\\n'; }\n      break;\n\n    case 'pre':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\\n\\n'; }\n      break;\n\n    case 'table':\n      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\\n\\n'; }\n      break;\n\n    //\n    // SPANS\n    //\n    case 'code':\n      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);\n      break;\n\n    case 'em':\n    case 'i':\n      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);\n      break;\n\n    case 'strong':\n    case 'b':\n      txt = showdown.subParser('makeMarkdown.strong')(node, globals);\n      break;\n\n    case 'del':\n      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);\n      break;\n\n    case 'a':\n      txt = showdown.subParser('makeMarkdown.links')(node, globals);\n      break;\n\n    case 'img':\n      txt = showdown.subParser('makeMarkdown.image')(node, globals);\n      break;\n\n    default:\n      txt = node.outerHTML + '\\n\\n';\n  }\n\n  // common normalization\n  // TODO eventually\n\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.paragraph', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasChildNodes()) {\n    var children = node.childNodes,\n        childrenLength = children.length;\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n    }\n  }\n\n  // some text normalization\n  txt = txt.trim();\n\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.pre', function (node, globals) {\n  'use strict';\n\n  var num  = node.getAttribute('prenum');\n  return '<pre>' + globals.preList[num] + '</pre>';\n});\n\r\nshowdown.subParser('makeMarkdown.strikethrough', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasChildNodes()) {\n    txt += '~~';\n    var children = node.childNodes,\n        childrenLength = children.length;\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n    }\n    txt += '~~';\n  }\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.strong', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (node.hasChildNodes()) {\n    txt += '**';\n    var children = node.childNodes,\n        childrenLength = children.length;\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);\n    }\n    txt += '**';\n  }\n  return txt;\n});\n\r\nshowdown.subParser('makeMarkdown.table', function (node, globals) {\n  'use strict';\n\n  var txt = '',\n      tableArray = [[], []],\n      headings   = node.querySelectorAll('thead>tr>th'),\n      rows       = node.querySelectorAll('tbody>tr'),\n      i, ii;\n  for (i = 0; i < headings.length; ++i) {\n    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),\n        allign = '---';\n\n    if (headings[i].hasAttribute('style')) {\n      var style = headings[i].getAttribute('style').toLowerCase().replace(/\\s/g, '');\n      switch (style) {\n        case 'text-align:left;':\n          allign = ':---';\n          break;\n        case 'text-align:right;':\n          allign = '---:';\n          break;\n        case 'text-align:center;':\n          allign = ':---:';\n          break;\n      }\n    }\n    tableArray[0][i] = headContent.trim();\n    tableArray[1][i] = allign;\n  }\n\n  for (i = 0; i < rows.length; ++i) {\n    var r = tableArray.push([]) - 1,\n        cols = rows[i].getElementsByTagName('td');\n\n    for (ii = 0; ii < headings.length; ++ii) {\n      var cellContent = ' ';\n      if (typeof cols[ii] !== 'undefined') {\n        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);\n      }\n      tableArray[r].push(cellContent);\n    }\n  }\n\n  var cellSpacesCount = 3;\n  for (i = 0; i < tableArray.length; ++i) {\n    for (ii = 0; ii < tableArray[i].length; ++ii) {\n      var strLen = tableArray[i][ii].length;\n      if (strLen > cellSpacesCount) {\n        cellSpacesCount = strLen;\n      }\n    }\n  }\n\n  for (i = 0; i < tableArray.length; ++i) {\n    for (ii = 0; ii < tableArray[i].length; ++ii) {\n      if (i === 1) {\n        if (tableArray[i][ii].slice(-1) === ':') {\n          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';\n        } else {\n          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');\n        }\n      } else {\n        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);\n      }\n    }\n    txt += '| ' + tableArray[i].join(' | ') + ' |\\n';\n  }\n\n  return txt.trim();\n});\n\r\nshowdown.subParser('makeMarkdown.tableCell', function (node, globals) {\n  'use strict';\n\n  var txt = '';\n  if (!node.hasChildNodes()) {\n    return '';\n  }\n  var children = node.childNodes,\n      childrenLength = children.length;\n\n  for (var i = 0; i < childrenLength; ++i) {\n    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);\n  }\n  return txt.trim();\n});\n\r\nshowdown.subParser('makeMarkdown.txt', function (node) {\n  'use strict';\n\n  var txt = node.nodeValue;\n\n  // multiple spaces are collapsed\n  txt = txt.replace(/ +/g, ' ');\n\n  // replace the custom ¨NBSP; with a space\n  txt = txt.replace(/¨NBSP;/g, ' ');\n\n  // \", <, > and & should replace escaped html entities\n  txt = showdown.helper.unescapeHTMLEntities(txt);\n\n  // escape markdown magic characters\n  // emphasis, strong and strikethrough - can appear everywhere\n  // we also escape pipe (|) because of tables\n  // and escape ` because of code blocks and spans\n  txt = txt.replace(/([*_~|`])/g, '\\\\$1');\n\n  // escape > because of blockquotes\n  txt = txt.replace(/^(\\s*)>/g, '\\\\$1>');\n\n  // hash character, only troublesome at the beginning of a line because of headers\n  txt = txt.replace(/^#/gm, '\\\\#');\n\n  // horizontal rules\n  txt = txt.replace(/^(\\s*)([-=]{3,})(\\s*)$/, '$1\\\\$2$3');\n\n  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer\n  txt = txt.replace(/^( {0,3}\\d+)\\./gm, '$1\\\\.');\n\n  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)\n  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\\\$2');\n\n  // images and links, ] followed by ( is problematic, so we escape it\n  txt = txt.replace(/]([\\s]*)\\(/g, '\\\\]$1\\\\(');\n\n  // reference URIs must also be escaped\n  txt = txt.replace(/^ {0,3}\\[([\\S \\t]*?)]:/gm, '\\\\[$1]:');\n\n  return txt;\n});\n\r\nvar root = this;\n\n// AMD Loader\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    'use strict';\n    return showdown;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n// CommonJS/nodeJS Loader\n} else {}\n}).call(this);\r\n\n//# sourceMappingURL=showdown.js.map\r\n\n\n//# sourceURL=webpack:///./node_modules/showdown/dist/showdown.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/editor-interface.js":
/*!*********************************!*\
  !*** ./src/editor-interface.js ***!
  \*********************************/
/*! exports provided: init_interface, select_tab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init_interface\", function() { return init_interface; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"select_tab\", function() { return select_tab; });\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n/* harmony import */ var _lib_createComponentList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/createComponentList */ \"./src/lib/createComponentList.js\");\n\n\nvar TOOLBAR = '.livingdocs-toolbar';\nvar TOOLBAR_FORM = '#Form_LivingForm';\nvar BOTTOM_BAR = '.livingdocs-bottom-bar';\nvar PAGE_OPTIONS = '#livingdocs-page-options';\nvar init_interface = function init_interface(doc, selectedDesign) {\n  init_toolbar_tabs();\n  init_toolbar_toggles();\n  init_toolbar_form();\n  init_component_list(doc, selectedDesign); // when adding a component, see if it has a set of components that should\n  // be immediately created. Useful for something like a table cell that should always\n  // have a paragraph in it when added\n\n  _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.componentAdded.add(function (newComponent) {\n    var toCreate = selectedDesign.prefilledComponents[newComponent.componentName];\n\n    if (toCreate && toCreate.components) {\n      for (var containerName in toCreate.components) {\n        Object(_lib_createComponentList__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(toCreate.components[containerName], newComponent, containerName);\n      }\n    }\n  });\n};\n\nfunction init_toolbar_tabs() {\n  $(document).on('click', '.ld-tab', function (e) {\n    e.preventDefault();\n    select_tab($(this).attr('href'));\n    return false;\n  });\n}\n\nfunction init_component_list(doc, selectedDesign) {\n  var defaultIcon = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M16.21 4.16l4 4v-4zm4 12l-4 4h4zm-12 4l-4-4v4zm-4-12l4-4h-4zm12.95-.95c-2.73-2.73-7.17-2.73-9.9 0s-2.73 7.17 0 9.9 7.17 2.73 9.9 0 2.73-7.16 0-9.9zm-1.1 8.8c-2.13 2.13-5.57 2.13-7.7 0s-2.13-5.57 0-7.7 5.57-2.13 7.7 0 2.13 5.57 0 7.7z\" fill=\"#010101\"/><path fill=\"none\" d=\"M.21.16h24v24h-24z\"/></svg>';\n  var $components = $('#livingdocs-components');\n  var $componentsList = $components.find('div.component-list');\n  var componentGroupMap = {};\n\n  var addGroup = function addGroup(label, num) {\n    var $group = $('<div>');\n    $group.append('<h2>' + label + '</h2>');\n    $group.append('<div class=\"group-component-holder\" id=\"gch-' + num + '\"></div>');\n    $componentsList.append($group);\n  }; // use selectedDesign - the template, not active components at this point, as it is simpler to\n  // iterate\n\n\n  for (var i = 0; i < selectedDesign.groups.length; i++) {\n    addGroup(selectedDesign.groups[i].label, i);\n\n    for (var j in selectedDesign.groups[i].components) {\n      componentGroupMap[selectedDesign.groups[i].components[j]] = 'gch-' + i;\n    }\n  }\n\n  addGroup('Misc', 'misc');\n\n  var addMenuComponent = function addMenuComponent(icon, label, name) {\n    var $entryWrap = $('<div class=\"toolbar-entry-wrapper\">');\n    var $entry = $('<div class=\"toolbar-entry\">');\n    var $entryLabel = $('<div class=\"toolbar-entry-title\" data-name=\"' + name + '\">');\n    $entry.html(icon ? icon : defaultIcon);\n    $entryLabel.html(label);\n    $entryWrap.append($entry).append($entryLabel);\n    var groupId = componentGroupMap[name];\n\n    if (!groupId) {\n      groupId = 'gch-misc';\n    }\n\n    var $holder = $('#' + groupId);\n    $holder.append($entryWrap);\n    draggableComponent(doc, name, $entry);\n  }; // Adds in all the components in their appropriate grouping\n  // this used to use LivingDoc.activeDesign, but that misses the icons\n\n\n  for (var i = 0; i < selectedDesign.components.length; i++) {\n    var template = selectedDesign.components[i];\n    addMenuComponent(template.icon, template.label, template.name);\n  }\n\n  if (selectedDesign.compounds) {\n    for (var compoundName in selectedDesign.compounds) {\n      addMenuComponent(selectedDesign.compounds[compoundName].icon, selectedDesign.compounds[compoundName].label, compoundName);\n    }\n  } // Binds the drag behaviour when a menu item is dragged\n\n\n  function draggableComponent(doc, name, $elem) {\n    $elem.on('mousedown', function (event) {\n      var newComponent;\n\n      if (selectedDesign.compounds && selectedDesign.compounds[name]) {\n        newComponent = Object(_lib_createComponentList__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(selectedDesign.compounds[name].components);\n      } else {\n        newComponent = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.createComponent(name);\n      }\n\n      doc.startDrag({\n        componentModel: newComponent,\n        event: event,\n        config: {\n          preventDefault: true,\n          direct: true\n        }\n      });\n    });\n  }\n}\n\nfunction init_toolbar_toggles() {\n  var toolbarToggle = $('<button>').text(\"Toggle toolbar\");\n  $(BOTTOM_BAR).find('.livingdocs-toolbar-controls').append(toolbarToggle);\n  toolbarToggle.click(function (e) {\n    $('body').toggleClass('show-livingdocs-toolbar');\n  });\n  var gridToggle = $('<input type=\"checkbox\" checked>');\n  var enableGrid = $('<label class=\"ld-toggle\">').append(gridToggle).append('Enable grid');\n  $(PAGE_OPTIONS).append(enableGrid);\n  gridToggle.click(function (e) {\n    $('body').toggleClass('no-grid-display');\n  });\n  var layoutToggle = $('<input type=\"checkbox\" checked>');\n  var enableLayout = $('<label class=\"ld-toggle\">').append(layoutToggle).append('Enable layout editing');\n  $(PAGE_OPTIONS).append(enableLayout);\n  layoutToggle.click(function (e) {\n    var state = $(this).attr('data-layout-editing');\n\n    if (state == 1) {\n      $(this).attr('data-layout-editing', 0);\n    } else {\n      $(this).attr('data-layout-editing', 1);\n    }\n  }); // and start with the toolbar shown\n\n  toolbarToggle.click();\n  _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.interactiveView.page.componentWillBeDragged.add(function (option) {\n    if (layoutToggle.attr('data-layout-editing') == 1) {\n      option.enable = false;\n    } else {\n      option.enable = true;\n    }\n  });\n}\n\nfunction init_toolbar_form() {\n  // re-structures the form to ensure ajax submits pass through the\n  // triggered action\n  $(document).on('click', 'form' + TOOLBAR_FORM + ' > .Actions .action', function (e) {\n    // catuch the \"live\" click and redirect instead\n    if ($(this).attr('name') == 'action_live') {\n      e.preventDefault();\n      location.href = location.href + '?edit=stop&stage=Live';\n      return false;\n    }\n\n    if ($(this).hasClass('link-action')) {\n      e.preventDefault();\n      location.href = $(this).attr('data-link');\n      return false;\n    }\n\n    var parentForm = $(this).parents('form');\n    parentForm.find('input.hidden-action').remove();\n    $('<input class=\"hidden-action\">').attr({\n      'type': 'hidden',\n      'name': $(this).attr('name'),\n      'value': '1'\n    }).appendTo(parentForm);\n  });\n}\n\nfunction select_tab(name) {\n  if (name == 'default') {\n    name = '#livingdocs-components';\n  }\n\n  if (name[0] != '#') {\n    name = '#' + name;\n  }\n\n  $('.ld-tab-panel').hide();\n  $('.ld-tab').removeClass('ld-tab--active');\n  $('.ld-tab[href=\"' + name + '\"]').addClass('ld-tab--active');\n  $(TOOLBAR).scrollTop(0, 0);\n  $(name).show();\n}\n\n//# sourceURL=webpack:///./src/editor-interface.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _living_frontend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./living-frontend */ \"./src/living-frontend.js\");\n/* harmony import */ var _modules_lf_attr_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/lf-attr-editor */ \"./src/modules/lf-attr-editor.js\");\n/* harmony import */ var _modules_lf_editing_history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/lf-editing-history */ \"./src/modules/lf-editing-history.js\");\n/* harmony import */ var _modules_lf_embed_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/lf-embed-selection */ \"./src/modules/lf-embed-selection.js\");\n/* harmony import */ var _modules_lf_html_editing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/lf-html-editing */ \"./src/modules/lf-html-editing.js\");\n/* harmony import */ var _modules_lf_iframed_dialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/lf-iframed-dialog */ \"./src/modules/lf-iframed-dialog.js\");\n/* harmony import */ var _modules_lf_links_buttons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/lf-links-buttons */ \"./src/modules/lf-links-buttons.js\");\n/* harmony import */ var _modules_lf_paste_image__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/lf-paste-image */ \"./src/modules/lf-paste-image.js\");\n/* harmony import */ var _modules_lf_text_actions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/lf-text-actions */ \"./src/modules/lf-text-actions.js\");\n/* harmony import */ var _modules_lf_wysiwyg_editing__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/lf-wysiwyg-editing */ \"./src/modules/lf-wysiwyg-editing.js\");\n/* harmony import */ var _style_livingdocs_scss__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style/livingdocs.scss */ \"./src/style/livingdocs.scss\");\n/* harmony import */ var _style_livingdocs_scss__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_style_livingdocs_scss__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _style_living_frontend_scss__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./style/living-frontend.scss */ \"./src/style/living-frontend.scss\");\n/* harmony import */ var _style_living_frontend_scss__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_style_living_frontend_scss__WEBPACK_IMPORTED_MODULE_11__);\n\n\n\n\n\n\n\n\n\n\n\n\nvar editors = [];\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lib/FormContentSource.js":
/*!**************************************!*\
  !*** ./src/lib/FormContentSource.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jquery_form__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-form */ \"./node_modules/jquery-form/dist/jquery.form.min.js\");\n/* harmony import */ var jquery_form__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_form__WEBPACK_IMPORTED_MODULE_1__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Represents a SilverStripe based form as being\n * the provider of content. In future, this can be\n * an API instead...\n */\n\nvar FormContentSource =\n/*#__PURE__*/\nfunction () {\n  function FormContentSource() {\n    _classCallCheck(this, FormContentSource);\n\n    _defineProperty(this, \"TOOLBAR_FORM\", '#Form_LivingForm');\n\n    _defineProperty(this, \"DOC_HOLDER\", '#livingdocs-editor');\n\n    _defineProperty(this, \"config\", {});\n  }\n\n  _createClass(FormContentSource, [{\n    key: \"init\",\n    value: function init() {\n      var config = jquery__WEBPACK_IMPORTED_MODULE_0__(this.DOC_HOLDER).data('config');\n      config.editorHost = this.DOC_HOLDER;\n\n      if (config.pageStructure) {\n        this.config = config;\n      }\n\n      jquery__WEBPACK_IMPORTED_MODULE_0__(document).on('submit', this.TOOLBAR_FORM, function () {\n        var _this = jquery__WEBPACK_IMPORTED_MODULE_0__(this);\n\n        _this.removeAttr('data-changed');\n\n        jquery__WEBPACK_IMPORTED_MODULE_0__(this).ajaxSubmit({\n          error: function error() {\n            alert(\"An error was encountered\");\n            console.log(arguments);\n          },\n          complete: function complete(response) {\n            _this.find('button.action').each(function () {\n              jquery__WEBPACK_IMPORTED_MODULE_0__(this).prop('disabled', false);\n              jquery__WEBPACK_IMPORTED_MODULE_0__(this).attr(\"data-clicked\", \"0\");\n            });\n          }\n        });\n\n        _this.find('button.action').each(function () {\n          jquery__WEBPACK_IMPORTED_MODULE_0__(this).prop('disabled', true);\n        });\n\n        return false;\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0__(document).on('mousedown', this.TOOLBAR_FORM + ' button.action', function (e) {\n        // catuch the \"live\" click and redirect instead\n        if (jquery__WEBPACK_IMPORTED_MODULE_0__(this).attr('name') == 'action_live') {\n          e.preventDefault();\n          location.href = location.href + '?edit=stop&stage=Live';\n          return false;\n        }\n\n        if (jquery__WEBPACK_IMPORTED_MODULE_0__(this).hasClass('link-action')) {\n          e.preventDefault();\n          location.href = jquery__WEBPACK_IMPORTED_MODULE_0__(this).attr('data-link');\n          return false;\n        }\n\n        var parentForm = jquery__WEBPACK_IMPORTED_MODULE_0__(this).parents('form');\n        parentForm.find('input.hidden-action').remove();\n        jquery__WEBPACK_IMPORTED_MODULE_0__('<input class=\"hidden-action\">').attr({\n          'type': 'hidden',\n          'name': jquery__WEBPACK_IMPORTED_MODULE_0__(this).attr('name'),\n          'value': '1'\n        }).appendTo(parentForm);\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0__(window).bind('beforeunload', function () {\n        if (jquery__WEBPACK_IMPORTED_MODULE_0__(this.TOOLBAR_FORM).attr('data-changed')) {\n          return \"You may have unsaved changes, sure?\";\n        }\n      });\n      jquery__WEBPACK_IMPORTED_MODULE_0__(document).on('updateLivingdocsDesign', function (e, selectedDesign) {\n        if (config.extraComponents) {\n          var _loop = function _loop(i) {\n            var newComponent = config.extraComponents[i];\n            var group = newComponent.group;\n            delete newComponent.group;\n\n            if (group && selectedDesign.groups) {\n              var existingIndex = selectedDesign.groups.findIndex(function (item) {\n                return item.label == group;\n              });\n\n              if (existingIndex >= 0) {\n                selectedDesign.groups[existingIndex].components.push(newComponent.name);\n              }\n            }\n\n            selectedDesign.components.push(newComponent);\n          };\n\n          for (var i in config.extraComponents) {\n            _loop(i);\n          }\n        }\n\n        if (config.compounds) {\n          var _loop2 = function _loop2(i) {\n            var newComponent = config.compounds[i];\n            var group = newComponent.group;\n            delete newComponent.group;\n\n            if (group && selectedDesign.groups) {\n              var existingIndex = selectedDesign.groups.findIndex(function (item) {\n                return item.label == group;\n              });\n\n              if (existingIndex >= 0) {\n                selectedDesign.groups[existingIndex].components.push(newComponent.name);\n              }\n            }\n\n            selectedDesign.compounds[newComponent.name] = newComponent;\n          };\n\n          for (var i in config.compounds) {\n            _loop2(i);\n          }\n        } else {\n          selectedDesign.compounds = {};\n        }\n      });\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config;\n    }\n  }, {\n    key: \"getPageStructure\",\n    value: function getPageStructure() {\n      if (!this.config.pageStructure) {\n        throw \"Page hasn't been properly initialised in the CMS\";\n        this.config.pageStructure = dummyStructure;\n      }\n\n      return this.config.pageStructure;\n    }\n  }, {\n    key: \"updatePageContent\",\n    value: function updatePageContent(docStructure, docHtml, realchange) {\n      jquery__WEBPACK_IMPORTED_MODULE_0__(this.TOOLBAR_FORM).find('[name=PageStructure]').val(docStructure);\n      jquery__WEBPACK_IMPORTED_MODULE_0__(this.TOOLBAR_FORM).find('[name=Content]').val(docHtml);\n\n      if (realchange) {\n        jquery__WEBPACK_IMPORTED_MODULE_0__(this.TOOLBAR_FORM).attr('data-changed', 1);\n        jquery__WEBPACK_IMPORTED_MODULE_0__(this.TOOLBAR_FORM).find('[name=action_publish]').prop('disabled', true);\n      }\n    }\n  }]);\n\n  return FormContentSource;\n}();\n\nvar ContentSource = new FormContentSource();\nContentSource.init();\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContentSource);\nvar dummyStructure = {\n  \"data\": {\n    \"content\": [],\n    \"design\": {\n      \"name\": \"bootstrap3\",\n      \"version\": \"0.0.1\"\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/lib/FormContentSource.js?");

/***/ }),

/***/ "./src/lib/LivingDocState.js":
/*!***********************************!*\
  !*** ./src/lib/LivingDocState.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar LivingDocState = {\n  livingdoc: null,\n  changeStack: [],\n  activeComponent: null,\n  trackChanges: true,\n  historyLength: 20,\n  formIdentifier: null,\n  selectedDesign: null,\n  activeDesign: null,\n  // \n  contentSource: null,\n  // references the global 'doc' object that livingdocs exposes\n  docApi: null,\n  loadLivingdoc: function loadLivingdoc(docApi, selectedDesign, structure, contentSource) {\n    this.docApi = docApi;\n    this.contentSource = contentSource;\n    this.selectedDesign = selectedDesign;\n    this.docApi.design.load(this.selectedDesign); // this is the active instance of the design being used. \n\n    this.activeDesign = this.docApi.design.designs[this.selectedDesign.name];\n    this.docApi.config({\n      livingdocsCssFile: false,\n      editable: {\n        browserSpellcheck: true,\n        changeDelay: 50\n      }\n    });\n    this.livingdoc = this.docApi.new(structure);\n    this.initialiseState();\n  },\n  initialiseState: function initialiseState() {\n    this.activeComponent = null;\n    this.changeStack = [];\n    this.notifyDocUpdate();\n  },\n  focusOn: function focusOn(component) {\n    this.activeComponent = component;\n  },\n  blur: function blur() {\n    // not a true blur, we don't trigger on all blur occasions otherwise we lose context\n    this.activeComponent = null;\n  },\n  saveState: function saveState(currentState) {\n    if (this.trackChanges) {\n      var actionId = this.activeComponent ? this.activeComponent.model.id : null; // if the action happened to the currently active component, we remove any previous \n      // actions to the same one\n\n      if (this.changeStack.length > 0 && actionId && this.changeStack[this.changeStack.length - 1].cid === actionId) {\n        this.changeStack.pop();\n      }\n\n      this.changeStack.push({\n        time: new Date(),\n        cid: actionId,\n        state: currentState\n      });\n\n      if (this.changeStack.length > this.historyLength) {\n        this.changeStack.shift();\n      }\n    }\n  },\n  loadState: function loadState(stateIndex) {\n    if (this.changeStack[stateIndex]) {\n      var dataSet = JSON.parse(this.changeStack[stateIndex].state);\n      this.trackChanges = false;\n\n      while (this.livingdoc.componentTree.root.first) {\n        this.livingdoc.componentTree.root.first.remove();\n      }\n\n      this.trackChanges = true;\n      this.livingdoc.componentTree.addDataWithAnimation(dataSet);\n    }\n  },\n  notifyDocUpdate: function notifyDocUpdate(realchange) {\n    var docStructure = this.livingdoc.toJson();\n    this.contentSource.updatePageContent(docStructure, this.livingdoc.toHtml(), realchange);\n    this.saveState(docStructure);\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (LivingDocState);\n\n//# sourceURL=webpack:///./src/lib/LivingDocState.js?");

/***/ }),

/***/ "./src/lib/createComponentList.js":
/*!****************************************!*\
  !*** ./src/lib/createComponentList.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createComponentList; });\n/* harmony import */ var _LivingDocState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LivingDocState */ \"./src/lib/LivingDocState.js\");\n\n/**\n * creates components, inside a given parent.\n *\n * @param array components\n * @param ComponentModel parent\n * @param string containerName\n * @returns void\n */\n\nfunction createComponentList(components, parent, containerName) {\n  var forceAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!parent) {\n    parent = _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.root;\n  }\n\n  var newComponents = _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.componentsFromList(components, _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].activeDesign);\n\n  if (parent) {\n    if (!containerName && newComponents.length == 1 && !forceAdd) {\n      return newComponents[0];\n    }\n\n    for (var i in newComponents) {\n      if (containerName) {\n        parent.append(containerName, newComponents[i]);\n      } else {\n        parent.append(newComponents[i]);\n      }\n    }\n  }\n}\n;\n\n//# sourceURL=webpack:///./src/lib/createComponentList.js?");

/***/ }),

/***/ "./src/lib/ld-property-editor.js":
/*!***************************************!*\
  !*** ./src/lib/ld-property-editor.js ***!
  \***************************************/
/*! exports provided: initialise_property_editor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialise_property_editor\", function() { return initialise_property_editor; });\n/* harmony import */ var _LivingDocState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LivingDocState */ \"./src/lib/LivingDocState.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _modules_lf_style_editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/lf-style-editor */ \"./src/modules/lf-style-editor.js\");\n/* harmony import */ var _modules_lf_component_export__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/lf-component-export */ \"./src/modules/lf-component-export.js\");\n/* harmony import */ var _modules_lf_image_selector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modules/lf-image-selector */ \"./src/modules/lf-image-selector.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_plugins_ss_link_selector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector.js\");\n/* harmony import */ var _createComponentList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createComponentList */ \"./src/lib/createComponentList.js\");\n/* harmony import */ var _editor_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../editor-interface */ \"./src/editor-interface.js\");\n/* harmony import */ var _modules_lf_attr_editor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../modules/lf-attr-editor */ \"./src/modules/lf-attr-editor.js\");\n\n\n\n\n\n\n\n\n\nvar PROPS_HOLDER = 'livingdocs_EditorField_Toolbar_options';\nvar BOTTOM_BAR = '.livingdocs-bottom-bar';\nvar ITEM_PROPERTIES_HOLDER = '.livingdocs-item-properties';\njquery__WEBPACK_IMPORTED_MODULE_1__(document).on('click', function (e) {\n  if (jquery__WEBPACK_IMPORTED_MODULE_1__(e.target).parents('#livingdocs-editor').length <= 0 && jquery__WEBPACK_IMPORTED_MODULE_1__(e.target).parents('.livingdocs-toolbar').length <= 0 && jquery__WEBPACK_IMPORTED_MODULE_1__(e.target).parents(ITEM_PROPERTIES_HOLDER).length <= 0 && jquery__WEBPACK_IMPORTED_MODULE_1__(e.target).parents(BOTTOM_BAR).length <= 0) {\n    // remove the properties editing\n    Object(_editor_interface__WEBPACK_IMPORTED_MODULE_7__[\"select_tab\"])('default');\n    jquery__WEBPACK_IMPORTED_MODULE_1__('.' + PROPS_HOLDER).remove();\n  }\n});\nfunction initialise_property_editor() {\n  _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.interactiveView.page.focus.componentFocus.add(function (component) {\n    jquery__WEBPACK_IMPORTED_MODULE_1__(\".\" + PROPS_HOLDER).remove();\n    jquery__WEBPACK_IMPORTED_MODULE_1__(\".livingdocs_EditorField_Toolbar_textopts\").remove();\n    var options = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<div>\").addClass(PROPS_HOLDER);\n    var $properties = jquery__WEBPACK_IMPORTED_MODULE_1__(ITEM_PROPERTIES_HOLDER);\n    _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].focusOn(component);\n    options.append(\"<h4>\" + component.model.componentName + \" properties</h4>\"); // handles all the 'styles' ie css classes that this\n    // component can have\n\n    for (var s_id in component.model.template.styles) {\n      var curr_style = component.model.template.styles[s_id];\n      var el = null;\n      var lbl = jquery__WEBPACK_IMPORTED_MODULE_1__('<label>').text(curr_style.label);\n      var currentVal = component.model.getStyle(s_id);\n\n      switch (curr_style.type) {\n        case \"select\":\n          el = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<select>\");\n          var multi = false;\n\n          for (var op_id in curr_style.options) {\n            var curr_op = curr_style.options[op_id]; // todo(Marcus) - this is such a hack\n\n            if (curr_op.caption.toLowerCase() == 'multiple') {\n              multi = true;\n              continue;\n            }\n\n            el.append(jquery__WEBPACK_IMPORTED_MODULE_1__(\"<option>\").val(curr_op.value).text(curr_op.caption));\n          }\n\n          if (multi) {\n            el.attr('size', 3).prop('multiple', true);\n\n            if (currentVal) {\n              currentVal = currentVal.split(' ');\n            }\n          }\n\n          el.val(currentVal);\n          el.on(\"change\", function (styleId) {\n            return function () {\n              var selection = jquery__WEBPACK_IMPORTED_MODULE_1__(this).val();\n\n              if (selection && typeof selection !== 'string' && selection.length) {\n                selection = selection.join(' ');\n              }\n\n              component.model.setStyle(styleId, selection);\n            };\n          }(s_id));\n          break;\n\n        case \"text\":\n          el = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<input>\").attr({\n            type: 'text'\n          }).val(currentVal);\n          el.on(\"change\", function (styleName) {\n            return function () {\n              component.model.setStyle(styleName, el.val());\n            }; //                                curr_style.value = el.val();\n          }(curr_style.name));\n          break;\n\n        case \"option\":\n          el = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<input>\").attr({\n            type: 'checkbox'\n          });\n          el.on(\"change\", function (styleName, styleValue) {\n            return function () {\n              if (jquery__WEBPACK_IMPORTED_MODULE_1__(this).prop('checked')) {\n                component.model.setStyle(styleName, styleValue);\n              } else {\n                component.model.setStyle(styleName, \"\");\n              }\n            };\n          }(curr_style.name, curr_style.value));\n\n          if (curr_style.value == currentVal) {\n            el.prop('checked', true);\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (el) {\n        jquery__WEBPACK_IMPORTED_MODULE_1__('<div>').append(el).appendTo(lbl);\n        options.append('<div>').append(lbl);\n      }\n    }\n\n    if (component.model.directives.image && component.model.directives.image.length) {\n      for (var directive_id in component.model.directives.image) {\n        var curr_img = component.model.directives.image[directive_id];\n        var $image_button = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<button class='ld-item-selector'>\").text(\"Select \\\"\" + curr_img.name + '\"');\n        $image_button.on(\"click\", function (comp, img, did) {\n          return function () {\n            Object(_modules_lf_image_selector__WEBPACK_IMPORTED_MODULE_4__[\"selectImage\"])(comp, img, did);\n          };\n        }(component, curr_img, directive_id));\n        options.append($image_button);\n      }\n    }\n\n    if (component.model.directives.link && component.model.directives.link.length) {\n      for (var linkIndex in component.model.directives.link) {\n        var updateLink = component.model.directives.link[linkIndex];\n        var $link_button = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<button class='ld-item-selector'>\").text('Select \"' + updateLink.name + '\"').on(\"click\", function (comp, link) {\n          return function () {\n            var linkAttrs = {\n              href: comp.get(link.name),\n              title: '',\n              target: '',\n              text: comp.get(link.name)\n            };\n            Object(_symbiote_silverstripe_prose_editor_editor_src_plugins_ss_link_selector__WEBPACK_IMPORTED_MODULE_5__[\"linkSelectorDialog\"])(linkAttrs, {\n              internal: true\n            }, function (attrs) {\n              // ComponentView.prototype.set\n              comp.model.setContent(link.name, attrs.href);\n            }, ['pageLink', 'externalLink']);\n          };\n        }(component, updateLink));\n        options.append($link_button);\n      }\n    }\n\n    if (component.model.componentName === 'table') {\n      // add row and add column\n      var tableNode = component.$html[0];\n\n      if (tableNode) {\n        _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].showButtonBar([{\n          label: 'Add row',\n          click: function click() {\n            alert(\"NEW\");\n            var currentRow = component.$html.find('tr:first');\n            var numCells = 0;\n\n            if (currentRow.length) {\n              numCells = currentRow.find('th').length ? currentRow.find('th').length : currentRow.find('td').length;\n            }\n\n            var newComponent = _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.getComponent(TABLE_ROW_COMPONENT);\n            component.model.append('tablebody', newComponent); //create cells\n\n            for (var i = 0; i < numCells; i++) {\n              var newCell = _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.getComponent(TABLE_CELL_COMPONENT);\n              newComponent.append('rowcells', newCell);\n              var newP = _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.getComponent(\"p\");\n              newCell.append(\"cellitems\", newP);\n            }\n          }\n        }, {\n          label: 'Add col',\n          click: function click() {\n            var headerRow = component.model.containers.tablehead.first;\n            addCellToRows(headerRow, HEADER_CELL_COMPONENT);\n            var bodyRow = component.model.containers.tablebody.first;\n            addCellToRows(bodyRow, TABLE_CELL_COMPONENT);\n          }\n        }], tableNode);\n      }\n    }\n\n    var $delete_button = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<button class='alert alert-danger'>\").text(\"Remove\").on(\"click\", function () {\n      if (confirm(\"Remove this?\")) {\n        component.model.remove();\n        jquery__WEBPACK_IMPORTED_MODULE_1__(\".\" + PROPS_HOLDER).remove();\n      }\n    });\n    var $dupe_button = jquery__WEBPACK_IMPORTED_MODULE_1__(\"<button class='alert alert-warning'>\").text(\"Duplicate\").on(\"click\", function () {\n      var tmpTree = new doc.ComponentTree({\n        design: _LivingDocState__WEBPACK_IMPORTED_MODULE_0__[\"default\"].livingdoc.componentTree.design\n      }); // need to swap out 'next' for the moment otherwise the serialize walker\n      // will do _all_ siblings.\n\n      var oldNext = component.model.next;\n      component.model.next = null;\n      var jsonRep = tmpTree.serialize(component.model, true);\n      component.model.next = oldNext;\n      Object(_createComponentList__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(jsonRep.content, component.model.parentContainer, null, true);\n    });\n    var exportButton = jquery__WEBPACK_IMPORTED_MODULE_1__('<button>Export</button>');\n    exportButton.click(function (e) {\n      Object(_modules_lf_component_export__WEBPACK_IMPORTED_MODULE_3__[\"componentExportForm\"])(component);\n    });\n    jquery__WEBPACK_IMPORTED_MODULE_1__('<div class=\"Actions component-actions\">').appendTo(options).append($dupe_button).append($delete_button).append(exportButton); // TODO Re-evaluate whether we need access to the raw attribute values\n\n    Object(_modules_lf_attr_editor__WEBPACK_IMPORTED_MODULE_8__[\"initialise_attribute_editor\"])(options, component);\n    var styleDiv = jquery__WEBPACK_IMPORTED_MODULE_1__('<div>').appendTo(options);\n    $properties.html(options);\n    Object(_modules_lf_style_editor__WEBPACK_IMPORTED_MODULE_2__[\"createStyleEditor\"])(component, styleDiv[0]);\n    Object(_editor_interface__WEBPACK_IMPORTED_MODULE_7__[\"select_tab\"])('livingdocs-property-tab');\n  });\n}\n\n//# sourceURL=webpack:///./src/lib/ld-property-editor.js?");

/***/ }),

/***/ "./src/living-frontend.js":
/*!********************************!*\
  !*** ./src/living-frontend.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _livingdocs_editable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./livingdocs/editable */ \"./src/livingdocs/editable.js\");\n/* harmony import */ var _livingdocs_livingdocs_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./livingdocs/livingdocs-engine */ \"./src/livingdocs/livingdocs-engine.js\");\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n/* harmony import */ var _lib_FormContentSource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/FormContentSource */ \"./src/lib/FormContentSource.js\");\n/* harmony import */ var _lib_ld_property_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/ld-property-editor */ \"./src/lib/ld-property-editor.js\");\n/* harmony import */ var _modules_lf_keyboard_handler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/lf-keyboard-handler */ \"./src/modules/lf-keyboard-handler.js\");\n/* harmony import */ var _modules_lf_messages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/lf-messages */ \"./src/modules/lf-messages.js\");\n/* harmony import */ var _editor_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor-interface */ \"./src/editor-interface.js\");\n\n\n\n\n\n\n\n\n\n\n(function ($) {\n  if (!window.$) {\n    window.$ = $;\n  }\n\n  var PING_TIME = 300;\n  var MAX_TIME = 86400;\n  var pingErrors = 0;\n  var editingTime = 0;\n  var pingterval = setInterval(function () {\n    if (editingTime > MAX_TIME) {\n      clearInterval(pingterval);\n      return;\n    }\n\n    $.get('Security/ping').then(function () {\n      pingErrors = 0;\n    }).catch(function () {\n      pingErrors++;\n\n      if (pingErrors > 5) {\n        alert(\"Your session may have expired, please try logging in again in a separate tab\");\n        clearInterval(pingterval);\n      }\n    });\n    editingTime += PING_TIME;\n  }, PING_TIME * 1000);\n  var TABLE_ROW_COMPONENT = 'tablerow';\n  Object(_modules_lf_messages__WEBPACK_IMPORTED_MODULE_7__[\"initialise_messages\"])();\n  $(document).on('mousedown', '#clicker', function (e) {\n    e.preventDefault();\n  });\n  $(document).on('click', '#clicker', function () {// ContentBridge.setLinkObject({\n    //     href: 'link/href', target: '', title: 'linktitle'\n    // });\n  });\n  $(function () {\n    var structure = _lib_FormContentSource__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getPageStructure(); // relies on a design file having been loaded earlier\n    // TODO - abstract this in _some_ manner. TBA\n\n    if (!window.design) {\n      alert(\"No design loaded\");\n      return;\n    }\n\n    var selectedDesignName = structure.data.design.name;\n    var selectedDesign = design[selectedDesignName];\n\n    if (!selectedDesign) {\n      alert(\"Selected design \" + selectedDesignName + \" couldn't be found\");\n      return;\n    } // provides 3rd party hooks\n\n\n    $(document).trigger('updateLivingdocsDesign', selectedDesign); // hard coded against the design for now??\n    // selectedDesign.assets.basePath = \"frontend-livingdoc/javascript/livingdocs/\";\n    // doc.design.load(selectedDesign);\n    // doc.config({\n    //     livingdocsCssFile: \"frontend-livingdoc/javascript/livingdocs/css/livingdocs.css\",\n    //     editable: {\n    //         browserSpellcheck: true,\n    //         changeDelay: 50\n    //     }\n    //     // ,\n    //     // // really not sure if this matters here, but we'll run with it for now.\n    //     // directives: {\n    //     //     dataobject: {\n    //     //         attr: 'doc-dataobject',\n    //     //         renderedAttr: 'calculated in augment_config',\n    //     //         overwritesContent: true\n    //     //     }\n    //     // }\n    // });\n    // livingdoc = doc.new(structure);\n\n    _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].loadLivingdoc(doc, selectedDesign, structure, _lib_FormContentSource__WEBPACK_IMPORTED_MODULE_4__[\"default\"]); // bind it into the bridge\n    // ContentBridge.setLivingDoc(livingdoc);\n\n    _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].notifyDocUpdate();\n    var ready = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].livingdoc.createView({\n      interactive: true,\n      iframe: false,\n      host: _lib_FormContentSource__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getConfig().editorHost,\n      wrapper: _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].activeDesign.wrapper\n    });\n    ready.then(function () {\n      // captures model changes that need updating\n      _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].livingdoc.model.changed.add(function () {\n        _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].notifyDocUpdate(true);\n      });\n      /** doc is declared in the global namespace */\n\n      Object(_editor_interface__WEBPACK_IMPORTED_MODULE_8__[\"init_interface\"])(doc, selectedDesign); // todo(Marcus)\n      // figure out how to allow selection of 'background' components\n      // let lastClickedComponent = \"\", lastClickedCount = 0;\n      // LivingDocState.livingdoc.interactiveView.page.componentClick.add(function (componentView, page, directives, event) {\n      //     if (componentView.model.hasContainers()) {\n      //         if (lastClickedComponent === componentView.model.id) {\n      //             lastClickedCount++;\n      //             if (lastClickedCount == 2) {\n      //                 // get the parent and select it\n      //                 let parent = componentView.parent();\n      //                 page.handleClickedComponent(event, parent);\n      //                 page.startDrag({\n      //                     componentView: parent,\n      //                     event: event\n      //                 });\n      //                 lastClickedCount = 0;\n      //             }\n      //         } else {\n      //             lastClickedCount = 0;\n      //         }\n      //         lastClickedComponent = componentView.model.id;\n      //     }\n      // });\n\n      Object(_lib_ld_property_editor__WEBPACK_IMPORTED_MODULE_5__[\"initialise_property_editor\"])();\n      Object(_modules_lf_keyboard_handler__WEBPACK_IMPORTED_MODULE_6__[\"initialise_keyboard\"])(_lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n      $(document).trigger('livingfrontend.updateLivingDoc', [_lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].livingdoc]);\n    });\n    /**\n     * Show a list of buttons in a toolbar. The button list should be\n     * [\n     *     { label: 'Label', title: 'tooltop', click: function () {} }\n     * ]\n     *\n     * @param an array of button objects\n     * @param an object with a .left and .top  property that defines where to show the bar\n     * @returns void\n     */\n\n    _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].showButtonBar = function (buttons, loc) {\n      $(\".livingdocs_EditorField_Toolbar_textopts\").remove();\n      var outer_el = $(\"<div>\").addClass(\"livingdocs_EditorField_Toolbar_textopts\");\n\n      for (var i = 0; i < buttons.length; i++) {\n        var b = buttons[i];\n        var buttonEl = $('<button>').html(b.label);\n\n        if (b.title) {\n          buttonEl.attr('title', b.title);\n        }\n\n        buttonEl.on('mousedown', function (theButton) {\n          return function (e) {\n            e.preventDefault();\n            theButton.click();\n          };\n        }(b));\n        outer_el.append(buttonEl);\n      }\n\n      var appendTo = $('body');\n\n      if (!loc.left) {\n        // we have a node instead\n        appendTo = $(loc).parent();\n        var newloc = {\n          top: loc.offsetTop + 20,\n          left: loc.offsetLeft + 20\n        };\n        loc = newloc;\n      }\n\n      outer_el.css({\n        position: \"absolute\",\n        left: loc.left,\n        top: loc.top - 40,\n        background: \"transparent\",\n        \"z-index\": 4000\n      });\n      appendTo.append(outer_el);\n    };\n\n    _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].showDialog = function () {\n      var popup;\n      var dialog = $('#lf-dialog');\n\n      if (!dialog.length) {\n        dialog = $('<div class=\"lf-overlay\" id=\"lf-dialog\">');\n        popup = $('<div class=\"lf-popup\">').appendTo(dialog);\n        popup.append('<a class=\"lf-dialog-close\" href=\"#\">&times;</a>');\n        popup.append('<div class=\"lf-dialog-content\">');\n        $('body').append(dialog);\n      }\n\n      popup = dialog.find('.lf-popup');\n      popup.empty();\n      $(dialog).addClass('active-dialog');\n      return popup;\n    };\n\n    _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].closeDialog = function () {\n      var dialog = $('#lf-dialog');\n\n      if (dialog.length) {\n        dialog.removeClass('active-dialog');\n        dialog.find('lf-dialog-content').html('');\n      }\n    };\n\n    $(document).on('click', 'a.lf-dialog-close', function (e) {\n      _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].closeDialog();\n      return false;\n    });\n    /**\n     * Iteratively add cells to all the rows in a given table container\n     *\n     * @param {type} firstRow\n     * @param {type} cellType\n     * @returns {.firstRow.next.next}\n     */\n\n    function addCellToRows(firstRow, cellType) {\n      if (firstRow) {\n        while (firstRow && firstRow.componentName == TABLE_ROW_COMPONENT) {\n          var newCell = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].livingdoc.componentTree.getComponent(cellType);\n          firstRow.append('rowcells', newCell);\n          firstRow = firstRow.next;\n          var newP = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_3__[\"default\"].livingdoc.componentTree.getComponent(\"p\");\n          newCell.append(\"cellitems\", newP);\n        }\n      }\n\n      return firstRow;\n    }\n  });\n})(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=webpack:///./src/living-frontend.js?");

/***/ }),

/***/ "./src/livingdocs/editable.js":
/*!************************************!*\
  !*** ./src/livingdocs/editable.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n/**\n * @license Rangy, a cross-browser JavaScript range and selection library\n * http://code.google.com/p/rangy/\n *\n * Copyright 2012, Tim Down\n * Licensed under the MIT license.\n * Version: 1.2.3\n * Build date: 26 February 2012\n */\n\nwindow['rangy'] = function () {\n  var OBJECT = \"object\",\n      FUNCTION = \"function\",\n      UNDEFINED = \"undefined\";\n  var domRangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\", \"commonAncestorContainer\", \"START_TO_START\", \"START_TO_END\", \"END_TO_START\", \"END_TO_END\"];\n  var domRangeMethods = [\"setStart\", \"setStartBefore\", \"setStartAfter\", \"setEnd\", \"setEndBefore\", \"setEndAfter\", \"collapse\", \"selectNode\", \"selectNodeContents\", \"compareBoundaryPoints\", \"deleteContents\", \"extractContents\", \"cloneContents\", \"insertNode\", \"surroundContents\", \"cloneRange\", \"toString\", \"detach\"];\n  var textRangeProperties = [\"boundingHeight\", \"boundingLeft\", \"boundingTop\", \"boundingWidth\", \"htmlText\", \"text\"]; // Subset of TextRange's full set of methods that we're interested in\n\n  var textRangeMethods = [\"collapse\", \"compareEndPoints\", \"duplicate\", \"getBookmark\", \"moveToBookmark\", \"moveToElementText\", \"parentElement\", \"pasteHTML\", \"select\", \"setEndPoint\", \"getBoundingClientRect\"];\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Trio of functions taken from Peter Michaux's article:\n  // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n\n  function isHostMethod(o, p) {\n    var t = _typeof(o[p]);\n\n    return t == FUNCTION || !!(t == OBJECT && o[p]) || t == \"unknown\";\n  }\n\n  function isHostObject(o, p) {\n    return !!(_typeof(o[p]) == OBJECT && o[p]);\n  }\n\n  function isHostProperty(o, p) {\n    return _typeof(o[p]) != UNDEFINED;\n  } // Creates a convenience function to save verbose repeated calls to tests functions\n\n\n  function createMultiplePropertyTest(testFunc) {\n    return function (o, props) {\n      var i = props.length;\n\n      while (i--) {\n        if (!testFunc(o, props[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  } // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n\n\n  var areHostMethods = createMultiplePropertyTest(isHostMethod);\n  var areHostObjects = createMultiplePropertyTest(isHostObject);\n  var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n  function isTextRange(range) {\n    return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n  }\n\n  var api = {\n    version: \"1.2.3\",\n    initialized: false,\n    supported: true,\n    util: {\n      isHostMethod: isHostMethod,\n      isHostObject: isHostObject,\n      isHostProperty: isHostProperty,\n      areHostMethods: areHostMethods,\n      areHostObjects: areHostObjects,\n      areHostProperties: areHostProperties,\n      isTextRange: isTextRange\n    },\n    features: {},\n    modules: {},\n    config: {\n      alertOnWarn: false,\n      preferTextRange: false\n    }\n  };\n\n  function fail(reason) {\n    window.alert(\"Rangy not supported in your browser. Reason: \" + reason);\n    api.initialized = true;\n    api.supported = false;\n  }\n\n  api.fail = fail;\n\n  function warn(msg) {\n    var warningMessage = \"Rangy warning: \" + msg;\n\n    if (api.config.alertOnWarn) {\n      window.alert(warningMessage);\n    } else if (_typeof(window.console) != UNDEFINED && _typeof(window.console.log) != UNDEFINED) {\n      window.console.log(warningMessage);\n    }\n  }\n\n  api.warn = warn;\n\n  if ({}.hasOwnProperty) {\n    api.util.extend = function (o, props) {\n      for (var i in props) {\n        if (props.hasOwnProperty(i)) {\n          o[i] = props[i];\n        }\n      }\n    };\n  } else {\n    fail(\"hasOwnProperty not supported\");\n  }\n\n  var initListeners = [];\n  var moduleInitializers = []; // Initialization\n\n  function init() {\n    if (api.initialized) {\n      return;\n    }\n\n    var testRange;\n    var implementsDomRange = false,\n        implementsTextRange = false; // First, perform basic feature tests\n\n    if (isHostMethod(document, \"createRange\")) {\n      testRange = document.createRange();\n\n      if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n        implementsDomRange = true;\n      }\n\n      testRange.detach();\n    }\n\n    var body = isHostObject(document, \"body\") ? document.body : document.getElementsByTagName(\"body\")[0];\n\n    if (body && isHostMethod(body, \"createTextRange\")) {\n      testRange = body.createTextRange();\n\n      if (isTextRange(testRange)) {\n        implementsTextRange = true;\n      }\n    }\n\n    if (!implementsDomRange && !implementsTextRange) {\n      fail(\"Neither Range nor TextRange are implemented\");\n    }\n\n    api.initialized = true;\n    api.features = {\n      implementsDomRange: implementsDomRange,\n      implementsTextRange: implementsTextRange\n    }; // Initialize modules and call init listeners\n\n    var allListeners = moduleInitializers.concat(initListeners);\n\n    for (var i = 0, len = allListeners.length; i < len; ++i) {\n      try {\n        allListeners[i](api);\n      } catch (ex) {\n        if (isHostObject(window, \"console\") && isHostMethod(window.console, \"log\")) {\n          window.console.log(\"Init listener threw an exception. Continuing.\", ex);\n        }\n      }\n    }\n  } // Allow external scripts to initialize this library in case it's loaded after the document has loaded\n\n\n  api.init = init; // Execute listener immediately if already initialized\n\n  api.addInitListener = function (listener) {\n    if (api.initialized) {\n      listener(api);\n    } else {\n      initListeners.push(listener);\n    }\n  };\n\n  var createMissingNativeApiListeners = [];\n\n  api.addCreateMissingNativeApiListener = function (listener) {\n    createMissingNativeApiListeners.push(listener);\n  };\n\n  function createMissingNativeApi(win) {\n    win = win || window;\n    init(); // Notify listeners\n\n    for (var i = 0, len = createMissingNativeApiListeners.length; i < len; ++i) {\n      createMissingNativeApiListeners[i](win);\n    }\n  }\n\n  api.createMissingNativeApi = createMissingNativeApi;\n  /**\n   * @constructor\n   */\n\n  function Module(name) {\n    this.name = name;\n    this.initialized = false;\n    this.supported = false;\n  }\n\n  Module.prototype.fail = function (reason) {\n    this.initialized = true;\n    this.supported = false;\n    throw new Error(\"Module '\" + this.name + \"' failed to load: \" + reason);\n  };\n\n  Module.prototype.warn = function (msg) {\n    api.warn(\"Module \" + this.name + \": \" + msg);\n  };\n\n  Module.prototype.createError = function (msg) {\n    return new Error(\"Error in Rangy \" + this.name + \" module: \" + msg);\n  };\n\n  api.createModule = function (name, initFunc) {\n    var module = new Module(name);\n    api.modules[name] = module;\n    moduleInitializers.push(function (api) {\n      initFunc(api, module);\n      module.initialized = true;\n      module.supported = true;\n    });\n  };\n\n  api.requireModules = function (modules) {\n    for (var i = 0, len = modules.length, module, moduleName; i < len; ++i) {\n      moduleName = modules[i];\n      module = api.modules[moduleName];\n\n      if (!module || !(module instanceof Module)) {\n        throw new Error(\"Module '\" + moduleName + \"' not found\");\n      }\n\n      if (!module.supported) {\n        throw new Error(\"Module '\" + moduleName + \"' not supported\");\n      }\n    }\n  };\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Wait for document to load before running tests\n\n\n  var docReady = false;\n\n  var loadHandler = function loadHandler(e) {\n    if (!docReady) {\n      docReady = true;\n\n      if (!api.initialized) {\n        init();\n      }\n    }\n  }; // Test whether we have window and document objects that we will need\n\n\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == UNDEFINED) {\n    fail(\"No window found\");\n    return;\n  }\n\n  if ((typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) == UNDEFINED) {\n    fail(\"No document found\");\n    return;\n  }\n\n  if (isHostMethod(document, \"addEventListener\")) {\n    document.addEventListener(\"DOMContentLoaded\", loadHandler, false);\n  } // Add a fallback in case the DOMContentLoaded event isn't supported\n\n\n  if (isHostMethod(window, \"addEventListener\")) {\n    window.addEventListener(\"load\", loadHandler, false);\n  } else if (isHostMethod(window, \"attachEvent\")) {\n    window.attachEvent(\"onload\", loadHandler);\n  } else {\n    fail(\"Window does not have required addEventListener or attachEvent method\");\n  }\n\n  return api;\n}();\n\nrangy.createModule(\"DomUtil\", function (api, module) {\n  var UNDEF = \"undefined\";\n  var util = api.util; // Perform feature tests\n\n  if (!util.areHostMethods(document, [\"createDocumentFragment\", \"createElement\", \"createTextNode\"])) {\n    module.fail(\"document missing a Node creation method\");\n  }\n\n  if (!util.isHostMethod(document, \"getElementsByTagName\")) {\n    module.fail(\"document missing getElementsByTagName method\");\n  }\n\n  var el = document.createElement(\"div\");\n\n  if (!util.areHostMethods(el, [\"insertBefore\", \"appendChild\", \"cloneNode\"] || false)) {\n    module.fail(\"Incomplete Element implementation\");\n  } // innerHTML is required for Range's createContextualFragment method\n\n\n  if (!util.isHostProperty(el, \"innerHTML\")) {\n    module.fail(\"Element is missing innerHTML property\");\n  }\n\n  var textNode = document.createTextNode(\"test\");\n\n  if (!util.areHostMethods(textNode, [\"splitText\", \"deleteData\", \"insertData\", \"appendData\", \"cloneNode\"] || false || false)) {\n    module.fail(\"Incomplete Text Node implementation\");\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been\n  // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n  // contains just the document as a single element and the value searched for is the document.\n\n\n  var arrayContains =\n  /*Array.prototype.indexOf ?\n  function(arr, val) {\n  return arr.indexOf(val) > -1;\n  }:*/\n  function arrayContains(arr, val) {\n    var i = arr.length;\n\n    while (i--) {\n      if (arr[i] === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n\n\n  function isHtmlNamespace(node) {\n    var ns;\n    return _typeof(node.namespaceURI) == UNDEF || (ns = node.namespaceURI) === null || ns == \"http://www.w3.org/1999/xhtml\";\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n    return parent.nodeType == 1 ? parent : null;\n  }\n\n  function getNodeIndex(node) {\n    var i = 0;\n\n    while (node = node.previousSibling) {\n      i++;\n    }\n\n    return i;\n  }\n\n  function getNodeLength(node) {\n    var childNodes;\n    return isCharacterDataNode(node) ? node.length : (childNodes = node.childNodes) ? childNodes.length : 0;\n  }\n\n  function getCommonAncestor(node1, node2) {\n    var ancestors = [],\n        n;\n\n    for (n = node1; n; n = n.parentNode) {\n      ancestors.push(n);\n    }\n\n    for (n = node2; n; n = n.parentNode) {\n      if (arrayContains(ancestors, n)) {\n        return n;\n      }\n    }\n\n    return null;\n  }\n\n  function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n    var n = selfIsAncestor ? descendant : descendant.parentNode;\n\n    while (n) {\n      if (n === ancestor) {\n        return true;\n      } else {\n        n = n.parentNode;\n      }\n    }\n\n    return false;\n  }\n\n  function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n    var p,\n        n = selfIsAncestor ? node : node.parentNode;\n\n    while (n) {\n      p = n.parentNode;\n\n      if (p === ancestor) {\n        return n;\n      }\n\n      n = p;\n    }\n\n    return null;\n  }\n\n  function isCharacterDataNode(node) {\n    var t = node.nodeType;\n    return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n  }\n\n  function insertAfter(node, precedingNode) {\n    var nextNode = precedingNode.nextSibling,\n        parent = precedingNode.parentNode;\n\n    if (nextNode) {\n      parent.insertBefore(node, nextNode);\n    } else {\n      parent.appendChild(node);\n    }\n\n    return node;\n  } // Note that we cannot use splitText() because it is bugridden in IE 9.\n\n\n  function splitDataNode(node, index) {\n    var newNode = node.cloneNode(false);\n    newNode.deleteData(0, index);\n    node.deleteData(index, node.length - index);\n    insertAfter(newNode, node);\n    return newNode;\n  }\n\n  function getDocument(node) {\n    if (node.nodeType == 9) {\n      return node;\n    } else if (_typeof(node.ownerDocument) != UNDEF) {\n      return node.ownerDocument;\n    } else if (_typeof(node.document) != UNDEF) {\n      return node.document;\n    } else if (node.parentNode) {\n      return getDocument(node.parentNode);\n    } else {\n      throw new Error(\"getDocument: no document found for node\");\n    }\n  }\n\n  function getWindow(node) {\n    var doc = getDocument(node);\n\n    if (_typeof(doc.defaultView) != UNDEF) {\n      return doc.defaultView;\n    } else if (_typeof(doc.parentWindow) != UNDEF) {\n      return doc.parentWindow;\n    } else {\n      throw new Error(\"Cannot get a window object for node\");\n    }\n  }\n\n  function getIframeDocument(iframeEl) {\n    if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument;\n    } else if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow.document;\n    } else {\n      throw new Error(\"getIframeWindow: No Document object found for iframe element\");\n    }\n  }\n\n  function getIframeWindow(iframeEl) {\n    if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow;\n    } else if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument.defaultView;\n    } else {\n      throw new Error(\"getIframeWindow: No Window object found for iframe element\");\n    }\n  }\n\n  function getBody(doc) {\n    return util.isHostObject(doc, \"body\") ? doc.body : doc.getElementsByTagName(\"body\")[0];\n  }\n\n  function getRootContainer(node) {\n    var parent;\n\n    while (parent = node.parentNode) {\n      node = parent;\n    }\n\n    return node;\n  }\n\n  function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n    // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n    var nodeC, root, childA, childB, n;\n\n    if (nodeA == nodeB) {\n      // Case 1: nodes are the same\n      return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {\n      // Case 2: node C (container B or an ancestor) is a child node of A\n      return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {\n      // Case 3: node C (container A or an ancestor) is a child node of B\n      return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n    } else {\n      // Case 4: containers are siblings or descendants of siblings\n      root = getCommonAncestor(nodeA, nodeB);\n      childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);\n      childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);\n\n      if (childA === childB) {\n        // This shouldn't be possible\n        throw new Error(\"comparePoints got to case 4 and childA and childB are the same!\");\n      } else {\n        n = root.firstChild;\n\n        while (n) {\n          if (n === childA) {\n            return -1;\n          } else if (n === childB) {\n            return 1;\n          }\n\n          n = n.nextSibling;\n        }\n\n        throw new Error(\"Should not be here!\");\n      }\n    }\n  }\n\n  function fragmentFromNodeChildren(node) {\n    var fragment = getDocument(node).createDocumentFragment(),\n        child;\n\n    while (child = node.firstChild) {\n      fragment.appendChild(child);\n    }\n\n    return fragment;\n  }\n\n  function inspectNode(node) {\n    if (!node) {\n      return \"[No node]\";\n    }\n\n    if (isCharacterDataNode(node)) {\n      return '\"' + node.data + '\"';\n    } else if (node.nodeType == 1) {\n      var idAttr = node.id ? ' id=\"' + node.id + '\"' : \"\";\n      return \"<\" + node.nodeName + idAttr + \">[\" + node.childNodes.length + \"]\";\n    } else {\n      return node.nodeName;\n    }\n  }\n  /**\n   * @constructor\n   */\n\n\n  function NodeIterator(root) {\n    this.root = root;\n    this._next = root;\n  }\n\n  NodeIterator.prototype = {\n    _current: null,\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n    next: function next() {\n      var n = this._current = this._next;\n      var child, next;\n\n      if (this._current) {\n        child = n.firstChild;\n\n        if (child) {\n          this._next = child;\n        } else {\n          next = null;\n\n          while (n !== this.root && !(next = n.nextSibling)) {\n            n = n.parentNode;\n          }\n\n          this._next = next;\n        }\n      }\n\n      return this._current;\n    },\n    detach: function detach() {\n      this._current = this._next = this.root = null;\n    }\n  };\n\n  function createIterator(root) {\n    return new NodeIterator(root);\n  }\n  /**\n   * @constructor\n   */\n\n\n  function DomPosition(node, offset) {\n    this.node = node;\n    this.offset = offset;\n  }\n\n  DomPosition.prototype = {\n    equals: function equals(pos) {\n      return this.node === pos.node & this.offset == pos.offset;\n    },\n    inspect: function inspect() {\n      return \"[DomPosition(\" + inspectNode(this.node) + \":\" + this.offset + \")]\";\n    }\n  };\n  /**\n   * @constructor\n   */\n\n  function DOMException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = \"DOMException: \" + this.codeName;\n  }\n\n  DOMException.prototype = {\n    INDEX_SIZE_ERR: 1,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INVALID_STATE_ERR: 11\n  };\n\n  DOMException.prototype.toString = function () {\n    return this.message;\n  };\n\n  api.dom = {\n    arrayContains: arrayContains,\n    isHtmlNamespace: isHtmlNamespace,\n    parentElement: parentElement,\n    getNodeIndex: getNodeIndex,\n    getNodeLength: getNodeLength,\n    getCommonAncestor: getCommonAncestor,\n    isAncestorOf: isAncestorOf,\n    getClosestAncestorIn: getClosestAncestorIn,\n    isCharacterDataNode: isCharacterDataNode,\n    insertAfter: insertAfter,\n    splitDataNode: splitDataNode,\n    getDocument: getDocument,\n    getWindow: getWindow,\n    getIframeWindow: getIframeWindow,\n    getIframeDocument: getIframeDocument,\n    getBody: getBody,\n    getRootContainer: getRootContainer,\n    comparePoints: comparePoints,\n    inspectNode: inspectNode,\n    fragmentFromNodeChildren: fragmentFromNodeChildren,\n    createIterator: createIterator,\n    DomPosition: DomPosition\n  };\n  api.DOMException = DOMException;\n});\nrangy.createModule(\"DomRange\", function (api, module) {\n  api.requireModules([\"DomUtil\"]);\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DOMException = api.DOMException;\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Utility functions\n\n  function isNonTextPartiallySelected(node, range) {\n    return node.nodeType != 3 && (dom.isAncestorOf(node, range.startContainer, true) || dom.isAncestorOf(node, range.endContainer, true));\n  }\n\n  function getRangeDocument(range) {\n    return dom.getDocument(range.startContainer);\n  }\n\n  function dispatchEvent(range, type, args) {\n    var listeners = range._listeners[type];\n\n    if (listeners) {\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n        listeners[i].call(range, {\n          target: range,\n          args: args\n        });\n      }\n    }\n  }\n\n  function getBoundaryBeforeNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node));\n  }\n\n  function getBoundaryAfterNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node) + 1);\n  }\n\n  function insertNodeAtPosition(node, n, o) {\n    var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n\n    if (dom.isCharacterDataNode(n)) {\n      if (o == n.length) {\n        dom.insertAfter(node, n);\n      } else {\n        n.parentNode.insertBefore(node, o == 0 ? n : dom.splitDataNode(n, o));\n      }\n    } else if (o >= n.childNodes.length) {\n      n.appendChild(node);\n    } else {\n      n.insertBefore(node, n.childNodes[o]);\n    }\n\n    return firstNodeInserted;\n  }\n\n  function cloneSubtree(iterator) {\n    var partiallySelected;\n\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n      partiallySelected = iterator.isPartiallySelectedSubtree();\n      node = node.cloneNode(!partiallySelected);\n\n      if (partiallySelected) {\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(cloneSubtree(subIterator));\n        subIterator.detach(true);\n      }\n\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n\n      frag.appendChild(node);\n    }\n\n    return frag;\n  }\n\n  function iterateSubtree(rangeIterator, func, iteratorState) {\n    var it, n;\n    iteratorState = iteratorState || {\n      stop: false\n    };\n\n    for (var node, subRangeIterator; node = rangeIterator.next();) {\n      //log.debug(\"iterateSubtree, partially selected: \" + rangeIterator.isPartiallySelectedSubtree(), nodeToString(node));\n      if (rangeIterator.isPartiallySelectedSubtree()) {\n        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of the\n        // node selected by the Range.\n        if (func(node) === false) {\n          iteratorState.stop = true;\n          return;\n        } else {\n          subRangeIterator = rangeIterator.getSubtreeIterator();\n          iterateSubtree(subRangeIterator, func, iteratorState);\n          subRangeIterator.detach(true);\n\n          if (iteratorState.stop) {\n            return;\n          }\n        }\n      } else {\n        // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n        // descendant\n        it = dom.createIterator(node);\n\n        while (n = it.next()) {\n          if (func(n) === false) {\n            iteratorState.stop = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function deleteSubtree(iterator) {\n    var subIterator;\n\n    while (iterator.next()) {\n      if (iterator.isPartiallySelectedSubtree()) {\n        subIterator = iterator.getSubtreeIterator();\n        deleteSubtree(subIterator);\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n    }\n  }\n\n  function extractSubtree(iterator) {\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n      if (iterator.isPartiallySelectedSubtree()) {\n        node = node.cloneNode(false);\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(extractSubtree(subIterator));\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n\n      frag.appendChild(node);\n    }\n\n    return frag;\n  }\n\n  function getNodesInRange(range, nodeTypes, filter) {\n    //log.info(\"getNodesInRange, \" + nodeTypes.join(\",\"));\n    var filterNodeTypes = !!(nodeTypes && nodeTypes.length),\n        regex;\n    var filterExists = !!filter;\n\n    if (filterNodeTypes) {\n      regex = new RegExp(\"^(\" + nodeTypes.join(\"|\") + \")$\");\n    }\n\n    var nodes = [];\n    iterateSubtree(new RangeIterator(range, false), function (node) {\n      if ((!filterNodeTypes || regex.test(node.nodeType)) && (!filterExists || filter(node))) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n  function _inspect(range) {\n    var name = typeof range.getName == \"undefined\" ? \"Range\" : range.getName();\n    return \"[\" + name + \"(\" + dom.inspectNode(range.startContainer) + \":\" + range.startOffset + \", \" + dom.inspectNode(range.endContainer) + \":\" + range.endOffset + \")]\";\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n  /**\n   * @constructor\n   */\n\n\n  function RangeIterator(range, clonePartiallySelectedTextNodes) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!range.collapsed) {\n      this.sc = range.startContainer;\n      this.so = range.startOffset;\n      this.ec = range.endContainer;\n      this.eo = range.endOffset;\n      var root = range.commonAncestorContainer;\n\n      if (this.sc === this.ec && dom.isCharacterDataNode(this.sc)) {\n        this.isSingleCharacterDataNode = true;\n        this._first = this._last = this._next = this.sc;\n      } else {\n        this._first = this._next = this.sc === root && !dom.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : dom.getClosestAncestorIn(this.sc, root, true);\n        this._last = this.ec === root && !dom.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : dom.getClosestAncestorIn(this.ec, root, true);\n      }\n    }\n  }\n\n  RangeIterator.prototype = {\n    _current: null,\n    _next: null,\n    _first: null,\n    _last: null,\n    isSingleCharacterDataNode: false,\n    reset: function reset() {\n      this._current = null;\n      this._next = this._first;\n    },\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n    next: function next() {\n      // Move to next node\n      var current = this._current = this._next;\n\n      if (current) {\n        this._next = current !== this._last ? current.nextSibling : null; // Check for partially selected text nodes\n\n        if (dom.isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n          if (current === this.ec) {\n            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n          }\n\n          if (this._current === this.sc) {\n            (current = current.cloneNode(true)).deleteData(0, this.so);\n          }\n        }\n      }\n\n      return current;\n    },\n    remove: function remove() {\n      var current = this._current,\n          start,\n          end;\n\n      if (dom.isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n        start = current === this.sc ? this.so : 0;\n        end = current === this.ec ? this.eo : current.length;\n\n        if (start != end) {\n          current.deleteData(start, end - start);\n        }\n      } else {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n        } else {}\n      }\n    },\n    // Checks if the current node is partially selected\n    isPartiallySelectedSubtree: function isPartiallySelectedSubtree() {\n      var current = this._current;\n      return isNonTextPartiallySelected(current, this.range);\n    },\n    getSubtreeIterator: function getSubtreeIterator() {\n      var subRange;\n\n      if (this.isSingleCharacterDataNode) {\n        subRange = this.range.cloneRange();\n        subRange.collapse();\n      } else {\n        subRange = new Range(getRangeDocument(this.range));\n        var current = this._current;\n        var startContainer = current,\n            startOffset = 0,\n            endContainer = current,\n            endOffset = dom.getNodeLength(current);\n\n        if (dom.isAncestorOf(current, this.sc, true)) {\n          startContainer = this.sc;\n          startOffset = this.so;\n        }\n\n        if (dom.isAncestorOf(current, this.ec, true)) {\n          endContainer = this.ec;\n          endOffset = this.eo;\n        }\n\n        updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n      }\n\n      return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n    },\n    detach: function detach(detachRange) {\n      if (detachRange) {\n        this.range.detach();\n      }\n\n      this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n    }\n  };\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Exceptions\n\n  /**\n   * @constructor\n   */\n\n  function RangeException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = \"RangeException: \" + this.codeName;\n  }\n\n  RangeException.prototype = {\n    BAD_BOUNDARYPOINTS_ERR: 1,\n    INVALID_NODE_TYPE_ERR: 2\n  };\n\n  RangeException.prototype.toString = function () {\n    return this.message;\n  };\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /**\n   * Currently iterates through all nodes in the range on creation until I think of a decent way to do it\n   * TODO: Look into making this a proper iterator, not requiring preloading everything first\n   * @constructor\n   */\n\n\n  function RangeNodeIterator(range, nodeTypes, filter) {\n    this.nodes = getNodesInRange(range, nodeTypes, filter);\n    this._next = this.nodes[0];\n    this._position = 0;\n  }\n\n  RangeNodeIterator.prototype = {\n    _current: null,\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n    next: function next() {\n      this._current = this._next;\n      this._next = this.nodes[++this._position];\n      return this._current;\n    },\n    detach: function detach() {\n      this._current = this._next = this.nodes = null;\n    }\n  };\n  var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n  var rootContainerNodeTypes = [2, 9, 11];\n  var readonlyNodeTypes = [5, 6, 10, 12];\n  var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n  var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n  function createAncestorFinder(nodeTypes) {\n    return function (node, selfIsAncestor) {\n      var t,\n          n = selfIsAncestor ? node : node.parentNode;\n\n      while (n) {\n        t = n.nodeType;\n\n        if (dom.arrayContains(nodeTypes, t)) {\n          return n;\n        }\n\n        n = n.parentNode;\n      }\n\n      return null;\n    };\n  }\n\n  var getRootContainer = dom.getRootContainer;\n  var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\n  var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n  var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\n\n  function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n    if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n      throw new RangeException(\"INVALID_NODE_TYPE_ERR\");\n    }\n  }\n\n  function assertNotDetached(range) {\n    if (!range.startContainer) {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  }\n\n  function assertValidNodeType(node, invalidTypes) {\n    if (!dom.arrayContains(invalidTypes, node.nodeType)) {\n      throw new RangeException(\"INVALID_NODE_TYPE_ERR\");\n    }\n  }\n\n  function assertValidOffset(node, offset) {\n    if (offset < 0 || offset > (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n      throw new DOMException(\"INDEX_SIZE_ERR\");\n    }\n  }\n\n  function assertSameDocumentOrFragment(node1, node2) {\n    if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n      throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n    }\n  }\n\n  function assertNodeNotReadOnly(node) {\n    if (getReadonlyAncestor(node, true)) {\n      throw new DOMException(\"NO_MODIFICATION_ALLOWED_ERR\");\n    }\n  }\n\n  function assertNode(node, codeName) {\n    if (!node) {\n      throw new DOMException(codeName);\n    }\n  }\n\n  function isOrphan(node) {\n    return !dom.arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);\n  }\n\n  function isValidOffset(node, offset) {\n    return offset <= (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length);\n  }\n\n  function isRangeValid(range) {\n    var a = !!range.startContainer && !!range.endContainer;\n    var sorph = isOrphan(range.startContainer);\n    var eorph = isOrphan(range.endContainer);\n    var soff = isValidOffset(range.startContainer, range.startOffset);\n    var eoff = isValidOffset(range.endContainer, range.endOffset);\n    return !!range.startContainer && !!range.endContainer && !isOrphan(range.startContainer) && !isOrphan(range.endContainer) && isValidOffset(range.startContainer, range.startOffset) && isValidOffset(range.endContainer, range.endOffset);\n  }\n\n  function assertRangeValid(range) {\n    assertNotDetached(range);\n\n    if (!isRangeValid(range)) {\n      throw new Error(\"Range error: Range is no longer valid after DOM mutation (\" + range.inspect() + \")\");\n    }\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Test the browser's innerHTML support to decide how to implement createContextualFragment\n\n\n  var styleEl = document.createElement(\"style\");\n  var htmlParsingConforms = false;\n\n  try {\n    styleEl.innerHTML = \"<b>x</b>\";\n    htmlParsingConforms = styleEl.firstChild.nodeType == 3; // Opera incorrectly creates an element node\n  } catch (e) {// IE 6 and 7 throw\n  }\n\n  api.features.htmlParsingConforms = htmlParsingConforms;\n  var createContextualFragment = htmlParsingConforms ? // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See\n  // discussion and base code for this implementation at issue 67.\n  // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n  // Thanks to Aleks Williams.\n  function (fragmentStr) {\n    // \"Let node the context object's start's node.\"\n    var node = this.startContainer;\n    var doc = dom.getDocument(node); // \"If the context object's start's node is null, raise an INVALID_STATE_ERR\n    // exception and abort these steps.\"\n\n    if (!node) {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    } // \"Let element be as follows, depending on node's interface:\"\n    // Document, Document Fragment: null\n\n\n    var el = null; // \"Element: node\"\n\n    if (node.nodeType == 1) {\n      el = node; // \"Text, Comment: node's parentElement\"\n    } else if (dom.isCharacterDataNode(node)) {\n      el = dom.parentElement(node);\n    } // \"If either element is null or element's ownerDocument is an HTML document\n    // and element's local name is \"html\" and element's namespace is the HTML\n    // namespace\"\n\n\n    if (el === null || el.nodeName == \"HTML\" && dom.isHtmlNamespace(dom.getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {\n      // \"let element be a new Element with \"body\" as its local name and the HTML\n      // namespace as its namespace.\"\"\n      el = doc.createElement(\"body\");\n    } else {\n      el = el.cloneNode(false);\n    } // \"If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm.\"\n    // \"If the node's document is an XML document: Invoke the XML fragment parsing algorithm.\"\n    // \"In either case, the algorithm must be invoked with fragment as the input\n    // and element as the context element.\"\n\n\n    el.innerHTML = fragmentStr; // \"If this raises an exception, then abort these steps. Otherwise, let new\n    // children be the nodes returned.\"\n    // \"Let fragment be a new DocumentFragment.\"\n    // \"Append all new children to fragment.\"\n    // \"Return fragment.\"\n\n    return dom.fragmentFromNodeChildren(el);\n  } : // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n  // previous versions of Rangy used (with the exception of using a body element rather than a div)\n  function (fragmentStr) {\n    assertNotDetached(this);\n    var doc = getRangeDocument(this);\n    var el = doc.createElement(\"body\");\n    el.innerHTML = fragmentStr;\n    return dom.fragmentFromNodeChildren(el);\n  };\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  var rangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\", \"commonAncestorContainer\"];\n  var s2s = 0,\n      s2e = 1,\n      e2e = 2,\n      e2s = 3;\n  var n_b = 0,\n      n_a = 1,\n      n_b_a = 2,\n      n_i = 3;\n\n  function RangePrototype() {}\n\n  RangePrototype.prototype = {\n    attachListener: function attachListener(type, listener) {\n      this._listeners[type].push(listener);\n    },\n    compareBoundaryPoints: function compareBoundaryPoints(how, range) {\n      assertRangeValid(this);\n      assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n      var nodeA, offsetA, nodeB, offsetB;\n      var prefixA = how == e2s || how == s2s ? \"start\" : \"end\";\n      var prefixB = how == s2e || how == s2s ? \"start\" : \"end\";\n      nodeA = this[prefixA + \"Container\"];\n      offsetA = this[prefixA + \"Offset\"];\n      nodeB = range[prefixB + \"Container\"];\n      offsetB = range[prefixB + \"Offset\"];\n      return dom.comparePoints(nodeA, offsetA, nodeB, offsetB);\n    },\n    insertNode: function insertNode(node) {\n      assertRangeValid(this);\n      assertValidNodeType(node, insertableNodeTypes);\n      assertNodeNotReadOnly(this.startContainer);\n\n      if (dom.isAncestorOf(node, this.startContainer, true)) {\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      } // No check for whether the container of the start of the Range is of a type that does not allow\n      // children of the type of node: the browser's DOM implementation should do this for us when we attempt\n      // to add the node\n\n\n      var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      this.setStartBefore(firstNodeInserted);\n    },\n    cloneContents: function cloneContents() {\n      assertRangeValid(this);\n      var clone, frag;\n\n      if (this.collapsed) {\n        return getRangeDocument(this).createDocumentFragment();\n      } else {\n        if (this.startContainer === this.endContainer && dom.isCharacterDataNode(this.startContainer)) {\n          clone = this.startContainer.cloneNode(true);\n          clone.data = clone.data.slice(this.startOffset, this.endOffset);\n          frag = getRangeDocument(this).createDocumentFragment();\n          frag.appendChild(clone);\n          return frag;\n        } else {\n          var iterator = new RangeIterator(this, true);\n          clone = cloneSubtree(iterator);\n          iterator.detach();\n        }\n\n        return clone;\n      }\n    },\n    canSurroundContents: function canSurroundContents() {\n      assertRangeValid(this);\n      assertNodeNotReadOnly(this.startContainer);\n      assertNodeNotReadOnly(this.endContainer); // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n      // no non-text nodes.\n\n      var iterator = new RangeIterator(this, true);\n      var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n      iterator.detach();\n      return !boundariesInvalid;\n    },\n    surroundContents: function surroundContents(node) {\n      assertValidNodeType(node, surroundNodeTypes);\n\n      if (!this.canSurroundContents()) {\n        throw new RangeException(\"BAD_BOUNDARYPOINTS_ERR\");\n      } // Extract the contents\n\n\n      var content = this.extractContents(); // Clear the children of the node\n\n      if (node.hasChildNodes()) {\n        while (node.lastChild) {\n          node.removeChild(node.lastChild);\n        }\n      } // Insert the new node and add the extracted contents\n\n\n      insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      node.appendChild(content);\n      this.selectNode(node);\n    },\n    cloneRange: function cloneRange() {\n      assertRangeValid(this);\n      var range = new Range(getRangeDocument(this));\n      var i = rangeProperties.length,\n          prop;\n\n      while (i--) {\n        prop = rangeProperties[i];\n        range[prop] = this[prop];\n      }\n\n      return range;\n    },\n    toString: function toString() {\n      assertRangeValid(this);\n      var sc = this.startContainer;\n\n      if (sc === this.endContainer && dom.isCharacterDataNode(sc)) {\n        return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : \"\";\n      } else {\n        var textBits = [],\n            iterator = new RangeIterator(this, true);\n        iterateSubtree(iterator, function (node) {\n          // Accept only text or CDATA nodes, not comments\n          if (node.nodeType == 3 || node.nodeType == 4) {\n            textBits.push(node.data);\n          }\n        });\n        iterator.detach();\n        return textBits.join(\"\");\n      }\n    },\n    // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n    // been removed from Mozilla.\n    compareNode: function compareNode(node) {\n      assertRangeValid(this);\n      var parent = node.parentNode;\n      var nodeIndex = dom.getNodeIndex(node);\n\n      if (!parent) {\n        throw new DOMException(\"NOT_FOUND_ERR\");\n      }\n\n      var startComparison = this.comparePoint(parent, nodeIndex),\n          endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n      if (startComparison < 0) {\n        // Node starts before\n        return endComparison > 0 ? n_b_a : n_b;\n      } else {\n        return endComparison > 0 ? n_a : n_i;\n      }\n    },\n    comparePoint: function comparePoint(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      if (dom.comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n        return -1;\n      } else if (dom.comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n        return 1;\n      }\n\n      return 0;\n    },\n    createContextualFragment: createContextualFragment,\n    toHtml: function toHtml() {\n      assertRangeValid(this);\n      var container = getRangeDocument(this).createElement(\"div\");\n      container.appendChild(this.cloneContents());\n      return container.innerHTML;\n    },\n    // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n    // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n    intersectsNode: function intersectsNode(node, touchingIsIntersecting) {\n      assertRangeValid(this);\n      assertNode(node, \"NOT_FOUND_ERR\");\n\n      if (dom.getDocument(node) !== getRangeDocument(this)) {\n        return false;\n      }\n\n      var parent = node.parentNode,\n          offset = dom.getNodeIndex(node);\n      assertNode(parent, \"NOT_FOUND_ERR\");\n      var startComparison = dom.comparePoints(parent, offset, this.endContainer, this.endOffset),\n          endComparison = dom.comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n    isPointInRange: function isPointInRange(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n      assertSameDocumentOrFragment(node, this.startContainer);\n      return dom.comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && dom.comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;\n    },\n    // The methods below are non-standard and invented by me.\n    // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n    intersectsRange: function intersectsRange(range, touchingIsIntersecting) {\n      assertRangeValid(this);\n\n      if (getRangeDocument(range) != getRangeDocument(this)) {\n        throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n      }\n\n      var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.endContainer, range.endOffset),\n          endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.startContainer, range.startOffset);\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n    intersection: function intersection(range) {\n      if (this.intersectsRange(range)) {\n        var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n            endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n        var intersectionRange = this.cloneRange();\n\n        if (startComparison == -1) {\n          intersectionRange.setStart(range.startContainer, range.startOffset);\n        }\n\n        if (endComparison == 1) {\n          intersectionRange.setEnd(range.endContainer, range.endOffset);\n        }\n\n        return intersectionRange;\n      }\n\n      return null;\n    },\n    union: function union(range) {\n      if (this.intersectsRange(range, true)) {\n        var unionRange = this.cloneRange();\n\n        if (dom.comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n          unionRange.setStart(range.startContainer, range.startOffset);\n        }\n\n        if (dom.comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n          unionRange.setEnd(range.endContainer, range.endOffset);\n        }\n\n        return unionRange;\n      } else {\n        throw new RangeException(\"Ranges do not intersect\");\n      }\n    },\n    containsNode: function containsNode(node, allowPartial) {\n      if (allowPartial) {\n        return this.intersectsNode(node, false);\n      } else {\n        return this.compareNode(node) == n_i;\n      }\n    },\n    containsNodeContents: function containsNodeContents(node) {\n      return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, dom.getNodeLength(node)) <= 0;\n    },\n    containsRange: function containsRange(range) {\n      return this.intersection(range).equals(range);\n    },\n    containsNodeText: function containsNodeText(node) {\n      var nodeRange = this.cloneRange();\n      nodeRange.selectNode(node);\n      var textNodes = nodeRange.getNodes([3]);\n\n      if (textNodes.length > 0) {\n        nodeRange.setStart(textNodes[0], 0);\n        var lastTextNode = textNodes.pop();\n        nodeRange.setEnd(lastTextNode, lastTextNode.length);\n        var contains = this.containsRange(nodeRange);\n        nodeRange.detach();\n        return contains;\n      } else {\n        return this.containsNodeContents(node);\n      }\n    },\n    createNodeIterator: function createNodeIterator(nodeTypes, filter) {\n      assertRangeValid(this);\n      return new RangeNodeIterator(this, nodeTypes, filter);\n    },\n    getNodes: function getNodes(nodeTypes, filter) {\n      assertRangeValid(this);\n      return getNodesInRange(this, nodeTypes, filter);\n    },\n    getDocument: function getDocument() {\n      return getRangeDocument(this);\n    },\n    collapseBefore: function collapseBefore(node) {\n      assertNotDetached(this);\n      this.setEndBefore(node);\n      this.collapse(false);\n    },\n    collapseAfter: function collapseAfter(node) {\n      assertNotDetached(this);\n      this.setStartAfter(node);\n      this.collapse(true);\n    },\n    getName: function getName() {\n      return \"DomRange\";\n    },\n    equals: function equals(range) {\n      return Range.rangesEqual(this, range);\n    },\n    isValid: function isValid() {\n      return isRangeValid(this);\n    },\n    inspect: function inspect() {\n      return _inspect(this);\n    }\n  };\n\n  function copyComparisonConstantsToObject(obj) {\n    obj.START_TO_START = s2s;\n    obj.START_TO_END = s2e;\n    obj.END_TO_END = e2e;\n    obj.END_TO_START = e2s;\n    obj.NODE_BEFORE = n_b;\n    obj.NODE_AFTER = n_a;\n    obj.NODE_BEFORE_AND_AFTER = n_b_a;\n    obj.NODE_INSIDE = n_i;\n  }\n\n  function copyComparisonConstants(constructor) {\n    copyComparisonConstantsToObject(constructor);\n    copyComparisonConstantsToObject(constructor.prototype);\n  }\n\n  function createRangeContentRemover(remover, boundaryUpdater) {\n    return function () {\n      assertRangeValid(this);\n      var sc = this.startContainer,\n          so = this.startOffset,\n          root = this.commonAncestorContainer;\n      var iterator = new RangeIterator(this, true); // Work out where to position the range after content removal\n\n      var node, boundary;\n\n      if (sc !== root) {\n        node = dom.getClosestAncestorIn(sc, root, true);\n        boundary = getBoundaryAfterNode(node);\n        sc = boundary.node;\n        so = boundary.offset;\n      } // Check none of the range is read-only\n\n\n      iterateSubtree(iterator, assertNodeNotReadOnly);\n      iterator.reset(); // Remove the content\n\n      var returnValue = remover(iterator);\n      iterator.detach(); // Move to the new position\n\n      boundaryUpdater(this, sc, so, sc, so);\n      return returnValue;\n    };\n  }\n\n  function createPrototypeRange(constructor, boundaryUpdater, detacher) {\n    function createBeforeAfterNodeSetter(isBefore, isStart) {\n      return function (node) {\n        assertNotDetached(this);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n        assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n        var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n        (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n      };\n    }\n\n    function setRangeStart(range, node, offset) {\n      var ec = range.endContainer,\n          eo = range.endOffset;\n\n      if (node !== range.startContainer || offset !== range.startOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(ec) || dom.comparePoints(node, offset, ec, eo) == 1) {\n          ec = node;\n          eo = offset;\n        }\n\n        boundaryUpdater(range, node, offset, ec, eo);\n      }\n    }\n\n    function setRangeEnd(range, node, offset) {\n      var sc = range.startContainer,\n          so = range.startOffset;\n\n      if (node !== range.endContainer || offset !== range.endOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(sc) || dom.comparePoints(node, offset, sc, so) == -1) {\n          sc = node;\n          so = offset;\n        }\n\n        boundaryUpdater(range, sc, so, node, offset);\n      }\n    }\n\n    function setRangeStartAndEnd(range, node, offset) {\n      if (node !== range.startContainer || offset !== range.startOffset || node !== range.endContainer || offset !== range.endOffset) {\n        boundaryUpdater(range, node, offset, node, offset);\n      }\n    }\n\n    constructor.prototype = new RangePrototype();\n    api.util.extend(constructor.prototype, {\n      setStart: function setStart(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n        setRangeStart(this, node, offset);\n      },\n      setEnd: function setEnd(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n        setRangeEnd(this, node, offset);\n      },\n      setStartBefore: createBeforeAfterNodeSetter(true, true),\n      setStartAfter: createBeforeAfterNodeSetter(false, true),\n      setEndBefore: createBeforeAfterNodeSetter(true, false),\n      setEndAfter: createBeforeAfterNodeSetter(false, false),\n      collapse: function collapse(isStart) {\n        assertRangeValid(this);\n\n        if (isStart) {\n          boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n        } else {\n          boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n        }\n      },\n      selectNodeContents: function selectNodeContents(node) {\n        // This doesn't seem well specified: the spec talks only about selecting the node's contents, which\n        // could be taken to mean only its children. However, browsers implement this the same as selectNode for\n        // text nodes, so I shall do likewise\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        boundaryUpdater(this, node, 0, node, dom.getNodeLength(node));\n      },\n      selectNode: function selectNode(node) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, false);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n        var start = getBoundaryBeforeNode(node),\n            end = getBoundaryAfterNode(node);\n        boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n      },\n      extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n      deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n      canSurroundContents: function canSurroundContents() {\n        assertRangeValid(this);\n        assertNodeNotReadOnly(this.startContainer);\n        assertNodeNotReadOnly(this.endContainer); // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n        // no non-text nodes.\n\n        var iterator = new RangeIterator(this, true);\n        var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n        iterator.detach();\n        return !boundariesInvalid;\n      },\n      detach: function detach() {\n        detacher(this);\n      },\n      splitBoundaries: function splitBoundaries() {\n        assertRangeValid(this);\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n        var startEndSame = sc === ec;\n\n        if (dom.isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n          dom.splitDataNode(ec, eo);\n        }\n\n        if (dom.isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n          sc = dom.splitDataNode(sc, so);\n\n          if (startEndSame) {\n            eo -= so;\n            ec = sc;\n          } else if (ec == sc.parentNode && eo >= dom.getNodeIndex(sc)) {\n            eo++;\n          }\n\n          so = 0;\n        }\n\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n      normalizeBoundaries: function normalizeBoundaries() {\n        assertRangeValid(this);\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n\n        var mergeForward = function mergeForward(node) {\n          var sibling = node.nextSibling;\n\n          if (sibling && sibling.nodeType == node.nodeType) {\n            ec = node;\n            eo = node.length;\n            node.appendData(sibling.data);\n            sibling.parentNode.removeChild(sibling);\n          }\n        };\n\n        var mergeBackward = function mergeBackward(node) {\n          var sibling = node.previousSibling;\n\n          if (sibling && sibling.nodeType == node.nodeType) {\n            sc = node;\n            var nodeLength = node.length;\n            so = sibling.length;\n            node.insertData(0, sibling.data);\n            sibling.parentNode.removeChild(sibling);\n\n            if (sc == ec) {\n              eo += so;\n              ec = sc;\n            } else if (ec == node.parentNode) {\n              var nodeIndex = dom.getNodeIndex(node);\n\n              if (eo == nodeIndex) {\n                ec = node;\n                eo = nodeLength;\n              } else if (eo > nodeIndex) {\n                eo--;\n              }\n            }\n          }\n        };\n\n        var normalizeStart = true;\n\n        if (dom.isCharacterDataNode(ec)) {\n          if (ec.length == eo) {\n            mergeForward(ec);\n          }\n        } else {\n          if (eo > 0) {\n            var endNode = ec.childNodes[eo - 1];\n\n            if (endNode && dom.isCharacterDataNode(endNode)) {\n              mergeForward(endNode);\n            }\n          }\n\n          normalizeStart = !this.collapsed;\n        }\n\n        if (normalizeStart) {\n          if (dom.isCharacterDataNode(sc)) {\n            if (so == 0) {\n              mergeBackward(sc);\n            }\n          } else {\n            if (so < sc.childNodes.length) {\n              var startNode = sc.childNodes[so];\n\n              if (startNode && dom.isCharacterDataNode(startNode)) {\n                mergeBackward(startNode);\n              }\n            }\n          }\n        } else {\n          sc = ec;\n          so = eo;\n        }\n\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n      collapseToPoint: function collapseToPoint(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n        setRangeStartAndEnd(this, node, offset);\n      }\n    });\n    copyComparisonConstants(constructor);\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n  // Updates commonAncestorContainer and collapsed after boundary change\n\n\n  function updateCollapsedAndCommonAncestor(range) {\n    range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n    range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n  }\n\n  function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n    var startMoved = range.startContainer !== startContainer || range.startOffset !== startOffset;\n    var endMoved = range.endContainer !== endContainer || range.endOffset !== endOffset;\n    range.startContainer = startContainer;\n    range.startOffset = startOffset;\n    range.endContainer = endContainer;\n    range.endOffset = endOffset;\n    updateCollapsedAndCommonAncestor(range);\n    dispatchEvent(range, \"boundarychange\", {\n      startMoved: startMoved,\n      endMoved: endMoved\n    });\n  }\n\n  function detach(range) {\n    assertNotDetached(range);\n    range.startContainer = range.startOffset = range.endContainer = range.endOffset = null;\n    range.collapsed = range.commonAncestorContainer = null;\n    dispatchEvent(range, \"detach\", null);\n    range._listeners = null;\n  }\n  /**\n   * @constructor\n   */\n\n\n  function Range(doc) {\n    this.startContainer = doc;\n    this.startOffset = 0;\n    this.endContainer = doc;\n    this.endOffset = 0;\n    this._listeners = {\n      boundarychange: [],\n      detach: []\n    };\n    updateCollapsedAndCommonAncestor(this);\n  }\n\n  createPrototypeRange(Range, updateBoundaries, detach);\n  api.rangePrototype = RangePrototype.prototype;\n  Range.rangeProperties = rangeProperties;\n  Range.RangeIterator = RangeIterator;\n  Range.copyComparisonConstants = copyComparisonConstants;\n  Range.createPrototypeRange = createPrototypeRange;\n  Range.inspect = _inspect;\n  Range.getRangeDocument = getRangeDocument;\n\n  Range.rangesEqual = function (r1, r2) {\n    return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;\n  };\n\n  api.DomRange = Range;\n  api.RangeException = RangeException;\n});\nrangy.createModule(\"WrappedRange\", function (api, module) {\n  api.requireModules([\"DomUtil\", \"DomRange\"]);\n  /**\n   * @constructor\n   */\n\n  var WrappedRange;\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DomRange = api.DomRange;\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /*\n  This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()\n  method. For example, in the following (where pipes denote the selection boundaries):\n   <ul id=\"ul\"><li id=\"a\">| a </li><li id=\"b\"> b |</li></ul>\n   var range = document.selection.createRange();\n  alert(range.parentElement().id); // Should alert \"ul\" but alerts \"b\"\n   This method returns the common ancestor node of the following:\n  - the parentElement() of the textRange\n  - the parentElement() of the textRange after calling collapse(true)\n  - the parentElement() of the textRange after calling collapse(false)\n   */\n\n  function getTextRangeContainerElement(textRange) {\n    var parentEl = textRange.parentElement();\n    var range = textRange.duplicate();\n    range.collapse(true);\n    var startEl = range.parentElement();\n    range = textRange.duplicate();\n    range.collapse(false);\n    var endEl = range.parentElement();\n    var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);\n    return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n  }\n\n  function textRangeIsCollapsed(textRange) {\n    return textRange.compareEndPoints(\"StartToEnd\", textRange) == 0;\n  } // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started out as\n  // an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/) but has\n  // grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange bugs, handling\n  // for inputs and images, plus optimizations.\n\n\n  function getTextRangeBoundaryPosition(textRange, wholeRangeContainerElement, isStart, isCollapsed) {\n    var workingRange = textRange.duplicate();\n    workingRange.collapse(isStart);\n    var containerElement = workingRange.parentElement(); // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so\n    // check for that\n    // TODO: Find out when. Workaround for wholeRangeContainerElement may break this\n\n    if (!dom.isAncestorOf(wholeRangeContainerElement, containerElement, true)) {\n      containerElement = wholeRangeContainerElement;\n    } // Deal with nodes that cannot \"contain rich HTML markup\". In practice, this means form inputs, images and\n    // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n\n\n    if (!containerElement.canHaveHTML) {\n      return new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n    }\n\n    var workingNode = dom.getDocument(containerElement).createElement(\"span\");\n    var comparison,\n        workingComparisonType = isStart ? \"StartToStart\" : \"StartToEnd\";\n    var previousNode, nextNode, boundaryPosition, boundaryNode; // Move the working range through the container's children, starting at the end and working backwards, until the\n    // working range reaches or goes past the boundary we're interested in\n\n    do {\n      containerElement.insertBefore(workingNode, workingNode.previousSibling);\n      workingRange.moveToElementText(workingNode);\n    } while ((comparison = workingRange.compareEndPoints(workingComparisonType, textRange)) > 0 && workingNode.previousSibling); // We've now reached or gone past the boundary of the text range we're interested in\n    // so have identified the node we want\n\n\n    boundaryNode = workingNode.nextSibling;\n\n    if (comparison == -1 && boundaryNode && dom.isCharacterDataNode(boundaryNode)) {\n      // This is a character data node (text, comment, cdata). The working range is collapsed at the start of the\n      // node containing the text range's boundary, so we move the end of the working range to the boundary point\n      // and measure the length of its text to get the boundary's offset within the node.\n      workingRange.setEndPoint(isStart ? \"EndToStart\" : \"EndToEnd\", textRange);\n      var offset;\n\n      if (/[\\r\\n]/.test(boundaryNode.data)) {\n        /*\n        For the particular case of a boundary within a text node containing line breaks (within a <pre> element,\n        for example), we need a slightly complicated approach to get the boundary's offset in IE. The facts:\n         - Each line break is represented as \\r in the text node's data/nodeValue properties\n        - Each line break is represented as \\r\\n in the TextRange's 'text' property\n        - The 'text' property of the TextRange does not contain trailing line breaks\n         To get round the problem presented by the final fact above, we can use the fact that TextRange's\n        moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily\n        the same as the number of characters it was instructed to move. The simplest approach is to use this to\n        store the characters moved when moving both the start and end of the range to the start of the document\n        body and subtracting the start offset from the end offset (the \"move-negative-gazillion\" method).\n        However, this is extremely slow when the document is large and the range is near the end of it. Clearly\n        doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same\n        problem.\n         Another approach that works is to use moveStart() to move the start boundary of the range up to the end\n        boundary one character at a time and incrementing a counter with the value returned by the moveStart()\n        call. However, the check for whether the start boundary has reached the end boundary is expensive, so\n        this method is slow (although unlike \"move-negative-gazillion\" is largely unaffected by the location of\n        the range within the document).\n         The method below is a hybrid of the two methods above. It uses the fact that a string containing the\n        TextRange's 'text' property with each \\r\\n converted to a single \\r character cannot be longer than the\n        text of the TextRange, so the start of the range is moved that length initially and then a character at\n        a time to make up for any trailing line breaks not contained in the 'text' property. This has good\n        performance in most situations compared to the previous two methods.\n        */\n        var tempRange = workingRange.duplicate();\n        var rangeLength = tempRange.text.replace(/\\r\\n/g, \"\\r\").length;\n        offset = tempRange.moveStart(\"character\", rangeLength);\n\n        while ((comparison = tempRange.compareEndPoints(\"StartToEnd\", tempRange)) == -1) {\n          offset++;\n          tempRange.moveStart(\"character\", 1);\n        }\n      } else {\n        offset = workingRange.text.length;\n      }\n\n      boundaryPosition = new DomPosition(boundaryNode, offset);\n    } else {\n      // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n      // a position within that, and likewise for a start boundary preceding a character data node\n      previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n      nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n\n      if (nextNode && dom.isCharacterDataNode(nextNode)) {\n        boundaryPosition = new DomPosition(nextNode, 0);\n      } else if (previousNode && dom.isCharacterDataNode(previousNode)) {\n        boundaryPosition = new DomPosition(previousNode, previousNode.length);\n      } else {\n        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n      }\n    } // Clean up\n\n\n    workingNode.parentNode.removeChild(workingNode);\n    return boundaryPosition;\n  } // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that node.\n  // This function started out as an optimized version of code found in Tim Cameron Ryan's IERange\n  // (http://code.google.com/p/ierange/)\n\n\n  function createBoundaryTextRange(boundaryPosition, isStart) {\n    var boundaryNode,\n        boundaryParent,\n        boundaryOffset = boundaryPosition.offset;\n    var doc = dom.getDocument(boundaryPosition.node);\n    var workingNode,\n        childNodes,\n        workingRange = doc.body.createTextRange();\n    var nodeIsDataNode = dom.isCharacterDataNode(boundaryPosition.node);\n\n    if (nodeIsDataNode) {\n      boundaryNode = boundaryPosition.node;\n      boundaryParent = boundaryNode.parentNode;\n    } else {\n      childNodes = boundaryPosition.node.childNodes;\n      boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;\n      boundaryParent = boundaryPosition.node;\n    } // Position the range immediately before the node containing the boundary\n\n\n    workingNode = doc.createElement(\"span\"); // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within the\n    // element rather than immediately before or after it, which is what we want\n\n    workingNode.innerHTML = \"&#feff;\"; // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n    // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n\n    if (boundaryNode) {\n      boundaryParent.insertBefore(workingNode, boundaryNode);\n    } else {\n      boundaryParent.appendChild(workingNode);\n    }\n\n    workingRange.moveToElementText(workingNode);\n    workingRange.collapse(!isStart); // Clean up\n\n    boundaryParent.removeChild(workingNode); // Move the working range to the text offset, if required\n\n    if (nodeIsDataNode) {\n      workingRange[isStart ? \"moveStart\" : \"moveEnd\"](\"character\", boundaryOffset);\n    }\n\n    return workingRange;\n  }\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n\n  if (api.features.implementsDomRange && (!api.features.implementsTextRange || !api.config.preferTextRange)) {\n    // This is a wrapper around the browser's native DOM Range. It has two aims:\n    // - Provide workarounds for specific browser bugs\n    // - provide convenient extensions, which are inherited from Rangy's DomRange\n    (function () {\n      var rangeProto;\n      var rangeProperties = DomRange.rangeProperties;\n      var canSetRangeStartAfterEnd;\n\n      function updateRangeProperties(range) {\n        var i = rangeProperties.length,\n            prop;\n\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = range.nativeRange[prop];\n        }\n      }\n\n      function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n        var startMoved = range.startContainer !== startContainer || range.startOffset != startOffset;\n        var endMoved = range.endContainer !== endContainer || range.endOffset != endOffset; // Always set both boundaries for the benefit of IE9 (see issue 35)\n\n        if (startMoved || endMoved) {\n          range.setEnd(endContainer, endOffset);\n          range.setStart(startContainer, startOffset);\n        }\n      }\n\n      function detach(range) {\n        range.nativeRange.detach();\n        range.detached = true;\n        var i = rangeProperties.length,\n            prop;\n\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = null;\n        }\n      }\n\n      var createBeforeAfterNodeSetter;\n\n      WrappedRange = function WrappedRange(range) {\n        if (!range) {\n          throw new Error(\"Range must be specified\");\n        }\n\n        this.nativeRange = range;\n        updateRangeProperties(this);\n      };\n\n      DomRange.createPrototypeRange(WrappedRange, updateNativeRange, detach);\n      rangeProto = WrappedRange.prototype;\n\n      rangeProto.selectNode = function (node) {\n        this.nativeRange.selectNode(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.deleteContents = function () {\n        this.nativeRange.deleteContents();\n        updateRangeProperties(this);\n      };\n\n      rangeProto.extractContents = function () {\n        var frag = this.nativeRange.extractContents();\n        updateRangeProperties(this);\n        return frag;\n      };\n\n      rangeProto.cloneContents = function () {\n        return this.nativeRange.cloneContents();\n      }; // TODO: Until I can find a way to programmatically trigger the Firefox bug (apparently long-standing, still\n      // present in 3.6.8) that throws \"Index or size is negative or greater than the allowed amount\" for\n      // insertNode in some circumstances, all browsers will have to use the Rangy's own implementation of\n      // insertNode, which works but is almost certainly slower than the native implementation.\n\n      /*\n                  rangeProto.insertNode = function(node) {\n                      this.nativeRange.insertNode(node);\n                      updateRangeProperties(this);\n                  };\n      */\n\n\n      rangeProto.surroundContents = function (node) {\n        this.nativeRange.surroundContents(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.collapse = function (isStart) {\n        this.nativeRange.collapse(isStart);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.cloneRange = function () {\n        return new WrappedRange(this.nativeRange.cloneRange());\n      };\n\n      rangeProto.refresh = function () {\n        updateRangeProperties(this);\n      };\n\n      rangeProto.toString = function () {\n        return this.nativeRange.toString();\n      }; // Create test range and node for feature detection\n\n\n      var testTextNode = document.createTextNode(\"test\");\n      dom.getBody(document).appendChild(testTextNode);\n      var range = document.createRange();\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n      // correct for it\n\n      range.setStart(testTextNode, 0);\n      range.setEnd(testTextNode, 0);\n\n      try {\n        range.setStart(testTextNode, 1);\n        canSetRangeStartAfterEnd = true;\n\n        rangeProto.setStart = function (node, offset) {\n          this.nativeRange.setStart(node, offset);\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          this.nativeRange.setEnd(node, offset);\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name) {\n          return function (node) {\n            this.nativeRange[name](node);\n            updateRangeProperties(this);\n          };\n        };\n      } catch (ex) {\n        canSetRangeStartAfterEnd = false;\n\n        rangeProto.setStart = function (node, offset) {\n          try {\n            this.nativeRange.setStart(node, offset);\n          } catch (ex) {\n            this.nativeRange.setEnd(node, offset);\n            this.nativeRange.setStart(node, offset);\n          }\n\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          try {\n            this.nativeRange.setEnd(node, offset);\n          } catch (ex) {\n            this.nativeRange.setStart(node, offset);\n            this.nativeRange.setEnd(node, offset);\n          }\n\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name, oppositeName) {\n          return function (node) {\n            try {\n              this.nativeRange[name](node);\n            } catch (ex) {\n              this.nativeRange[oppositeName](node);\n              this.nativeRange[name](node);\n            }\n\n            updateRangeProperties(this);\n          };\n        };\n      }\n\n      rangeProto.setStartBefore = createBeforeAfterNodeSetter(\"setStartBefore\", \"setEndBefore\");\n      rangeProto.setStartAfter = createBeforeAfterNodeSetter(\"setStartAfter\", \"setEndAfter\");\n      rangeProto.setEndBefore = createBeforeAfterNodeSetter(\"setEndBefore\", \"setStartBefore\");\n      rangeProto.setEndAfter = createBeforeAfterNodeSetter(\"setEndAfter\", \"setStartAfter\");\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for and correct Firefox 2 behaviour with selectNodeContents on text nodes: it collapses the range to\n      // the 0th character of the text node\n\n      range.selectNodeContents(testTextNode);\n\n      if (range.startContainer == testTextNode && range.endContainer == testTextNode && range.startOffset == 0 && range.endOffset == testTextNode.length) {\n        rangeProto.selectNodeContents = function (node) {\n          this.nativeRange.selectNodeContents(node);\n          updateRangeProperties(this);\n        };\n      } else {\n        rangeProto.selectNodeContents = function (node) {\n          this.setStart(node, 0);\n          this.setEnd(node, DomRange.getEndOffset(node));\n        };\n      }\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for WebKit bug that has the beahviour of compareBoundaryPoints round the wrong way for constants\n      // START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n\n      range.selectNodeContents(testTextNode);\n      range.setEnd(testTextNode, 3);\n      var range2 = document.createRange();\n      range2.selectNodeContents(testTextNode);\n      range2.setEnd(testTextNode, 4);\n      range2.setStart(testTextNode, 2);\n\n      if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 & range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n        // This is the wrong way round, so correct for it\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          range = range.nativeRange || range;\n\n          if (type == range.START_TO_END) {\n            type = range.END_TO_START;\n          } else if (type == range.END_TO_START) {\n            type = range.START_TO_END;\n          }\n\n          return this.nativeRange.compareBoundaryPoints(type, range);\n        };\n      } else {\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n        };\n      }\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Test for existence of createContextualFragment and delegate to it if it exists\n\n\n      if (api.util.isHostMethod(range, \"createContextualFragment\")) {\n        rangeProto.createContextualFragment = function (fragmentStr) {\n          return this.nativeRange.createContextualFragment(fragmentStr);\n        };\n      }\n      /*--------------------------------------------------------------------------------------------------------*/\n      // Clean up\n\n\n      dom.getBody(document).removeChild(testTextNode);\n      range.detach();\n      range2.detach();\n    })();\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.createRange();\n    };\n  } else if (api.features.implementsTextRange) {\n    // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a\n    // prototype\n    WrappedRange = function WrappedRange(textRange) {\n      this.textRange = textRange;\n      this.refresh();\n    };\n\n    WrappedRange.prototype = new DomRange(document);\n\n    WrappedRange.prototype.refresh = function () {\n      var start, end; // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n\n      var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n      if (textRangeIsCollapsed(this.textRange)) {\n        end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true);\n      } else {\n        start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n        end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false);\n      }\n\n      this.setStart(start.node, start.offset);\n      this.setEnd(end.node, end.offset);\n    };\n\n    DomRange.copyComparisonConstants(WrappedRange); // Add WrappedRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n\n    var globalObj = function () {\n      return this;\n    }();\n\n    if (typeof globalObj.Range == \"undefined\") {\n      globalObj.Range = WrappedRange;\n    }\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.body.createTextRange();\n    };\n  }\n\n  if (api.features.implementsTextRange) {\n    WrappedRange.rangeToTextRange = function (range) {\n      if (range.collapsed) {\n        var tr = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n        return tr; //return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n      } else {\n        var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n        var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n        var textRange = dom.getDocument(range.startContainer).body.createTextRange();\n        textRange.setEndPoint(\"StartToStart\", startRange);\n        textRange.setEndPoint(\"EndToEnd\", endRange);\n        return textRange;\n      }\n    };\n  }\n\n  WrappedRange.prototype.getName = function () {\n    return \"WrappedRange\";\n  };\n\n  api.WrappedRange = WrappedRange;\n\n  api.createRange = function (doc) {\n    doc = doc || document;\n    return new WrappedRange(api.createNativeRange(doc));\n  };\n\n  api.createRangyRange = function (doc) {\n    doc = doc || document;\n    return new DomRange(doc);\n  };\n\n  api.createIframeRange = function (iframeEl) {\n    return api.createRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.createIframeRangyRange = function (iframeEl) {\n    return api.createRangyRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    var doc = win.document;\n\n    if (typeof doc.createRange == \"undefined\") {\n      doc.createRange = function () {\n        return api.createRange(this);\n      };\n    }\n\n    doc = win = null;\n  });\n});\nrangy.createModule(\"WrappedSelection\", function (api, module) {\n  // This will create a selection object wrapper that follows the Selection object found in the WHATWG draft DOM Range\n  // spec (http://html5.org/specs/dom-range.html)\n  api.requireModules([\"DomUtil\", \"DomRange\", \"WrappedRange\"]);\n  api.config.checkSelectionRanges = true;\n  var BOOLEAN = \"boolean\",\n      windowPropertyName = \"_rangySelection\",\n      dom = api.dom,\n      util = api.util,\n      DomRange = api.DomRange,\n      WrappedRange = api.WrappedRange,\n      DOMException = api.DOMException,\n      DomPosition = dom.DomPosition,\n      getSelection,\n      selectionIsCollapsed,\n      CONTROL = \"Control\";\n\n  function getWinSelection(winParam) {\n    return (winParam || window).getSelection();\n  }\n\n  function getDocSelection(winParam) {\n    return (winParam || window).document.selection;\n  } // Test for the Range/TextRange and Selection features required\n  // Test for ability to retrieve selection\n\n\n  var implementsWinGetSelection = api.util.isHostMethod(window, \"getSelection\"),\n      implementsDocSelection = api.util.isHostObject(document, \"selection\");\n  var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n  if (useDocumentSelection) {\n    getSelection = getDocSelection;\n\n    api.isSelectionValid = function (winParam) {\n      var doc = (winParam || window).document,\n          nativeSel = doc.selection; // Check whether the selection TextRange is actually contained within the correct document\n\n      return nativeSel.type != \"None\" || dom.getDocument(nativeSel.createRange().parentElement()) == doc;\n    };\n  } else if (implementsWinGetSelection) {\n    getSelection = getWinSelection;\n\n    api.isSelectionValid = function () {\n      return true;\n    };\n  } else {\n    module.fail(\"Neither document.selection or window.getSelection() detected.\");\n  }\n\n  api.getNativeSelection = getSelection;\n  var testSelection = getSelection();\n  var testRange = api.createNativeRange(document);\n  var body = dom.getBody(document); // Obtaining a range from a selection\n\n  var selectionHasAnchorAndFocus = util.areHostObjects(testSelection,  true && util.areHostProperties(testSelection, [\"anchorOffset\", \"focusOffset\"]));\n  api.features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus; // Test for existence of native selection extend() method\n\n  var selectionHasExtend = util.isHostMethod(testSelection, \"extend\");\n  api.features.selectionHasExtend = selectionHasExtend; // Test if rangeCount exists\n\n  var selectionHasRangeCount = typeof testSelection.rangeCount == \"number\";\n  api.features.selectionHasRangeCount = selectionHasRangeCount;\n  var selectionSupportsMultipleRanges = false;\n  var collapsedNonEditableSelectionsSupported = true;\n\n  if (util.areHostMethods(testSelection, [\"addRange\", \"getRangeAt\", \"removeAllRanges\"]) && typeof testSelection.rangeCount == \"number\" && api.features.implementsDomRange) {\n    (function () {\n      var iframe = document.createElement(\"iframe\");\n      iframe.frameBorder = 0;\n      iframe.style.position = \"absolute\";\n      iframe.style.left = \"-10000px\";\n      body.appendChild(iframe);\n      var iframeDoc = dom.getIframeDocument(iframe);\n      iframeDoc.open();\n      iframeDoc.write(\"<html><head></head><body>12</body></html>\");\n      iframeDoc.close();\n      var sel = dom.getIframeWindow(iframe).getSelection();\n      var docEl = iframeDoc.documentElement;\n      var iframeBody = docEl.lastChild,\n          textNode = iframeBody.firstChild; // Test whether the native selection will allow a collapsed selection within a non-editable element\n\n      var r1 = iframeDoc.createRange();\n      r1.setStart(textNode, 1);\n      r1.collapse(true);\n      sel.addRange(r1);\n      collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;\n      sel.removeAllRanges(); // Test whether the native selection is capable of supporting multiple ranges\n\n      var r2 = r1.cloneRange();\n      r1.setStart(textNode, 0);\n      r2.setEnd(textNode, 2);\n      sel.addRange(r1);\n      sel.addRange(r2);\n      selectionSupportsMultipleRanges = sel.rangeCount == 2; // Clean up\n\n      r1.detach();\n      r2.detach();\n      body.removeChild(iframe);\n    })();\n  }\n\n  api.features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n  api.features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported; // ControlRanges\n\n  var implementsControlRange = false,\n      testControlRange;\n\n  if (body && util.isHostMethod(body, \"createControlRange\")) {\n    testControlRange = body.createControlRange();\n\n    if (util.areHostProperties(testControlRange, [\"item\", \"add\"])) {\n      implementsControlRange = true;\n    }\n  }\n\n  api.features.implementsControlRange = implementsControlRange; // Selection collapsedness\n\n  if (selectionHasAnchorAndFocus) {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n    };\n  } else {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n    };\n  }\n\n  function updateAnchorAndFocusFromRange(sel, range, backwards) {\n    var anchorPrefix = backwards ? \"end\" : \"start\",\n        focusPrefix = backwards ? \"start\" : \"end\";\n    sel.anchorNode = range[anchorPrefix + \"Container\"];\n    sel.anchorOffset = range[anchorPrefix + \"Offset\"];\n    sel.focusNode = range[focusPrefix + \"Container\"];\n    sel.focusOffset = range[focusPrefix + \"Offset\"];\n  }\n\n  function updateAnchorAndFocusFromNativeSelection(sel) {\n    var nativeSel = sel.nativeSelection;\n    sel.anchorNode = nativeSel.anchorNode;\n    sel.anchorOffset = nativeSel.anchorOffset;\n    sel.focusNode = nativeSel.focusNode;\n    sel.focusOffset = nativeSel.focusOffset;\n  }\n\n  function updateEmptySelection(sel) {\n    sel.anchorNode = sel.focusNode = null;\n    sel.anchorOffset = sel.focusOffset = 0;\n    sel.rangeCount = 0;\n    sel.isCollapsed = true;\n    sel._ranges.length = 0;\n  }\n\n  function getNativeRange(range) {\n    var nativeRange;\n\n    if (range instanceof DomRange) {\n      nativeRange = range._selectionNativeRange;\n\n      if (!nativeRange) {\n        nativeRange = api.createNativeRange(dom.getDocument(range.startContainer));\n        nativeRange.setEnd(range.endContainer, range.endOffset);\n        nativeRange.setStart(range.startContainer, range.startOffset);\n        range._selectionNativeRange = nativeRange;\n        range.attachListener(\"detach\", function () {\n          this._selectionNativeRange = null;\n        });\n      }\n    } else if (range instanceof WrappedRange) {\n      nativeRange = range.nativeRange;\n    } else if (api.features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {\n      nativeRange = range;\n    }\n\n    return nativeRange;\n  }\n\n  function rangeContainsSingleElement(rangeNodes) {\n    if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n      return false;\n    }\n\n    for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n      if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getSingleElementFromRange(range) {\n    var nodes = range.getNodes();\n\n    if (!rangeContainsSingleElement(nodes)) {\n      throw new Error(\"getSingleElementFromRange: range \" + range.inspect() + \" did not consist of a single element\");\n    }\n\n    return nodes[0];\n  }\n\n  function isTextRange(range) {\n    return !!range && typeof range.text != \"undefined\";\n  }\n\n  function updateFromTextRange(sel, range) {\n    // Create a Range from the selected TextRange\n    var wrappedRange = new WrappedRange(range);\n    sel._ranges = [wrappedRange];\n    updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n    sel.rangeCount = 1;\n    sel.isCollapsed = wrappedRange.collapsed;\n  }\n\n  function updateControlSelection(sel) {\n    // Update the wrapped selection based on what's now in the native selection\n    sel._ranges.length = 0;\n\n    if (sel.docSelection.type == \"None\") {\n      updateEmptySelection(sel);\n    } else {\n      var controlRange = sel.docSelection.createRange();\n\n      if (isTextRange(controlRange)) {\n        // This case (where the selection type is \"Control\" and calling createRange() on the selection returns\n        // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n        // ControlRange have been removed from the ControlRange and removed from the document.\n        updateFromTextRange(sel, controlRange);\n      } else {\n        sel.rangeCount = controlRange.length;\n        var range,\n            doc = dom.getDocument(controlRange.item(0));\n\n        for (var i = 0; i < sel.rangeCount; ++i) {\n          range = api.createRange(doc);\n          range.selectNode(controlRange.item(i));\n\n          sel._ranges.push(range);\n        }\n\n        sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n      }\n    }\n  }\n\n  function addRangeToControlSelection(sel, range) {\n    var controlRange = sel.docSelection.createRange();\n    var rangeElement = getSingleElementFromRange(range); // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n    // contained by the supplied range\n\n    var doc = dom.getDocument(controlRange.item(0));\n    var newControlRange = dom.getBody(doc).createControlRange();\n\n    for (var i = 0, len = controlRange.length; i < len; ++i) {\n      newControlRange.add(controlRange.item(i));\n    }\n\n    try {\n      newControlRange.add(rangeElement);\n    } catch (ex) {\n      throw new Error(\"addRange(): Element within the specified Range could not be added to control selection (does it have layout?)\");\n    }\n\n    newControlRange.select(); // Update the wrapped selection based on what's now in the native selection\n\n    updateControlSelection(sel);\n  }\n\n  var getSelectionRangeAt;\n\n  if (util.isHostMethod(testSelection, \"getRangeAt\")) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel, index) {\n      try {\n        return sel.getRangeAt(index);\n      } catch (ex) {\n        return null;\n      }\n    };\n  } else if (selectionHasAnchorAndFocus) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel) {\n      var doc = dom.getDocument(sel.anchorNode);\n      var range = api.createRange(doc);\n      range.setStart(sel.anchorNode, sel.anchorOffset);\n      range.setEnd(sel.focusNode, sel.focusOffset); // Handle the case when the selection was selected backwards (from the end to the start in the\n      // document)\n\n      if (range.collapsed !== this.isCollapsed) {\n        range.setStart(sel.focusNode, sel.focusOffset);\n        range.setEnd(sel.anchorNode, sel.anchorOffset);\n      }\n\n      return range;\n    };\n  }\n  /**\n   * @constructor\n   */\n\n\n  function WrappedSelection(selection, docSelection, win) {\n    this.nativeSelection = selection;\n    this.docSelection = docSelection;\n    this._ranges = [];\n    this.win = win;\n    this.refresh();\n  }\n\n  api.getSelection = function (win) {\n    win = win || window;\n    var sel = win[windowPropertyName];\n    var nativeSel = getSelection(win),\n        docSel = implementsDocSelection ? getDocSelection(win) : null;\n\n    if (sel) {\n      sel.nativeSelection = nativeSel;\n      sel.docSelection = docSel;\n      sel.refresh(win);\n    } else {\n      sel = new WrappedSelection(nativeSel, docSel, win);\n      win[windowPropertyName] = sel;\n    }\n\n    return sel;\n  };\n\n  api.getIframeSelection = function (iframeEl) {\n    return api.getSelection(dom.getIframeWindow(iframeEl));\n  };\n\n  var selProto = WrappedSelection.prototype;\n\n  function createControlSelection(sel, ranges) {\n    // Ensure that the selection becomes of type \"Control\"\n    var doc = dom.getDocument(ranges[0].startContainer);\n    var controlRange = dom.getBody(doc).createControlRange();\n\n    for (var i = 0, el; i < rangeCount; ++i) {\n      el = getSingleElementFromRange(ranges[i]);\n\n      try {\n        controlRange.add(el);\n      } catch (ex) {\n        throw new Error(\"setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)\");\n      }\n    }\n\n    controlRange.select(); // Update the wrapped selection based on what's now in the native selection\n\n    updateControlSelection(sel);\n  } // Selecting a range\n\n\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [\"removeAllRanges\", \"addRange\"])) {\n    selProto.removeAllRanges = function () {\n      this.nativeSelection.removeAllRanges();\n      updateEmptySelection(this);\n    };\n\n    var addRangeBackwards = function addRangeBackwards(sel, range) {\n      var doc = DomRange.getRangeDocument(range);\n      var endRange = api.createRange(doc);\n      endRange.collapseToPoint(range.endContainer, range.endOffset);\n      sel.nativeSelection.addRange(getNativeRange(endRange));\n      sel.nativeSelection.extend(range.startContainer, range.startOffset);\n      sel.refresh();\n    };\n\n    if (selectionHasRangeCount) {\n      selProto.addRange = function (range, backwards) {\n        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n          addRangeToControlSelection(this, range);\n        } else {\n          if (backwards && selectionHasExtend) {\n            addRangeBackwards(this, range);\n          } else {\n            var previousRangeCount;\n\n            if (selectionSupportsMultipleRanges) {\n              previousRangeCount = this.rangeCount;\n            } else {\n              this.removeAllRanges();\n              previousRangeCount = 0;\n            }\n\n            this.nativeSelection.addRange(getNativeRange(range)); // Check whether adding the range was successful\n\n            this.rangeCount = this.nativeSelection.rangeCount;\n\n            if (this.rangeCount == previousRangeCount + 1) {\n              // The range was added successfully\n              // Check whether the range that we added to the selection is reflected in the last range extracted from\n              // the selection\n              if (api.config.checkSelectionRanges) {\n                var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n\n                if (nativeRange && !DomRange.rangesEqual(nativeRange, range)) {\n                  // Happens in WebKit with, for example, a selection placed at the start of a text node\n                  range = new WrappedRange(nativeRange);\n                }\n              }\n\n              this._ranges[this.rangeCount - 1] = range;\n              updateAnchorAndFocusFromRange(this, range, selectionIsBackwards(this.nativeSelection));\n              this.isCollapsed = selectionIsCollapsed(this);\n            } else {\n              // The range was not added successfully. The simplest thing is to refresh\n              this.refresh();\n            }\n          }\n        }\n      };\n    } else {\n      selProto.addRange = function (range, backwards) {\n        if (backwards && selectionHasExtend) {\n          addRangeBackwards(this, range);\n        } else {\n          this.nativeSelection.addRange(getNativeRange(range));\n          this.refresh();\n        }\n      };\n    }\n\n    selProto.setRanges = function (ranges) {\n      if (implementsControlRange && ranges.length > 1) {\n        createControlSelection(this, ranges);\n      } else {\n        this.removeAllRanges();\n\n        for (var i = 0, len = ranges.length; i < len; ++i) {\n          this.addRange(ranges[i]);\n        }\n      }\n    };\n  } else if (util.isHostMethod(testSelection, \"empty\") && util.isHostMethod(testRange, \"select\") && implementsControlRange && useDocumentSelection) {\n    selProto.removeAllRanges = function () {\n      // Added try/catch as fix for issue #21\n      try {\n        this.docSelection.empty(); // Check for empty() not working (issue #24)\n\n        if (this.docSelection.type != \"None\") {\n          // Work around failure to empty a control selection by instead selecting a TextRange and then\n          // calling empty()\n          var doc;\n\n          if (this.anchorNode) {\n            doc = dom.getDocument(this.anchorNode);\n          } else if (this.docSelection.type == CONTROL) {\n            var controlRange = this.docSelection.createRange();\n\n            if (controlRange.length) {\n              doc = dom.getDocument(controlRange.item(0)).body.createTextRange();\n            }\n          }\n\n          if (doc) {\n            var textRange = doc.body.createTextRange();\n            textRange.select();\n            this.docSelection.empty();\n          }\n        }\n      } catch (ex) {}\n\n      updateEmptySelection(this);\n    };\n\n    selProto.addRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        addRangeToControlSelection(this, range);\n      } else {\n        WrappedRange.rangeToTextRange(range).select();\n        this._ranges[0] = range;\n        this.rangeCount = 1;\n        this.isCollapsed = this._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(this, range, false);\n      }\n    };\n\n    selProto.setRanges = function (ranges) {\n      this.removeAllRanges();\n      var rangeCount = ranges.length;\n\n      if (rangeCount > 1) {\n        createControlSelection(this, ranges);\n      } else if (rangeCount) {\n        this.addRange(ranges[0]);\n      }\n    };\n  } else {\n    module.fail(\"No means of selecting a Range or TextRange was found\");\n    return false;\n  }\n\n  selProto.getRangeAt = function (index) {\n    if (index < 0 || index >= this.rangeCount) {\n      throw new DOMException(\"INDEX_SIZE_ERR\");\n    } else {\n      return this._ranges[index];\n    }\n  };\n\n  var refreshSelection;\n\n  if (useDocumentSelection) {\n    refreshSelection = function refreshSelection(sel) {\n      var range;\n\n      if (api.isSelectionValid(sel.win)) {\n        range = sel.docSelection.createRange();\n      } else {\n        range = dom.getBody(sel.win.document).createTextRange();\n        range.collapse(true);\n      }\n\n      if (sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else if (isTextRange(range)) {\n        updateFromTextRange(sel, range);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else if (util.isHostMethod(testSelection, \"getRangeAt\") && typeof testSelection.rangeCount == \"number\") {\n    refreshSelection = function refreshSelection(sel) {\n      if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else {\n        sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n\n        if (sel.rangeCount) {\n          for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n          }\n\n          updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackwards(sel.nativeSelection));\n          sel.isCollapsed = selectionIsCollapsed(sel);\n        } else {\n          updateEmptySelection(sel);\n        }\n      }\n    };\n  } else if (selectionHasAnchorAndFocus && _typeof(testSelection.isCollapsed) == BOOLEAN && _typeof(testRange.collapsed) == BOOLEAN && api.features.implementsDomRange) {\n    refreshSelection = function refreshSelection(sel) {\n      var range,\n          nativeSel = sel.nativeSelection;\n\n      if (nativeSel.anchorNode) {\n        range = getSelectionRangeAt(nativeSel, 0);\n        sel._ranges = [range];\n        sel.rangeCount = 1;\n        updateAnchorAndFocusFromNativeSelection(sel);\n        sel.isCollapsed = selectionIsCollapsed(sel);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else {\n    module.fail(\"No means of obtaining a Range or TextRange from the user's selection was found\");\n    return false;\n  }\n\n  selProto.refresh = function (checkForChanges) {\n    var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n    refreshSelection(this);\n\n    if (checkForChanges) {\n      var i = oldRanges.length;\n\n      if (i != this._ranges.length) {\n        return false;\n      }\n\n      while (i--) {\n        if (!DomRange.rangesEqual(oldRanges[i], this._ranges[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }; // Removal of a single range\n\n\n  var removeRangeManually = function removeRangeManually(sel, range) {\n    var ranges = sel.getAllRanges(),\n        removed = false;\n    sel.removeAllRanges();\n\n    for (var i = 0, len = ranges.length; i < len; ++i) {\n      if (removed || range !== ranges[i]) {\n        sel.addRange(ranges[i]);\n      } else {\n        // According to the draft WHATWG Range spec, the same range may be added to the selection multiple\n        // times. removeRange should only remove the first instance, so the following ensures only the first\n        // instance is removed\n        removed = true;\n      }\n    }\n\n    if (!sel.rangeCount) {\n      updateEmptySelection(sel);\n    }\n  };\n\n  if (implementsControlRange) {\n    selProto.removeRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        var controlRange = this.docSelection.createRange();\n        var rangeElement = getSingleElementFromRange(range); // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n        // element contained by the supplied range\n\n        var doc = dom.getDocument(controlRange.item(0));\n        var newControlRange = dom.getBody(doc).createControlRange();\n        var el,\n            removed = false;\n\n        for (var i = 0, len = controlRange.length; i < len; ++i) {\n          el = controlRange.item(i);\n\n          if (el !== rangeElement || removed) {\n            newControlRange.add(controlRange.item(i));\n          } else {\n            removed = true;\n          }\n        }\n\n        newControlRange.select(); // Update the wrapped selection based on what's now in the native selection\n\n        updateControlSelection(this);\n      } else {\n        removeRangeManually(this, range);\n      }\n    };\n  } else {\n    selProto.removeRange = function (range) {\n      removeRangeManually(this, range);\n    };\n  } // Detecting if a selection is backwards\n\n\n  var selectionIsBackwards;\n\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && api.features.implementsDomRange) {\n    selectionIsBackwards = function selectionIsBackwards(sel) {\n      var backwards = false;\n\n      if (sel.anchorNode) {\n        backwards = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;\n      }\n\n      return backwards;\n    };\n\n    selProto.isBackwards = function () {\n      return selectionIsBackwards(this);\n    };\n  } else {\n    selectionIsBackwards = selProto.isBackwards = function () {\n      return false;\n    };\n  } // Selection text\n  // This is conformant to the new WHATWG DOM Range draft spec but differs from WebKit and Mozilla's implementation\n\n\n  selProto.toString = function () {\n    var rangeTexts = [];\n\n    for (var i = 0, len = this.rangeCount; i < len; ++i) {\n      rangeTexts[i] = \"\" + this._ranges[i];\n    }\n\n    return rangeTexts.join(\"\");\n  };\n\n  function assertNodeInSameDocument(sel, node) {\n    if (sel.anchorNode && dom.getDocument(sel.anchorNode) !== dom.getDocument(node)) {\n      throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n    }\n  } // No current browsers conform fully to the HTML 5 draft spec for this method, so Rangy's own method is always used\n\n\n  selProto.collapse = function (node, offset) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.collapseToPoint(node, offset);\n    this.removeAllRanges();\n    this.addRange(range);\n    this.isCollapsed = true;\n  };\n\n  selProto.collapseToStart = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[0];\n      this.collapse(range.startContainer, range.startOffset);\n    } else {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  };\n\n  selProto.collapseToEnd = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[this.rangeCount - 1];\n      this.collapse(range.endContainer, range.endOffset);\n    } else {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  }; // The HTML 5 spec is very specific on how selectAllChildren should be implemented so the native implementation is\n  // never used by Rangy.\n\n\n  selProto.selectAllChildren = function (node) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.selectNodeContents(node);\n    this.removeAllRanges();\n    this.addRange(range);\n  };\n\n  selProto.deleteFromDocument = function () {\n    // Sepcial behaviour required for Control selections\n    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n      var controlRange = this.docSelection.createRange();\n      var element;\n\n      while (controlRange.length) {\n        element = controlRange.item(0);\n        controlRange.remove(element);\n        element.parentNode.removeChild(element);\n      }\n\n      this.refresh();\n    } else if (this.rangeCount) {\n      var ranges = this.getAllRanges();\n      this.removeAllRanges();\n\n      for (var i = 0, len = ranges.length; i < len; ++i) {\n        ranges[i].deleteContents();\n      } // The HTML5 spec says nothing about what the selection should contain after calling deleteContents on each\n      // range. Firefox moves the selection to where the final selected range was, so we emulate that\n\n\n      this.addRange(ranges[len - 1]);\n    }\n  }; // The following are non-standard extensions\n\n\n  selProto.getAllRanges = function () {\n    return this._ranges.slice(0);\n  };\n\n  selProto.setSingleRange = function (range) {\n    this.setRanges([range]);\n  };\n\n  selProto.containsNode = function (node, allowPartial) {\n    for (var i = 0, len = this._ranges.length; i < len; ++i) {\n      if (this._ranges[i].containsNode(node, allowPartial)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  selProto.toHtml = function () {\n    var html = \"\";\n\n    if (this.rangeCount) {\n      var container = DomRange.getRangeDocument(this._ranges[0]).createElement(\"div\");\n\n      for (var i = 0, len = this._ranges.length; i < len; ++i) {\n        container.appendChild(this._ranges[i].cloneContents());\n      }\n\n      html = container.innerHTML;\n    }\n\n    return html;\n  };\n\n  function inspect(sel) {\n    var rangeInspects = [];\n    var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n    var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n    var name = typeof sel.getName == \"function\" ? sel.getName() : \"Selection\";\n\n    if (typeof sel.rangeCount != \"undefined\") {\n      for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n        rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n      }\n    }\n\n    return \"[\" + name + \"(Ranges: \" + rangeInspects.join(\", \") + \")(anchor: \" + anchor.inspect() + \", focus: \" + focus.inspect() + \"]\";\n  }\n\n  selProto.getName = function () {\n    return \"WrappedSelection\";\n  };\n\n  selProto.inspect = function () {\n    return inspect(this);\n  };\n\n  selProto.detach = function () {\n    this.win[windowPropertyName] = null;\n    this.win = this.anchorNode = this.focusNode = null;\n  };\n\n  WrappedSelection.inspect = inspect;\n  api.Selection = WrappedSelection;\n  api.selectionPrototype = selProto;\n  api.addCreateMissingNativeApiListener(function (win) {\n    if (typeof win.getSelection == \"undefined\") {\n      win.getSelection = function () {\n        return api.getSelection(this);\n      };\n    }\n\n    win = null;\n  });\n});\n/*!\n  * Bowser - a browser detector\n  * https://github.com/ded/bowser\n  * MIT License | (c) Dustin Diaz 2014\n  */\n\nvar bowser = function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n  var t = true;\n\n  function detect(ua) {\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return match && match.length > 1 && match[1] || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),\n        likeAndroid = /like android/i.test(ua),\n        android = !likeAndroid && /android/i.test(ua),\n        versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i),\n        tablet = /tablet/i.test(ua),\n        mobile = !tablet && /[^-]mobi/i.test(ua),\n        result;\n\n    if (/opera|opr/i.test(ua)) {\n      result = {\n        name: 'Opera',\n        opera: t,\n        version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/windows phone/i.test(ua)) {\n      result = {\n        name: 'Windows Phone',\n        windowsphone: t,\n        msie: t,\n        version: getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer',\n        msie: t,\n        version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome',\n        chrome: t,\n        version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (iosdevice) {\n      result = {\n        name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod' // WTF: version is not part of user agent in web apps\n\n      };\n\n      if (versionIdentifier) {\n        result.version = versionIdentifier;\n      }\n    } else if (/sailfish/i.test(ua)) {\n      result = {\n        name: 'Sailfish',\n        sailfish: t,\n        version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey',\n        seamonkey: t,\n        version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/firefox|iceweasel/i.test(ua)) {\n      result = {\n        name: 'Firefox',\n        firefox: t,\n        version: getFirstMatch(/(?:firefox|iceweasel)[ \\/](\\d+(\\.\\d+)?)/i)\n      };\n\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t;\n      }\n    } else if (/silk/i.test(ua)) {\n      result = {\n        name: 'Amazon Silk',\n        silk: t,\n        version: getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (android) {\n      result = {\n        name: 'Android',\n        version: versionIdentifier\n      };\n    } else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS',\n        phantom: t,\n        version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry',\n        blackberry: t,\n        version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/(web|hpw)os/i.test(ua)) {\n      result = {\n        name: 'WebOS',\n        webos: t,\n        version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t);\n    } else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada',\n        bada: t,\n        version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/tizen/i.test(ua)) {\n      result = {\n        name: 'Tizen',\n        tizen: t,\n        version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    } else if (/safari/i.test(ua)) {\n      result = {\n        name: 'Safari',\n        safari: t,\n        version: versionIdentifier\n      };\n    } else result = {}; // set webkit or gecko flag for browsers based on these engines\n\n\n    if (/(apple)?webkit/i.test(ua)) {\n      result.name = result.name || \"Webkit\";\n      result.webkit = t;\n\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier;\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\";\n      result.gecko = t;\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i);\n    } // set OS flags for platforms that have multiple browsers\n\n\n    if (android || result.silk) {\n      result.android = t;\n    } else if (iosdevice) {\n      result[iosdevice] = t;\n      result.ios = t;\n    } // OS version extraction\n\n\n    var osVersion = '';\n\n    if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n\n    if (osVersion) {\n      result.osversion = osVersion;\n    } // device type extraction\n\n\n    var osMajorVersion = osVersion.split('.')[0];\n\n    if (tablet || iosdevice == 'ipad' || android && (osMajorVersion == 3 || osMajorVersion == 4 && !mobile) || result.silk) {\n      result.tablet = t;\n    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {\n      result.mobile = t;\n    } // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n\n\n    if (result.msie && result.version >= 10 || result.chrome && result.version >= 20 || result.firefox && result.version >= 20.0 || result.safari && result.version >= 6 || result.opera && result.version >= 10.0 || result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6 || result.blackberry && result.version >= 10.1) {\n      result.a = t;\n    } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20.0 || result.safari && result.version < 6 || result.opera && result.version < 10.0 || result.ios && result.osversion && result.osversion.split(\".\")[0] < 6) {\n      result.c = t;\n    } else result.x = t;\n\n    return result;\n  }\n\n  var bd = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '');\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n\n  bd._detect = detect;\n  return bd;\n}();\n\n;\n\n(function (window, document, jQuery, undefined) {\n  'use strict';\n\n  var Editable = {};\n\n  var $ = function () {\n    return jQuery || function () {\n      throw new Error('jQuery-like library not yet implemented');\n    };\n  }();\n\n  var log, error; // Allows for safe console logging\n  // If the last param is the string \"trace\" console.trace will be called\n  // configuration: disable with config.log = false\n\n  log = function log() {\n    if (config.log === false) {\n      return;\n    }\n\n    var args, _ref;\n\n    args = Array.prototype.slice.call(arguments);\n\n    if (args.length) {\n      if (args[args.length - 1] === \"trace\") {\n        args.pop();\n\n        if ((_ref = window.console) ? _ref.trace : void 0) {\n          console.trace();\n        }\n      }\n    }\n\n    if (args.length === 1) {\n      args = args[0];\n    }\n\n    if (window.console) {\n      return console.log(args);\n    }\n  }; // Allows for safe error logging\n  // Falls back to console.log if console.error is not available\n\n\n  error = function error() {\n    if (config.logErrors === false) {\n      return;\n    }\n\n    var args;\n    args = Array.prototype.slice.call(arguments);\n\n    if (args.length === 1) {\n      args = args[0];\n    }\n\n    if (window.console && typeof window.console.error === \"function\") {\n      return console.error(args);\n    } else if (window.console) {\n      return console.log(args);\n    }\n  };\n\n  var string = function () {\n    var toString = Object.prototype.toString;\n    var htmlCharacters = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      '\\'': '&#39;'\n    };\n    return {\n      trimRight: function trimRight(text) {\n        return text.replace(/\\s+$/, '');\n      },\n      trimLeft: function trimLeft(text) {\n        return text.replace(/^\\s+/, '');\n      },\n      trim: function trim(text) {\n        return text.replace(/^\\s+|\\s+$/g, '');\n      },\n      isString: function isString(obj) {\n        return toString.call(obj) === '[object String]';\n      },\n\n      /**\n       * Turn any string into a regular expression.\n       * This can be used to search or replace a string conveniently.\n       */\n      regexp: function regexp(str, flags) {\n        if (!flags) flags = 'g';\n        var escapedStr = str.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n        return new RegExp(escapedStr, flags);\n      },\n\n      /**\n       * Escape HTML characters <, > and &\n       * Usage: escapeHtml('<div>');\n       *\n       * @param { String }\n       * @param { Boolean } Optional. If true \" and ' will also be escaped.\n       * @return { String } Escaped Html you can assign to innerHTML of an element.\n       */\n      escapeHtml: function escapeHtml(s, forAttribute) {\n        return s.replace(forAttribute ? /[&<>'\"]/g : /[&<>]/g, function (c) {\n          // \"'\n          return htmlCharacters[c];\n        });\n      },\n\n      /**\n       * Escape a string the browser way.\n       */\n      browserEscapeHtml: function browserEscapeHtml(str) {\n        var div = document.createElement('div');\n        div.appendChild(document.createTextNode(str));\n        return div.innerHTML;\n      }\n    };\n  }();\n  /**\n   * Defines all supported event types by Editable.JS and provides default\n   * implementations for them defined in {{#crossLink \"Behavior\"}}{{/crossLink}}\n   *\n   * @type {Object}\n   */\n\n\n  var config = {\n    log: false,\n    logErrors: true,\n    editableClass: 'js-editable',\n    editableDisabledClass: 'js-editable-disabled',\n    pastingAttribute: 'data-editable-is-pasting',\n    boldTag: 'strong',\n    italicTag: 'em',\n    // Rules that are applied when filtering pasted content\n    pastedHtmlRules: {\n      // Elements and their attributes to keep in pasted text\n      allowedElements: {\n        'a': {\n          'href': true\n        },\n        'strong': {},\n        'em': {},\n        'br': {}\n      },\n      // Elements that have required attributes.\n      // If these are not present the elements are filtered out.\n      // Required attributes have to be present in the 'allowed' object\n      // as well if they should not be filtered out.\n      requiredAttributes: {\n        'a': ['href']\n      },\n      // Elements that should be transformed into other elements\n      transformElements: {\n        'b': 'strong',\n        'i': 'em'\n      },\n      // A list of elements which should be split into paragraphs.\n      splitIntoBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'blockquote'],\n      // A list of HTML block level elements.\n      blockLevelElements: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'p', 'pre', 'hr', 'blockquote', 'article', 'figure', 'header', 'footer', 'ul', 'ol', 'li', 'section', 'table', 'video']\n    }\n  };\n  /**\n   * The Core module provides the Editable class that defines the Editable.JS\n   * API and is the main entry point for Editable.JS.\n   * It also provides the cursor module for cross-browser cursors, and the dom\n   * submodule.\n   *\n   * @module core\n   */\n\n  /**\n   * Constructor for the Editable.JS API that is externally visible.\n   * Note that the Editable literal is defined\n   * first in editable.prefix in order for it to be the only externally visible\n   * variable.\n   *\n   * @param {Object} configuration for this editable instance.\n   *   window: The window where to attach the editable events.\n   *   defaultBehavior: {Boolean} Load default-behavior.js.\n   *   mouseMoveSelectionChanges: {Boolean} Whether to get cursor and selection events on mousemove.\n   *   browserSpellcheck: {Boolean} Set the spellcheck attribute on editable elements\n   *\n   * @class Editable\n   */\n\n  Editable = function Editable(instanceConfig) {\n    var defaultInstanceConfig = {\n      window: window,\n      defaultBehavior: true,\n      mouseMoveSelectionChanges: false,\n      browserSpellcheck: true\n    };\n    this.config = $.extend(defaultInstanceConfig, instanceConfig);\n    this.win = this.config.window;\n    this.editableSelector = '.' + config.editableClass;\n\n    if (!rangy.initialized) {\n      rangy.init();\n    }\n\n    this.dispatcher = new Dispatcher(this);\n\n    if (this.config.defaultBehavior === true) {\n      this.dispatcher.on(createDefaultEvents(this));\n    }\n  };\n  /**\n   * Set configuration options that affect all editable\n   * instances.\n   *\n   * @param {Object} global configuration options (defaults are defined in config.js)\n   *   log: {Boolean}\n   *   logErrors: {Boolean}\n   *   editableClass: {String} e.g. 'js-editable'\n   *   editableDisabledClass: {String} e.g. 'js-editable-disabled'\n   *   pastingAttribute: {String} default: e.g. 'data-editable-is-pasting'\n   *   boldTag: e.g. '<strong>'\n   *   italicTag: e.g. '<em>'\n   */\n\n\n  Editable.globalConfig = function (globalConfig) {\n    $.extend(config, globalConfig);\n    clipboard.updateConfig(config);\n  };\n  /**\n   * Adds the Editable.JS API to the given target elements.\n   * Opposite of {{#crossLink \"Editable/remove\"}}{{/crossLink}}.\n   * Calls dispatcher.setup to setup all event listeners.\n   *\n   * @method add\n   * @param {HTMLElement|Array(HTMLElement)|String} target A HTMLElement, an\n   *    array of HTMLElement or a query selector representing the target where\n   *    the API should be added on.\n   * @chainable\n   */\n\n\n  Editable.prototype.add = function (target) {\n    this.enable($(target)); // todo: check css whitespace settings\n\n    return this;\n  };\n  /**\n   * Removes the Editable.JS API from the given target elements.\n   * Opposite of {{#crossLink \"Editable/add\"}}{{/crossLink}}.\n   *\n   * @method remove\n   * @param {HTMLElement|Array(HTMLElement)|String} target A HTMLElement, an\n   *    array of HTMLElement or a query selector representing the target where\n   *    the API should be removed from.\n   * @chainable\n   */\n\n\n  Editable.prototype.remove = function (target) {\n    var $target = $(target);\n    this.disable($target);\n    $target.removeClass(config.editableDisabledClass);\n    return this;\n  };\n  /**\n   * Removes the Editable.JS API from the given target elements.\n   * The target elements are marked as disabled.\n   *\n   * @method disable\n   * @param { jQuery element | undefined  } target editable root element(s)\n   *    If no param is specified all editables are disabled.\n   * @chainable\n   */\n\n\n  Editable.prototype.disable = function ($elem) {\n    var body = this.win.document.body;\n    $elem = $elem || $('.' + config.editableClass, body);\n    $elem.removeAttr('contenteditable').removeAttr('spellcheck').removeClass(config.editableClass).addClass(config.editableDisabledClass);\n    return this;\n  };\n  /**\n   * Adds the Editable.JS API to the given target elements.\n   *\n   * @method enable\n   * @param { jQuery element | undefined } target editable root element(s)\n   *    If no param is specified all editables marked as disabled are enabled.\n   * @chainable\n   */\n\n\n  Editable.prototype.enable = function ($elem, normalize) {\n    var body = this.win.document.body;\n    $elem = $elem || $('.' + config.editableDisabledClass, body);\n    $elem.attr('contenteditable', true).attr('spellcheck', this.config.browserSpellcheck).removeClass(config.editableDisabledClass).addClass(config.editableClass);\n\n    if (normalize) {\n      $elem.each(function (index, el) {\n        content.tidyHtml(el);\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Temporarily disable an editable.\n   * Can be used to prevent text selction while dragging an element\n   * for example.\n   *\n   * @method suspend\n   * @param jQuery object\n   */\n\n\n  Editable.prototype.suspend = function ($elem) {\n    var body = this.win.document.body;\n    $elem = $elem || $('.' + config.editableClass, body);\n    $elem.removeAttr('contenteditable');\n    return this;\n  };\n  /**\n   * Reverse the effects of suspend()\n   *\n   * @method continue\n   * @param jQuery object\n   */\n\n\n  Editable.prototype.continue = function ($elem) {\n    var body = this.win.document.body;\n    $elem = $elem || $('.' + config.editableClass, body);\n    $elem.attr('contenteditable', true);\n    return this;\n  };\n  /**\n   * Set the cursor inside of an editable block.\n   *\n   * @method createCursor\n   * @param position 'beginning', 'end', 'before', 'after'\n   */\n\n\n  Editable.prototype.createCursor = function (element, position) {\n    var cursor;\n    var $host = $(element).closest(this.editableSelector);\n    position = position || 'beginning';\n\n    if ($host.length) {\n      var range = rangy.createRange();\n\n      if (position === 'beginning' || position === 'end') {\n        range.selectNodeContents(element);\n        range.collapse(position === 'beginning' ? true : false);\n      } else if (element !== $host[0]) {\n        if (position === 'before') {\n          range.setStartBefore(element);\n          range.setEndBefore(element);\n        } else if (position === 'after') {\n          range.setStartAfter(element);\n          range.setEndAfter(element);\n        }\n      } else {\n        error('EditableJS: cannot create cursor outside of an editable block.');\n      }\n\n      cursor = new Cursor($host[0], range);\n    }\n\n    return cursor;\n  };\n\n  Editable.prototype.createCursorAtBeginning = function (element) {\n    return this.createCursor(element, 'beginning');\n  };\n\n  Editable.prototype.createCursorAtEnd = function (element) {\n    return this.createCursor(element, 'end');\n  };\n\n  Editable.prototype.createCursorBefore = function (element) {\n    return this.createCursor(element, 'before');\n  };\n\n  Editable.prototype.createCursorAfter = function (element) {\n    return this.createCursor(element, 'after');\n  };\n  /**\n   * Extract the content from an editable host or document fragment.\n   * This method will remove all internal elements and ui-elements.\n   *\n   * @param {DOM node or Document Fragment} The innerHTML of this element or fragment will be extracted.\n   * @returns {String} The cleaned innerHTML.\n   */\n\n\n  Editable.prototype.getContent = function (element) {\n    return content.extractContent(element);\n  };\n  /**\n   * @param {String | DocumentFragment} content to append.\n   * @returns {Cursor} A new Cursor object just before the inserted content.\n   */\n\n\n  Editable.prototype.appendTo = function (element, contentToAppend) {\n    element = content.adoptElement(element, this.win.document);\n\n    if (typeof contentToAppend === 'string') {\n      // todo: create content in the right window\n      contentToAppend = content.createFragmentFromString(contentToAppend);\n    }\n\n    var cursor = this.createCursor(element, 'end');\n    cursor.insertAfter(contentToAppend);\n    return cursor;\n  };\n  /**\n   * @param {String | DocumentFragment} content to prepend\n   * @returns {Cursor} A new Cursor object just after the inserted content.\n   */\n\n\n  Editable.prototype.prependTo = function (element, contentToPrepend) {\n    element = content.adoptElement(element, this.win.document);\n\n    if (typeof contentToPrepend === 'string') {\n      // todo: create content in the right window\n      contentToPrepend = content.createFragmentFromString(contentToPrepend);\n    }\n\n    var cursor = this.createCursor(element, 'beginning');\n    cursor.insertBefore(contentToPrepend);\n    return cursor;\n  };\n  /**\n   * Get the current selection.\n   * Only returns something if the selection is within an editable element.\n   * If you pass an editable host as param it only returns something if the selection is inside this\n   * very editable element.\n   *\n   * @param {DOMNode} Optional. An editable host where the selection needs to be contained.\n   * @returns A Cursor or Selection object or undefined.\n   */\n\n\n  Editable.prototype.getSelection = function (editableHost) {\n    var selection = this.dispatcher.selectionWatcher.getFreshSelection();\n\n    if (editableHost && selection) {\n      var range = selection.range; // Check if the selection is inside the editableHost\n      // The try...catch is required if the editableHost was removed from the DOM.\n\n      try {\n        if (range.compareNode(editableHost) !== range.NODE_BEFORE_AND_AFTER) {\n          selection = undefined;\n        }\n      } catch (e) {\n        selection = undefined;\n      }\n    }\n\n    return selection;\n  };\n  /**\n   * Enable spellchecking\n   *\n   * @chainable\n   */\n\n\n  Editable.prototype.setupSpellcheck = function (spellcheckConfig) {\n    this.spellcheck = new Spellcheck(this, spellcheckConfig);\n    return this;\n  };\n  /**\n   * Subscribe a callback function to a custom event fired by the API.\n   *\n   * @param {String} event The name of the event.\n   * @param {Function} handler The callback to execute in response to the\n   *     event.\n   *\n   * @chainable\n   */\n\n\n  Editable.prototype.on = function (event, handler) {\n    // TODO throw error if event is not one of EVENTS\n    // TODO throw error if handler is not a function\n    this.dispatcher.on(event, handler);\n    return this;\n  };\n  /**\n   * Unsubscribe a callback function from a custom event fired by the API.\n   * Opposite of {{#crossLink \"Editable/on\"}}{{/crossLink}}.\n   *\n   * @param {String} event The name of the event.\n   * @param {Function} handler The callback to remove from the\n   *     event or the special value false to remove all callbacks.\n   *\n   * @chainable\n   */\n\n\n  Editable.prototype.off = function (event, handler) {\n    var args = Array.prototype.slice.call(arguments);\n    this.dispatcher.off.apply(this.dispatcher, args);\n    return this;\n  };\n  /**\n   * Unsubscribe all callbacks and event listeners.\n   *\n   * @chainable\n   */\n\n\n  Editable.prototype.unload = function () {\n    this.dispatcher.unload();\n    return this;\n  };\n  /**\n   * Generate a callback function to subscribe to an event.\n   *\n   * @method createEventSubscriber\n   * @param {String} Event name\n   */\n\n\n  var createEventSubscriber = function createEventSubscriber(name) {\n    Editable.prototype[name] = function (handler) {\n      return this.on(name, handler);\n    };\n  };\n  /**\n   * Set up callback functions for several events.\n   */\n\n\n  var events = ['focus', 'blur', 'flow', 'selection', 'cursor', 'newline', 'insert', 'split', 'merge', 'empty', 'change', 'switch', 'move', 'clipboard', 'paste'];\n\n  for (var i = 0; i < events.length; ++i) {\n    var eventName = events[i];\n    createEventSubscriber(eventName);\n  }\n\n  var block = function () {\n    var getSibling = function getSibling(type) {\n      return function (element) {\n        var sibling = element[type];\n        if (sibling && sibling.getAttribute('contenteditable')) return sibling;\n        return null;\n      };\n    };\n\n    return {\n      next: getSibling('nextElementSibling'),\n      previous: getSibling('previousElementSibling')\n    };\n  }();\n\n  var clipboard = function () {\n    var allowedElements, requiredAttributes, transformElements;\n    var blockLevelElements, splitIntoBlocks;\n    var whitespaceOnly = /^\\s*$/;\n    var blockPlaceholder = '<!-- BLOCK -->';\n\n    var updateConfig = function updateConfig(config) {\n      var i,\n          name,\n          rules = config.pastedHtmlRules;\n      allowedElements = rules.allowedElements || {};\n      requiredAttributes = rules.requiredAttributes || {};\n      transformElements = rules.transformElements || {};\n      blockLevelElements = {};\n\n      for (i = 0; i < rules.blockLevelElements.length; i++) {\n        name = rules.blockLevelElements[i];\n        blockLevelElements[name] = true;\n      }\n\n      splitIntoBlocks = {};\n\n      for (i = 0; i < rules.splitIntoBlocks.length; i++) {\n        name = rules.splitIntoBlocks[i];\n        splitIntoBlocks[name] = true;\n      }\n    };\n\n    updateConfig(config);\n    return {\n      updateConfig: updateConfig,\n      paste: function paste(element, cursor, callback) {\n        var document = element.ownerDocument;\n        element.setAttribute(config.pastingAttribute, true);\n\n        if (cursor.isSelection) {\n          cursor = cursor.deleteContent();\n        } // Create a placeholder and set the focus to the pasteholder\n        // to redirect the browser pasting into the pasteholder.\n\n\n        cursor.save();\n        var pasteHolder = this.injectPasteholder(document);\n        pasteHolder.focus(); // Use a timeout to give the browser some time to paste the content.\n        // After that grab the pasted content, filter it and restore the focus.\n\n        var _this = this;\n\n        setTimeout(function () {\n          var blocks;\n          blocks = _this.parseContent(pasteHolder);\n          $(pasteHolder).remove();\n          element.removeAttribute(config.pastingAttribute);\n          cursor.restore();\n          callback(blocks, cursor);\n        }, 0);\n      },\n      injectPasteholder: function injectPasteholder(document) {\n        var pasteHolder = $(document.createElement('div')).attr('contenteditable', true).css({\n          position: 'fixed',\n          right: '5px',\n          top: '50%',\n          width: '1px',\n          height: '1px',\n          overflow: 'hidden',\n          outline: 'none'\n        })[0];\n        $(document.body).append(pasteHolder);\n        return pasteHolder;\n      },\n\n      /**\n       * - Parse pasted content\n       * - Split it up into blocks\n       * - clean and normalize every block\n       *\n       * @param {DOM node} A container where the pasted content is located.\n       * @returns {Array of Strings} An array of cleaned innerHTML like strings.\n       */\n      parseContent: function parseContent(element) {\n        // Filter pasted content\n        var pastedString = this.filterHtmlElements(element); // Handle Blocks\n\n        var blocks = pastedString.split(blockPlaceholder);\n\n        for (var i = 0; i < blocks.length; i++) {\n          var entry = blocks[i]; // Clean Whitesapce\n\n          entry = this.cleanWhitespace(entry); // Trim pasted Text\n\n          entry = string.trim(entry);\n          blocks[i] = entry;\n        }\n\n        blocks = blocks.filter(function (entry) {\n          return !whitespaceOnly.test(entry);\n        });\n        return blocks;\n      },\n      filterHtmlElements: function filterHtmlElements(elem, parents) {\n        if (!parents) parents = [];\n        var child,\n            content = '';\n\n        for (var i = 0; i < elem.childNodes.length; i++) {\n          child = elem.childNodes[i];\n\n          if (child.nodeType === nodeType.elementNode) {\n            var childContent = this.filterHtmlElements(child, parents);\n            content += this.conditionalNodeWrap(child, childContent);\n          } else if (child.nodeType === nodeType.textNode) {\n            // Escape HTML characters <, > and &\n            content += string.escapeHtml(child.nodeValue);\n          }\n        }\n\n        return content;\n      },\n      conditionalNodeWrap: function conditionalNodeWrap(child, content) {\n        var nodeName = child.nodeName.toLowerCase();\n        nodeName = this.transformNodeName(nodeName);\n\n        if (this.shouldKeepNode(nodeName, child)) {\n          var attributes = this.filterAttributes(nodeName, child);\n\n          if (nodeName === 'br') {\n            return '<' + nodeName + attributes + '>';\n          } else if (!whitespaceOnly.test(content)) {\n            return '<' + nodeName + attributes + '>' + content + '</' + nodeName + '>';\n          } else {\n            return content;\n          }\n        } else {\n          if (splitIntoBlocks[nodeName]) {\n            return blockPlaceholder + content + blockPlaceholder;\n          } else if (blockLevelElements[nodeName]) {\n            // prevent missing whitespace between text when block-level\n            // elements are removed.\n            return content + ' ';\n          } else {\n            return content;\n          }\n        }\n      },\n      filterAttributes: function filterAttributes(nodeName, node) {\n        var attributes = '';\n\n        for (var i = 0, len = (node.attributes || []).length; i < len; i++) {\n          var name = node.attributes[i].name;\n          var value = node.attributes[i].value;\n\n          if (allowedElements[nodeName][name] && value) {\n            attributes += ' ' + name + '=\"' + value + '\"';\n          }\n        }\n\n        return attributes;\n      },\n      transformNodeName: function transformNodeName(nodeName) {\n        if (transformElements[nodeName]) {\n          return transformElements[nodeName];\n        } else {\n          return nodeName;\n        }\n      },\n      hasRequiredAttributes: function hasRequiredAttributes(nodeName, node) {\n        var attrName, attrValue;\n        var requiredAttrs = requiredAttributes[nodeName];\n\n        if (requiredAttrs) {\n          for (var i = 0; i < requiredAttrs.length; i++) {\n            attrName = requiredAttrs[i];\n            attrValue = node.getAttribute(attrName);\n\n            if (!attrValue) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      },\n      shouldKeepNode: function shouldKeepNode(nodeName, node) {\n        return allowedElements[nodeName] && this.hasRequiredAttributes(nodeName, node);\n      },\n      cleanWhitespace: function cleanWhitespace(str) {\n        var cleanedStr = str.replace(/(.)(\\u00A0)/g, function (match, group1, group2, offset, string) {\n          if (/[\\u0020]/.test(group1)) {\n            return group1 + \"\\xA0\";\n          } else {\n            return group1 + ' ';\n          }\n        });\n        return cleanedStr;\n      }\n    };\n  }();\n\n  var content = function () {\n    var restoreRange = function restoreRange(host, range, func) {\n      range = rangeSaveRestore.save(range);\n      func.call(content);\n      return rangeSaveRestore.restore(host, range);\n    };\n\n    var zeroWidthSpace = /\\u200B/g;\n    var zeroWidthNonBreakingSpace = /\\uFEFF/g;\n    var whitespaceExceptSpace = /[^\\S ]/g;\n    return {\n      /**\n       * Clean up the Html.\n       */\n      tidyHtml: function tidyHtml(element) {\n        this.normalizeTags(element);\n      },\n\n      /**\n       * Remove empty tags and merge consecutive tags (they must have the same\n       * attributes).\n       *\n       * @method normalizeTags\n       * @param  {HTMLElement} element The element to process.\n       */\n      normalizeTags: function normalizeTags(element) {\n        var i, j, node, sibling;\n        var fragment = document.createDocumentFragment();\n\n        for (i = 0; i < element.childNodes.length; i++) {\n          node = element.childNodes[i];\n          if (!node) continue; // skip empty tags, so they'll get removed\n\n          if (node.nodeName !== 'BR' && !node.textContent) continue;\n\n          if (node.nodeType === nodeType.elementNode && node.nodeName !== 'BR') {\n            sibling = node;\n\n            while ((sibling = sibling.nextSibling) !== null) {\n              if (!parser.isSameNode(sibling, node)) break;\n\n              for (j = 0; j < sibling.childNodes.length; j++) {\n                node.appendChild(sibling.childNodes[j].cloneNode(true));\n              }\n\n              sibling.parentNode.removeChild(sibling);\n            }\n\n            this.normalizeTags(node);\n          }\n\n          fragment.appendChild(node.cloneNode(true));\n        }\n\n        while (element.firstChild) {\n          element.removeChild(element.firstChild);\n        }\n\n        element.appendChild(fragment);\n      },\n      normalizeWhitespace: function normalizeWhitespace(text) {\n        return text.replace(whitespaceExceptSpace, ' ');\n      },\n\n      /**\n       * Clean the element from character, tags, etc... added by the plugin logic.\n       *\n       * @method cleanInternals\n       * @param  {HTMLElement} element The element to process.\n       */\n      cleanInternals: function cleanInternals(element) {\n        // Uses extract content for simplicity. A custom method\n        // that does not clone the element could be faster if needed.\n        element.innerHTML = this.extractContent(element, true);\n      },\n\n      /**\n       * Extracts the content from a host element.\n       * Does not touch or change the host. Just returns\n       * the content and removes elements marked for removal by editable.\n       *\n       * @param {DOM node or document framgent} Element where to clean out the innerHTML. If you pass a document fragment it will be empty after this call.\n       * @param {Boolean} Flag whether to keep ui elements like spellchecking highlights.\n       * @returns {String} The cleaned innerHTML of the passed element or document fragment.\n       */\n      extractContent: function extractContent(element, keepUiElements) {\n        var innerHtml;\n\n        if (element.nodeType === nodeType.documentFragmentNode) {\n          innerHtml = this.getInnerHtmlOfFragment(element);\n        } else {\n          innerHtml = element.innerHTML;\n        }\n\n        innerHtml = innerHtml.replace(zeroWidthNonBreakingSpace, ''); // Used for forcing inline elments to have a height\n\n        innerHtml = innerHtml.replace(zeroWidthSpace, '<br>'); // Used for cross-browser newlines\n\n        var clone = document.createElement('div');\n        clone.innerHTML = innerHtml;\n        this.unwrapInternalNodes(clone, keepUiElements);\n        return clone.innerHTML;\n      },\n      getInnerHtmlOfFragment: function getInnerHtmlOfFragment(documentFragment) {\n        var div = document.createElement('div');\n        div.appendChild(documentFragment);\n        return div.innerHTML;\n      },\n\n      /**\n       * Create a document fragment from an html string\n       * @param {String} e.g. 'some html <span>text</span>.'\n       */\n      createFragmentFromString: function createFragmentFromString(htmlString) {\n        var fragment = document.createDocumentFragment();\n        var contents = $('<div>').html(htmlString).contents();\n\n        for (var i = 0; i < contents.length; i++) {\n          var el = contents[i];\n          fragment.appendChild(el);\n        }\n\n        return fragment;\n      },\n      adoptElement: function adoptElement(node, doc) {\n        if (node.ownerDocument !== doc) {\n          return doc.adoptNode(node);\n        } else {\n          return node;\n        }\n      },\n\n      /**\n       * This is a slight variation of the cloneContents method of a rangyRange.\n       * It will return a fragment with the cloned contents of the range\n       * without the commonAncestorElement.\n       *\n       * @param {rangyRange}\n       * @return {DocumentFragment}\n       */\n      cloneRangeContents: function cloneRangeContents(range) {\n        var rangeFragment = range.cloneContents();\n        var parent = rangeFragment.childNodes[0];\n        var fragment = document.createDocumentFragment();\n\n        while (parent.childNodes.length) {\n          fragment.appendChild(parent.childNodes[0]);\n        }\n\n        return fragment;\n      },\n\n      /**\n       * Remove elements that were inserted for internal or user interface purposes\n       *\n       * @param {DOM node}\n       * @param {Boolean} whether to keep ui elements like spellchecking highlights\n       * Currently:\n       * - Saved ranges\n       */\n      unwrapInternalNodes: function unwrapInternalNodes(sibling, keepUiElements) {\n        while (sibling) {\n          var nextSibling = sibling.nextSibling;\n\n          if (sibling.nodeType === nodeType.elementNode) {\n            var attr = sibling.getAttribute('data-editable');\n\n            if (sibling.firstChild) {\n              this.unwrapInternalNodes(sibling.firstChild, keepUiElements);\n            }\n\n            if (attr === 'remove') {\n              $(sibling).remove();\n            } else if (attr === 'unwrap') {\n              this.unwrap(sibling);\n            } else if (attr === 'ui-remove' && !keepUiElements) {\n              $(sibling).remove();\n            } else if (attr === 'ui-unwrap' && !keepUiElements) {\n              this.unwrap(sibling);\n            }\n          }\n\n          sibling = nextSibling;\n        }\n      },\n\n      /**\n       * Get all tags that start or end inside the range\n       */\n      getTags: function getTags(host, range, filterFunc) {\n        var tags = this.getInnerTags(range, filterFunc); // get all tags that surround the range\n\n        var node = range.commonAncestorContainer;\n\n        while (node !== host) {\n          if (!filterFunc || filterFunc(node)) {\n            tags.push(node);\n          }\n\n          node = node.parentNode;\n        }\n\n        return tags;\n      },\n      getTagsByName: function getTagsByName(host, range, tagName) {\n        return this.getTags(host, range, function (node) {\n          return node.nodeName === tagName.toUpperCase();\n        });\n      },\n\n      /**\n       * Get all tags that start or end inside the range\n       */\n      getInnerTags: function getInnerTags(range, filterFunc) {\n        return range.getNodes([nodeType.elementNode], filterFunc);\n      },\n\n      /**\n       * Transform an array of elements into a an array\n       * of tagnames in uppercase\n       *\n       * @return example: ['STRONG', 'B']\n       */\n      getTagNames: function getTagNames(elements) {\n        var names = [];\n        if (!elements) return names;\n\n        for (var i = 0; i < elements.length; i++) {\n          names.push(elements[i].nodeName);\n        }\n\n        return names;\n      },\n      isAffectedBy: function isAffectedBy(host, range, tagName) {\n        var elem;\n        var tags = this.getTags(host, range);\n\n        for (var i = 0; i < tags.length; i++) {\n          elem = tags[i];\n\n          if (elem.nodeName === tagName.toUpperCase()) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n\n      /**\n       * Check if the range selects all of the elements contents,\n       * not less or more.\n       *\n       * @param visible: Only compare visible text. That way it does not\n       *   matter if the user selects an additional whitespace or not.\n       */\n      isExactSelection: function isExactSelection(range, elem, visible) {\n        var elemRange = rangy.createRange();\n        elemRange.selectNodeContents(elem);\n\n        if (range.intersectsRange(elemRange)) {\n          var rangeText = range.toString();\n          var elemText = $(elem).text();\n\n          if (visible) {\n            rangeText = string.trim(rangeText);\n            elemText = string.trim(elemText);\n          }\n\n          return rangeText !== '' && rangeText === elemText;\n        } else {\n          return false;\n        }\n      },\n      expandTo: function expandTo(host, range, elem) {\n        range.selectNodeContents(elem);\n        return range;\n      },\n      toggleTag: function toggleTag(host, range, elem) {\n        var elems = this.getTagsByName(host, range, elem.nodeName);\n\n        if (elems.length === 1 && this.isExactSelection(range, elems[0], 'visible')) {\n          return this.removeFormatting(host, range, elem.nodeName);\n        }\n\n        return this.forceWrap(host, range, elem);\n      },\n      isWrappable: function isWrappable(range) {\n        return range.canSurroundContents();\n      },\n      forceWrap: function forceWrap(host, range, elem) {\n        range = restoreRange(host, range, function () {\n          this.nuke(host, range, elem.nodeName);\n        }); // remove all tags if the range is not wrappable\n\n        if (!this.isWrappable(range)) {\n          range = restoreRange(host, range, function () {\n            this.nuke(host, range);\n          });\n        }\n\n        this.wrap(range, elem);\n        return range;\n      },\n      wrap: function wrap(range, elem) {\n        elem = string.isString(elem) ? $(elem)[0] : elem;\n\n        if (this.isWrappable(range)) {\n          var a = range.surroundContents(elem);\n        } else {\n          console.log('content.wrap(): can not surround range');\n        }\n      },\n      unwrap: function unwrap(elem) {\n        var $elem = $(elem);\n        var contents = $elem.contents();\n\n        if (contents.length) {\n          contents.unwrap();\n        } else {\n          $elem.remove();\n        }\n      },\n      removeFormatting: function removeFormatting(host, range, tagName) {\n        return restoreRange(host, range, function () {\n          this.nuke(host, range, tagName);\n        });\n      },\n\n      /**\n       * Unwrap all tags this range is affected by.\n       * Can also affect content outside of the range.\n       */\n      nuke: function nuke(host, range, tagName) {\n        var tags = this.getTags(host, range);\n\n        for (var i = 0; i < tags.length; i++) {\n          var elem = tags[i];\n\n          if (elem.nodeName !== 'BR' && (!tagName || elem.nodeName === tagName.toUpperCase())) {\n            this.unwrap(elem);\n          }\n        }\n      },\n\n      /**\n       * Insert a single character (or string) before or after the\n       * the range.\n       */\n      insertCharacter: function insertCharacter(range, character, atStart) {\n        var insertEl = document.createTextNode(character);\n        var boundaryRange = range.cloneRange();\n        boundaryRange.collapse(atStart);\n        boundaryRange.insertNode(insertEl);\n\n        if (atStart) {\n          range.setStartBefore(insertEl);\n        } else {\n          range.setEndAfter(insertEl);\n        }\n\n        range.normalizeBoundaries();\n      },\n\n      /**\n       * Surround the range with characters like start and end quotes.\n       *\n       * @method surround\n       */\n      surround: function surround(host, range, startCharacter, endCharacter) {\n        if (!endCharacter) endCharacter = startCharacter;\n        this.insertCharacter(range, endCharacter, false);\n        this.insertCharacter(range, startCharacter, true);\n        return range;\n      },\n\n      /**\n       * Removes a character from the text within a range.\n       *\n       * @method deleteCharacter\n       */\n      deleteCharacter: function deleteCharacter(host, range, character) {\n        if (this.containsString(range, character)) {\n          range.splitBoundaries();\n          range = restoreRange(host, range, function () {\n            var charRegexp = string.regexp(character);\n            var textNodes = range.getNodes([nodeType.textNode], function (node) {\n              return node.nodeValue.search(charRegexp) >= 0;\n            });\n\n            for (var i = 0; i < textNodes.length; i++) {\n              var node = textNodes[i];\n              node.nodeValue = node.nodeValue.replace(charRegexp, '');\n            }\n          });\n          range.normalizeBoundaries();\n        }\n\n        return range;\n      },\n      containsString: function containsString(range, str) {\n        var text = range.toString();\n        return text.indexOf(str) >= 0;\n      },\n\n      /**\n       * Unwrap all tags this range is affected by.\n       * Can also affect content outside of the range.\n       */\n      nukeTag: function nukeTag(host, range, tagName) {\n        var tags = this.getTags(host, range);\n\n        for (var i = 0; i < tags.length; i++) {\n          var elem = tags[i];\n          if (elem.nodeName === tagName) this.unwrap(elem);\n        }\n      }\n    };\n  }();\n  /**\n   * The Cursor module provides a cross-browser abstraction layer for cursor.\n   *\n   * @module core\n   * @submodule cursor\n   */\n\n\n  var Cursor = function () {\n    /**\n     * Class for the Cursor module.\n     *\n     * @class Cursor\n     * @constructor\n     */\n    var Cursor = function Cursor(editableHost, rangyRange) {\n      this.setHost(editableHost);\n      this.range = rangyRange;\n      this.isCursor = true;\n    };\n\n    Cursor.prototype = function () {\n      return {\n        isAtEnd: function isAtEnd() {\n          return parser.isEndOfHost(this.host, this.range.endContainer, this.range.endOffset);\n        },\n        isAtTextEnd: function isAtTextEnd() {\n          return parser.isTextEndOfHost(this.host, this.range.endContainer, this.range.endOffset);\n        },\n        isAtBeginning: function isAtBeginning() {\n          return parser.isBeginningOfHost(this.host, this.range.startContainer, this.range.startOffset);\n        },\n\n        /**\n         * Insert content before the cursor\n         *\n         * @param {String, DOM node or document fragment}\n         */\n        insertBefore: function insertBefore(element) {\n          if (string.isString(element)) {\n            element = content.createFragmentFromString(element);\n          }\n\n          if (parser.isDocumentFragmentWithoutChildren(element)) return;\n          element = this.adoptElement(element);\n          var preceedingElement = element;\n\n          if (element.nodeType === nodeType.documentFragmentNode) {\n            var lastIndex = element.childNodes.length - 1;\n            preceedingElement = element.childNodes[lastIndex];\n          }\n\n          this.range.insertNode(element);\n          this.range.setStartAfter(preceedingElement);\n          this.range.setEndAfter(preceedingElement);\n        },\n\n        /**\n         * Insert content after the cursor\n         *\n         * @param {String, DOM node or document fragment}\n         */\n        insertAfter: function insertAfter(element) {\n          if (string.isString(element)) {\n            element = content.createFragmentFromString(element);\n          }\n\n          if (parser.isDocumentFragmentWithoutChildren(element)) return;\n          element = this.adoptElement(element);\n          this.range.insertNode(element);\n        },\n\n        /**\n         * Alias for #setVisibleSelection()\n         */\n        setSelection: function setSelection() {\n          this.setVisibleSelection();\n        },\n        setVisibleSelection: function setVisibleSelection() {\n          // Without setting focus() Firefox is not happy (seems setting a selection is not enough.\n          // Probably because Firefox can handle multiple selections).\n          if (this.win.document.activeElement !== this.host) {\n            $(this.host).focus();\n          }\n\n          rangy.getSelection(this.win).setSingleRange(this.range);\n        },\n\n        /**\n         * Take the following example:\n         * (The character '|' represents the cursor position)\n         *\n         * <div contenteditable=\"true\">fo|o</div>\n         * before() will return a document frament containing a text node 'fo'.\n         *\n         * @returns {Document Fragment} content before the cursor or selection.\n         */\n        before: function before() {\n          var fragment = null;\n          var range = this.range.cloneRange();\n          range.setStartBefore(this.host);\n          fragment = content.cloneRangeContents(range);\n          return fragment;\n        },\n\n        /**\n         * Same as before() but returns a string.\n         */\n        beforeHtml: function beforeHtml() {\n          return content.getInnerHtmlOfFragment(this.before());\n        },\n\n        /**\n         * Take the following example:\n         * (The character '|' represents the cursor position)\n         *\n         * <div contenteditable=\"true\">fo|o</div>\n         * after() will return a document frament containing a text node 'o'.\n         *\n         * @returns {Document Fragment} content after the cursor or selection.\n         */\n        after: function after() {\n          var fragment = null;\n          var range = this.range.cloneRange();\n          range.setEndAfter(this.host);\n          fragment = content.cloneRangeContents(range);\n          return fragment;\n        },\n\n        /**\n         * Same as after() but returns a string.\n         */\n        afterHtml: function afterHtml() {\n          return content.getInnerHtmlOfFragment(this.after());\n        },\n\n        /**\n         * Get the BoundingClientRect of the cursor.\n         * The returned values are transformed to be absolute\n         # (relative to the document).\n         */\n        getCoordinates: function getCoordinates(positioning) {\n          positioning = positioning || 'absolute';\n          var coords = this.range.nativeRange.getBoundingClientRect();\n          if (positioning === 'fixed') return coords; // code from mdn: https://developer.mozilla.org/en-US/docs/Web/API/window.scrollX\n\n          var win = this.win;\n          var x = win.pageXOffset !== undefined ? win.pageXOffset : (win.document.documentElement || win.document.body.parentNode || win.document.body).scrollLeft;\n          var y = win.pageYOffset !== undefined ? win.pageYOffset : (win.document.documentElement || win.document.body.parentNode || win.document.body).scrollTop; // translate into absolute positions\n\n          return {\n            top: coords.top + y,\n            bottom: coords.bottom + y,\n            left: coords.left + x,\n            right: coords.right + x,\n            height: coords.height,\n            width: coords.width\n          };\n        },\n        moveBefore: function moveBefore(element) {\n          this.updateHost(element);\n          this.range.setStartBefore(element);\n          this.range.setEndBefore(element);\n          if (this.isSelection) return new Cursor(this.host, this.range);\n        },\n        moveAfter: function moveAfter(element) {\n          this.updateHost(element);\n          this.range.setStartAfter(element);\n          this.range.setEndAfter(element);\n          if (this.isSelection) return new Cursor(this.host, this.range);\n        },\n\n        /**\n         * Move the cursor to the beginning of the host.\n         */\n        moveAtBeginning: function moveAtBeginning(element) {\n          if (!element) element = this.host;\n          this.updateHost(element);\n          this.range.selectNodeContents(element);\n          this.range.collapse(true);\n          if (this.isSelection) return new Cursor(this.host, this.range);\n        },\n\n        /**\n         * Move the cursor to the end of the host.\n         */\n        moveAtEnd: function moveAtEnd(element) {\n          if (!element) element = this.host;\n          this.updateHost(element);\n          this.range.selectNodeContents(element);\n          this.range.collapse(false);\n          if (this.isSelection) return new Cursor(this.host, this.range);\n        },\n\n        /**\n         * Move the cursor after the last visible character of the host.\n         */\n        moveAtTextEnd: function moveAtTextEnd(element) {\n          return this.moveAtEnd(parser.latestChild(element));\n        },\n        setHost: function setHost(element) {\n          if (element.jquery) element = element[0];\n          this.host = element;\n          this.win = element === undefined || element === null ? window : element.ownerDocument.defaultView;\n        },\n        updateHost: function updateHost(element) {\n          var host = parser.getHost(element);\n\n          if (!host) {\n            error('Can not set cursor outside of an editable block');\n          }\n\n          this.setHost(host);\n        },\n        retainVisibleSelection: function retainVisibleSelection(callback) {\n          this.save();\n          callback();\n          this.restore();\n          this.setVisibleSelection();\n        },\n        save: function save() {\n          this.savedRangeInfo = rangeSaveRestore.save(this.range);\n          this.savedRangeInfo.host = this.host;\n        },\n        restore: function restore() {\n          if (this.savedRangeInfo) {\n            this.host = this.savedRangeInfo.host;\n            this.range = rangeSaveRestore.restore(this.host, this.savedRangeInfo);\n            this.savedRangeInfo = undefined;\n          } else {\n            error('Could not restore selection');\n          }\n        },\n        equals: function equals(cursor) {\n          if (!cursor) return false;\n          if (!cursor.host) return false;\n          if (!cursor.host.isEqualNode(this.host)) return false;\n          if (!cursor.range) return false;\n          if (!cursor.range.equals(this.range)) return false;\n          return true;\n        },\n        // Create an element with the correct ownerWindow\n        // (see: http://www.w3.org/DOM/faq.html#ownerdoc)\n        createElement: function createElement(tagName) {\n          return this.win.document.createElement(tagName);\n        },\n        // Make sure a node has the correct ownerWindow\n        // (see: https://developer.mozilla.org/en-US/docs/Web/API/Document/importNode)\n        adoptElement: function adoptElement(node) {\n          return content.adoptElement(node, this.win.document);\n        },\n        // Currently we call triggerChange manually after format changes.\n        // This is to prevent excessive triggering of the change event during\n        // merge or split operations or other manipulations by scripts.\n        triggerChange: function triggerChange() {\n          $(this.host).trigger('formatEditable');\n        }\n      };\n    }();\n\n    return Cursor;\n  }();\n  /**\n   * The Behavior module defines the behavior triggered in response to the Editable.JS\n   * events (see {{#crossLink \"Editable\"}}{{/crossLink}}).\n   * The behavior can be overwritten by a user with Editable.init() or on\n   * Editable.add() per element.\n   *\n   * @module core\n   * @submodule behavior\n   */\n\n\n  var createDefaultBehavior = function createDefaultBehavior(editable) {\n    var document = editable.win.document;\n    var selectionWatcher = editable.dispatcher.selectionWatcher;\n    /**\n      * Factory for the default behavior.\n      * Provides default behavior of the Editable.JS API.\n      *\n      * @static\n      */\n\n    return {\n      focus: function focus(element) {\n        // Add a <br> element if the editable is empty to force it to have height\n        // E.g. Firefox does not render empty block elements and most browsers do\n        // not render  empty inline elements.\n        if (parser.isVoid(element)) {\n          var br = document.createElement('br');\n          br.setAttribute('data-editable', 'remove');\n          element.appendChild(br);\n        }\n      },\n      blur: function blur(element) {\n        content.cleanInternals(element);\n      },\n      selection: function selection(element, _selection) {\n        if (_selection) {\n          log('Default selection behavior');\n        } else {\n          log('Default selection empty behavior');\n        }\n      },\n      cursor: function cursor(element, _cursor) {\n        if (_cursor) {\n          log('Default cursor behavior');\n        } else {\n          log('Default cursor empty behavior');\n        }\n      },\n      newline: function newline(element, cursor) {\n        var atEnd = cursor.isAtEnd();\n        var br = document.createElement('br');\n        cursor.insertBefore(br);\n\n        if (atEnd) {\n          log('at the end');\n          var noWidthSpace = document.createTextNode(\"\\u200B\");\n          cursor.insertAfter(noWidthSpace); // var trailingBr = document.createElement('br');\n          // trailingBr.setAttribute('type', '-editablejs');\n          // cursor.insertAfter(trailingBr);\n        } else {\n          log('not at the end');\n        }\n\n        cursor.setVisibleSelection();\n      },\n      insert: function insert(element, direction, cursor) {\n        var parent = element.parentNode;\n        var newElement = element.cloneNode(false);\n        if (newElement.id) newElement.removeAttribute('id');\n\n        switch (direction) {\n          case 'before':\n            parent.insertBefore(newElement, element);\n            element.focus();\n            break;\n\n          case 'after':\n            parent.insertBefore(newElement, element.nextSibling);\n            newElement.focus();\n            break;\n        }\n      },\n      split: function split(element, before, after, cursor) {\n        var newNode = element.cloneNode();\n        newNode.appendChild(before);\n        var parent = element.parentNode;\n        parent.insertBefore(newNode, element);\n\n        while (element.firstChild) {\n          element.removeChild(element.firstChild);\n        }\n\n        element.appendChild(after);\n        content.tidyHtml(newNode);\n        content.tidyHtml(element);\n        element.focus();\n      },\n      merge: function merge(element, direction, cursor) {\n        var container, merger, fragment, chunks, i, newChild, range;\n\n        switch (direction) {\n          case 'before':\n            container = block.previous(element);\n            merger = element;\n            break;\n\n          case 'after':\n            container = element;\n            merger = block.next(element);\n            break;\n        }\n\n        if (!(container && merger)) return;\n\n        if (container.childNodes.length > 0) {\n          cursor = editable.appendTo(container, merger.innerHTML);\n        } else {\n          cursor = editable.prependTo(container, merger.innerHTML);\n        } // remove merged node\n\n\n        merger.parentNode.removeChild(merger);\n        cursor.save();\n        content.tidyHtml(container);\n        cursor.restore();\n        cursor.setVisibleSelection();\n      },\n      empty: function empty(element) {\n        log('Default empty behavior');\n      },\n      'switch': function _switch(element, direction, cursor) {\n        var next, previous;\n\n        switch (direction) {\n          case 'before':\n            previous = block.previous(element);\n\n            if (previous) {\n              cursor.moveAtTextEnd(previous);\n              cursor.setVisibleSelection();\n            }\n\n            break;\n\n          case 'after':\n            next = block.next(element);\n\n            if (next) {\n              cursor.moveAtBeginning(next);\n              cursor.setVisibleSelection();\n            }\n\n            break;\n        }\n      },\n      move: function move(element, selection, direction) {\n        log('Default move behavior');\n      },\n      paste: function paste(element, blocks, cursor) {\n        var fragment;\n        var firstBlock = blocks[0];\n        cursor.insertBefore(firstBlock);\n\n        if (blocks.length <= 1) {\n          cursor.setVisibleSelection();\n        } else {\n          var parent = element.parentNode;\n          var currentElement = element;\n\n          for (var i = 1; i < blocks.length; i++) {\n            var newElement = element.cloneNode(false);\n            if (newElement.id) newElement.removeAttribute('id');\n            fragment = content.createFragmentFromString(blocks[i]);\n            $(newElement).append(fragment);\n            parent.insertBefore(newElement, currentElement.nextSibling);\n            currentElement = newElement;\n          } // focus last element\n\n\n          cursor = editable.createCursorAtEnd(currentElement);\n          cursor.setVisibleSelection();\n        }\n      },\n      clipboard: function clipboard(element, action, cursor) {\n        log('Default clipboard behavior');\n      }\n    };\n  };\n\n  var createDefaultEvents = function createDefaultEvents(editable) {\n    var behavior = createDefaultBehavior(editable);\n    return {\n      /**\n       * The focus event is triggered when an element gains focus.\n       * The default behavior is to... TODO\n       *\n       * @event focus\n       * @param {HTMLElement} element The element triggering the event.\n       */\n      focus: function focus(element) {\n        behavior.focus(element);\n      },\n\n      /**\n       * The blur event is triggered when an element looses focus.\n       * The default behavior is to... TODO\n       *\n       * @event blur\n       * @param {HTMLElement} element The element triggering the event.\n       */\n      blur: function blur(element) {\n        behavior.blur(element);\n      },\n\n      /**\n       * The flow event is triggered when the user starts typing or pause typing.\n       * The default behavior is to... TODO\n       *\n       * @event flow\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {String} action The flow action: \"start\" or \"pause\".\n       */\n      flow: function flow(element, action) {\n        behavior.flow(element, action);\n      },\n\n      /**\n       * The selection event is triggered after the user has selected some\n       * content.\n       * The default behavior is to... TODO\n       *\n       * @event selection\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {Selection} selection The actual Selection object.\n       */\n      selection: function selection(element, _selection2) {\n        behavior.selection(element, _selection2);\n      },\n\n      /**\n       * The cursor event is triggered after cursor position has changed.\n       * The default behavior is to... TODO\n       *\n       * @event cursor\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {Cursor} cursor The actual Cursor object.\n       */\n      cursor: function cursor(element, _cursor2) {\n        behavior.cursor(element, _cursor2);\n      },\n\n      /**\n       * The newline event is triggered when a newline should be inserted. This\n       * happens when SHIFT+ENTER key is pressed.\n       * The default behavior is to add a <br />\n       *\n       * @event newline\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {Cursor} cursor The actual cursor object.\n       */\n      newline: function newline(element, cursor) {\n        behavior.newline(element, cursor);\n      },\n\n      /**\n       * The split event is triggered when a block should be splitted into two\n       * blocks. This happens when ENTER is pressed within a non-empty block.\n       * The default behavior is to... TODO\n       *\n       * @event split\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {String} before The HTML string before the split.\n       * @param {String} after The HTML string after the split.\n       * @param {Cursor} cursor The actual cursor object.\n       */\n      split: function split(element, before, after, cursor) {\n        behavior.split(element, before, after, cursor);\n      },\n\n      /**\n       * The insert event is triggered when a new block should be inserted. This\n       * happens when ENTER key is pressed at the beginning of a block (should\n       * insert before) or at the end of a block (should insert after).\n       * The default behavior is to... TODO\n       *\n       * @event insert\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {String} direction The insert direction: \"before\" or \"after\".\n       * @param {Cursor} cursor The actual cursor object.\n       */\n      insert: function insert(element, direction, cursor) {\n        behavior.insert(element, direction, cursor);\n      },\n\n      /**\n       * The merge event is triggered when two needs to be merged. This happens\n       * when BACKSPACE is pressed at the beginning of a block (should merge with\n       * the preceeding block) or DEL is pressed at the end of a block (should\n       * merge with the following block).\n       * The default behavior is to... TODO\n       *\n       * @event merge\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {String} direction The merge direction: \"before\" or \"after\".\n       * @param {Cursor} cursor The actual cursor object.\n       */\n      merge: function merge(element, direction, cursor) {\n        behavior.merge(element, direction, cursor);\n      },\n\n      /**\n       * The empty event is triggered when a block is emptied.\n       * The default behavior is to... TODO\n       *\n       * @event empty\n       * @param {HTMLElement} element The element triggering the event.\n       */\n      empty: function empty(element) {\n        behavior.empty(element);\n      },\n\n      /**\n       * The switch event is triggered when the user switches to another block.\n       * This happens when an ARROW key is pressed near the boundaries of a block.\n       * The default behavior is to... TODO\n       *\n       * @event switch\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {String} direction The switch direction: \"before\" or \"after\".\n       * @param {Cursor} cursor The actual cursor object.*\n       */\n      'switch': function _switch(element, direction, cursor) {\n        behavior.switch(element, direction, cursor);\n      },\n\n      /**\n       * The move event is triggered when the user moves a selection in a block.\n       * This happens when the user selects some (or all) content in a block and\n       * an ARROW key is pressed (up: drag before, down: drag after).\n       * The default behavior is to... TODO\n       *\n       * @event move\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {Selection} selection The actual Selection object.\n       * @param {String} direction The move direction: \"before\" or \"after\".\n       */\n      move: function move(element, selection, direction) {\n        behavior.move(element, selection, direction);\n      },\n\n      /**\n       * The clipboard event is triggered when the user copies or cuts\n       * a selection within a block.\n       *\n       * @event clipboard\n       * @param {HTMLElement} element The element triggering the event.\n       * @param {String} action The clipboard action: \"copy\" or \"cut\".\n       * @param {Cursor} cursor The actual cursor object.\n       */\n      clipboard: function clipboard(element, action, cursor) {\n        behavior.clipboard(element, action, cursor);\n      },\n\n      /**\n       * The paste event is triggered when the user pastes text\n       *\n       * @event paste\n       * @param {HTMLElement} The element triggering the event.\n       * @param {Array of String} The pasted blocks\n       * @param {Cursor} The cursor object.\n       */\n      paste: function paste(element, blocks, cursor) {\n        behavior.paste(element, blocks, cursor);\n      }\n    };\n  };\n  /**\n   * The Dispatcher module is responsible for dealing with events and their handlers.\n   *\n   * @module core\n   * @submodule dispatcher\n   */\n\n\n  var Dispatcher = function Dispatcher(editable) {\n    var win = editable.win;\n    eventable(this, editable);\n    this.supportsInputEvent = false;\n    this.$document = $(win.document);\n    this.config = editable.config;\n    this.editable = editable;\n    this.editableSelector = editable.editableSelector;\n    this.keyboard = new Keyboard();\n    this.selectionWatcher = new SelectionWatcher(this, win);\n    this.setup();\n  }; // This will be set to true once we detect the input event is working.\n  // Input event description on MDN:\n  // https://developer.mozilla.org/en-US/docs/Web/Reference/Events/input\n\n\n  var isInputEventSupported = false;\n  /**\n   * Sets up all events that Editable.JS is catching.\n   *\n   * @method setup\n   */\n\n  Dispatcher.prototype.setup = function () {\n    // setup all events notifications\n    this.setupElementEvents();\n    this.setupKeyboardEvents();\n\n    if (browserFeatures.selectionchange) {\n      this.setupSelectionChangeEvents();\n    } else {\n      this.setupSelectionChangeFallback();\n    }\n  };\n\n  Dispatcher.prototype.unload = function () {\n    this.off();\n    this.$document.off('.editable');\n  };\n  /**\n   * Sets up events that are triggered on modifying an element.\n   *\n   * @method setupElementEvents\n   * @param {HTMLElement} $document: The document element.\n   * @param {Function} notifier: The callback to be triggered when the event is caught.\n   */\n\n\n  Dispatcher.prototype.setupElementEvents = function () {\n    var _this = this;\n\n    this.$document.on('focus.editable', _this.editableSelector, function (event) {\n      if (this.getAttribute(config.pastingAttribute)) return;\n\n      _this.notify('focus', this);\n    }).on('blur.editable', _this.editableSelector, function (event) {\n      if (this.getAttribute(config.pastingAttribute)) return;\n\n      _this.notify('blur', this);\n    }).on('copy.editable', _this.editableSelector, function (event) {\n      _this.notify('clipboard', this, 'copy', _this.selectionWatcher.getFreshSelection());\n    }).on('cut.editable', _this.editableSelector, function (event) {\n      _this.notify('clipboard', this, 'cut', _this.selectionWatcher.getFreshSelection());\n\n      _this.triggerChangeEvent(this);\n    }).on('paste.editable', _this.editableSelector, function (event) {\n      var element = this;\n\n      var afterPaste = function afterPaste(blocks, cursor) {\n        if (blocks.length) {\n          _this.notify('paste', element, blocks, cursor); // The input event does not fire when we process the content manually\n          // and insert it via script\n\n\n          _this.notify('change', element);\n        } else {\n          cursor.setVisibleSelection();\n        }\n      };\n\n      var cursor = _this.selectionWatcher.getFreshSelection();\n\n      clipboard.paste(this, cursor, afterPaste);\n    }).on('input.editable', _this.editableSelector, function (event) {\n      if (isInputEventSupported) {\n        _this.notify('change', this);\n      } else {\n        // Most likely the event was already handled manually by\n        // triggerChangeEvent so the first time we just switch the\n        // isInputEventSupported flag without notifiying the change event.\n        isInputEventSupported = true;\n      }\n    }).on('formatEditable.editable', _this.editableSelector, function (event) {\n      _this.notify('change', this);\n    });\n  };\n  /**\n   * Trigger a change event\n   *\n   * This should be done in these cases:\n   * - typing a letter\n   * - delete (backspace and delete keys)\n   * - cut\n   * - paste\n   * - copy and paste (not easily possible manually as far as I know)\n   *\n   * Preferrably this is done using the input event. But the input event is not\n   * supported on all browsers for contenteditable elements.\n   * To make things worse it is not detectable either. So instead of detecting\n   * we set 'isInputEventSupported' when the input event fires the first time.\n   */\n\n\n  Dispatcher.prototype.triggerChangeEvent = function (target) {\n    if (isInputEventSupported) return;\n    this.notify('change', target);\n  };\n\n  Dispatcher.prototype.dispatchSwitchEvent = function (event, element, direction) {\n    var cursor;\n    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return;\n    cursor = this.selectionWatcher.getSelection();\n    if (!cursor || cursor.isSelection) return; // Detect if the browser moved the cursor in the next tick.\n    // If the cursor stays at its position, fire the switch event.\n\n    var dispatcher = this;\n    setTimeout(function () {\n      var newCursor = dispatcher.selectionWatcher.forceCursor();\n\n      if (newCursor.equals(cursor)) {\n        event.preventDefault();\n        event.stopPropagation();\n        dispatcher.notify('switch', element, direction, newCursor);\n      }\n    }, 1);\n  };\n  /**\n   * Sets up events that are triggered on keyboard events.\n   * Keyboard definitions are in {{#crossLink \"Keyboard\"}}{{/crossLink}}.\n   *\n   * @method setupKeyboardEvents\n   * @param {HTMLElement} $document: The document element.\n   * @param {Function} notifier: The callback to be triggered when the event is caught.\n   */\n\n\n  Dispatcher.prototype.setupKeyboardEvents = function () {\n    var _this = this;\n\n    this.$document.on('keydown.editable', this.editableSelector, function (event) {\n      var notifyCharacterEvent = !isInputEventSupported;\n\n      _this.keyboard.dispatchKeyEvent(event, this, notifyCharacterEvent);\n    });\n    this.keyboard.on('left', function (event) {\n      _this.dispatchSwitchEvent(event, this, 'before');\n    }).on('up', function (event) {\n      _this.dispatchSwitchEvent(event, this, 'before');\n    }).on('right', function (event) {\n      _this.dispatchSwitchEvent(event, this, 'after');\n    }).on('down', function (event) {\n      _this.dispatchSwitchEvent(event, this, 'after');\n    }).on('tab', function (event) {}).on('shiftTab', function (event) {}).on('esc', function (event) {}).on('backspace', function (event) {\n      var range = _this.selectionWatcher.getFreshRange();\n\n      if (range.isCursor) {\n        var cursor = range.getCursor();\n\n        if (cursor.isAtBeginning()) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          _this.notify('merge', this, 'before', cursor);\n        } else {\n          _this.triggerChangeEvent(this);\n        }\n      } else {\n        _this.triggerChangeEvent(this);\n      }\n    }).on('delete', function (event) {\n      var range = _this.selectionWatcher.getFreshRange();\n\n      if (range.isCursor) {\n        var cursor = range.getCursor();\n\n        if (cursor.isAtTextEnd()) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          _this.notify('merge', this, 'after', cursor);\n        } else {\n          _this.triggerChangeEvent(this);\n        }\n      } else {\n        _this.triggerChangeEvent(this);\n      }\n    }).on('enter', function (event) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      var range = _this.selectionWatcher.getFreshRange();\n\n      var cursor = range.forceCursor();\n\n      if (cursor.isAtTextEnd()) {\n        _this.notify('insert', this, 'after', cursor);\n      } else if (cursor.isAtBeginning()) {\n        _this.notify('insert', this, 'before', cursor);\n      } else {\n        _this.notify('split', this, cursor.before(), cursor.after(), cursor);\n      }\n    }).on('shiftEnter', function (event) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      var cursor = _this.selectionWatcher.forceCursor();\n\n      _this.notify('newline', this, cursor);\n    }).on('character', function (event) {\n      _this.notify('change', this);\n    });\n  };\n  /**\n   * Sets up events that are triggered on a selection change.\n   *\n   * @method setupSelectionChangeEvents\n   * @param {HTMLElement} $document: The document element.\n   * @param {Function} notifier: The callback to be triggered when the event is caught.\n   */\n\n\n  Dispatcher.prototype.setupSelectionChangeEvents = function () {\n    var selectionDirty = false;\n    var suppressSelectionChanges = false;\n    var $document = this.$document;\n    var selectionWatcher = this.selectionWatcher;\n\n    var _this = this; // fires on mousemove (thats probably a bit too much)\n    // catches changes like 'select all' from context menu\n\n\n    $document.on('selectionchange.editable', function (event) {\n      if (suppressSelectionChanges) {\n        selectionDirty = true;\n      } else {\n        selectionWatcher.selectionChanged();\n      }\n    }); // listen for selection changes by mouse so we can\n    // suppress the selectionchange event and only fire the\n    // change event on mouseup\n\n    $document.on('mousedown.editable', this.editableSelector, function (event) {\n      if (_this.config.mouseMoveSelectionChanges === false) {\n        suppressSelectionChanges = true; // Without this timeout the previous selection is active\n        // until the mouseup event (no. not good).\n\n        setTimeout($.proxy(selectionWatcher, 'selectionChanged'), 0);\n      }\n\n      $document.on('mouseup.editableSelection', function (event) {\n        $document.off('.editableSelection');\n        suppressSelectionChanges = false;\n\n        if (selectionDirty) {\n          selectionDirty = false;\n          selectionWatcher.selectionChanged();\n        }\n      });\n    });\n  };\n  /**\n   * Fallback solution to support selection change events on browsers that don't\n   * support selectionChange.\n   *\n   * @method setupSelectionChangeFallback\n   * @param {HTMLElement} $document: The document element.\n   * @param {Function} notifier: The callback to be triggered when the event is caught.\n   */\n\n\n  Dispatcher.prototype.setupSelectionChangeFallback = function () {\n    var $document = this.$document;\n    var selectionWatcher = this.selectionWatcher; // listen for selection changes by mouse\n\n    $document.on('mouseup.editableSelection', function (event) {\n      // In Opera when clicking outside of a block\n      // it does not update the selection as it should\n      // without the timeout\n      setTimeout($.proxy(selectionWatcher, 'selectionChanged'), 0);\n    }); // listen for selection changes by keys\n\n    $document.on('keyup.editable', this.editableSelector, function (event) {\n      // when pressing Command + Shift + Left for example the keyup is only triggered\n      // after at least two keys are released. Strange. The culprit seems to be the\n      // Command key. Do we need a workaround?\n      selectionWatcher.selectionChanged();\n    });\n  }; // Eventable Mixin.\n  //\n  // Simple mixin to add event emitter methods to an object (Publish/Subscribe).\n  //\n  // Add on, off and notify methods to an object:\n  // eventable(obj);\n  //\n  // publish an event:\n  // obj.notify(context, 'action', param1, param2);\n  //\n  // Optionally pass a context that will be applied to every event:\n  // eventable(obj, context);\n  //\n  // With this publishing can omit the context argument:\n  // obj.notify('action', param1, param2);\n  //\n  // Subscribe to a 'channel'\n  // obj.on('action', funtion(param1, param2){ ... });\n  //\n  // Unsubscribe an individual listener:\n  // obj.off('action', method);\n  //\n  // Unsubscribe all listeners of a channel:\n  // obj.off('action');\n  //\n  // Unsubscribe all listeners of all channels:\n  // obj.off();\n\n\n  var getEventableModule = function getEventableModule(notifyContext) {\n    var listeners = {};\n\n    var addListener = function addListener(event, listener) {\n      if (listeners[event] === undefined) {\n        listeners[event] = [];\n      }\n\n      listeners[event].push(listener);\n    };\n\n    var removeListener = function removeListener(event, listener) {\n      var eventListeners = listeners[event];\n      if (eventListeners === undefined) return;\n\n      for (var i = 0, len = eventListeners.length; i < len; i++) {\n        if (eventListeners[i] === listener) {\n          eventListeners.splice(i, 1);\n          break;\n        }\n      }\n    }; // Public Methods\n\n\n    return {\n      on: function on(event, listener) {\n        if (arguments.length === 2) {\n          addListener(event, listener);\n        } else if (arguments.length === 1) {\n          var eventObj = event;\n\n          for (var eventType in eventObj) {\n            addListener(eventType, eventObj[eventType]);\n          }\n        }\n\n        return this;\n      },\n      off: function off(event, listener) {\n        if (arguments.length === 2) {\n          removeListener(event, listener);\n        } else if (arguments.length === 1) {\n          listeners[event] = [];\n        } else {\n          listeners = {};\n        }\n      },\n      notify: function notify(context, event) {\n        var args;\n\n        if (notifyContext) {\n          event = context;\n          context = notifyContext;\n          args = Array.prototype.slice.call(arguments).splice(1);\n        } else {\n          args = Array.prototype.slice.call(arguments).splice(2);\n        }\n\n        var eventListeners = listeners[event];\n        if (eventListeners === undefined) return; // Traverse backwards and execute the newest listeners first.\n        // Stop if a listener returns false.\n\n        for (var i = eventListeners.length - 1; i >= 0; i--) {\n          if (eventListeners[i].apply(context, args) === false) break;\n        }\n      }\n    };\n  };\n\n  var eventable = function eventable(obj, notifyContext) {\n    var module = getEventableModule(notifyContext);\n\n    for (var prop in module) {\n      obj[prop] = module[prop];\n    }\n  };\n\n  var browserFeatures = function () {\n    /**\n     * Check for contenteditable support\n     *\n     * (from Modernizr)\n     * this is known to false positive in some mobile browsers\n     * here is a whitelist of verified working browsers:\n     * https://github.com/NielsLeenheer/html5test/blob/549f6eac866aa861d9649a0707ff2c0157895706/scripts/engine.js#L2083\n     */\n    var contenteditable = typeof document.documentElement.contentEditable !== 'undefined';\n    /**\n     * Check selectionchange event (currently supported in IE, Chrome and Safari)\n     *\n     * To handle selectionchange in firefox see CKEditor selection object\n     * https://github.com/ckeditor/ckeditor-dev/blob/master/core/selection.js#L388\n     */\n\n    var selectionchange = function () {\n      // not exactly feature detection... is it?\n      return !(bowser.gecko || bowser.opera);\n    }();\n\n    return {\n      contenteditable: contenteditable,\n      selectionchange: selectionchange\n    };\n  }();\n\n  var highlightText = function () {\n    return {\n      extractText: function extractText(element) {\n        var text = '';\n        this.getText(element, function (part) {\n          text += part;\n        });\n        return text;\n      },\n      // Extract the text of an element.\n      // This has two notable behaviours:\n      // - It uses a NodeIterator which will skip elements\n      //   with data-editable=\"remove\"\n      // - It returns a space for <br> elements\n      //   (The only block level element allowed inside of editables)\n      getText: function getText(element, callback) {\n        var iterator = new NodeIterator(element);\n        var next;\n\n        while (next = iterator.getNext()) {\n          if (next.nodeType === nodeType.textNode && next.data !== '') {\n            callback(next.data);\n          } else if (next.nodeType === nodeType.elementNode && next.nodeName === 'BR') {\n            callback(' ');\n          }\n        }\n      },\n      highlight: function highlight(element, regex, stencilElement) {\n        var matches = this.find(element, regex);\n        this.highlightMatches(element, matches, stencilElement);\n      },\n      find: function find(element, regex) {\n        var text = this.extractText(element);\n        var match;\n        var matches = [];\n        var matchIndex = 0;\n\n        while (match = regex.exec(text)) {\n          matches.push(this.prepareMatch(match, matchIndex));\n          matchIndex += 1;\n        }\n\n        return matches;\n      },\n      highlightMatches: function highlightMatches(element, matches, stencilElement) {\n        if (!matches || matches.length === 0) {\n          return;\n        }\n\n        var next, textNode, length, offset, isFirstPortion, isLastPortion, wordId;\n        var currentMatchIndex = 0;\n        var currentMatch = matches[currentMatchIndex];\n        var totalOffset = 0;\n        var iterator = new NodeIterator(element);\n        var portions = [];\n\n        while (next = iterator.getNext()) {\n          // Account for <br> elements\n          if (next.nodeType === nodeType.textNode && next.data !== '') {\n            textNode = next;\n          } else if (next.nodeType === nodeType.elementNode && next.nodeName === 'BR') {\n            totalOffset = totalOffset + 1;\n            continue;\n          } else {\n            continue;\n          }\n\n          var nodeText = textNode.data;\n          var nodeEndOffset = totalOffset + nodeText.length;\n\n          if (currentMatch.startIndex < nodeEndOffset && totalOffset < currentMatch.endIndex) {\n            // get portion position (fist, last or in the middle)\n            isFirstPortion = isLastPortion = false;\n\n            if (totalOffset <= currentMatch.startIndex) {\n              isFirstPortion = true;\n              wordId = currentMatch.startIndex;\n            }\n\n            if (nodeEndOffset >= currentMatch.endIndex) {\n              isLastPortion = true;\n            } // calculate offset and length\n\n\n            if (isFirstPortion) {\n              offset = currentMatch.startIndex - totalOffset;\n            } else {\n              offset = 0;\n            }\n\n            if (isLastPortion) {\n              length = currentMatch.endIndex - totalOffset - offset;\n            } else {\n              length = nodeText.length - offset;\n            } // create portion object\n\n\n            var portion = {\n              element: textNode,\n              text: nodeText.substring(offset, offset + length),\n              offset: offset,\n              length: length,\n              isLastPortion: isLastPortion,\n              wordId: wordId\n            };\n            portions.push(portion);\n\n            if (isLastPortion) {\n              var lastNode = this.wrapWord(portions, stencilElement);\n              iterator.replaceCurrent(lastNode); // recalculate nodeEndOffset if we have to replace the current node.\n\n              nodeEndOffset = totalOffset + portion.length + portion.offset;\n              portions = [];\n              currentMatchIndex += 1;\n\n              if (currentMatchIndex < matches.length) {\n                currentMatch = matches[currentMatchIndex];\n              }\n            }\n          }\n\n          totalOffset = nodeEndOffset;\n        }\n      },\n      getRange: function getRange(element) {\n        var range = rangy.createRange();\n        range.selectNodeContents(element);\n        return range;\n      },\n      // @return the last wrapped element\n      wrapWord: function wrapWord(portions, stencilElement) {\n        var element;\n\n        for (var i = 0; i < portions.length; i++) {\n          var portion = portions[i];\n          element = this.wrapPortion(portion, stencilElement);\n        }\n\n        return element;\n      },\n      wrapPortion: function wrapPortion(portion, stencilElement) {\n        var range = rangy.createRange();\n        range.setStart(portion.element, portion.offset);\n        range.setEnd(portion.element, portion.offset + portion.length);\n        var node = stencilElement.cloneNode(true);\n        node.setAttribute('data-word-id', portion.wordId);\n        range.surroundContents(node); // Fix a weird behaviour where an empty text node is inserted after the range\n\n        if (node.nextSibling) {\n          var next = node.nextSibling;\n\n          if (next.nodeType === nodeType.textNode && next.data === '') {\n            next.parentNode.removeChild(next);\n          }\n        }\n\n        return node;\n      },\n      prepareMatch: function prepareMatch(match, matchIndex) {\n        // Quickfix for the spellcheck regex where we need to match the second subgroup.\n        if (match[2]) {\n          return this.prepareMatchForSecondSubgroup(match, matchIndex);\n        }\n\n        return {\n          startIndex: match.index,\n          endIndex: match.index + match[0].length,\n          matchIndex: matchIndex,\n          search: match[0]\n        };\n      },\n      prepareMatchForSecondSubgroup: function prepareMatchForSecondSubgroup(match, matchIndex) {\n        var index = match.index;\n        index += match[1].length;\n        return {\n          startIndex: index,\n          endIndex: index + match[2].length,\n          matchIndex: matchIndex,\n          search: match[0]\n        };\n      }\n    };\n  }();\n  /**\n   * The Keyboard module defines an event API for key events.\n   */\n\n\n  var Keyboard = function Keyboard() {\n    eventable(this);\n  };\n\n  Keyboard.prototype.dispatchKeyEvent = function (event, target, notifyCharacterEvent) {\n    switch (event.keyCode) {\n      case this.key.left:\n        this.notify(target, 'left', event);\n        break;\n\n      case this.key.right:\n        this.notify(target, 'right', event);\n        break;\n\n      case this.key.up:\n        this.notify(target, 'up', event);\n        break;\n\n      case this.key.down:\n        this.notify(target, 'down', event);\n        break;\n\n      case this.key.tab:\n        if (event.shiftKey) {\n          this.notify(target, 'shiftTab', event);\n        } else {\n          this.notify(target, 'tab', event);\n        }\n\n        break;\n\n      case this.key.esc:\n        this.notify(target, 'esc', event);\n        break;\n\n      case this.key.backspace:\n        this.notify(target, 'backspace', event);\n        break;\n\n      case this.key['delete']:\n        this.notify(target, 'delete', event);\n        break;\n\n      case this.key.enter:\n        if (event.shiftKey) {\n          this.notify(target, 'shiftEnter', event);\n        } else {\n          this.notify(target, 'enter', event);\n        }\n\n        break;\n\n      case this.key.ctrl:\n      case this.key.shift:\n      case this.key.alt:\n        break;\n      // Metakey\n\n      case 224: // Firefox: 224\n\n      case 17: // Opera: 17\n\n      case 91: // Chrome/Safari: 91 (Left)\n\n      case 93:\n        // Chrome/Safari: 93 (Right)\n        break;\n\n      default:\n        if (notifyCharacterEvent) {\n          this.notify(target, 'character', event);\n        }\n\n    }\n  };\n\n  Keyboard.prototype.key = {\n    left: 37,\n    up: 38,\n    right: 39,\n    down: 40,\n    tab: 9,\n    esc: 27,\n    backspace: 8,\n    'delete': 46,\n    enter: 13,\n    shift: 16,\n    ctrl: 17,\n    alt: 18\n  };\n  Keyboard.key = Keyboard.prototype.key; // A DOM node iterator.\n  //\n  // Has the ability to replace nodes on the fly and continue\n  // the iteration.\n\n  var NodeIterator = function () {\n    var NodeIterator = function NodeIterator(root) {\n      this.root = root;\n      this.current = this.next = this.root;\n    };\n\n    NodeIterator.prototype.getNextTextNode = function () {\n      var next;\n\n      while (next = this.getNext()) {\n        if (next.nodeType === nodeType.textNode && next.data !== '') {\n          return next;\n        }\n      }\n    };\n\n    NodeIterator.prototype.getNext = function () {\n      var child, n;\n      n = this.current = this.next;\n      child = this.next = undefined;\n\n      if (this.current) {\n        child = n.firstChild; // Skip the children of elements with the attribute data-editable=\"remove\"\n        // This prevents text nodes that are not part of the content to be included.\n\n        if (child && n.getAttribute('data-editable') !== 'remove') {\n          this.next = child;\n        } else {\n          while (n !== this.root && !(this.next = n.nextSibling)) {\n            n = n.parentNode;\n          }\n        }\n      }\n\n      return this.current;\n    };\n\n    NodeIterator.prototype.replaceCurrent = function (replacement) {\n      this.current = replacement;\n      this.next = undefined;\n      var n = this.current;\n\n      while (n !== this.root && !(this.next = n.nextSibling)) {\n        n = n.parentNode;\n      }\n    };\n\n    return NodeIterator;\n  }(); // DOM node types\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\n\n\n  var nodeType = {\n    elementNode: 1,\n    attributeNode: 2,\n    textNode: 3,\n    cdataSectionNode: 4,\n    entityReferenceNode: 5,\n    entityNode: 6,\n    processingInstructionNode: 7,\n    commentNode: 8,\n    documentNode: 9,\n    documentTypeNode: 10,\n    documentFragmentNode: 11,\n    notationNode: 12\n  };\n  /**\n   * The parser module provides helper methods to parse html-chunks\n   * manipulations and helpers for common tasks.\n   *\n   * @module core\n   * @submodule parser\n   */\n\n  var parser = function () {\n    /**\n     * Singleton that provides DOM lookup helpers.\n     * @static\n     */\n    return {\n      /**\n       * Get the editableJS host block of a node.\n       *\n       * @method getHost\n       * @param {DOM Node}\n       * @return {DOM Node}\n       */\n      getHost: function getHost(node) {\n        var editableSelector = '.' + config.editableClass;\n        var hostNode = $(node).closest(editableSelector);\n        return hostNode.length ? hostNode[0] : undefined;\n      },\n\n      /**\n       * Get the index of a node.\n       * So that parent.childNodes[ getIndex(node) ] would return the node again\n       *\n       * @method getNodeIndex\n       * @param {HTMLElement}\n       */\n      getNodeIndex: function getNodeIndex(node) {\n        var index = 0;\n\n        while ((node = node.previousSibling) !== null) {\n          index += 1;\n        }\n\n        return index;\n      },\n\n      /**\n       * Check if node contains text or element nodes\n       * whitespace counts too!\n       *\n       * @method isVoid\n       * @param {HTMLElement}\n       */\n      isVoid: function isVoid(node) {\n        var child, i, len;\n        var childNodes = node.childNodes;\n\n        for (i = 0, len = childNodes.length; i < len; i++) {\n          child = childNodes[i];\n\n          if (child.nodeType === nodeType.textNode && !this.isVoidTextNode(child)) {\n            return false;\n          } else if (child.nodeType === nodeType.elementNode) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n\n      /**\n       * Check if node is a text node and completely empty without any whitespace\n       *\n       * @method isVoidTextNode\n       * @param {HTMLElement}\n       */\n      isVoidTextNode: function isVoidTextNode(node) {\n        return node.nodeType === nodeType.textNode && !node.nodeValue;\n      },\n\n      /**\n       * Check if node is a text node and contains nothing but whitespace\n       *\n       * @method isWhitespaceOnly\n       * @param {HTMLElement}\n       */\n      isWhitespaceOnly: function isWhitespaceOnly(node) {\n        return node.nodeType === nodeType.textNode && this.lastOffsetWithContent(node) === 0;\n      },\n      isLinebreak: function isLinebreak(node) {\n        return node.nodeType === nodeType.elementNode && node.tagName === 'BR';\n      },\n\n      /**\n       * Returns the last offset where the cursor can be positioned to\n       * be at the visible end of its container.\n       * Currently works only for empty text nodes (not empty tags)\n       *\n       * @method isWhitespaceOnly\n       * @param {HTMLElement}\n       */\n      lastOffsetWithContent: function lastOffsetWithContent(node) {\n        if (node.nodeType === nodeType.textNode) {\n          return string.trimRight(node.nodeValue).length;\n        } else {\n          var i,\n              childNodes = node.childNodes;\n\n          for (i = childNodes.length - 1; i >= 0; i--) {\n            node = childNodes[i];\n\n            if (this.isWhitespaceOnly(node) || this.isLinebreak(node)) {\n              continue;\n            } else {\n              // The offset starts at 0 before the first element\n              // and ends with the length after the last element.\n              return i + 1;\n            }\n          }\n\n          return 0;\n        }\n      },\n      isBeginningOfHost: function isBeginningOfHost(host, container, offset) {\n        if (container === host) {\n          return this.isStartOffset(container, offset);\n        }\n\n        if (this.isStartOffset(container, offset)) {\n          var parentContainer = container.parentNode; // The index of the element simulates a range offset\n          // right before the element.\n\n          var offsetInParent = this.getNodeIndex(container);\n          return this.isBeginningOfHost(host, parentContainer, offsetInParent);\n        } else {\n          return false;\n        }\n      },\n      isEndOfHost: function isEndOfHost(host, container, offset) {\n        if (container === host) {\n          return this.isEndOffset(container, offset);\n        }\n\n        if (this.isEndOffset(container, offset)) {\n          var parentContainer = container.parentNode; // The index of the element plus one simulates a range offset\n          // right after the element.\n\n          var offsetInParent = this.getNodeIndex(container) + 1;\n          return this.isEndOfHost(host, parentContainer, offsetInParent);\n        } else {\n          return false;\n        }\n      },\n      isStartOffset: function isStartOffset(container, offset) {\n        if (container.nodeType === nodeType.textNode) {\n          return offset === 0;\n        } else {\n          if (container.childNodes.length === 0) return true;else return container.childNodes[offset] === container.firstChild;\n        }\n      },\n      isEndOffset: function isEndOffset(container, offset) {\n        if (container.nodeType === nodeType.textNode) {\n          return offset === container.length;\n        } else {\n          if (container.childNodes.length === 0) return true;else if (offset > 0) return container.childNodes[offset - 1] === container.lastChild;else return false;\n        }\n      },\n      isTextEndOfHost: function isTextEndOfHost(host, container, offset) {\n        if (container === host) {\n          return this.isTextEndOffset(container, offset);\n        }\n\n        if (this.isTextEndOffset(container, offset)) {\n          var parentContainer = container.parentNode; // The index of the element plus one simulates a range offset\n          // right after the element.\n\n          var offsetInParent = this.getNodeIndex(container) + 1;\n          return this.isTextEndOfHost(host, parentContainer, offsetInParent);\n        } else {\n          return false;\n        }\n      },\n      isTextEndOffset: function isTextEndOffset(container, offset) {\n        if (container.nodeType === nodeType.textNode) {\n          var text = string.trimRight(container.nodeValue);\n          return offset >= text.length;\n        } else if (container.childNodes.length === 0) {\n          return true;\n        } else {\n          var lastOffset = this.lastOffsetWithContent(container);\n          return offset >= lastOffset;\n        }\n      },\n      isSameNode: function isSameNode(target, source) {\n        var i, len, attr;\n        if (target.nodeType !== source.nodeType) return false;\n        if (target.nodeName !== source.nodeName) return false;\n\n        for (i = 0, len = target.attributes.length; i < len; i++) {\n          attr = target.attributes[i];\n          if (source.getAttribute(attr.name) !== attr.value) return false;\n        }\n\n        return true;\n      },\n\n      /**\n       * Return the deepest last child of a node.\n       *\n       * @method  latestChild\n       * @param  {HTMLElement} container The container to iterate on.\n       * @return {HTMLElement}           THe deepest last child in the container.\n       */\n      latestChild: function latestChild(container) {\n        if (container.lastChild) return this.latestChild(container.lastChild);else return container;\n      },\n\n      /**\n       * Checks if a documentFragment has no children.\n       * Fragments without children can cause errors if inserted into ranges.\n       *\n       * @method  isDocumentFragmentWithoutChildren\n       * @param  {HTMLElement} DOM node.\n       * @return {Boolean}\n       */\n      isDocumentFragmentWithoutChildren: function isDocumentFragmentWithoutChildren(fragment) {\n        if (fragment && fragment.nodeType === nodeType.documentFragmentNode && fragment.childNodes.length === 0) {\n          return true;\n        }\n\n        return false;\n      },\n\n      /**\n       * Determine if an element behaves like an inline element.\n       */\n      isInlineElement: function isInlineElement(window, element) {\n        var styles = element.currentStyle || window.getComputedStyle(element, '');\n        var display = styles.display;\n\n        switch (display) {\n          case 'inline':\n          case 'inline-block':\n            return true;\n\n          default:\n            return false;\n        }\n      }\n    };\n  }();\n  /** RangeContainer\n   *\n   * primarily used to compare ranges\n   * its designed to work with undefined ranges as well\n   * so we can easily compare them without checking for undefined\n   * all the time\n   */\n\n\n  var RangeContainer = function RangeContainer(editableHost, rangyRange) {\n    this.host = editableHost && editableHost.jquery ? editableHost[0] : editableHost;\n    this.range = rangyRange;\n    this.isAnythingSelected = rangyRange !== undefined;\n    this.isCursor = this.isAnythingSelected && rangyRange.collapsed;\n    this.isSelection = this.isAnythingSelected && !this.isCursor;\n  };\n\n  RangeContainer.prototype.getCursor = function () {\n    if (this.isCursor) {\n      return new Cursor(this.host, this.range);\n    }\n  };\n\n  RangeContainer.prototype.getSelection = function () {\n    if (this.isSelection) {\n      return new Selection(this.host, this.range);\n    }\n  };\n\n  RangeContainer.prototype.forceCursor = function () {\n    if (this.isSelection) {\n      var selection = this.getSelection();\n      return selection.deleteContent();\n    } else {\n      return this.getCursor();\n    }\n  };\n\n  RangeContainer.prototype.isDifferentFrom = function (otherRangeContainer) {\n    otherRangeContainer = otherRangeContainer || new RangeContainer();\n    var self = this.range;\n    var other = otherRangeContainer.range;\n\n    if (self && other) {\n      return !self.equals(other);\n    } else if (!self && !other) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Inspired by the Selection save and restore module for Rangy by Tim Down\n   * Saves and restores ranges using invisible marker elements in the DOM.\n   */\n\n\n  var rangeSaveRestore = function () {\n    var boundaryMarkerId = 0; // (U+FEFF) zero width no-break space\n\n    var markerTextChar = \"\\uFEFF\";\n\n    var getMarker = function getMarker(host, id) {\n      return host.querySelector('#' + id);\n    };\n\n    return {\n      insertRangeBoundaryMarker: function insertRangeBoundaryMarker(range, atStart) {\n        var markerId = 'editable-range-boundary-' + (boundaryMarkerId += 1);\n        var markerEl;\n        var container = range.commonAncestorContainer; // If ownerDocument is null the commonAncestorContainer is window.document\n\n        if (container.ownerDocument === null || container.ownerDocument === undefined) {\n          error('Cannot save range: range is emtpy');\n        }\n\n        var doc = container.ownerDocument.defaultView.document; // Clone the Range and collapse to the appropriate boundary point\n\n        var boundaryRange = range.cloneRange();\n        boundaryRange.collapse(atStart); // Create the marker element containing a single invisible character using DOM methods and insert it\n\n        markerEl = doc.createElement('span');\n        markerEl.id = markerId;\n        markerEl.setAttribute('data-editable', 'remove');\n        markerEl.style.lineHeight = '0';\n        markerEl.style.display = 'none';\n        markerEl.appendChild(doc.createTextNode(markerTextChar));\n        boundaryRange.insertNode(markerEl);\n        return markerEl;\n      },\n      setRangeBoundary: function setRangeBoundary(host, range, markerId, atStart) {\n        var markerEl = getMarker(host, markerId);\n\n        if (markerEl) {\n          range[atStart ? 'setStartBefore' : 'setEndBefore'](markerEl);\n          markerEl.parentNode.removeChild(markerEl);\n        } else {\n          console.log('Marker element has been removed. Cannot restore selection.');\n        }\n      },\n      save: function save(range) {\n        var rangeInfo, startEl, endEl; // insert markers\n\n        if (range.collapsed) {\n          endEl = this.insertRangeBoundaryMarker(range, false);\n          rangeInfo = {\n            markerId: endEl.id,\n            collapsed: true\n          };\n        } else {\n          endEl = this.insertRangeBoundaryMarker(range, false);\n          startEl = this.insertRangeBoundaryMarker(range, true);\n          rangeInfo = {\n            startMarkerId: startEl.id,\n            endMarkerId: endEl.id,\n            collapsed: false\n          };\n        } // Adjust each range's boundaries to lie between its markers\n\n\n        if (range.collapsed) {\n          range.collapseBefore(endEl);\n        } else {\n          range.setEndBefore(endEl);\n          range.setStartAfter(startEl);\n        }\n\n        return rangeInfo;\n      },\n      restore: function restore(host, rangeInfo) {\n        if (rangeInfo.restored) return;\n        var range = rangy.createRange();\n\n        if (rangeInfo.collapsed) {\n          var markerEl = getMarker(host, rangeInfo.markerId);\n\n          if (markerEl) {\n            markerEl.style.display = 'inline';\n            var previousNode = markerEl.previousSibling; // Workaround for rangy issue 17\n\n            if (previousNode && previousNode.nodeType === nodeType.textNode) {\n              markerEl.parentNode.removeChild(markerEl);\n              range.collapseToPoint(previousNode, previousNode.length);\n            } else {\n              range.collapseBefore(markerEl);\n              markerEl.parentNode.removeChild(markerEl);\n            }\n          } else {\n            console.log('Marker element has been removed. Cannot restore selection.');\n          }\n        } else {\n          this.setRangeBoundary(host, range, rangeInfo.startMarkerId, true);\n          this.setRangeBoundary(host, range, rangeInfo.endMarkerId, false);\n        }\n\n        range.normalizeBoundaries();\n        return range;\n      }\n    };\n  }();\n  /**\n   * The SelectionWatcher module watches for selection changes inside\n   * of editable blocks.\n   *\n   * @module core\n   * @submodule selectionWatcher\n   */\n\n\n  var SelectionWatcher = function SelectionWatcher(dispatcher, win) {\n    this.dispatcher = dispatcher;\n    this.win = win || window;\n    this.rangySelection = undefined;\n    this.currentSelection = undefined;\n    this.currentRange = undefined;\n  };\n  /**\n   * Return a RangeContainer if the current selection is within an editable\n   * otherwise return an empty RangeContainer\n   */\n\n\n  SelectionWatcher.prototype.getRangeContainer = function () {\n    this.rangySelection = rangy.getSelection(this.win); // rangeCount is 0 or 1 in all browsers except firefox\n    // firefox can work with multiple ranges\n    // (on a mac hold down the command key to select multiple ranges)\n\n    if (this.rangySelection.rangeCount) {\n      var range = this.rangySelection.getRangeAt(0);\n      var hostNode = parser.getHost(range.commonAncestorContainer);\n\n      if (hostNode) {\n        return new RangeContainer(hostNode, range);\n      }\n    } // return an empty range container\n\n\n    return new RangeContainer();\n  };\n  /**\n   * Gets a fresh RangeContainer with the current selection or cursor.\n   *\n   * @return RangeContainer instance\n   */\n\n\n  SelectionWatcher.prototype.getFreshRange = function () {\n    return this.getRangeContainer();\n  };\n  /**\n   * Gets a fresh RangeContainer with the current selection or cursor.\n   *\n   * @return Either a Cursor or Selection instance or undefined if\n   * there is neither a selection or cursor.\n   */\n\n\n  SelectionWatcher.prototype.getFreshSelection = function () {\n    var range = this.getRangeContainer();\n    return range.isCursor ? range.getCursor(this.win) : range.getSelection(this.win);\n  };\n  /**\n   * Get the selection set by the last selectionChanged event.\n   * Sometimes the event does not fire fast enough and the seleciton\n   * you get is not the one the user sees.\n   * In those cases use #getFreshSelection()\n   *\n   * @return Either a Cursor or Selection instance or undefined if\n   * there is neither a selection or cursor.\n   */\n\n\n  SelectionWatcher.prototype.getSelection = function () {\n    return this.currentSelection;\n  };\n\n  SelectionWatcher.prototype.forceCursor = function () {\n    var range = this.getRangeContainer();\n    return range.forceCursor();\n  };\n\n  SelectionWatcher.prototype.selectionChanged = function () {\n    var newRange = this.getRangeContainer();\n\n    if (newRange.isDifferentFrom(this.currentRange)) {\n      var lastSelection = this.currentSelection;\n      this.currentRange = newRange; // empty selection or cursor\n\n      if (lastSelection) {\n        if (lastSelection.isCursor && !this.currentRange.isCursor) {\n          this.dispatcher.notify('cursor', lastSelection.host);\n        } else if (lastSelection.isSelection && !this.currentRange.isSelection) {\n          this.dispatcher.notify('selection', lastSelection.host);\n        }\n      } // set new selection or cursor and fire event\n\n\n      if (this.currentRange.isCursor) {\n        this.currentSelection = new Cursor(this.currentRange.host, this.currentRange.range);\n        this.dispatcher.notify('cursor', this.currentSelection.host, this.currentSelection);\n      } else if (this.currentRange.isSelection) {\n        this.currentSelection = new Selection(this.currentRange.host, this.currentRange.range);\n        this.dispatcher.notify('selection', this.currentSelection.host, this.currentSelection);\n      } else {\n        this.currentSelection = undefined;\n      }\n    }\n  };\n  /**\n   * The Selection module provides a cross-browser abstraction layer for range\n   * and selection.\n   *\n   * @module core\n   * @submodule selection\n   */\n\n\n  var Selection = function () {\n    /**\n     * Class that represents a selection and provides functionality to access or\n     * modify the selection.\n     *\n     * @class Selection\n     * @constructor\n     */\n    var Selection = function Selection(editableHost, rangyRange) {\n      this.setHost(editableHost);\n      this.range = rangyRange;\n      this.isSelection = true;\n    }; // add Cursor prototpye to Selection prototype chain\n\n\n    var Base = function Base() {};\n\n    Base.prototype = Cursor.prototype;\n    Selection.prototype = $.extend(new Base(), {\n      /**\n       * Get the text inside the selection.\n       *\n       * @method text\n       */\n      text: function text() {\n        return this.range.toString();\n      },\n\n      /**\n       * Get the html inside the selection.\n       *\n       * @method html\n       */\n      html: function html() {\n        return this.range.toHtml();\n      },\n\n      /**\n       *\n       * @method isAllSelected\n       */\n      isAllSelected: function isAllSelected() {\n        return parser.isBeginningOfHost(this.host, this.range.startContainer, this.range.startOffset) && parser.isTextEndOfHost(this.host, this.range.endContainer, this.range.endOffset);\n      },\n\n      /**\n       * Get the ClientRects of this selection.\n       * Use this if you want more precision than getBoundingClientRect can give.\n       */\n      getRects: function getRects() {\n        var coords = this.range.nativeRange.getClientRects(); // todo: translate into absolute positions\n        // just like Cursor#getCoordinates()\n\n        return coords;\n      },\n\n      /**\n       *\n       * @method link\n       */\n      link: function link(href, attrs) {\n        var $link = $(this.createElement('a'));\n        if (href) $link.attr('href', href);\n\n        for (var name in attrs) {\n          $link.attr(name, attrs[name]);\n        }\n\n        this.forceWrap($link[0]);\n      },\n      unlink: function unlink() {\n        this.removeFormatting('a');\n      },\n      toggleLink: function toggleLink(href, attrs) {\n        var links = this.getTagsByName('a');\n\n        if (links.length >= 1) {\n          var firstLink = links[0];\n\n          if (this.isExactSelection(firstLink, 'visible')) {\n            this.unlink();\n          } else {\n            this.expandTo(firstLink);\n          }\n        } else {\n          this.link(href, attrs);\n        }\n      },\n      toggle: function toggle(elem) {\n        elem = this.adoptElement(elem);\n        this.range = content.toggleTag(this.host, this.range, elem);\n        this.setSelection();\n      },\n\n      /**\n       *\n       * @method makeBold\n       */\n      makeBold: function makeBold() {\n        var bold = this.createElement(config.boldTag);\n        this.forceWrap(bold);\n      },\n      toggleBold: function toggleBold() {\n        var bold = this.createElement(config.boldTag);\n        this.toggle(bold);\n      },\n\n      /**\n       *\n       * @method giveEmphasis\n       */\n      giveEmphasis: function giveEmphasis() {\n        var em = this.createElement(config.italicTag);\n        this.forceWrap(em);\n      },\n      toggleEmphasis: function toggleEmphasis() {\n        var em = this.createElement(config.italicTag);\n        this.toggle(em);\n      },\n\n      /**\n       * Surround the selection with characters like quotes.\n       *\n       * @method surround\n       * @param {String} E.g. '«'\n       * @param {String} E.g. '»'\n       */\n      surround: function surround(startCharacter, endCharacter) {\n        this.range = content.surround(this.host, this.range, startCharacter, endCharacter);\n        this.setSelection();\n      },\n      removeSurround: function removeSurround(startCharacter, endCharacter) {\n        this.range = content.deleteCharacter(this.host, this.range, startCharacter);\n        this.range = content.deleteCharacter(this.host, this.range, endCharacter);\n        this.setSelection();\n      },\n      toggleSurround: function toggleSurround(startCharacter, endCharacter) {\n        if (this.containsString(startCharacter) && this.containsString(endCharacter)) {\n          this.removeSurround(startCharacter, endCharacter);\n        } else {\n          this.surround(startCharacter, endCharacter);\n        }\n      },\n\n      /**\n       * @method removeFormatting\n       * @param {String} tagName. E.g. 'a' to remove all links.\n       */\n      removeFormatting: function removeFormatting(tagName) {\n        this.range = content.removeFormatting(this.host, this.range, tagName);\n        this.setSelection();\n      },\n\n      /**\n       * Delete the contents inside the range. After that the selection will be a\n       * cursor.\n       *\n       * @method deleteContent\n       * @return Cursor instance\n       */\n      deleteContent: function deleteContent() {\n        this.range.deleteContents();\n        return new Cursor(this.host, this.range);\n      },\n\n      /**\n       * Expand the current selection.\n       *\n       * @method expandTo\n       * @param {DOM Node}\n       */\n      expandTo: function expandTo(elem) {\n        this.range = content.expandTo(this.host, this.range, elem);\n        this.setSelection();\n      },\n\n      /**\n       *  Collapse the selection at the beginning of the selection\n       *\n       *  @return Cursor instance\n       */\n      collapseAtBeginning: function collapseAtBeginning(elem) {\n        this.range.collapse(true);\n        this.setSelection();\n        return new Cursor(this.host, this.range);\n      },\n\n      /**\n       *  Collapse the selection at the end of the selection\n       *\n       *  @return Cursor instance\n       */\n      collapseAtEnd: function collapseAtEnd(elem) {\n        this.range.collapse(false);\n        this.setSelection();\n        return new Cursor(this.host, this.range);\n      },\n\n      /**\n       * Wrap the selection with the specified tag. If any other tag with\n       * the same tagName is affecting the selection this tag will be\n       * remove first.\n       *\n       * @method forceWrap\n       */\n      forceWrap: function forceWrap(elem) {\n        elem = this.adoptElement(elem);\n        this.range = content.forceWrap(this.host, this.range, elem);\n        this.setSelection();\n      },\n\n      /**\n       * Get all tags that affect the current selection. Optionally pass a\n       * method to filter the returned elements.\n       *\n       * @method getTags\n       * @param {Function filter(node)} [Optional] Method to filter the returned\n       *   DOM Nodes.\n       * @return {Array of DOM Nodes}\n       */\n      getTags: function getTags(filterFunc) {\n        return content.getTags(this.host, this.range, filterFunc);\n      },\n\n      /**\n       * Get all tags of the specified type that affect the current selection.\n       *\n       * @method getTagsByName\n       * @param {String} tagName. E.g. 'a' to get all links.\n       * @return {Array of DOM Nodes}\n       */\n      getTagsByName: function getTagsByName(tagName) {\n        return content.getTagsByName(this.host, this.range, tagName);\n      },\n\n      /**\n       * Check if the selection is the same as the elements contents.\n       *\n       * @method isExactSelection\n       * @param {DOM Node}\n       * @param {flag:  undefined or 'visible'} if 'visible' is passed\n       *   whitespaces at the beginning or end of the selection will\n       *   be ignored.\n       * @return {Boolean}\n       */\n      isExactSelection: function isExactSelection(elem, onlyVisible) {\n        return content.isExactSelection(this.range, elem, onlyVisible);\n      },\n\n      /**\n       * Check if the selection contains the passed string.\n       *\n       * @method containsString\n       * @return {Boolean}\n       */\n      containsString: function containsString(str) {\n        return content.containsString(this.range, str);\n      },\n\n      /**\n       * Delete all occurences of the specified character from the\n       * selection.\n       *\n       * @method deleteCharacter\n       */\n      deleteCharacter: function deleteCharacter(character) {\n        this.range = content.deleteCharacter(this.host, this.range, character);\n        this.setSelection();\n      }\n    });\n    return Selection;\n  }();\n\n  var Spellcheck = function () {\n    // Unicode character blocks for letters.\n    // See: http://jrgraphix.net/research/unicode_blocks.php\n    //\n    // \\\\u0041-\\\\u005A    A-Z (Basic Latin)\n    // \\\\u0061-\\\\u007A    a-z (Basic Latin)\n    // \\\\u0030-\\\\u0039    0-9 (Basic Latin)\n    // \\\\u00AA            ª   (Latin-1 Supplement)\n    // \\\\u00B5            µ   (Latin-1 Supplement)\n    // \\\\u00BA            º   (Latin-1 Supplement)\n    // \\\\u00C0-\\\\u00D6    À-Ö (Latin-1 Supplement)\n    // \\\\u00D8-\\\\u00F6    Ø-ö (Latin-1 Supplement)\n    // \\\\u00F8-\\\\u00FF    ø-ÿ (Latin-1 Supplement)\n    // \\\\u0100-\\\\u017F    Ā-ſ (Latin Extended-A)\n    // \\\\u0180-\\\\u024F    ƀ-ɏ (Latin Extended-B)\n    var letterChars = \"\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u0030-\\\\u0039\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u00FF\\\\u0100-\\\\u017F\\\\u0180-\\\\u024F\";\n\n    var escapeRegEx = function escapeRegEx(s) {\n      return String(s).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n    };\n    /**\n     * Spellcheck class.\n     *\n     * @class Spellcheck\n     * @constructor\n     */\n\n\n    var Spellcheck = function Spellcheck(editable, configuration) {\n      var defaultConfig = {\n        checkOnFocus: false,\n        // check on focus\n        checkOnChange: true,\n        // check after changes\n        throttle: 1000,\n        // unbounce rate in ms before calling the spellcheck service after changes\n        removeOnCorrection: true,\n        // remove highlights after a change if the cursor is inside a highlight\n        markerNode: $('<span class=\"spellcheck\"></span>'),\n        spellcheckService: undefined\n      };\n      this.editable = editable;\n      this.win = editable.win;\n      this.config = $.extend(defaultConfig, configuration);\n      this.prepareMarkerNode();\n      this.setup();\n    };\n\n    Spellcheck.prototype.setup = function (editable) {\n      if (this.config.checkOnFocus) {\n        this.editable.on('focus', $.proxy(this, 'onFocus'));\n        this.editable.on('blur', $.proxy(this, 'onBlur'));\n      }\n\n      if (this.config.checkOnChange || this.config.removeOnCorrection) {\n        this.editable.on('change', $.proxy(this, 'onChange'));\n      }\n    };\n\n    Spellcheck.prototype.onFocus = function (editableHost) {\n      if (this.focusedEditable !== editableHost) {\n        this.focusedEditable = editableHost;\n        this.editableHasChanged(editableHost);\n      }\n    };\n\n    Spellcheck.prototype.onBlur = function (editableHost) {\n      if (this.focusedEditable === editableHost) {\n        this.focusedEditable = undefined;\n      }\n    };\n\n    Spellcheck.prototype.onChange = function (editableHost) {\n      if (this.config.checkOnChange) {\n        this.editableHasChanged(editableHost, this.config.throttle);\n      }\n\n      if (this.config.removeOnCorrection) {\n        this.removeHighlightsAtCursor(editableHost);\n      }\n    };\n\n    Spellcheck.prototype.prepareMarkerNode = function () {\n      var marker = this.config.markerNode;\n\n      if (marker.jquery) {\n        marker = marker[0];\n      }\n\n      marker = content.adoptElement(marker, this.win.document);\n      this.config.markerNode = marker;\n      marker.setAttribute('data-editable', 'ui-unwrap');\n      marker.setAttribute('data-spellcheck', 'spellcheck');\n    };\n\n    Spellcheck.prototype.createMarkerNode = function () {\n      return this.config.markerNode.cloneNode();\n    };\n\n    Spellcheck.prototype.removeHighlights = function (editableHost) {\n      $(editableHost).find('[data-spellcheck=spellcheck]').each(function (index, elem) {\n        content.unwrap(elem);\n      });\n    };\n\n    Spellcheck.prototype.removeHighlightsAtCursor = function (editableHost) {\n      var wordId;\n      var selection = this.editable.getSelection(editableHost);\n\n      if (selection && selection.isCursor) {\n        var elementAtCursor = selection.range.startContainer;\n\n        if (elementAtCursor.nodeType === nodeType.textNode) {\n          elementAtCursor = elementAtCursor.parentNode;\n        }\n\n        do {\n          if (elementAtCursor === editableHost) return;\n\n          if (elementAtCursor.hasAttribute('data-word-id')) {\n            wordId = elementAtCursor.getAttribute('data-word-id');\n            break;\n          }\n        } while (elementAtCursor = elementAtCursor.parentNode);\n\n        if (wordId) {\n          selection.retainVisibleSelection(function () {\n            $(editableHost).find('[data-word-id=' + wordId + ']').each(function (index, elem) {\n              content.unwrap(elem);\n            });\n          });\n        }\n      }\n    };\n\n    Spellcheck.prototype.createRegex = function (words) {\n      var escapedWords = $.map(words, function (word) {\n        return escapeRegEx(word);\n      });\n      var regex = '';\n      regex += '([^' + letterChars + ']|^)';\n      regex += '(' + escapedWords.join('|') + ')';\n      regex += '(?=[^' + letterChars + ']|$)';\n      return new RegExp(regex, 'g');\n    };\n\n    Spellcheck.prototype.highlight = function (editableHost, misspelledWords) {\n      // Remove old highlights\n      this.removeHighlights(editableHost); // Create new highlights\n\n      if (misspelledWords && misspelledWords.length > 0) {\n        var regex = this.createRegex(misspelledWords);\n        var span = this.createMarkerNode();\n        highlightText.highlight(editableHost, regex, span);\n      }\n    };\n\n    Spellcheck.prototype.editableHasChanged = function (editableHost, throttle) {\n      if (this.timeoutId && this.currentEditableHost === editableHost) {\n        clearTimeout(this.timeoutId);\n      }\n\n      var that = this;\n      this.timeoutId = setTimeout(function () {\n        that.checkSpelling(editableHost);\n        that.currentEditableHost = undefined;\n        that.timeoutId = undefined;\n      }, throttle || 0);\n      this.currentEditableHost = editableHost;\n    };\n\n    Spellcheck.prototype.checkSpelling = function (editableHost) {\n      var that = this;\n      var text = highlightText.extractText(editableHost);\n      text = content.normalizeWhitespace(text);\n      this.config.spellcheckService(text, function (misspelledWords) {\n        var selection = that.editable.getSelection(editableHost);\n\n        if (selection) {\n          selection.retainVisibleSelection(function () {\n            that.highlight(editableHost, misspelledWords);\n          });\n        } else {\n          that.highlight(editableHost, misspelledWords);\n        }\n      });\n    };\n\n    return Spellcheck;\n  }();\n\n  window.Editable = Editable;\n  Editable.parser = parser;\n  Editable.content = content;\n  Editable.bowser = bowser;\n})(window, document, jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=webpack:///./src/livingdocs/editable.js?");

/***/ }),

/***/ "./src/livingdocs/livingdocs-engine.js":
/*!*********************************************!*\
  !*** ./src/livingdocs/livingdocs-engine.js ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\nvar require;var require;var require;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\nvar $ = jquery__WEBPACK_IMPORTED_MODULE_0__;\n\nrequire = function e(t, n, r) {\n  function s(o, u) {\n    if (!n[o]) {\n      if (!t[o]) {\n        var a = typeof require == \"function\" && require;\n        if (!u && a) return require(o, !0);\n        if (i) return i(o, !0);\n        var f = new Error(\"Cannot find module '\" + o + \"'\");\n        throw f.code = \"MODULE_NOT_FOUND\", f;\n      }\n\n      var l = n[o] = {\n        exports: {}\n      };\n      t[o][0].call(l.exports, function (e) {\n        var n = t[o][1][e];\n        return s(n ? n : e);\n      }, l, l.exports, e, t, n, r);\n    }\n\n    return n[o].exports;\n  }\n\n  var i = typeof require == \"function\" && require;\n\n  for (var o = 0; o < r.length; o++) {\n    s(r[o]);\n  }\n\n  return s;\n}({\n  1: [function (require, module, exports) {\n    var pSlice = Array.prototype.slice;\n\n    var objectKeys = require('./lib/keys.js');\n\n    var isArguments = require('./lib/is_arguments.js');\n\n    var deepEqual = module.exports = function (actual, expected, opts) {\n      if (!opts) opts = {}; // 7.1. All identical values are equivalent, as determined by ===.\n\n      if (actual === expected) {\n        return true;\n      } else if (actual instanceof Date && expected instanceof Date) {\n        return actual.getTime() === expected.getTime(); // 7.3. Other pairs that do not both pass typeof value == 'object',\n        // equivalence is determined by ==.\n      } else if (_typeof(actual) != 'object' && _typeof(expected) != 'object') {\n        return opts.strict ? actual === expected : actual == expected; // 7.4. For all other Object pairs, including Array objects, equivalence is\n        // determined by having the same number of owned properties (as verified\n        // with Object.prototype.hasOwnProperty.call), the same set of keys\n        // (although not necessarily the same order), equivalent values for every\n        // corresponding key, and an identical 'prototype' property. Note: this\n        // accounts for both named and indexed properties on Arrays.\n      } else {\n        return objEquiv(actual, expected, opts);\n      }\n    };\n\n    function isUndefinedOrNull(value) {\n      return value === null || value === undefined;\n    }\n\n    function isBuffer(x) {\n      if (!x || _typeof(x) !== 'object' || typeof x.length !== 'number') return false;\n\n      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n        return false;\n      }\n\n      if (x.length > 0 && typeof x[0] !== 'number') return false;\n      return true;\n    }\n\n    function objEquiv(a, b, opts) {\n      var i, key;\n      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false; // an identical 'prototype' property.\n\n      if (a.prototype !== b.prototype) return false; //~~~I've managed to break Object.keys through screwy arguments passing.\n      //   Converting to array solves the problem.\n\n      if (isArguments(a)) {\n        if (!isArguments(b)) {\n          return false;\n        }\n\n        a = pSlice.call(a);\n        b = pSlice.call(b);\n        return deepEqual(a, b, opts);\n      }\n\n      if (isBuffer(a)) {\n        if (!isBuffer(b)) {\n          return false;\n        }\n\n        if (a.length !== b.length) return false;\n\n        for (i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) return false;\n        }\n\n        return true;\n      }\n\n      try {\n        var ka = objectKeys(a),\n            kb = objectKeys(b);\n      } catch (e) {\n        //happens when one is a string literal and the other isn't\n        return false;\n      } // having the same number of owned properties (keys incorporates\n      // hasOwnProperty)\n\n\n      if (ka.length != kb.length) return false; //the same set of keys (although not necessarily the same order),\n\n      ka.sort();\n      kb.sort(); //~~~cheap key test\n\n      for (i = ka.length - 1; i >= 0; i--) {\n        if (ka[i] != kb[i]) return false;\n      } //equivalent values for every corresponding key, and\n      //~~~possibly expensive deep test\n\n\n      for (i = ka.length - 1; i >= 0; i--) {\n        key = ka[i];\n        if (!deepEqual(a[key], b[key], opts)) return false;\n      }\n\n      return true;\n    }\n  }, {\n    \"./lib/is_arguments.js\": 2,\n    \"./lib/keys.js\": 3\n  }],\n  2: [function (require, module, exports) {\n    var supportsArgumentsClass = function () {\n      return Object.prototype.toString.call(arguments);\n    }() == '[object Arguments]';\n\n    exports = module.exports = supportsArgumentsClass ? supported : unsupported;\n    exports.supported = supported;\n\n    function supported(object) {\n      return Object.prototype.toString.call(object) == '[object Arguments]';\n    }\n\n    ;\n    exports.unsupported = unsupported;\n\n    function unsupported(object) {\n      return object && _typeof(object) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;\n    }\n\n    ;\n  }, {}],\n  3: [function (require, module, exports) {\n    exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;\n    exports.shim = shim;\n\n    function shim(obj) {\n      var keys = [];\n\n      for (var key in obj) {\n        keys.push(key);\n      }\n\n      return keys;\n    }\n  }, {}],\n  4: [function (require, module, exports) {\n    var Scheme, jScheme;\n    Scheme = require('./scheme');\n    jScheme = new Scheme();\n\n    jScheme[\"new\"] = function () {\n      return new Scheme();\n    };\n\n    module.exports = jScheme;\n\n    if (typeof window !== \"undefined\" && window !== null) {\n      window.jScheme = jScheme;\n    }\n  }, {\n    \"./scheme\": 6\n  }],\n  5: [function (require, module, exports) {\n    var PropertyValidator;\n\n    module.exports = PropertyValidator = function () {\n      var termRegex;\n      termRegex = /\\w[\\w ]*\\w/g;\n\n      function PropertyValidator(_arg) {\n        var _ref;\n\n        this.inputString = _arg.inputString, this.scheme = _arg.scheme, this.property = _arg.property, this.parent = _arg.parent;\n        this.validators = [];\n        this.location = this.getLocation();\n\n        if (this.scheme.propertiesRequired) {\n          if ((_ref = this.parent) != null) {\n            _ref.addRequiredProperty(this.property);\n          }\n        }\n\n        this.addValidations(this.inputString);\n      }\n\n      PropertyValidator.prototype.getLocation = function () {\n        if (this.property == null) {\n          return '';\n        } else if (this.parent != null) {\n          return this.parent.location + this.scheme.writeProperty(this.property);\n        } else {\n          return this.scheme.writeProperty(this.property);\n        }\n      };\n\n      PropertyValidator.prototype.getPropLocation = function (key) {\n        return \"\" + this.location + this.scheme.writeProperty(key);\n      };\n\n      PropertyValidator.prototype.addValidations = function (configString) {\n        var result, term, types;\n\n        while (result = termRegex.exec(configString)) {\n          term = result[0];\n\n          if (term === 'optional') {\n            this.parent.removeRequiredProperty(this.property);\n          } else if (term === 'required') {\n            this.parent.addRequiredProperty(this.property);\n          } else if (term.indexOf('array of ') === 0) {\n            this.validators.push('array');\n            this.arrayValidator = term.slice(9);\n          } else if (term.indexOf(' or ') !== -1) {\n            types = term.split(' or ');\n            console.log('todo');\n          } else {\n            this.validators.push(term);\n          }\n        }\n\n        return void 0;\n      };\n\n      PropertyValidator.prototype.validate = function (value, errors) {\n        var isValid, name, validationResult, validator, validators, _i, _len, _ref;\n\n        isValid = true;\n\n        if (value == null && this.isOptional()) {\n          return isValid;\n        }\n\n        validators = this.scheme.validators;\n        _ref = this.validators || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          name = _ref[_i];\n          validator = validators[name];\n\n          if (validator == null) {\n            return errors.add(\"missing validator \" + name, {\n              location: this.location\n            });\n          }\n\n          validationResult = validator(value);\n\n          if (validationResult === true) {\n            continue;\n          }\n\n          errors.add(validationResult, {\n            location: this.location,\n            defaultMessage: \"\" + name + \" validator failed\"\n          });\n          isValid = false;\n        }\n\n        if (!(isValid = this.validateArray(value, errors))) {\n          return false;\n        }\n\n        if (!(isValid = this.validateRequiredProperties(value, errors))) {\n          return false;\n        }\n\n        return isValid;\n      };\n\n      PropertyValidator.prototype.validateArray = function (arr, errors) {\n        var entry, index, isValid, location, validationResult, validator, _i, _len, _ref;\n\n        if (this.arrayValidator == null) {\n          return true;\n        }\n\n        isValid = true;\n        validator = this.scheme.validators[this.arrayValidator];\n\n        if (validator == null) {\n          return errors.add(\"missing validator \" + this.arrayValidator, {\n            location: this.location\n          });\n        }\n\n        _ref = arr || [];\n\n        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n          entry = _ref[index];\n          validationResult = validator(entry);\n\n          if (validationResult === true) {\n            continue;\n          }\n\n          location = \"\" + this.location + \"[\" + index + \"]\";\n          errors.add(validationResult, {\n            location: location,\n            defaultMessage: \"\" + this.arrayValidator + \" validator failed\"\n          });\n          isValid = false;\n        }\n\n        return isValid;\n      };\n\n      PropertyValidator.prototype.validateOtherProperty = function (key, value, errors) {\n        var isValid;\n\n        if (this.otherPropertyValidator != null) {\n          this.scheme.errors = void 0;\n\n          if (isValid = this.otherPropertyValidator.call(this, key, value)) {\n            return true;\n          }\n\n          if (this.scheme.errors != null) {\n            errors.join(this.scheme.errors, {\n              location: this.getPropLocation(key)\n            });\n          } else {\n            errors.add(\"additional property check failed\", {\n              location: this.getPropLocation(key)\n            });\n          }\n\n          return false;\n        } else {\n          if (this.scheme.allowAdditionalProperties) {\n            return true;\n          } else {\n            errors.add(\"unspecified additional property\", {\n              location: this.getPropLocation(key)\n            });\n            return false;\n          }\n        }\n      };\n\n      PropertyValidator.prototype.validateRequiredProperties = function (obj, errors) {\n        var isRequired, isValid, key, _ref;\n\n        isValid = true;\n        _ref = this.requiredProperties;\n\n        for (key in _ref) {\n          isRequired = _ref[key];\n\n          if (obj[key] == null && isRequired) {\n            errors.add(\"required property missing\", {\n              location: this.getPropLocation(key)\n            });\n            isValid = false;\n          }\n        }\n\n        return isValid;\n      };\n\n      PropertyValidator.prototype.addRequiredProperty = function (key) {\n        if (this.requiredProperties == null) {\n          this.requiredProperties = {};\n        }\n\n        return this.requiredProperties[key] = true;\n      };\n\n      PropertyValidator.prototype.removeRequiredProperty = function (key) {\n        var _ref;\n\n        return (_ref = this.requiredProperties) != null ? _ref[key] = void 0 : void 0;\n      };\n\n      PropertyValidator.prototype.isOptional = function () {\n        if (this.parent != null) {\n          return !this.parent.requiredProperties[this.property] === true;\n        }\n      };\n\n      return PropertyValidator;\n    }();\n  }, {}],\n  6: [function (require, module, exports) {\n    var PropertyValidator, Scheme, ValidationErrors, type, validators;\n    ValidationErrors = require('./validation_errors');\n    PropertyValidator = require('./property_validator');\n    validators = require('./validators');\n    type = require('./type');\n\n    module.exports = Scheme = function () {\n      var jsVariableName;\n      jsVariableName = /^[a-zA-Z]\\w*$/;\n\n      function Scheme() {\n        this.validators = Object.create(validators);\n        this.schemas = {};\n        this.propertiesRequired = true;\n        this.allowAdditionalProperties = true;\n      }\n\n      Scheme.prototype.configure = function (_arg) {\n        this.propertiesRequired = _arg.propertiesRequired, this.allowAdditionalProperties = _arg.allowAdditionalProperties;\n      };\n\n      Scheme.prototype.add = function (name, schema) {\n        if (type.isFunction(schema)) {\n          this.addValidator(name, schema);\n        } else {\n          this.addSchema(name, this.parseConfigObj(schema, void 0, name));\n        }\n\n        return this;\n      };\n\n      Scheme.prototype.addSchema = function (name, schema) {\n        if (this.validators[name] != null) {\n          throw new Error(\"A validator is alredy registered under this name: \" + name);\n        }\n\n        this.schemas[name] = schema;\n\n        this.validators[name] = function (_this) {\n          return function (value) {\n            var errors;\n            errors = _this.recursiveValidate(schema, value);\n\n            if (errors.hasErrors()) {\n              return errors;\n            } else {\n              return true;\n            }\n          };\n        }(this);\n\n        return this;\n      };\n\n      Scheme.prototype.addValidator = function (name, func) {\n        this.validators[name] = func;\n        return this;\n      };\n\n      Scheme.prototype.validate = function (schemaName, obj) {\n        var schema;\n        this.errors = void 0;\n        schema = this.schemas[schemaName];\n\n        if (schema == null) {\n          this.errors = new ValidationErrors();\n          this.errors.add(\"missing schema\", {\n            location: schemaName\n          });\n          return false;\n        }\n\n        this.errors = this.recursiveValidate(schema, obj).setRoot(schemaName);\n        return !this.errors.hasErrors();\n      };\n\n      Scheme.prototype.hasErrors = function () {\n        var _ref;\n\n        return (_ref = this.errors) != null ? _ref.hasErrors() : void 0;\n      };\n\n      Scheme.prototype.getErrorMessages = function () {\n        var _ref;\n\n        return (_ref = this.errors) != null ? _ref.getMessages() : void 0;\n      };\n\n      Scheme.prototype.recursiveValidate = function (schemaObj, obj) {\n        var errors, isValid, key, parentValidator, propertyValidator, value;\n        parentValidator = schemaObj['__validator'];\n        errors = new ValidationErrors();\n        parentValidator.validate(obj, errors);\n\n        for (key in obj) {\n          value = obj[key];\n\n          if (schemaObj[key] != null) {\n            propertyValidator = schemaObj[key]['__validator'];\n            isValid = propertyValidator.validate(value, errors);\n\n            if (isValid && propertyValidator.childSchemaName == null && type.isObject(value)) {\n              errors.join(this.recursiveValidate(schemaObj[key], value));\n            }\n          } else {\n            parentValidator.validateOtherProperty(key, value, errors);\n          }\n        }\n\n        return errors;\n      };\n\n      Scheme.prototype.parseConfigObj = function (obj, parentValidator) {\n        var key, propValidator, value;\n\n        if (parentValidator == null) {\n          parentValidator = new PropertyValidator({\n            inputString: 'object',\n            scheme: this\n          });\n        }\n\n        for (key in obj) {\n          value = obj[key];\n\n          if (this.addParentValidator(parentValidator, key, value)) {\n            continue;\n          }\n\n          if (type.isString(value)) {\n            propValidator = new PropertyValidator({\n              inputString: value,\n              property: key,\n              parent: parentValidator,\n              scheme: this\n            });\n            obj[key] = {\n              '__validator': propValidator\n            };\n          } else if (type.isObject(value)) {\n            propValidator = new PropertyValidator({\n              inputString: 'object',\n              property: key,\n              parent: parentValidator,\n              scheme: this\n            });\n            obj[key] = this.parseConfigObj(value, propValidator);\n          }\n        }\n\n        obj['__validator'] = parentValidator;\n        return obj;\n      };\n\n      Scheme.prototype.addParentValidator = function (parentValidator, key, validator) {\n        switch (key) {\n          case '__validate':\n            parentValidator.addValidations(validator);\n            break;\n\n          case '__additionalProperty':\n            if (type.isFunction(validator)) {\n              parentValidator.otherPropertyValidator = validator;\n            }\n\n            break;\n\n          default:\n            return false;\n        }\n\n        return true;\n      };\n\n      Scheme.prototype.writeProperty = function (value) {\n        if (jsVariableName.test(value)) {\n          return \".\" + value;\n        } else {\n          return \"['\" + value + \"']\";\n        }\n      };\n\n      return Scheme;\n    }();\n  }, {\n    \"./property_validator\": 5,\n    \"./type\": 7,\n    \"./validation_errors\": 8,\n    \"./validators\": 9\n  }],\n  7: [function (require, module, exports) {\n    var toString, type;\n    toString = Object.prototype.toString;\n    module.exports = type = {\n      isObject: function isObject(obj) {\n        var t;\n        t = _typeof(obj);\n        return t === 'object' && !!obj && !this.isArray(obj);\n      },\n      isBoolean: function isBoolean(obj) {\n        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n      }\n    };\n    ['Function', 'String', 'Number', 'Date', 'RegExp', 'Array'].forEach(function (name) {\n      return type[\"is\" + name] = function (obj) {\n        return toString.call(obj) === \"[object \" + name + \"]\";\n      };\n    });\n\n    if (Array.isArray) {\n      type.isArray = Array.isArray;\n    }\n  }, {}],\n  8: [function (require, module, exports) {\n    var ValidationErrors, type;\n    type = require('./type');\n\n    module.exports = ValidationErrors = function () {\n      function ValidationErrors() {}\n\n      ValidationErrors.prototype.hasErrors = function () {\n        return this.errors != null;\n      };\n\n      ValidationErrors.prototype.setRoot = function (root) {\n        this.root = root;\n        return this;\n      };\n\n      ValidationErrors.prototype.add = function (message, _arg) {\n        var defaultMessage, error, location, _ref;\n\n        _ref = _arg != null ? _arg : {}, location = _ref.location, defaultMessage = _ref.defaultMessage;\n\n        if (message === false) {\n          message = defaultMessage;\n        }\n\n        if (message === void 0) {\n          message = \"validator returned undefined. Check your validator implementation.\";\n        }\n\n        if (this.errors == null) {\n          this.errors = [];\n        }\n\n        if (type.isString(message)) {\n          this.errors.push({\n            path: location,\n            message: message\n          });\n        } else if (message instanceof ValidationErrors) {\n          this.join(message, {\n            location: location\n          });\n        } else if (message.path && message.message) {\n          error = message;\n          this.errors.push({\n            path: location + error.path,\n            message: error.message\n          });\n        } else {\n          throw new Error('ValidationError.add() unknown error type');\n        }\n\n        return false;\n      };\n\n      ValidationErrors.prototype.join = function (_arg, _arg1) {\n        var error, errors, location, _i, _len, _results;\n\n        errors = _arg.errors;\n        location = (_arg1 != null ? _arg1 : {}).location;\n\n        if (errors == null) {\n          return;\n        }\n\n        if (errors.length) {\n          if (this.errors == null) {\n            this.errors = [];\n          }\n\n          _results = [];\n\n          for (_i = 0, _len = errors.length; _i < _len; _i++) {\n            error = errors[_i];\n\n            _results.push(this.errors.push({\n              path: (location || '') + error.path,\n              message: error.message\n            }));\n          }\n\n          return _results;\n        }\n      };\n\n      ValidationErrors.prototype.getMessages = function () {\n        var error, messages, _i, _len, _ref;\n\n        messages = [];\n        _ref = this.errors || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          error = _ref[_i];\n          messages.push(\"\" + (this.root || '') + error.path + \": \" + error.message);\n        }\n\n        return messages;\n      };\n\n      return ValidationErrors;\n    }();\n  }, {\n    \"./type\": 7\n  }],\n  9: [function (require, module, exports) {\n    var type;\n    type = require('./type');\n    module.exports = {\n      'object': function object(value) {\n        return type.isObject(value);\n      },\n      'string': function string(value) {\n        return type.isString(value);\n      },\n      'boolean': function boolean(value) {\n        return type.isBoolean(value);\n      },\n      'number': function number(value) {\n        return type.isNumber(value);\n      },\n      'function': function _function(value) {\n        return type.isFunction(value);\n      },\n      'date': function date(value) {\n        return type.isDate(value);\n      },\n      'regexp': function regexp(value) {\n        return type.isRegExp(value);\n      },\n      'array': function array(value) {\n        return type.isArray(value);\n      },\n      'falsy': function falsy(value) {\n        return !!value === false;\n      },\n      'truthy': function truthy(value) {\n        return !!value === true;\n      },\n      'not empty': function notEmpty(value) {\n        return !!value === true;\n      },\n      'deprecated': function deprecated(value) {\n        return true;\n      }\n    };\n  }, {\n    \"./type\": 7\n  }],\n  10: [function (require, module, exports) {\n    //     Underscore.js 1.6.0\n    //     http://underscorejs.org\n    //     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n    //     Underscore may be freely distributed under the MIT license.\n    (function () {\n      // Baseline setup\n      // --------------\n      // Establish the root object, `window` in the browser, or `exports` on the server.\n      var root = this; // Save the previous value of the `_` variable.\n\n      var previousUnderscore = root._; // Establish the object that gets returned to break out of a loop iteration.\n\n      var breaker = {}; // Save bytes in the minified (but not gzipped) version:\n\n      var ArrayProto = Array.prototype,\n          ObjProto = Object.prototype,\n          FuncProto = Function.prototype; // Create quick reference variables for speed access to core prototypes.\n\n      var push = ArrayProto.push,\n          slice = ArrayProto.slice,\n          concat = ArrayProto.concat,\n          toString = ObjProto.toString,\n          hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use\n      // are declared here.\n\n      var nativeForEach = ArrayProto.forEach,\n          nativeMap = ArrayProto.map,\n          nativeReduce = ArrayProto.reduce,\n          nativeReduceRight = ArrayProto.reduceRight,\n          nativeFilter = ArrayProto.filter,\n          nativeEvery = ArrayProto.every,\n          nativeSome = ArrayProto.some,\n          nativeIndexOf = ArrayProto.indexOf,\n          nativeLastIndexOf = ArrayProto.lastIndexOf,\n          nativeIsArray = Array.isArray,\n          nativeKeys = Object.keys,\n          nativeBind = FuncProto.bind; // Create a safe reference to the Underscore object for use below.\n\n      var _ = function _(obj) {\n        if (obj instanceof _) return obj;\n        if (!(this instanceof _)) return new _(obj);\n        this._wrapped = obj;\n      }; // Export the Underscore object for **Node.js**, with\n      // backwards-compatibility for the old `require()` API. If we're in\n      // the browser, add `_` as a global object via a string identifier,\n      // for Closure Compiler \"advanced\" mode.\n\n\n      if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n          exports = module.exports = _;\n        }\n\n        exports._ = _;\n      } else {\n        root._ = _;\n      } // Current version.\n\n\n      _.VERSION = '1.6.0'; // Collection Functions\n      // --------------------\n      // The cornerstone, an `each` implementation, aka `forEach`.\n      // Handles objects with the built-in `forEach`, arrays, and raw objects.\n      // Delegates to **ECMAScript 5**'s native `forEach` if available.\n\n      var each = _.each = _.forEach = function (obj, iterator, context) {\n        if (obj == null) return obj;\n\n        if (nativeForEach && obj.forEach === nativeForEach) {\n          obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n          for (var i = 0, length = obj.length; i < length; i++) {\n            if (iterator.call(context, obj[i], i, obj) === breaker) return;\n          }\n        } else {\n          var keys = _.keys(obj);\n\n          for (var i = 0, length = keys.length; i < length; i++) {\n            if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n          }\n        }\n\n        return obj;\n      }; // Return the results of applying the iterator to each element.\n      // Delegates to **ECMAScript 5**'s native `map` if available.\n\n\n      _.map = _.collect = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n        each(obj, function (value, index, list) {\n          results.push(iterator.call(context, value, index, list));\n        });\n        return results;\n      };\n\n      var reduceError = 'Reduce of empty array with no initial value'; // **Reduce** builds up a single result from a list of values, aka `inject`,\n      // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n\n      _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {\n        var initial = arguments.length > 2;\n        if (obj == null) obj = [];\n\n        if (nativeReduce && obj.reduce === nativeReduce) {\n          if (context) iterator = _.bind(iterator, context);\n          return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n        }\n\n        each(obj, function (value, index, list) {\n          if (!initial) {\n            memo = value;\n            initial = true;\n          } else {\n            memo = iterator.call(context, memo, value, index, list);\n          }\n        });\n        if (!initial) throw new TypeError(reduceError);\n        return memo;\n      }; // The right-associative version of reduce, also known as `foldr`.\n      // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n\n\n      _.reduceRight = _.foldr = function (obj, iterator, memo, context) {\n        var initial = arguments.length > 2;\n        if (obj == null) obj = [];\n\n        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n          if (context) iterator = _.bind(iterator, context);\n          return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n        }\n\n        var length = obj.length;\n\n        if (length !== +length) {\n          var keys = _.keys(obj);\n\n          length = keys.length;\n        }\n\n        each(obj, function (value, index, list) {\n          index = keys ? keys[--length] : --length;\n\n          if (!initial) {\n            memo = obj[index];\n            initial = true;\n          } else {\n            memo = iterator.call(context, memo, obj[index], index, list);\n          }\n        });\n        if (!initial) throw new TypeError(reduceError);\n        return memo;\n      }; // Return the first value which passes a truth test. Aliased as `detect`.\n\n\n      _.find = _.detect = function (obj, predicate, context) {\n        var result;\n        any(obj, function (value, index, list) {\n          if (predicate.call(context, value, index, list)) {\n            result = value;\n            return true;\n          }\n        });\n        return result;\n      }; // Return all the elements that pass a truth test.\n      // Delegates to **ECMAScript 5**'s native `filter` if available.\n      // Aliased as `select`.\n\n\n      _.filter = _.select = function (obj, predicate, context) {\n        var results = [];\n        if (obj == null) return results;\n        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n        each(obj, function (value, index, list) {\n          if (predicate.call(context, value, index, list)) results.push(value);\n        });\n        return results;\n      }; // Return all the elements for which a truth test fails.\n\n\n      _.reject = function (obj, predicate, context) {\n        return _.filter(obj, function (value, index, list) {\n          return !predicate.call(context, value, index, list);\n        }, context);\n      }; // Determine whether all of the elements match a truth test.\n      // Delegates to **ECMAScript 5**'s native `every` if available.\n      // Aliased as `all`.\n\n\n      _.every = _.all = function (obj, predicate, context) {\n        predicate || (predicate = _.identity);\n        var result = true;\n        if (obj == null) return result;\n        if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n        each(obj, function (value, index, list) {\n          if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n        });\n        return !!result;\n      }; // Determine if at least one element in the object matches a truth test.\n      // Delegates to **ECMAScript 5**'s native `some` if available.\n      // Aliased as `any`.\n\n\n      var any = _.some = _.any = function (obj, predicate, context) {\n        predicate || (predicate = _.identity);\n        var result = false;\n        if (obj == null) return result;\n        if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n        each(obj, function (value, index, list) {\n          if (result || (result = predicate.call(context, value, index, list))) return breaker;\n        });\n        return !!result;\n      }; // Determine if the array or object contains a given value (using `===`).\n      // Aliased as `include`.\n\n\n      _.contains = _.include = function (obj, target) {\n        if (obj == null) return false;\n        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n        return any(obj, function (value) {\n          return value === target;\n        });\n      }; // Invoke a method (with arguments) on every item in a collection.\n\n\n      _.invoke = function (obj, method) {\n        var args = slice.call(arguments, 2);\n\n        var isFunc = _.isFunction(method);\n\n        return _.map(obj, function (value) {\n          return (isFunc ? method : value[method]).apply(value, args);\n        });\n      }; // Convenience version of a common use case of `map`: fetching a property.\n\n\n      _.pluck = function (obj, key) {\n        return _.map(obj, _.property(key));\n      }; // Convenience version of a common use case of `filter`: selecting only objects\n      // containing specific `key:value` pairs.\n\n\n      _.where = function (obj, attrs) {\n        return _.filter(obj, _.matches(attrs));\n      }; // Convenience version of a common use case of `find`: getting the first object\n      // containing specific `key:value` pairs.\n\n\n      _.findWhere = function (obj, attrs) {\n        return _.find(obj, _.matches(attrs));\n      }; // Return the maximum element or (element-based computation).\n      // Can't optimize arrays of integers longer than 65,535 elements.\n      // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n\n\n      _.max = function (obj, iterator, context) {\n        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n          return Math.max.apply(Math, obj);\n        }\n\n        var result = -Infinity,\n            lastComputed = -Infinity;\n        each(obj, function (value, index, list) {\n          var computed = iterator ? iterator.call(context, value, index, list) : value;\n\n          if (computed > lastComputed) {\n            result = value;\n            lastComputed = computed;\n          }\n        });\n        return result;\n      }; // Return the minimum element (or element-based computation).\n\n\n      _.min = function (obj, iterator, context) {\n        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n          return Math.min.apply(Math, obj);\n        }\n\n        var result = Infinity,\n            lastComputed = Infinity;\n        each(obj, function (value, index, list) {\n          var computed = iterator ? iterator.call(context, value, index, list) : value;\n\n          if (computed < lastComputed) {\n            result = value;\n            lastComputed = computed;\n          }\n        });\n        return result;\n      }; // Shuffle an array, using the modern version of the\n      // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n\n\n      _.shuffle = function (obj) {\n        var rand;\n        var index = 0;\n        var shuffled = [];\n        each(obj, function (value) {\n          rand = _.random(index++);\n          shuffled[index - 1] = shuffled[rand];\n          shuffled[rand] = value;\n        });\n        return shuffled;\n      }; // Sample **n** random values from a collection.\n      // If **n** is not specified, returns a single random element.\n      // The internal `guard` argument allows it to work with `map`.\n\n\n      _.sample = function (obj, n, guard) {\n        if (n == null || guard) {\n          if (obj.length !== +obj.length) obj = _.values(obj);\n          return obj[_.random(obj.length - 1)];\n        }\n\n        return _.shuffle(obj).slice(0, Math.max(0, n));\n      }; // An internal function to generate lookup iterators.\n\n\n      var lookupIterator = function lookupIterator(value) {\n        if (value == null) return _.identity;\n        if (_.isFunction(value)) return value;\n        return _.property(value);\n      }; // Sort the object's values by a criterion produced by an iterator.\n\n\n      _.sortBy = function (obj, iterator, context) {\n        iterator = lookupIterator(iterator);\n        return _.pluck(_.map(obj, function (value, index, list) {\n          return {\n            value: value,\n            index: index,\n            criteria: iterator.call(context, value, index, list)\n          };\n        }).sort(function (left, right) {\n          var a = left.criteria;\n          var b = right.criteria;\n\n          if (a !== b) {\n            if (a > b || a === void 0) return 1;\n            if (a < b || b === void 0) return -1;\n          }\n\n          return left.index - right.index;\n        }), 'value');\n      }; // An internal function used for aggregate \"group by\" operations.\n\n\n      var group = function group(behavior) {\n        return function (obj, iterator, context) {\n          var result = {};\n          iterator = lookupIterator(iterator);\n          each(obj, function (value, index) {\n            var key = iterator.call(context, value, index, obj);\n            behavior(result, key, value);\n          });\n          return result;\n        };\n      }; // Groups the object's values by a criterion. Pass either a string attribute\n      // to group by, or a function that returns the criterion.\n\n\n      _.groupBy = group(function (result, key, value) {\n        _.has(result, key) ? result[key].push(value) : result[key] = [value];\n      }); // Indexes the object's values by a criterion, similar to `groupBy`, but for\n      // when you know that your index values will be unique.\n\n      _.indexBy = group(function (result, key, value) {\n        result[key] = value;\n      }); // Counts instances of an object that group by a certain criterion. Pass\n      // either a string attribute to count by, or a function that returns the\n      // criterion.\n\n      _.countBy = group(function (result, key) {\n        _.has(result, key) ? result[key]++ : result[key] = 1;\n      }); // Use a comparator function to figure out the smallest index at which\n      // an object should be inserted so as to maintain order. Uses binary search.\n\n      _.sortedIndex = function (array, obj, iterator, context) {\n        iterator = lookupIterator(iterator);\n        var value = iterator.call(context, obj);\n        var low = 0,\n            high = array.length;\n\n        while (low < high) {\n          var mid = low + high >>> 1;\n          iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n        }\n\n        return low;\n      }; // Safely create a real, live array from anything iterable.\n\n\n      _.toArray = function (obj) {\n        if (!obj) return [];\n        if (_.isArray(obj)) return slice.call(obj);\n        if (obj.length === +obj.length) return _.map(obj, _.identity);\n        return _.values(obj);\n      }; // Return the number of elements in an object.\n\n\n      _.size = function (obj) {\n        if (obj == null) return 0;\n        return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n      }; // Array Functions\n      // ---------------\n      // Get the first element of an array. Passing **n** will return the first N\n      // values in the array. Aliased as `head` and `take`. The **guard** check\n      // allows it to work with `_.map`.\n\n\n      _.first = _.head = _.take = function (array, n, guard) {\n        if (array == null) return void 0;\n        if (n == null || guard) return array[0];\n        if (n < 0) return [];\n        return slice.call(array, 0, n);\n      }; // Returns everything but the last entry of the array. Especially useful on\n      // the arguments object. Passing **n** will return all the values in\n      // the array, excluding the last N. The **guard** check allows it to work with\n      // `_.map`.\n\n\n      _.initial = function (array, n, guard) {\n        return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));\n      }; // Get the last element of an array. Passing **n** will return the last N\n      // values in the array. The **guard** check allows it to work with `_.map`.\n\n\n      _.last = function (array, n, guard) {\n        if (array == null) return void 0;\n        if (n == null || guard) return array[array.length - 1];\n        return slice.call(array, Math.max(array.length - n, 0));\n      }; // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n      // Especially useful on the arguments object. Passing an **n** will return\n      // the rest N values in the array. The **guard**\n      // check allows it to work with `_.map`.\n\n\n      _.rest = _.tail = _.drop = function (array, n, guard) {\n        return slice.call(array, n == null || guard ? 1 : n);\n      }; // Trim out all falsy values from an array.\n\n\n      _.compact = function (array) {\n        return _.filter(array, _.identity);\n      }; // Internal implementation of a recursive `flatten` function.\n\n\n      var flatten = function flatten(input, shallow, output) {\n        if (shallow && _.every(input, _.isArray)) {\n          return concat.apply(output, input);\n        }\n\n        each(input, function (value) {\n          if (_.isArray(value) || _.isArguments(value)) {\n            shallow ? push.apply(output, value) : flatten(value, shallow, output);\n          } else {\n            output.push(value);\n          }\n        });\n        return output;\n      }; // Flatten out an array, either recursively (by default), or just one level.\n\n\n      _.flatten = function (array, shallow) {\n        return flatten(array, shallow, []);\n      }; // Return a version of the array that does not contain the specified value(s).\n\n\n      _.without = function (array) {\n        return _.difference(array, slice.call(arguments, 1));\n      }; // Split an array into two arrays: one whose elements all satisfy the given\n      // predicate, and one whose elements all do not satisfy the predicate.\n\n\n      _.partition = function (array, predicate) {\n        var pass = [],\n            fail = [];\n        each(array, function (elem) {\n          (predicate(elem) ? pass : fail).push(elem);\n        });\n        return [pass, fail];\n      }; // Produce a duplicate-free version of the array. If the array has already\n      // been sorted, you have the option of using a faster algorithm.\n      // Aliased as `unique`.\n\n\n      _.uniq = _.unique = function (array, isSorted, iterator, context) {\n        if (_.isFunction(isSorted)) {\n          context = iterator;\n          iterator = isSorted;\n          isSorted = false;\n        }\n\n        var initial = iterator ? _.map(array, iterator, context) : array;\n        var results = [];\n        var seen = [];\n        each(initial, function (value, index) {\n          if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {\n            seen.push(value);\n            results.push(array[index]);\n          }\n        });\n        return results;\n      }; // Produce an array that contains the union: each distinct element from all of\n      // the passed-in arrays.\n\n\n      _.union = function () {\n        return _.uniq(_.flatten(arguments, true));\n      }; // Produce an array that contains every item shared between all the\n      // passed-in arrays.\n\n\n      _.intersection = function (array) {\n        var rest = slice.call(arguments, 1);\n        return _.filter(_.uniq(array), function (item) {\n          return _.every(rest, function (other) {\n            return _.contains(other, item);\n          });\n        });\n      }; // Take the difference between one array and a number of other arrays.\n      // Only the elements present in just the first array will remain.\n\n\n      _.difference = function (array) {\n        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n        return _.filter(array, function (value) {\n          return !_.contains(rest, value);\n        });\n      }; // Zip together multiple lists into a single array -- elements that share\n      // an index go together.\n\n\n      _.zip = function () {\n        var length = _.max(_.pluck(arguments, 'length').concat(0));\n\n        var results = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          results[i] = _.pluck(arguments, '' + i);\n        }\n\n        return results;\n      }; // Converts lists into objects. Pass either a single array of `[key, value]`\n      // pairs, or two parallel arrays of the same length -- one of keys, and one of\n      // the corresponding values.\n\n\n      _.object = function (list, values) {\n        if (list == null) return {};\n        var result = {};\n\n        for (var i = 0, length = list.length; i < length; i++) {\n          if (values) {\n            result[list[i]] = values[i];\n          } else {\n            result[list[i][0]] = list[i][1];\n          }\n        }\n\n        return result;\n      }; // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n      // we need this function. Return the position of the first occurrence of an\n      // item in an array, or -1 if the item is not included in the array.\n      // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n      // If the array is large and already in sort order, pass `true`\n      // for **isSorted** to use binary search.\n\n\n      _.indexOf = function (array, item, isSorted) {\n        if (array == null) return -1;\n        var i = 0,\n            length = array.length;\n\n        if (isSorted) {\n          if (typeof isSorted == 'number') {\n            i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;\n          } else {\n            i = _.sortedIndex(array, item);\n            return array[i] === item ? i : -1;\n          }\n        }\n\n        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n\n        for (; i < length; i++) {\n          if (array[i] === item) return i;\n        }\n\n        return -1;\n      }; // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n\n\n      _.lastIndexOf = function (array, item, from) {\n        if (array == null) return -1;\n        var hasIndex = from != null;\n\n        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n          return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n        }\n\n        var i = hasIndex ? from : array.length;\n\n        while (i--) {\n          if (array[i] === item) return i;\n        }\n\n        return -1;\n      }; // Generate an integer Array containing an arithmetic progression. A port of\n      // the native Python `range()` function. See\n      // [the Python documentation](http://docs.python.org/library/functions.html#range).\n\n\n      _.range = function (start, stop, step) {\n        if (arguments.length <= 1) {\n          stop = start || 0;\n          start = 0;\n        }\n\n        step = arguments[2] || 1;\n        var length = Math.max(Math.ceil((stop - start) / step), 0);\n        var idx = 0;\n        var range = new Array(length);\n\n        while (idx < length) {\n          range[idx++] = start;\n          start += step;\n        }\n\n        return range;\n      }; // Function (ahem) Functions\n      // ------------------\n      // Reusable constructor function for prototype setting.\n\n\n      var ctor = function ctor() {}; // Create a function bound to a given object (assigning `this`, and arguments,\n      // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n      // available.\n\n\n      _.bind = function (func, context) {\n        var args, _bound;\n\n        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n        if (!_.isFunction(func)) throw new TypeError();\n        args = slice.call(arguments, 2);\n        return _bound = function bound() {\n          if (!(this instanceof _bound)) return func.apply(context, args.concat(slice.call(arguments)));\n          ctor.prototype = func.prototype;\n          var self = new ctor();\n          ctor.prototype = null;\n          var result = func.apply(self, args.concat(slice.call(arguments)));\n          if (Object(result) === result) return result;\n          return self;\n        };\n      }; // Partially apply a function by creating a version that has had some of its\n      // arguments pre-filled, without changing its dynamic `this` context. _ acts\n      // as a placeholder, allowing any combination of arguments to be pre-filled.\n\n\n      _.partial = function (func) {\n        var boundArgs = slice.call(arguments, 1);\n        return function () {\n          var position = 0;\n          var args = boundArgs.slice();\n\n          for (var i = 0, length = args.length; i < length; i++) {\n            if (args[i] === _) args[i] = arguments[position++];\n          }\n\n          while (position < arguments.length) {\n            args.push(arguments[position++]);\n          }\n\n          return func.apply(this, args);\n        };\n      }; // Bind a number of an object's methods to that object. Remaining arguments\n      // are the method names to be bound. Useful for ensuring that all callbacks\n      // defined on an object belong to it.\n\n\n      _.bindAll = function (obj) {\n        var funcs = slice.call(arguments, 1);\n        if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n        each(funcs, function (f) {\n          obj[f] = _.bind(obj[f], obj);\n        });\n        return obj;\n      }; // Memoize an expensive function by storing its results.\n\n\n      _.memoize = function (func, hasher) {\n        var memo = {};\n        hasher || (hasher = _.identity);\n        return function () {\n          var key = hasher.apply(this, arguments);\n          return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);\n        };\n      }; // Delays a function for the given number of milliseconds, and then calls\n      // it with the arguments supplied.\n\n\n      _.delay = function (func, wait) {\n        var args = slice.call(arguments, 2);\n        return setTimeout(function () {\n          return func.apply(null, args);\n        }, wait);\n      }; // Defers a function, scheduling it to run after the current call stack has\n      // cleared.\n\n\n      _.defer = function (func) {\n        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n      }; // Returns a function, that, when invoked, will only be triggered at most once\n      // during a given window of time. Normally, the throttled function will run\n      // as much as it can, without ever going more than once per `wait` duration;\n      // but if you'd like to disable the execution on the leading edge, pass\n      // `{leading: false}`. To disable execution on the trailing edge, ditto.\n\n\n      _.throttle = function (func, wait, options) {\n        var context, args, result;\n        var timeout = null;\n        var previous = 0;\n        options || (options = {});\n\n        var later = function later() {\n          previous = options.leading === false ? 0 : _.now();\n          timeout = null;\n          result = func.apply(context, args);\n          context = args = null;\n        };\n\n        return function () {\n          var now = _.now();\n\n          if (!previous && options.leading === false) previous = now;\n          var remaining = wait - (now - previous);\n          context = this;\n          args = arguments;\n\n          if (remaining <= 0) {\n            clearTimeout(timeout);\n            timeout = null;\n            previous = now;\n            result = func.apply(context, args);\n            context = args = null;\n          } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n          }\n\n          return result;\n        };\n      }; // Returns a function, that, as long as it continues to be invoked, will not\n      // be triggered. The function will be called after it stops being called for\n      // N milliseconds. If `immediate` is passed, trigger the function on the\n      // leading edge, instead of the trailing.\n\n\n      _.debounce = function (func, wait, immediate) {\n        var timeout, args, context, timestamp, result;\n\n        var later = function later() {\n          var last = _.now() - timestamp;\n\n          if (last < wait) {\n            timeout = setTimeout(later, wait - last);\n          } else {\n            timeout = null;\n\n            if (!immediate) {\n              result = func.apply(context, args);\n              context = args = null;\n            }\n          }\n        };\n\n        return function () {\n          context = this;\n          args = arguments;\n          timestamp = _.now();\n          var callNow = immediate && !timeout;\n\n          if (!timeout) {\n            timeout = setTimeout(later, wait);\n          }\n\n          if (callNow) {\n            result = func.apply(context, args);\n            context = args = null;\n          }\n\n          return result;\n        };\n      }; // Returns a function that will be executed at most one time, no matter how\n      // often you call it. Useful for lazy initialization.\n\n\n      _.once = function (func) {\n        var ran = false,\n            memo;\n        return function () {\n          if (ran) return memo;\n          ran = true;\n          memo = func.apply(this, arguments);\n          func = null;\n          return memo;\n        };\n      }; // Returns the first function passed as an argument to the second,\n      // allowing you to adjust arguments, run code before and after, and\n      // conditionally execute the original function.\n\n\n      _.wrap = function (func, wrapper) {\n        return _.partial(wrapper, func);\n      }; // Returns a function that is the composition of a list of functions, each\n      // consuming the return value of the function that follows.\n\n\n      _.compose = function () {\n        var funcs = arguments;\n        return function () {\n          var args = arguments;\n\n          for (var i = funcs.length - 1; i >= 0; i--) {\n            args = [funcs[i].apply(this, args)];\n          }\n\n          return args[0];\n        };\n      }; // Returns a function that will only be executed after being called N times.\n\n\n      _.after = function (times, func) {\n        return function () {\n          if (--times < 1) {\n            return func.apply(this, arguments);\n          }\n        };\n      }; // Object Functions\n      // ----------------\n      // Retrieve the names of an object's properties.\n      // Delegates to **ECMAScript 5**'s native `Object.keys`\n\n\n      _.keys = function (obj) {\n        if (!_.isObject(obj)) return [];\n        if (nativeKeys) return nativeKeys(obj);\n        var keys = [];\n\n        for (var key in obj) {\n          if (_.has(obj, key)) keys.push(key);\n        }\n\n        return keys;\n      }; // Retrieve the values of an object's properties.\n\n\n      _.values = function (obj) {\n        var keys = _.keys(obj);\n\n        var length = keys.length;\n        var values = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          values[i] = obj[keys[i]];\n        }\n\n        return values;\n      }; // Convert an object into a list of `[key, value]` pairs.\n\n\n      _.pairs = function (obj) {\n        var keys = _.keys(obj);\n\n        var length = keys.length;\n        var pairs = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          pairs[i] = [keys[i], obj[keys[i]]];\n        }\n\n        return pairs;\n      }; // Invert the keys and values of an object. The values must be serializable.\n\n\n      _.invert = function (obj) {\n        var result = {};\n\n        var keys = _.keys(obj);\n\n        for (var i = 0, length = keys.length; i < length; i++) {\n          result[obj[keys[i]]] = keys[i];\n        }\n\n        return result;\n      }; // Return a sorted list of the function names available on the object.\n      // Aliased as `methods`\n\n\n      _.functions = _.methods = function (obj) {\n        var names = [];\n\n        for (var key in obj) {\n          if (_.isFunction(obj[key])) names.push(key);\n        }\n\n        return names.sort();\n      }; // Extend a given object with all the properties in passed-in object(s).\n\n\n      _.extend = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n          if (source) {\n            for (var prop in source) {\n              obj[prop] = source[prop];\n            }\n          }\n        });\n        return obj;\n      }; // Return a copy of the object only containing the whitelisted properties.\n\n\n      _.pick = function (obj) {\n        var copy = {};\n        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n        each(keys, function (key) {\n          if (key in obj) copy[key] = obj[key];\n        });\n        return copy;\n      }; // Return a copy of the object without the blacklisted properties.\n\n\n      _.omit = function (obj) {\n        var copy = {};\n        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n\n        for (var key in obj) {\n          if (!_.contains(keys, key)) copy[key] = obj[key];\n        }\n\n        return copy;\n      }; // Fill in a given object with default properties.\n\n\n      _.defaults = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n          if (source) {\n            for (var prop in source) {\n              if (obj[prop] === void 0) obj[prop] = source[prop];\n            }\n          }\n        });\n        return obj;\n      }; // Create a (shallow-cloned) duplicate of an object.\n\n\n      _.clone = function (obj) {\n        if (!_.isObject(obj)) return obj;\n        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n      }; // Invokes interceptor with the obj, and then returns obj.\n      // The primary purpose of this method is to \"tap into\" a method chain, in\n      // order to perform operations on intermediate results within the chain.\n\n\n      _.tap = function (obj, interceptor) {\n        interceptor(obj);\n        return obj;\n      }; // Internal recursive comparison function for `isEqual`.\n\n\n      var eq = function eq(a, b, aStack, bStack) {\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n        if (a === b) return a !== 0 || 1 / a == 1 / b; // A strict comparison is necessary because `null == undefined`.\n\n        if (a == null || b == null) return a === b; // Unwrap any wrapped objects.\n\n        if (a instanceof _) a = a._wrapped;\n        if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names.\n\n        var className = toString.call(a);\n        if (className != toString.call(b)) return false;\n\n        switch (className) {\n          // Strings, numbers, dates, and booleans are compared by value.\n          case '[object String]':\n            // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n            // equivalent to `new String(\"5\")`.\n            return a == String(b);\n\n          case '[object Number]':\n            // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n            // other numeric values.\n            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;\n\n          case '[object Date]':\n          case '[object Boolean]':\n            // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n            // millisecond representations. Note that invalid dates with millisecond representations\n            // of `NaN` are not equivalent.\n            return +a == +b;\n          // RegExps are compared by their source patterns and flags.\n\n          case '[object RegExp]':\n            return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n        }\n\n        if (_typeof(a) != 'object' || _typeof(b) != 'object') return false; // Assume equality for cyclic structures. The algorithm for detecting cyclic\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n        var length = aStack.length;\n\n        while (length--) {\n          // Linear search. Performance is inversely proportional to the number of\n          // unique nested structures.\n          if (aStack[length] == a) return bStack[length] == b;\n        } // Objects with different constructors are not equivalent, but `Object`s\n        // from different frames are.\n\n\n        var aCtor = a.constructor,\n            bCtor = b.constructor;\n\n        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {\n          return false;\n        } // Add the first object to the stack of traversed objects.\n\n\n        aStack.push(a);\n        bStack.push(b);\n        var size = 0,\n            result = true; // Recursively compare objects and arrays.\n\n        if (className == '[object Array]') {\n          // Compare array lengths to determine if a deep comparison is necessary.\n          size = a.length;\n          result = size == b.length;\n\n          if (result) {\n            // Deep compare the contents, ignoring non-numeric properties.\n            while (size--) {\n              if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n            }\n          }\n        } else {\n          // Deep compare objects.\n          for (var key in a) {\n            if (_.has(a, key)) {\n              // Count the expected number of properties.\n              size++; // Deep compare each member.\n\n              if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n            }\n          } // Ensure that both objects contain the same number of properties.\n\n\n          if (result) {\n            for (key in b) {\n              if (_.has(b, key) && !size--) break;\n            }\n\n            result = !size;\n          }\n        } // Remove the first object from the stack of traversed objects.\n\n\n        aStack.pop();\n        bStack.pop();\n        return result;\n      }; // Perform a deep comparison to check if two objects are equal.\n\n\n      _.isEqual = function (a, b) {\n        return eq(a, b, [], []);\n      }; // Is a given array, string, or object empty?\n      // An \"empty\" object has no enumerable own-properties.\n\n\n      _.isEmpty = function (obj) {\n        if (obj == null) return true;\n        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n\n        for (var key in obj) {\n          if (_.has(obj, key)) return false;\n        }\n\n        return true;\n      }; // Is a given value a DOM element?\n\n\n      _.isElement = function (obj) {\n        return !!(obj && obj.nodeType === 1);\n      }; // Is a given value an array?\n      // Delegates to ECMA5's native Array.isArray\n\n\n      _.isArray = nativeIsArray || function (obj) {\n        return toString.call(obj) == '[object Array]';\n      }; // Is a given variable an object?\n\n\n      _.isObject = function (obj) {\n        return obj === Object(obj);\n      }; // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n\n\n      each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {\n        _['is' + name] = function (obj) {\n          return toString.call(obj) == '[object ' + name + ']';\n        };\n      }); // Define a fallback version of the method in browsers (ahem, IE), where\n      // there isn't any inspectable \"Arguments\" type.\n\n      if (!_.isArguments(arguments)) {\n        _.isArguments = function (obj) {\n          return !!(obj && _.has(obj, 'callee'));\n        };\n      } // Optimize `isFunction` if appropriate.\n\n\n      if (true) {\n        _.isFunction = function (obj) {\n          return typeof obj === 'function';\n        };\n      } // Is a given object a finite number?\n\n\n      _.isFinite = function (obj) {\n        return isFinite(obj) && !isNaN(parseFloat(obj));\n      }; // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n\n\n      _.isNaN = function (obj) {\n        return _.isNumber(obj) && obj != +obj;\n      }; // Is a given value a boolean?\n\n\n      _.isBoolean = function (obj) {\n        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n      }; // Is a given value equal to null?\n\n\n      _.isNull = function (obj) {\n        return obj === null;\n      }; // Is a given variable undefined?\n\n\n      _.isUndefined = function (obj) {\n        return obj === void 0;\n      }; // Shortcut function for checking if an object has a given property directly\n      // on itself (in other words, not on a prototype).\n\n\n      _.has = function (obj, key) {\n        return hasOwnProperty.call(obj, key);\n      }; // Utility Functions\n      // -----------------\n      // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n      // previous owner. Returns a reference to the Underscore object.\n\n\n      _.noConflict = function () {\n        root._ = previousUnderscore;\n        return this;\n      }; // Keep the identity function around for default iterators.\n\n\n      _.identity = function (value) {\n        return value;\n      };\n\n      _.constant = function (value) {\n        return function () {\n          return value;\n        };\n      };\n\n      _.property = function (key) {\n        return function (obj) {\n          return obj[key];\n        };\n      }; // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n\n\n      _.matches = function (attrs) {\n        return function (obj) {\n          if (obj === attrs) return true; //avoid comparing an object to itself.\n\n          for (var key in attrs) {\n            if (attrs[key] !== obj[key]) return false;\n          }\n\n          return true;\n        };\n      }; // Run a function **n** times.\n\n\n      _.times = function (n, iterator, context) {\n        var accum = Array(Math.max(0, n));\n\n        for (var i = 0; i < n; i++) {\n          accum[i] = iterator.call(context, i);\n        }\n\n        return accum;\n      }; // Return a random integer between min and max (inclusive).\n\n\n      _.random = function (min, max) {\n        if (max == null) {\n          max = min;\n          min = 0;\n        }\n\n        return min + Math.floor(Math.random() * (max - min + 1));\n      }; // A (possibly faster) way to get the current timestamp as an integer.\n\n\n      _.now = Date.now || function () {\n        return new Date().getTime();\n      }; // List of HTML entities for escaping.\n\n\n      var entityMap = {\n        escape: {\n          '&': '&amp;',\n          '<': '&lt;',\n          '>': '&gt;',\n          '\"': '&quot;',\n          \"'\": '&#x27;'\n        }\n      };\n      entityMap.unescape = _.invert(entityMap.escape); // Regexes containing the keys and values listed immediately above.\n\n      var entityRegexes = {\n        escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n        unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n      }; // Functions for escaping and unescaping strings to/from HTML interpolation.\n\n      _.each(['escape', 'unescape'], function (method) {\n        _[method] = function (string) {\n          if (string == null) return '';\n          return ('' + string).replace(entityRegexes[method], function (match) {\n            return entityMap[method][match];\n          });\n        };\n      }); // If the value of the named `property` is a function then invoke it with the\n      // `object` as context; otherwise, return it.\n\n\n      _.result = function (object, property) {\n        if (object == null) return void 0;\n        var value = object[property];\n        return _.isFunction(value) ? value.call(object) : value;\n      }; // Add your own custom functions to the Underscore object.\n\n\n      _.mixin = function (obj) {\n        each(_.functions(obj), function (name) {\n          var func = _[name] = obj[name];\n\n          _.prototype[name] = function () {\n            var args = [this._wrapped];\n            push.apply(args, arguments);\n            return result.call(this, func.apply(_, args));\n          };\n        });\n      }; // Generate a unique integer id (unique within the entire client session).\n      // Useful for temporary DOM ids.\n\n\n      var idCounter = 0;\n\n      _.uniqueId = function (prefix) {\n        var id = ++idCounter + '';\n        return prefix ? prefix + id : id;\n      }; // By default, Underscore uses ERB-style template delimiters, change the\n      // following template settings to use alternative delimiters.\n\n\n      _.templateSettings = {\n        evaluate: /<%([\\s\\S]+?)%>/g,\n        interpolate: /<%=([\\s\\S]+?)%>/g,\n        escape: /<%-([\\s\\S]+?)%>/g\n      }; // When customizing `templateSettings`, if you don't want to define an\n      // interpolation, evaluation or escaping regex, we need one that is\n      // guaranteed not to match.\n\n      var noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a\n      // string literal.\n\n      var escapes = {\n        \"'\": \"'\",\n        '\\\\': '\\\\',\n        '\\r': 'r',\n        '\\n': 'n',\n        '\\t': 't',\n        \"\\u2028\": 'u2028',\n        \"\\u2029\": 'u2029'\n      };\n      var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g; // JavaScript micro-templating, similar to John Resig's implementation.\n      // Underscore templating handles arbitrary delimiters, preserves whitespace,\n      // and correctly escapes quotes within interpolated code.\n\n      _.template = function (text, data, settings) {\n        var render;\n        settings = _.defaults({}, settings, _.templateSettings); // Combine delimiters into one regular expression via alternation.\n\n        var matcher = new RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately.\n\n        var index = 0;\n        var source = \"__p+='\";\n        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n          source += text.slice(index, offset).replace(escaper, function (match) {\n            return '\\\\' + escapes[match];\n          });\n\n          if (escape) {\n            source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n          }\n\n          if (interpolate) {\n            source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n          }\n\n          if (evaluate) {\n            source += \"';\\n\" + evaluate + \"\\n__p+='\";\n          }\n\n          index = offset + match.length;\n          return match;\n        });\n        source += \"';\\n\"; // If a variable is not specified, place data values in local scope.\n\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n        source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + source + \"return __p;\\n\";\n\n        try {\n          render = new Function(settings.variable || 'obj', '_', source);\n        } catch (e) {\n          e.source = source;\n          throw e;\n        }\n\n        if (data) return render(data, _);\n\n        var template = function template(data) {\n          return render.call(this, data, _);\n        }; // Provide the compiled function source as a convenience for precompilation.\n\n\n        template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n        return template;\n      }; // Add a \"chain\" function, which will delegate to the wrapper.\n\n\n      _.chain = function (obj) {\n        return _(obj).chain();\n      }; // OOP\n      // ---------------\n      // If Underscore is called as a function, it returns a wrapped object that\n      // can be used OO-style. This wrapper holds altered versions of all the\n      // underscore functions. Wrapped objects may be chained.\n      // Helper function to continue chaining intermediate results.\n\n\n      var result = function result(obj) {\n        return this._chain ? _(obj).chain() : obj;\n      }; // Add all of the Underscore functions to the wrapper object.\n\n\n      _.mixin(_); // Add all mutator Array functions to the wrapper.\n\n\n      each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n        var method = ArrayProto[name];\n\n        _.prototype[name] = function () {\n          var obj = this._wrapped;\n          method.apply(obj, arguments);\n          if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n          return result.call(this, obj);\n        };\n      }); // Add all accessor Array functions to the wrapper.\n\n      each(['concat', 'join', 'slice'], function (name) {\n        var method = ArrayProto[name];\n\n        _.prototype[name] = function () {\n          return result.call(this, method.apply(this._wrapped, arguments));\n        };\n      });\n\n      _.extend(_.prototype, {\n        // Start chaining a wrapped Underscore object.\n        chain: function chain() {\n          this._chain = true;\n          return this;\n        },\n        // Extracts the result from a wrapped and chained object.\n        value: function value() {\n          return this._wrapped;\n        }\n      }); // AMD registration happens at the end for compatibility with AMD loaders\n      // that may not enforce next-turn semantics on modules. Even though general\n      // practice for AMD registration is to be anonymous, underscore registers\n      // as a named module because, like jQuery, it is a base library that is\n      // popular enough to be bundled in a third party lib, but not be part of\n      // an AMD load request. Those cases could generate an error when an\n      // anonymous define() is called outside of a loader request.\n\n\n      if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n        define('underscore', [], function () {\n          return _;\n        });\n      }\n    }).call(this);\n  }, {}],\n  11: [function (require, module, exports) {\n    /*!\n     * EventEmitter v4.2.11 - git.io/ee\n     * Unlicense - http://unlicense.org/\n     * Oliver Caldwell - http://oli.me.uk/\n     * @preserve\n     */\n    ;\n    (function () {\n      'use strict';\n      /**\n       * Class for managing events.\n       * Can be extended to provide event functionality in other classes.\n       *\n       * @class EventEmitter Manages event registering and emitting.\n       */\n\n      function EventEmitter() {} // Shortcuts to improve speed and size\n\n\n      var proto = EventEmitter.prototype;\n      var exports = this;\n      var originalGlobalValue = exports.EventEmitter;\n      /**\n       * Finds the index of the listener for the event in its storage array.\n       *\n       * @param {Function[]} listeners Array of listeners to search through.\n       * @param {Function} listener Method to look for.\n       * @return {Number} Index of the specified listener, -1 if not found\n       * @api private\n       */\n\n      function indexOfListener(listeners, listener) {\n        var i = listeners.length;\n\n        while (i--) {\n          if (listeners[i].listener === listener) {\n            return i;\n          }\n        }\n\n        return -1;\n      }\n      /**\n       * Alias a method while keeping the context correct, to allow for overwriting of target method.\n       *\n       * @param {String} name The name of the target method.\n       * @return {Function} The aliased method\n       * @api private\n       */\n\n\n      function alias(name) {\n        return function aliasClosure() {\n          return this[name].apply(this, arguments);\n        };\n      }\n      /**\n       * Returns the listener array for the specified event.\n       * Will initialise the event object and listener arrays if required.\n       * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n       * Each property in the object response is an array of listener functions.\n       *\n       * @param {String|RegExp} evt Name of the event to return the listeners from.\n       * @return {Function[]|Object} All listener functions for the event.\n       */\n\n\n      proto.getListeners = function getListeners(evt) {\n        var events = this._getEvents();\n\n        var response;\n        var key; // Return a concatenated array of all matching events if\n        // the selector is a regular expression.\n\n        if (evt instanceof RegExp) {\n          response = {};\n\n          for (key in events) {\n            if (events.hasOwnProperty(key) && evt.test(key)) {\n              response[key] = events[key];\n            }\n          }\n        } else {\n          response = events[evt] || (events[evt] = []);\n        }\n\n        return response;\n      };\n      /**\n       * Takes a list of listener objects and flattens it into a list of listener functions.\n       *\n       * @param {Object[]} listeners Raw listener objects.\n       * @return {Function[]} Just the listener functions.\n       */\n\n\n      proto.flattenListeners = function flattenListeners(listeners) {\n        var flatListeners = [];\n        var i;\n\n        for (i = 0; i < listeners.length; i += 1) {\n          flatListeners.push(listeners[i].listener);\n        }\n\n        return flatListeners;\n      };\n      /**\n       * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n       *\n       * @param {String|RegExp} evt Name of the event to return the listeners from.\n       * @return {Object} All listener functions for an event in an object.\n       */\n\n\n      proto.getListenersAsObject = function getListenersAsObject(evt) {\n        var listeners = this.getListeners(evt);\n        var response;\n\n        if (listeners instanceof Array) {\n          response = {};\n          response[evt] = listeners;\n        }\n\n        return response || listeners;\n      };\n      /**\n       * Adds a listener function to the specified event.\n       * The listener will not be added if it is a duplicate.\n       * If the listener returns true then it will be removed after it is called.\n       * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n       *\n       * @param {String|RegExp} evt Name of the event to attach the listener to.\n       * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.addListener = function addListener(evt, listener) {\n        var listeners = this.getListenersAsObject(evt);\n        var listenerIsWrapped = _typeof(listener) === 'object';\n        var key;\n\n        for (key in listeners) {\n          if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n            listeners[key].push(listenerIsWrapped ? listener : {\n              listener: listener,\n              once: false\n            });\n          }\n        }\n\n        return this;\n      };\n      /**\n       * Alias of addListener\n       */\n\n\n      proto.on = alias('addListener');\n      /**\n       * Semi-alias of addListener. It will add a listener that will be\n       * automatically removed after its first execution.\n       *\n       * @param {String|RegExp} evt Name of the event to attach the listener to.\n       * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n      proto.addOnceListener = function addOnceListener(evt, listener) {\n        return this.addListener(evt, {\n          listener: listener,\n          once: true\n        });\n      };\n      /**\n       * Alias of addOnceListener.\n       */\n\n\n      proto.once = alias('addOnceListener');\n      /**\n       * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n       * You need to tell it what event names should be matched by a regex.\n       *\n       * @param {String} evt Name of the event to create.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n      proto.defineEvent = function defineEvent(evt) {\n        this.getListeners(evt);\n        return this;\n      };\n      /**\n       * Uses defineEvent to define multiple events.\n       *\n       * @param {String[]} evts An array of event names to define.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.defineEvents = function defineEvents(evts) {\n        for (var i = 0; i < evts.length; i += 1) {\n          this.defineEvent(evts[i]);\n        }\n\n        return this;\n      };\n      /**\n       * Removes a listener function from the specified event.\n       * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n       *\n       * @param {String|RegExp} evt Name of the event to remove the listener from.\n       * @param {Function} listener Method to remove from the event.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.removeListener = function removeListener(evt, listener) {\n        var listeners = this.getListenersAsObject(evt);\n        var index;\n        var key;\n\n        for (key in listeners) {\n          if (listeners.hasOwnProperty(key)) {\n            index = indexOfListener(listeners[key], listener);\n\n            if (index !== -1) {\n              listeners[key].splice(index, 1);\n            }\n          }\n        }\n\n        return this;\n      };\n      /**\n       * Alias of removeListener\n       */\n\n\n      proto.off = alias('removeListener');\n      /**\n       * Adds listeners in bulk using the manipulateListeners method.\n       * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n       * You can also pass it a regular expression to add the array of listeners to all events that match it.\n       * Yeah, this function does quite a bit. That's probably a bad thing.\n       *\n       * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n       * @param {Function[]} [listeners] An optional array of listener functions to add.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n      proto.addListeners = function addListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(false, evt, listeners);\n      };\n      /**\n       * Removes listeners in bulk using the manipulateListeners method.\n       * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n       * You can also pass it an event name and an array of listeners to be removed.\n       * You can also pass it a regular expression to remove the listeners from all events that match it.\n       *\n       * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n       * @param {Function[]} [listeners] An optional array of listener functions to remove.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.removeListeners = function removeListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(true, evt, listeners);\n      };\n      /**\n       * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n       * The first argument will determine if the listeners are removed (true) or added (false).\n       * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n       * You can also pass it an event name and an array of listeners to be added/removed.\n       * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n       *\n       * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n       * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n       * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n        var i;\n        var value;\n        var single = remove ? this.removeListener : this.addListener;\n        var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method\n\n        if (_typeof(evt) === 'object' && !(evt instanceof RegExp)) {\n          for (i in evt) {\n            if (evt.hasOwnProperty(i) && (value = evt[i])) {\n              // Pass the single listener straight through to the singular method\n              if (typeof value === 'function') {\n                single.call(this, i, value);\n              } else {\n                // Otherwise pass back to the multiple function\n                multiple.call(this, i, value);\n              }\n            }\n          }\n        } else {\n          // So evt must be a string\n          // And listeners must be an array of listeners\n          // Loop over it and pass each one to the multiple method\n          i = listeners.length;\n\n          while (i--) {\n            single.call(this, evt, listeners[i]);\n          }\n        }\n\n        return this;\n      };\n      /**\n       * Removes all listeners from a specified event.\n       * If you do not specify an event then all listeners will be removed.\n       * That means every event will be emptied.\n       * You can also pass a regex to remove all events that match it.\n       *\n       * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.removeEvent = function removeEvent(evt) {\n        var type = _typeof(evt);\n\n        var events = this._getEvents();\n\n        var key; // Remove different things depending on the state of evt\n\n        if (type === 'string') {\n          // Remove all listeners for the specified event\n          delete events[evt];\n        } else if (evt instanceof RegExp) {\n          // Remove all events matching the regex.\n          for (key in events) {\n            if (events.hasOwnProperty(key) && evt.test(key)) {\n              delete events[key];\n            }\n          }\n        } else {\n          // Remove all listeners in all events\n          delete this._events;\n        }\n\n        return this;\n      };\n      /**\n       * Alias of removeEvent.\n       *\n       * Added to mirror the node API.\n       */\n\n\n      proto.removeAllListeners = alias('removeEvent');\n      /**\n       * Emits an event of your choice.\n       * When emitted, every listener attached to that event will be executed.\n       * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n       * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n       * So they will not arrive within the array on the other side, they will be separate.\n       * You can also pass a regular expression to emit to all events that match it.\n       *\n       * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n       * @param {Array} [args] Optional array of arguments to be passed to each listener.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n      proto.emitEvent = function emitEvent(evt, args) {\n        var listeners = this.getListenersAsObject(evt);\n        var listener;\n        var i;\n        var key;\n        var response;\n\n        for (key in listeners) {\n          if (listeners.hasOwnProperty(key)) {\n            i = listeners[key].length;\n\n            while (i--) {\n              // If the listener returns true then it shall be removed from the event\n              // The function is executed either with a basic call or an apply if there is an args array\n              listener = listeners[key][i];\n\n              if (listener.once === true) {\n                this.removeListener(evt, listener.listener);\n              }\n\n              response = listener.listener.apply(this, args || []);\n\n              if (response === this._getOnceReturnValue()) {\n                this.removeListener(evt, listener.listener);\n              }\n            }\n          }\n        }\n\n        return this;\n      };\n      /**\n       * Alias of emitEvent\n       */\n\n\n      proto.trigger = alias('emitEvent');\n      /**\n       * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n       * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n       *\n       * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n       * @param {...*} Optional additional arguments to be passed to each listener.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n      proto.emit = function emit(evt) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return this.emitEvent(evt, args);\n      };\n      /**\n       * Sets the current value to check against when executing listeners. If a\n       * listeners return value matches the one set here then it will be removed\n       * after execution. This value defaults to true.\n       *\n       * @param {*} value The new value to check for when executing listeners.\n       * @return {Object} Current instance of EventEmitter for chaining.\n       */\n\n\n      proto.setOnceReturnValue = function setOnceReturnValue(value) {\n        this._onceReturnValue = value;\n        return this;\n      };\n      /**\n       * Fetches the current value to check against when executing listeners. If\n       * the listeners return value matches this one then it should be removed\n       * automatically. It will return true by default.\n       *\n       * @return {*|Boolean} The current value to check for or the default, true.\n       * @api private\n       */\n\n\n      proto._getOnceReturnValue = function _getOnceReturnValue() {\n        if (this.hasOwnProperty('_onceReturnValue')) {\n          return this._onceReturnValue;\n        } else {\n          return true;\n        }\n      };\n      /**\n       * Fetches the events object and creates one if required.\n       *\n       * @return {Object} The events storage object.\n       * @api private\n       */\n\n\n      proto._getEvents = function _getEvents() {\n        return this._events || (this._events = {});\n      };\n      /**\n       * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n       *\n       * @return {Function} Non conflicting EventEmitter class.\n       */\n\n\n      EventEmitter.noConflict = function noConflict() {\n        exports.EventEmitter = originalGlobalValue;\n        return EventEmitter;\n      }; // Expose the class either via AMD, CommonJS or the global object\n\n\n      if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n        define(function () {\n          return EventEmitter;\n        });\n      } else if (_typeof(module) === 'object' && module.exports) {\n        module.exports = EventEmitter;\n      } else {\n        exports.EventEmitter = EventEmitter;\n      }\n    }).call(this);\n  }, {}],\n  12: [function (require, module, exports) {\n    var ComponentTree, CssLoader, EditorPage, JsLoader, Livingdoc, augmentConfig, _config, designCache, doc, imageService, version;\n\n    _config = require('./configuration/config');\n    augmentConfig = require('./configuration/augment_config');\n    Livingdoc = require('./livingdoc');\n    ComponentTree = require('./component_tree/component_tree');\n    designCache = require('./design/design_cache');\n    EditorPage = require('./rendering_container/editor_page');\n    JsLoader = require('./rendering_container/js_loader');\n    CssLoader = require('./rendering_container/css_loader');\n    version = require('../version');\n    imageService = require('./image_services/image_service');\n\n    module.exports = doc = function () {\n      var editorPage;\n      editorPage = new EditorPage();\n      return {\n        version: version.version,\n        revision: version.revision,\n        design: designCache,\n        Livingdoc: Livingdoc,\n        ComponentTree: ComponentTree,\n        createLivingdoc: function createLivingdoc(_arg) {\n          var componentTree, data, designName, designVersion, layout;\n          data = _arg.data, designName = _arg.designName, designVersion = _arg.designVersion, layout = _arg.layout, componentTree = _arg.componentTree;\n          return Livingdoc.create({\n            data: data,\n            designName: designName,\n            designVersion: designVersion,\n            layoutName: layout,\n            componentTree: componentTree\n          });\n        },\n        \"new\": function _new() {\n          return this.createLivingdoc.apply(this, arguments);\n        },\n        create: function create() {\n          return this.createLivingdoc.apply(this, arguments);\n        },\n        startDrag: $.proxy(editorPage, 'startDrag'),\n        config: function config(userConfig) {\n          $.extend(true, _config, userConfig);\n          return augmentConfig(_config);\n        },\n        JsLoader: JsLoader,\n        CssLoader: CssLoader,\n        getImageService: function getImageService(serviceName) {\n          return imageService.get(serviceName);\n        }\n      };\n    }();\n\n    window.doc = doc;\n  }, {\n    \"../version\": 75,\n    \"./component_tree/component_tree\": 19,\n    \"./configuration/augment_config\": 25,\n    \"./configuration/config\": 26,\n    \"./design/design_cache\": 30,\n    \"./image_services/image_service\": 37,\n    \"./livingdoc\": 45,\n    \"./rendering_container/css_loader\": 63,\n    \"./rendering_container/editor_page\": 64,\n    \"./rendering_container/js_loader\": 66\n  }],\n  13: [function (require, module, exports) {\n    var ComponentArray;\n\n    module.exports = ComponentArray = function () {\n      function ComponentArray(components) {\n        this.components = components;\n\n        if (this.components == null) {\n          this.components = [];\n        }\n\n        this.createPseudoArray();\n      }\n\n      ComponentArray.prototype.createPseudoArray = function () {\n        var index, result, _i, _len, _ref;\n\n        _ref = this.components;\n\n        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n          result = _ref[index];\n          this[index] = result;\n        }\n\n        this.length = this.components.length;\n\n        if (this.components.length) {\n          this.first = this[0];\n          return this.last = this[this.components.length - 1];\n        }\n      };\n\n      ComponentArray.prototype.each = function (callback) {\n        var component, _i, _len, _ref;\n\n        _ref = this.components;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          component = _ref[_i];\n          callback(component);\n        }\n\n        return this;\n      };\n\n      ComponentArray.prototype.remove = function () {\n        this.each(function (component) {\n          return component.remove();\n        });\n        return this;\n      };\n\n      return ComponentArray;\n    }();\n  }, {}],\n  14: [function (require, module, exports) {\n    var ComponentContainer, assert;\n    assert = require('../modules/logging/assert');\n\n    module.exports = ComponentContainer = function () {\n      function ComponentContainer(_arg) {\n        var config, isRoot;\n        this.parentComponent = _arg.parentComponent, this.name = _arg.name, isRoot = _arg.isRoot, config = _arg.config;\n        this.isRoot = isRoot != null;\n        this.first = this.last = void 0;\n        this.allowedChildren = void 0;\n        this.parseConfig(config);\n      }\n\n      ComponentContainer.prototype.parseConfig = function (configuration) {\n        var componentName, _i, _len, _ref, _results;\n\n        if (configuration == null) {\n          return;\n        }\n\n        _ref = configuration.allowedChildren || [];\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          componentName = _ref[_i];\n\n          if (this.allowedChildren == null) {\n            this.allowedChildren = {};\n          }\n\n          _results.push(this.allowedChildren[componentName] = true);\n        }\n\n        return _results;\n      };\n\n      ComponentContainer.prototype.isAllowedAsChild = function (component) {\n        if (!component) {\n          return false;\n        }\n\n        return !!(this.canBeNested(component.id) && this.isChildAllowed(component.template) && this.isAllowedAsParent(component.template));\n      };\n\n      ComponentContainer.prototype.isTypeAllowedAsChild = function (template) {\n        if (template == null) {\n          return false;\n        }\n\n        return !!(this.isChildAllowed(template) && this.isAllowedAsParent(template));\n      };\n\n      ComponentContainer.prototype.canBeNested = function (componentId) {\n        var parent;\n        parent = this.parentComponent;\n\n        while (parent != null) {\n          if (parent.id === componentId) {\n            return false;\n          }\n\n          parent = parent.getParent();\n        }\n\n        return true;\n      };\n\n      ComponentContainer.prototype.isChildAllowed = function (template) {\n        return this.allowedChildren === void 0 || this.allowedChildren[template.name];\n      };\n\n      ComponentContainer.prototype.isAllowedAsParent = function (template) {\n        var allowed, allowedParents, parentName, _i, _len, _ref;\n\n        if (!(allowedParents = template.allowedParents)) {\n          return true;\n        }\n\n        parentName = this.isRoot ? 'root' : (_ref = this.parentComponent) != null ? _ref.componentName : void 0;\n\n        for (_i = 0, _len = allowedParents.length; _i < _len; _i++) {\n          allowed = allowedParents[_i];\n\n          if (parentName === allowed) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      ComponentContainer.prototype.getComponentTree = function () {\n        var _ref;\n\n        return this.componentTree || ((_ref = this.parentComponent) != null ? _ref.componentTree : void 0);\n      };\n\n      ComponentContainer.prototype.prepend = function (component) {\n        if (this.first) {\n          this.insertBefore(this.first, component);\n        } else {\n          this.attachComponent(component);\n        }\n\n        return this;\n      };\n\n      ComponentContainer.prototype.append = function (component) {\n        if (this.parentComponent) {\n          assert(component !== this.parentComponent, 'cannot append component to itself');\n        }\n\n        if (this.last) {\n          this.insertAfter(this.last, component);\n        } else {\n          this.attachComponent(component);\n        }\n\n        return this;\n      };\n\n      ComponentContainer.prototype.insertBefore = function (component, insertedComponent) {\n        var position;\n\n        if (component.previous === insertedComponent) {\n          return;\n        }\n\n        assert(component !== insertedComponent, 'cannot insert component before itself');\n        position = {\n          previous: component.previous,\n          next: component,\n          parentContainer: component.parentContainer\n        };\n        return this.attachComponent(insertedComponent, position);\n      };\n\n      ComponentContainer.prototype.insertAfter = function (component, insertedComponent) {\n        var position;\n\n        if (component.next === insertedComponent) {\n          return;\n        }\n\n        assert(component !== insertedComponent, 'cannot insert component after itself');\n        position = {\n          previous: component,\n          next: component.next,\n          parentContainer: component.parentContainer\n        };\n        return this.attachComponent(insertedComponent, position);\n      };\n\n      ComponentContainer.prototype.up = function (component) {\n        if (component.previous != null) {\n          return this.insertBefore(component.previous, component);\n        }\n      };\n\n      ComponentContainer.prototype.down = function (component) {\n        if (component.next != null) {\n          return this.insertAfter(component.next, component);\n        }\n      };\n\n      ComponentContainer.prototype.remove = function (component) {\n        component.destroy();\n        return this._detachComponent(component);\n      };\n\n      ComponentContainer.prototype.each = function (callback) {\n        var component, _results;\n\n        component = this.first;\n        _results = [];\n\n        while (component) {\n          component.descendantsAndSelf(callback);\n\n          _results.push(component = component.next);\n        }\n\n        return _results;\n      };\n\n      ComponentContainer.prototype.eachContainer = function (callback) {\n        callback(this);\n        return this.each(function (component) {\n          var componentContainer, name, _ref, _results;\n\n          _ref = component.containers;\n          _results = [];\n\n          for (name in _ref) {\n            componentContainer = _ref[name];\n\n            _results.push(callback(componentContainer));\n          }\n\n          return _results;\n        });\n      };\n\n      ComponentContainer.prototype.all = function (callback) {\n        callback(this);\n        return this.each(function (component) {\n          var componentContainer, name, _ref, _results;\n\n          callback(component);\n          _ref = component.containers;\n          _results = [];\n\n          for (name in _ref) {\n            componentContainer = _ref[name];\n\n            _results.push(callback(componentContainer));\n          }\n\n          return _results;\n        });\n      };\n\n      ComponentContainer.prototype.attachComponent = function (component, position) {\n        var componentTree, func;\n\n        if (position == null) {\n          position = {};\n        }\n\n        if (!this.isAllowedAsChild(component)) {\n          return;\n        }\n\n        assert(this.isAllowedAsChild(component), \"Component '\" + component.componentName + \"' is not allowed as a child of \" + this.getContainerIdentifier());\n\n        func = function (_this) {\n          return function () {\n            return _this.link(component, position);\n          };\n        }(this);\n\n        if (componentTree = this.getComponentTree()) {\n          return componentTree.attachingComponent(component, func);\n        } else {\n          return func();\n        }\n      };\n\n      ComponentContainer.prototype._detachComponent = function (component) {\n        var componentTree, func;\n\n        func = function (_this) {\n          return function () {\n            return _this.unlink(component);\n          };\n        }(this);\n\n        if (componentTree = this.getComponentTree()) {\n          return componentTree.detachingComponent(component, func);\n        } else {\n          return func();\n        }\n      };\n\n      ComponentContainer.prototype.link = function (component, position) {\n        if (component.parentContainer) {\n          this.unlink(component);\n        }\n\n        position.parentContainer || (position.parentContainer = this);\n        return this.setComponentPosition(component, position);\n      };\n\n      ComponentContainer.prototype.unlink = function (component) {\n        var container, _ref, _ref1;\n\n        container = component.parentContainer;\n\n        if (container) {\n          if (component.previous == null) {\n            container.first = component.next;\n          }\n\n          if (component.next == null) {\n            container.last = component.previous;\n          }\n\n          if ((_ref = component.next) != null) {\n            _ref.previous = component.previous;\n          }\n\n          if ((_ref1 = component.previous) != null) {\n            _ref1.next = component.next;\n          }\n\n          return this.setComponentPosition(component, {});\n        }\n      };\n\n      ComponentContainer.prototype.setComponentPosition = function (component, _arg) {\n        var next, parentContainer, previous;\n        parentContainer = _arg.parentContainer, previous = _arg.previous, next = _arg.next;\n        component.parentContainer = parentContainer;\n        component.previous = previous;\n        component.next = next;\n\n        if (parentContainer) {\n          if (previous) {\n            previous.next = component;\n          }\n\n          if (next) {\n            next.previous = component;\n          }\n\n          if (component.previous == null) {\n            parentContainer.first = component;\n          }\n\n          if (component.next == null) {\n            return parentContainer.last = component;\n          }\n        }\n      };\n\n      ComponentContainer.prototype.getContainerIdentifier = function () {\n        if (this.isRoot) {\n          return 'root';\n        } else {\n          return \"\" + this.parentComponent.componentName + \".containers['\" + this.name + \"']\";\n        }\n      };\n\n      return ComponentContainer;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50\n  }],\n  15: [function (require, module, exports) {\n    var ComponentDirective;\n\n    module.exports = ComponentDirective = function () {\n      function ComponentDirective(_arg) {\n        this.component = _arg.component, this.templateDirective = _arg.templateDirective;\n        this.name = this.templateDirective.name;\n        this.type = this.templateDirective.type;\n      }\n\n      ComponentDirective.prototype.getContent = function () {\n        return this.component.content[this.name];\n      };\n\n      ComponentDirective.prototype.setContent = function (value) {\n        return this.component.setContent(this.name, value);\n      };\n\n      ComponentDirective.prototype.copyTo = function (otherDirective) {\n        return otherDirective.setContent(this.getContent());\n      };\n\n      ComponentDirective.prototype.isEmpty = function () {\n        return !this.getContent();\n      };\n\n      ComponentDirective.prototype.setData = function (key, value) {\n        var dataStore, directiveData;\n        dataStore = \"_\" + this.name + \"Directive\";\n        directiveData = this.component.getData(dataStore);\n\n        if (directiveData == null) {\n          directiveData = {};\n        }\n\n        directiveData[key] = value;\n        return this.component.setData(dataStore, directiveData);\n      };\n\n      ComponentDirective.prototype.getData = function (key) {\n        var _ref;\n\n        if (key) {\n          return (_ref = this.component.dataValues[\"_\" + this.name + \"Directive\"]) != null ? _ref[key] : void 0;\n        } else {\n          return this.component.dataValues[\"_\" + this.name + \"Directive\"];\n        }\n      };\n\n      ComponentDirective.prototype.setTmp = function (key, value) {\n        this.tmp = {};\n        return this.tmp[key] = value;\n      };\n\n      ComponentDirective.prototype.getTmp = function (key) {\n        var _ref;\n\n        return (_ref = this.tmp) != null ? _ref[key] : void 0;\n      };\n\n      return ComponentDirective;\n    }();\n  }, {}],\n  16: [function (require, module, exports) {\n    var ComponentDirective, EditableDirective, HtmlDirective, ImageDirective, LinkDirective, EmbedItemDirective, WysiwygDirective, assert, imageService;\n    assert = require('../modules/logging/assert');\n    imageService = require('../image_services/image_service');\n    EditableDirective = require('./editable_directive');\n    ImageDirective = require('./image_directive');\n    HtmlDirective = require('./html_directive');\n    LinkDirective = require('./link_directive');\n    ComponentDirective = require('./component_directive');\n\n    var __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    }; // todo(Marcus) need to re-compile from coffee script really...\n\n\n    EmbedItemDirective = function (_super) {\n      __extends(EmbedItemDirective, _super);\n\n      function EmbedItemDirective() {\n        return EmbedItemDirective.__super__.constructor.apply(this, arguments);\n      }\n\n      EmbedItemDirective.prototype.isEmbed = true;\n      return EmbedItemDirective;\n    }(ComponentDirective); // todo(Marcus) need to re-compile from coffee script really...\n\n\n    WysiwygDirective = function (_super) {\n      __extends(WysiwygDirective, _super);\n\n      function WysiwygDirective() {\n        return WysiwygDirective.__super__.constructor.apply(this, arguments);\n      }\n\n      WysiwygDirective.prototype.isWysiwyg = true;\n      return WysiwygDirective;\n    }(ComponentDirective);\n\n    module.exports = {\n      create: function create(_arg) {\n        var Directive, component, templateDirective;\n        component = _arg.component, templateDirective = _arg.templateDirective;\n        Directive = this.getDirectiveConstructor(templateDirective.type);\n        return new Directive({\n          component: component,\n          templateDirective: templateDirective\n        });\n      },\n      getDirectiveConstructor: function getDirectiveConstructor(directiveType) {\n        switch (directiveType) {\n          case 'editable':\n            return EditableDirective;\n\n          case 'image':\n            return ImageDirective;\n\n          case 'html':\n            return HtmlDirective;\n\n          case 'link':\n            return LinkDirective;\n\n          case 'embeditem':\n            return EmbedItemDirective;\n\n          case 'wysiwyg':\n            return WysiwygDirective;\n\n          default:\n            return assert(false, \"Unsupported component directive: \" + directiveType);\n        }\n      }\n    };\n  }, {\n    \"../image_services/image_service\": 37,\n    \"../modules/logging/assert\": 50,\n    \"./editable_directive\": 20,\n    \"./html_directive\": 22,\n    \"./image_directive\": 23,\n    \"./link_directive\": 24,\n    \"./component_directive\": 15\n  }],\n  17: [function (require, module, exports) {\n    var ComponentContainer, ComponentModel, DirectiveCollection, assert, config, deepEqual, directiveFactory, guid, log;\n    deepEqual = require('deep-equal');\n    config = require('../configuration/config');\n    ComponentContainer = require('./component_container');\n    guid = require('../modules/guid');\n    log = require('../modules/logging/log');\n    assert = require('../modules/logging/assert');\n    directiveFactory = require('./component_directive_factory');\n    DirectiveCollection = require('../template/directive_collection');\n\n    module.exports = ComponentModel = function () {\n      function ComponentModel(_arg) {\n        var id, _ref;\n\n        _ref = _arg != null ? _arg : {}, this.template = _ref.template, id = _ref.id;\n        assert(this.template, 'cannot instantiate component without template reference');\n        this.initializeDirectives();\n        this.styles = {};\n        this.dataValues = {};\n        this.id = id || guid.next();\n        this.componentName = this.template.name;\n        this.next = void 0;\n        this.previous = void 0;\n        this.componentTree = void 0;\n      }\n\n      ComponentModel.prototype.initializeDirectives = function () {\n        var directive, _i, _len, _ref, _results;\n\n        this.directives = new DirectiveCollection();\n        _ref = this.template.directives;\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          directive = _ref[_i];\n\n          switch (directive.type) {\n            case 'container':\n              this.containers || (this.containers = {});\n\n              _results.push(this.containers[directive.name] = new ComponentContainer({\n                name: directive.name,\n                parentComponent: this,\n                config: directive.config\n              }));\n\n              break;\n\n            case 'editable':\n            case 'image':\n            case 'html':\n            case 'link':\n            case 'embeditem':\n            case 'wysiwyg':\n              this.createComponentDirective(directive);\n              this.content || (this.content = {});\n\n              _results.push(this.content[directive.name] = void 0);\n\n              break;\n\n            default:\n              _results.push(log.error(\"Template directive type '\" + directive.type + \"' not implemented in ComponentModel\"));\n\n          }\n        }\n\n        return _results;\n      };\n\n      ComponentModel.prototype.createComponentDirective = function (templateDirective) {\n        return this.directives.add(directiveFactory.create({\n          component: this,\n          templateDirective: templateDirective\n        }));\n      };\n\n      ComponentModel.prototype.createView = function (isReadOnly) {\n        return this.template.createView(this, isReadOnly);\n      };\n\n      ComponentModel.prototype.getMainView = function () {\n        return this.componentTree.getMainComponentView(this.id);\n      };\n\n      ComponentModel.prototype.isAllowedAsSibling = function (component) {\n        return this.parentContainer.isAllowedAsChild(component);\n      };\n\n      ComponentModel.prototype.isTypeAllowedAsSibling = function (template) {\n        if (this.parentContainer == null) {\n          return true;\n        }\n\n        return this.parentContainer.isTypeAllowedAsChild(template);\n      };\n\n      ComponentModel.prototype.isAllowedAsChild = function (containerName, component) {\n        return this.containers[containerName].isAllowedAsChild(component);\n      };\n\n      ComponentModel.prototype.before = function (componentModel) {\n        if (componentModel) {\n          this.parentContainer.insertBefore(this, componentModel);\n          return this;\n        } else {\n          return this.previous;\n        }\n      };\n\n      ComponentModel.prototype.after = function (componentModel) {\n        if (componentModel) {\n          this.parentContainer.insertAfter(this, componentModel);\n          return this;\n        } else {\n          return this.next;\n        }\n      };\n\n      ComponentModel.prototype.append = function (containerName, componentModel) {\n        this.containers[containerName].append(componentModel);\n        return this;\n      };\n\n      ComponentModel.prototype.prepend = function (containerName, componentModel) {\n        this.containers[containerName].prepend(componentModel);\n        return this;\n      };\n\n      ComponentModel.prototype.up = function () {\n        this.parentContainer.up(this);\n        return this;\n      };\n\n      ComponentModel.prototype.down = function () {\n        this.parentContainer.down(this);\n        return this;\n      };\n\n      ComponentModel.prototype.remove = function () {\n        return this.parentContainer.remove(this);\n      };\n\n      ComponentModel.prototype.getTransforms = function () {\n        var transforms, _ref;\n\n        return transforms = (_ref = this.template.design) != null ? _ref.transforms : void 0;\n      };\n\n      ComponentModel.prototype.getTransformOptions = function (_arg) {\n        var directives, oneWay, transforms, _ref;\n\n        _ref = _arg != null ? _arg : {}, oneWay = _ref.oneWay, directives = _ref.directives;\n        transforms = this.getTransforms();\n\n        if (transforms == null) {\n          return;\n        }\n\n        return transforms.getOptionsList({\n          template: this.template,\n          oneWay: oneWay,\n          directives: directives,\n          filter: function (_this) {\n            return function (template) {\n              return _this.isTypeAllowedAsSibling(template);\n            };\n          }(this)\n        });\n      };\n\n      ComponentModel.prototype.transform = function (componentName) {\n        var compatibility, design, from, fromDirective, newDirective, newModel, newTemplate, to, transforms, _ref;\n\n        transforms = this.getTransforms();\n        design = this.template.design;\n        newTemplate = design.get(componentName);\n        compatibility = transforms.isCompatible(this, newTemplate, {\n          oneWay: true\n        });\n        assert(compatibility.isCompatible, \"Component \" + this.componentName + \" can not be transformed into \" + componentName + \".\");\n        newModel = newTemplate.createModel();\n        _ref = compatibility.mapping || [];\n\n        for (from in _ref) {\n          to = _ref[from];\n          fromDirective = this.directives.get(from);\n          newDirective = newModel.directives.get(to);\n          fromDirective.copyTo(newDirective);\n        }\n\n        return this.replaceWith(newModel);\n      };\n\n      ComponentModel.prototype.replaceWith = function (otherComponent) {\n        this.after(otherComponent);\n        this.remove();\n        return otherComponent;\n      };\n\n      ComponentModel.prototype.getParent = function () {\n        var _ref;\n\n        return (_ref = this.parentContainer) != null ? _ref.parentComponent : void 0;\n      };\n\n      ComponentModel.prototype.parents = function (callback) {\n        var componentModel, _results;\n\n        componentModel = this;\n        _results = [];\n\n        while (componentModel = componentModel.getParent()) {\n          _results.push(callback(componentModel));\n        }\n\n        return _results;\n      };\n\n      ComponentModel.prototype.children = function (callback) {\n        var componentContainer, componentModel, name, _ref, _results;\n\n        _ref = this.containers;\n        _results = [];\n\n        for (name in _ref) {\n          componentContainer = _ref[name];\n          componentModel = componentContainer.first;\n\n          _results.push(function () {\n            var _results1;\n\n            _results1 = [];\n\n            while (componentModel) {\n              callback(componentModel);\n\n              _results1.push(componentModel = componentModel.next);\n            }\n\n            return _results1;\n          }());\n        }\n\n        return _results;\n      };\n\n      ComponentModel.prototype.childrenAndSelf = function (callback) {\n        callback(this);\n        return this.children(callback);\n      };\n\n      ComponentModel.prototype.descendants = function (callback) {\n        var componentContainer, componentModel, name, _ref, _results;\n\n        _ref = this.containers;\n        _results = [];\n\n        for (name in _ref) {\n          componentContainer = _ref[name];\n          componentModel = componentContainer.first;\n\n          _results.push(function () {\n            var _results1;\n\n            _results1 = [];\n\n            while (componentModel) {\n              callback(componentModel);\n              componentModel.descendants(callback);\n\n              _results1.push(componentModel = componentModel.next);\n            }\n\n            return _results1;\n          }());\n        }\n\n        return _results;\n      };\n\n      ComponentModel.prototype.descendantsAndSelf = function (callback) {\n        callback(this);\n        return this.descendants(callback);\n      };\n\n      ComponentModel.prototype.parentContainers = function (callback) {\n        var componentModel, _results;\n\n        componentModel = this;\n        _results = [];\n\n        while (componentModel != null) {\n          callback(componentModel.parentContainer);\n\n          _results.push(componentModel = componentModel.getParent());\n        }\n\n        return _results;\n      };\n\n      ComponentModel.prototype.descendantContainers = function (callback) {\n        return this.descendantsAndSelf(function (componentModel) {\n          var componentContainer, name, _ref, _results;\n\n          _ref = componentModel.containers;\n          _results = [];\n\n          for (name in _ref) {\n            componentContainer = _ref[name];\n\n            _results.push(callback(componentContainer));\n          }\n\n          return _results;\n        });\n      };\n\n      ComponentModel.prototype.allDescendants = function (callback) {\n        return this.descendantsAndSelf(function (_this) {\n          return function (componentModel) {\n            var componentContainer, name, _ref, _results;\n\n            if (componentModel !== _this) {\n              callback(componentModel);\n            }\n\n            _ref = componentModel.containers;\n            _results = [];\n\n            for (name in _ref) {\n              componentContainer = _ref[name];\n\n              _results.push(callback(componentContainer));\n            }\n\n            return _results;\n          };\n        }(this));\n      };\n\n      ComponentModel.prototype.hasContainers = function () {\n        return this.containers != null;\n      };\n\n      ComponentModel.prototype.hasEditables = function () {\n        return this.directives.count('editable') > 0;\n      };\n\n      ComponentModel.prototype.hasHtml = function () {\n        return this.directives.count('html') > 0;\n      };\n\n      ComponentModel.prototype.hasWysiwyg = function () {\n        return this.directives.count('wysiwyg') > 0;\n      };\n\n      ComponentModel.prototype.hasImages = function () {\n        return this.directives.count('image') > 0;\n      };\n\n      ComponentModel.prototype.hasLinks = function () {\n        return this.directives.count('link') > 0;\n      };\n\n      ComponentModel.prototype.setContent = function (name, value) {\n        if (!value) {\n          if (this.content[name]) {\n            this.content[name] = void 0;\n\n            if (this.componentTree) {\n              return this.componentTree.contentChanging(this, name);\n            }\n          }\n        } else if (typeof value === 'string') {\n          if (this.content[name] !== value) {\n            this.content[name] = value;\n\n            if (this.componentTree) {\n              return this.componentTree.contentChanging(this, name);\n            }\n          }\n        } else {\n          if (!deepEqual(this.content[name], value)) {\n            this.content[name] = value;\n\n            if (this.componentTree) {\n              return this.componentTree.contentChanging(this, name);\n            }\n          }\n        }\n      };\n\n      ComponentModel.prototype.set = function (name, value) {\n        var directive, _ref;\n\n        assert((_ref = this.content) != null ? _ref.hasOwnProperty(name) : void 0, \"set error: \" + this.componentName + \" has no content named \" + name);\n        directive = this.directives.get(name);\n\n        if (directive.isImage) {\n          if (directive.getImageUrl() !== value) {\n            directive.setImageUrl(value);\n\n            if (this.componentTree) {\n              return this.componentTree.contentChanging(this, name);\n            }\n          }\n        } else {\n          return this.setContent(name, value);\n        }\n      };\n\n      ComponentModel.prototype.get = function (name) {\n        var _ref;\n\n        assert((_ref = this.content) != null ? _ref.hasOwnProperty(name) : void 0, \"get error: \" + this.componentName + \" has no content named \" + name);\n        return this.directives.get(name).getContent();\n      };\n\n      ComponentModel.prototype.isEmpty = function (name) {\n        var value;\n        value = this.get(name);\n        return value === void 0 || value === '';\n      };\n\n      ComponentModel.prototype.data = function (arg) {\n        var changedDataProperties, name, value, _ref;\n\n        if (_typeof(arg) === 'object') {\n          changedDataProperties = [];\n\n          for (name in arg) {\n            value = arg[name];\n\n            if (this.changeData(name, value)) {\n              changedDataProperties.push(name);\n            }\n          }\n\n          if (changedDataProperties.length > 0) {\n            return (_ref = this.componentTree) != null ? _ref.dataChanging(this, changedDataProperties) : void 0;\n          }\n        } else if (arg) {\n          return this.dataValues[arg];\n        } else {\n          return this.dataValues;\n        }\n      };\n\n      ComponentModel.prototype.setDirectiveAttribute = function (name, attr, value) {\n        var attributes,\n            itemAttributes = {};\n        attributes = this.getData('data_attributes');\n\n        if (!attributes) {\n          attributes = {};\n        }\n\n        if (attributes[name]) {\n          itemAttributes = attributes[name];\n        }\n\n        itemAttributes[attr] = value;\n        attributes[name] = itemAttributes;\n        this.setData('data_attributes', attributes);\n      };\n\n      ComponentModel.prototype.getDirectiveAttribute = function (name, attr, value) {\n        var attributes,\n            itemAttributes = {};\n        attributes = this.getData('data_attributes');\n\n        if (!attributes) {\n          attributes = {};\n        }\n\n        if (attributes[name]) {\n          itemAttributes = attributes[name];\n        }\n\n        return itemAttributes[attr] ? itemAttributes[attr] : value;\n      };\n\n      ComponentModel.prototype.setData = function (key, value) {\n        var _ref;\n\n        if (key && this.changeData(key, value)) {\n          return (_ref = this.componentTree) != null ? _ref.dataChanging(this, [key]) : void 0;\n        }\n      };\n\n      ComponentModel.prototype.getData = function (key) {\n        if (key) {\n          return this.dataValues[key];\n        } else {\n          return this.dataValues;\n        }\n      };\n\n      ComponentModel.prototype.changeData = function (name, value) {\n        if (deepEqual(this.dataValues[name], value)) {\n          return false;\n        }\n\n        this.dataValues[name] = value;\n        return true;\n      };\n\n      ComponentModel.prototype.getPluginName = function () {\n        var _ref;\n\n        return (_ref = this.plugin) != null ? _ref.name : void 0;\n      };\n\n      ComponentModel.prototype.setPlugin = function (plugin) {\n        return this.plugin = plugin;\n      };\n\n      ComponentModel.prototype.getPlugin = function (plugin) {\n        return this.plugin;\n      };\n\n      ComponentModel.prototype.getStyle = function (name) {\n        return this.styles[name];\n      };\n\n      ComponentModel.prototype.setStyle = function (name, value) {\n        var style;\n        style = this.template.styles[name];\n\n        if (!style) {\n          return log.warn(\"Unknown style '\" + name + \"' in ComponentModel \" + this.componentName);\n        } else if (!style.validateValue(value)) {\n          return log.warn(\"Invalid value '\" + value + \"' for style '\" + name + \"' in ComponentModel \" + this.componentName);\n        } else {\n          if (this.styles[name] !== value) {\n            this.styles[name] = value;\n\n            if (this.componentTree) {\n              return this.componentTree.htmlChanging(this, 'style', {\n                name: name,\n                value: value\n              });\n            }\n          }\n        }\n      };\n\n      ComponentModel.prototype.style = function (name, value) {\n        console.log(\"ComponentModel#style() is deprecated. Please use #getStyle() and #setStyle().\");\n\n        if (arguments.length === 1) {\n          return this.styles[name];\n        } else {\n          return this.setStyle(name, value);\n        }\n      };\n\n      ComponentModel.prototype.copy = function () {\n        return log.warn(\"ComponentModel#copy() is not implemented yet.\");\n      };\n\n      ComponentModel.prototype.copyWithoutContent = function () {\n        return this.template.createModel();\n      };\n\n      ComponentModel.prototype.destroy = function () {};\n\n      return ComponentModel;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/guid\": 49,\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../template/directive_collection\": 70,\n    \"./component_container\": 14,\n    \"./component_directive_factory\": 16,\n    \"deep-equal\": 1\n  }],\n  18: [function (require, module, exports) {\n    var $, ComponentModel, assert, config, deepEqual, guid, log, serialization;\n    $ = require('jquery');\n    deepEqual = require('deep-equal');\n    config = require('../configuration/config');\n    guid = require('../modules/guid');\n    log = require('../modules/logging/log');\n    assert = require('../modules/logging/assert');\n    ComponentModel = require('./component_model');\n    serialization = require('../modules/serialization');\n\n    module.exports = function () {\n      ComponentModel.prototype.toJson = function (component) {\n        var json, name;\n\n        if (component == null) {\n          component = this;\n        }\n\n        json = {\n          id: component.id,\n          identifier: component.template.identifier\n        };\n\n        if (!serialization.isEmpty(component.content)) {\n          json.content = serialization.flatCopy(component.content);\n        }\n\n        if (!serialization.isEmpty(component.styles)) {\n          json.styles = serialization.flatCopy(component.styles);\n        }\n\n        if (!serialization.isEmpty(component.dataValues)) {\n          json.data = $.extend(true, {}, component.dataValues);\n        }\n\n        for (name in component.containers) {\n          json.containers || (json.containers = {});\n          json.containers[name] = [];\n        }\n\n        return json;\n      };\n\n      return {\n        fromJson: function fromJson(json, design) {\n          var child, componentArray, containerName, model, name, styleName, template, value, _i, _len, _ref, _ref1, _ref2;\n\n          template = design.get(json.component || json.identifier);\n\n          if (!template) {\n            console.error(\"Uknown template identifier: \" + json.identifier);\n            return;\n          }\n\n          assert(template, \"error while deserializing component: unknown template identifier '\" + json.identifier + \"'\");\n          model = new ComponentModel({\n            template: template,\n            id: json.id\n          });\n          _ref = json.content;\n\n          for (name in _ref) {\n            value = _ref[name];\n\n            if (!model.content.hasOwnProperty(name)) {\n              console.log(\"Unknown content found while deserializing \" + model.componentName + \": unknown content '\" + name);\n              continue;\n            } //        assert(model.content.hasOwnProperty(name), \"error while deserializing component \" + model.componentName + \": unknown content '\" + name + \"'\");\n\n\n            if (model.directives.get(name).type === 'image' && typeof value === 'string') {\n              model.content[name] = {\n                url: value\n              };\n            } else {\n              model.content[name] = value;\n            }\n          }\n\n          _ref1 = json.styles;\n\n          for (styleName in _ref1) {\n            value = _ref1[styleName];\n            model.setStyle(styleName, value);\n          }\n\n          if (json.data) {\n            model.data(json.data);\n          }\n\n          _ref2 = json.containers;\n\n          for (containerName in _ref2) {\n            componentArray = _ref2[containerName];\n\n            if (!model.containers.hasOwnProperty(containerName)) {\n              console.warn(\"error while deserializing component: unknown container \" + containerName);\n              componentArray = null;\n            }\n\n            if (componentArray) {\n              assert($.isArray(componentArray), \"error while deserializing component: container is not array \" + containerName);\n\n              for (_i = 0, _len = componentArray.length; _i < _len; _i++) {\n                child = componentArray[_i];\n                model.append(containerName, this.fromJson(child, design));\n              }\n            }\n          }\n\n          return model;\n        }\n      };\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/guid\": 49,\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../modules/serialization\": 54,\n    \"./component_model\": 17,\n    \"deep-equal\": 1,\n    \"jquery\": \"jquery\"\n  }],\n  19: [function (require, module, exports) {\n    var $,\n        ComponentArray,\n        ComponentContainer,\n        ComponentModel,\n        ComponentTree,\n        assert,\n        componentModelSerializer,\n        __slice = [].slice;\n    $ = require('jquery');\n    assert = require('../modules/logging/assert');\n    ComponentContainer = require('./component_container');\n    ComponentArray = require('./component_array');\n    ComponentModel = require('./component_model');\n    componentModelSerializer = require('./component_model_serializer');\n\n    module.exports = ComponentTree = function () {\n      function ComponentTree(_arg) {\n        var content, _ref;\n\n        _ref = _arg != null ? _arg : {}, content = _ref.content, this.design = _ref.design;\n        assert(this.design != null, \"Error instantiating ComponentTree: design param is misssing.\");\n        this.componentById = {};\n        this.root = new ComponentContainer({\n          isRoot: true\n        });\n\n        if (content != null) {\n          this.fromJson(content, this.design);\n        }\n\n        this.root.componentTree = this;\n        this.initializeEvents();\n      }\n\n      ComponentTree.prototype.prepend = function (component) {\n        component = this.getComponent(component);\n\n        if (component != null) {\n          this.root.prepend(component);\n        }\n\n        return this;\n      };\n\n      ComponentTree.prototype.append = function (component) {\n        component = this.getComponent(component);\n\n        if (component != null) {\n          this.root.append(component);\n        }\n\n        return this;\n      };\n\n      ComponentTree.prototype.getComponent = function (componentName) {\n        if (typeof componentName === 'string') {\n          return this.createComponent(componentName);\n        } else {\n          return componentName;\n        }\n      };\n\n      ComponentTree.prototype.createComponent = function (componentName) {\n        var template;\n        template = this.getTemplate(componentName);\n\n        if (template) {\n          return template.createModel();\n        }\n      };\n\n      ComponentTree.prototype.getTemplate = function (componentName) {\n        var template;\n        template = this.design.get(componentName);\n        assert(template, \"Could not find template \" + componentName);\n        return template;\n      };\n\n      ComponentTree.prototype.initializeEvents = function () {\n        this.componentAdded = $.Callbacks();\n        this.componentRemoved = $.Callbacks();\n        this.componentMoved = $.Callbacks();\n        this.componentContentChanged = $.Callbacks();\n        this.componentHtmlChanged = $.Callbacks();\n        this.componentSettingsChanged = $.Callbacks();\n        this.componentDataChanged = $.Callbacks();\n        return this.changed = $.Callbacks();\n      };\n\n      ComponentTree.prototype.each = function (callback) {\n        return this.root.each(callback);\n      };\n\n      ComponentTree.prototype.eachContainer = function (callback) {\n        return this.root.eachContainer(callback);\n      };\n\n      ComponentTree.prototype.first = function () {\n        return this.root.first;\n      };\n\n      ComponentTree.prototype.getAllComponents = function () {\n        if (this._componentsArrayCache) {\n          return this._componentsArrayCache;\n        }\n\n        this._componentsArrayCache = [];\n        this.each(function (_this) {\n          return function (c) {\n            return _this._componentsArrayCache.push(c);\n          };\n        }(this));\n        return this._componentsArrayCache;\n      };\n\n      ComponentTree.prototype.eq = function (index) {\n        return this.getAllComponents()[index];\n      };\n\n      ComponentTree.prototype.indexOf = function (component) {\n        return this.getAllComponents().indexOf(component);\n      };\n\n      ComponentTree.prototype.all = function (callback) {\n        return this.root.all(callback);\n      };\n\n      ComponentTree.prototype.find = function (search) {\n        var res;\n\n        if (typeof search === 'string') {\n          res = [];\n          this.each(function (component) {\n            if (component.componentName === search) {\n              return res.push(component);\n            }\n          });\n          return new ComponentArray(res);\n        } else {\n          return new ComponentArray();\n        }\n      };\n\n      ComponentTree.prototype.findById = function (id) {\n        return this.componentById[id];\n      };\n\n      ComponentTree.prototype.detach = function () {\n        var oldRoot;\n        this.root.componentTree = void 0;\n        this.each(function (_this) {\n          return function (component) {\n            component.componentTree = void 0;\n            return _this.componentById[component.id] = void 0;\n          };\n        }(this));\n        oldRoot = this.root;\n        this.root = new ComponentContainer({\n          isRoot: true\n        });\n        return oldRoot;\n      };\n\n      ComponentTree.prototype.setMainView = function (_arg) {\n        var renderer;\n        renderer = _arg.renderer;\n        assert(renderer, 'componentTree.setMainView: view does not have an initialized renderer');\n        assert(renderer.componentTree === this, 'componentTree.setMainView: Cannot set renderer from different componentTree');\n        return this.mainRenderer = renderer;\n      };\n\n      ComponentTree.prototype.getMainComponentView = function (componentId) {\n        var _ref;\n\n        return (_ref = this.mainRenderer) != null ? _ref.getComponentViewById(componentId) : void 0;\n      };\n\n      ComponentTree.prototype.isDropAllowed = function (component, targetObj) {\n        var componentView, containerName, target, targetComponent;\n        target = targetObj.target, componentView = targetObj.componentView, containerName = targetObj.containerName;\n\n        if (target === 'root') {\n          return this.root.isAllowedAsChild(component);\n        } else if (target === 'component') {\n          targetComponent = componentView.model;\n          return targetComponent.isAllowedAsSibling(component);\n        } else if (target === 'container') {\n          targetComponent = componentView.model;\n          return targetComponent.isAllowedAsChild(containerName, component);\n        }\n      };\n\n      ComponentTree.prototype.print = function () {\n        var addLine, output, _walker;\n\n        output = 'ComponentTree\\n-----------\\n';\n\n        addLine = function addLine(text, indentation) {\n          if (indentation == null) {\n            indentation = 0;\n          }\n\n          return output += \"\" + Array(indentation + 1).join(\" \") + text + \"\\n\";\n        };\n\n        _walker = function walker(component, indentation) {\n          var componentContainer, name, template, _ref;\n\n          if (indentation == null) {\n            indentation = 0;\n          }\n\n          template = component.template;\n          addLine(\"- \" + template.label + \" (\" + template.name + \")\", indentation);\n          _ref = component.containers;\n\n          for (name in _ref) {\n            componentContainer = _ref[name];\n            addLine(\"\" + name + \":\", indentation + 2);\n\n            if (componentContainer.first) {\n              _walker(componentContainer.first, indentation + 4);\n            }\n          }\n\n          if (component.next) {\n            return _walker(component.next, indentation);\n          }\n        };\n\n        if (this.root.first) {\n          _walker(this.root.first);\n        }\n\n        return output;\n      };\n\n      ComponentTree.prototype.attachingComponent = function (component, attachComponentFunc) {\n        if (component.componentTree === this) {\n          attachComponentFunc();\n          delete this._componentsArrayCache;\n          return this.fireEvent('componentMoved', component);\n        } else {\n          if (component.componentTree != null) {\n            component.remove();\n          }\n\n          component.descendantsAndSelf(function (_this) {\n            return function (descendant) {\n              descendant.componentTree = _this;\n              return _this.componentById[descendant.id] = component;\n            };\n          }(this));\n          attachComponentFunc();\n          delete this._componentsArrayCache;\n          return this.fireEvent('componentAdded', component);\n        }\n      };\n\n      ComponentTree.prototype.fireEvent = function () {\n        var args, event;\n        event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        this[event].fire.apply(void 0, args);\n        return this.changed.fire();\n      };\n\n      ComponentTree.prototype.detachingComponent = function (component, detachComponentFunc) {\n        assert(component.componentTree === this, 'cannot remove component from another ComponentTree');\n        component.descendantsAndSelf(function (_this) {\n          return function (descendant) {\n            descendant.componentTree = void 0;\n            return _this.componentById[descendant.id] = void 0;\n          };\n        }(this));\n        detachComponentFunc();\n        delete this._componentsArrayCache;\n        return this.fireEvent('componentRemoved', component);\n      };\n\n      ComponentTree.prototype.contentChanging = function (component, directiveName) {\n        return this.fireEvent('componentContentChanged', component, directiveName);\n      };\n\n      ComponentTree.prototype.htmlChanging = function (component) {\n        return this.fireEvent('componentHtmlChanged', component);\n      };\n\n      ComponentTree.prototype.dataChanging = function (component, changedProperties) {\n        return this.fireEvent('componentDataChanged', component, changedProperties);\n      };\n\n      ComponentTree.prototype.printJson = function () {\n        return words.readableJson(this.toJson());\n      };\n\n      ComponentTree.prototype.serialize = function (startComponent, excludeId) {\n        var componentToData, data, _walker2;\n\n        data = {};\n        data['content'] = [];\n        data['design'] = {\n          name: this.design.name,\n          version: this.design.version\n        };\n\n        componentToData = function componentToData(component, level, containerArray) {\n          var componentData;\n          componentData = component.toJson();\n\n          if (excludeId) {\n            delete componentData.id;\n          }\n\n          containerArray.push(componentData);\n          return componentData;\n        };\n\n        _walker2 = function walker(component, level, dataObj) {\n          var componentContainer, componentData, containerArray, name, _ref;\n\n          componentData = componentToData(component, level, dataObj);\n          _ref = component.containers;\n\n          for (name in _ref) {\n            componentContainer = _ref[name];\n            containerArray = componentData.containers[componentContainer.name] = [];\n\n            if (componentContainer.first) {\n              _walker2(componentContainer.first, level + 1, containerArray);\n            }\n          }\n\n          if (component.next) {\n            return _walker2(component.next, level, dataObj);\n          }\n        };\n\n        if (!startComponent) {\n          startComponent = this.root.first;\n        }\n\n        if (startComponent) {\n          _walker2(startComponent, 0, data['content']);\n        }\n\n        return data;\n      };\n\n      ComponentTree.prototype.componentsFromList = function (data, design) {\n        var created = [];\n\n        for (var i = 0, c = data.length; i < c; i++) {\n          var componentData = data[i];\n          created.push(componentModelSerializer.fromJson(componentData, design));\n        }\n\n        return created;\n      };\n\n      ComponentTree.prototype.fromData = function (data, design, silent) {\n        var component,\n            componentData,\n            _i,\n            _len,\n            _ref,\n            created = [];\n\n        if (silent == null) {\n          silent = true;\n        }\n\n        if (design != null) {\n          assert(this.design == null || design.equals(this.design), 'Error loading data. Specified design is different from current componentTree design');\n        } else {\n          design = this.design;\n        }\n\n        if (silent) {\n          this.root.componentTree = void 0;\n        }\n\n        if (data.content) {\n          _ref = data.content;\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            componentData = _ref[_i];\n            component = componentModelSerializer.fromJson(componentData, design);\n            this.root.append(component);\n            created.push(component);\n          }\n        }\n\n        if (silent) {\n          this.root.componentTree = this;\n          return this.root.each(function (_this) {\n            return function (component) {\n              component.componentTree = _this;\n              return _this.componentById[component.id] = component;\n            };\n          }(this));\n        }\n\n        return created;\n      };\n\n      ComponentTree.prototype.addData = function (data, design) {\n        return this.fromData(data, design, false);\n      };\n\n      ComponentTree.prototype.addDataWithAnimation = function (data, delay) {\n        var componentData, timeout, _fn, _i, _len, _ref, _results;\n\n        if (delay == null) {\n          delay = 200;\n        }\n\n        assert(this.design != null, 'Error adding data. ComponentTree has no design');\n        timeout = Number(delay);\n        _ref = data.content;\n\n        _fn = function (_this) {\n          return function () {\n            var content;\n            content = componentData;\n            return setTimeout(function () {\n              var component;\n              component = componentModelSerializer.fromJson(content, _this.design);\n              return _this.root.append(component);\n            }, timeout);\n          };\n        }(this);\n\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          componentData = _ref[_i];\n\n          _fn();\n\n          _results.push(timeout += Number(delay));\n        }\n\n        return _results;\n      };\n\n      ComponentTree.prototype.toData = function () {\n        return this.serialize();\n      };\n\n      ComponentTree.prototype.fromJson = function () {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return this.fromData.apply(this, args);\n      };\n\n      ComponentTree.prototype.toJson = function () {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return this.toData.apply(this, args);\n      };\n\n      return ComponentTree;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"./component_array\": 13,\n    \"./component_container\": 14,\n    \"./component_model\": 17,\n    \"./component_model_serializer\": 18,\n    \"jquery\": \"jquery\"\n  }],\n  20: [function (require, module, exports) {\n    var ComponentDirective,\n        EditableDirective,\n        assert,\n        words,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    assert = require('../modules/logging/assert');\n    words = require('../modules/words');\n    ComponentDirective = require('./component_directive');\n\n    module.exports = EditableDirective = function (_super) {\n      __extends(EditableDirective, _super);\n\n      function EditableDirective() {\n        return EditableDirective.__super__.constructor.apply(this, arguments);\n      }\n\n      EditableDirective.prototype.isEditable = true;\n\n      EditableDirective.prototype.getText = function () {\n        var content;\n        content = this.getContent();\n\n        if (!content) {\n          return '';\n        }\n\n        return words.extractTextFromHtml(content);\n      };\n\n      return EditableDirective;\n    }(ComponentDirective);\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"../modules/words\": 55,\n    \"./component_directive\": 15\n  }],\n  21: [function (require, module, exports) {\n    var $,\n        FieldExtractor,\n        assert,\n        _,\n        __bind = function __bind(fn, me) {\n      return function () {\n        return fn.apply(me, arguments);\n      };\n    };\n\n    assert = require('../modules/logging/assert');\n    _ = require('underscore');\n    $ = require('jquery');\n\n    module.exports = FieldExtractor = function () {\n      function FieldExtractor(componentTree, metadataConfig) {\n        this.componentTree = componentTree;\n        this.metadataConfig = metadataConfig;\n        this.onComponentChange = __bind(this.onComponentChange, this);\n        this.extractAll = __bind(this.extractAll, this);\n        this.onTreeChange = __bind(this.onTreeChange, this);\n        this.fields = {};\n        this.initEvents();\n        this.extractAll();\n        this.setupListeners();\n      }\n\n      FieldExtractor.prototype.setupListeners = function () {\n        this.componentTree.componentAdded.add(this.onTreeChange);\n        this.componentTree.componentRemoved.add(this.onTreeChange);\n        this.componentTree.componentMoved.add(this.onTreeChange);\n        return this.componentTree.componentContentChanged.add(this.onComponentChange);\n      };\n\n      FieldExtractor.prototype.onTreeChange = function (componentModel) {\n        var changedFields, componentName, field, fieldName, fieldsHaveChanged, fieldsToExtract, _ref;\n\n        componentName = componentModel.componentName;\n        fieldsToExtract = this.metadataConfig.getComponentMap()[componentName];\n        changedFields = {};\n        fieldsHaveChanged = false;\n        _ref = this.extractFields(fieldsToExtract);\n\n        for (fieldName in _ref) {\n          field = _ref[fieldName];\n\n          if (!!_.isEqual(this.fields[fieldName], field)) {\n            continue;\n          }\n\n          fieldsHaveChanged = true;\n          changedFields[fieldName] = this.fields[fieldName] = field;\n        }\n\n        if (!fieldsHaveChanged) {\n          return;\n        }\n\n        return this.fieldsChanged.fire(changedFields, this.fields);\n      };\n\n      FieldExtractor.prototype.extractAll = function () {\n        var allFields;\n        allFields = this.metadataConfig.getListOfFields();\n        this.fields = this.extractFields(allFields);\n        this.fieldsChanged.fire(this.fields, this.fields);\n        return this.fields;\n      };\n\n      FieldExtractor.prototype.extractFields = function (fieldsToExtract) {\n        var fields, fieldsByComponentToExtract;\n        fields = {};\n        fieldsByComponentToExtract = {};\n\n        _(this.metadataConfig.getComponentMap()).forEach(function (fieldsByComponent, componentName) {\n          return fieldsByComponentToExtract[componentName] = _.intersection(fieldsByComponent, fieldsToExtract);\n        });\n\n        this.componentTree.each(function (_this) {\n          return function (componentModel) {\n            var componentName, newFields, _ref;\n\n            componentName = componentModel.componentName;\n\n            if (!((_ref = fieldsByComponentToExtract[componentName]) != null ? _ref.length : void 0)) {\n              return;\n            }\n\n            newFields = _this.extractFieldsFromComponent(componentModel, fieldsByComponentToExtract[componentName]);\n            return _(newFields).forEach(function (field, fieldName) {\n              _(fieldsByComponentToExtract).forEach(function (fieldsByComponent, componentName) {\n                return fieldsByComponentToExtract[componentName] = _.without(fieldsByComponent, fieldName);\n              });\n\n              return fields[fieldName] = field;\n            });\n          };\n        }(this));\n        return fields;\n      };\n\n      FieldExtractor.prototype.extractFieldsFromComponent = function (componentModel, fieldsToExtract) {\n        var componentName, fields;\n        fields = {};\n        componentName = componentModel.componentName;\n        fieldsToExtract.forEach(function (_this) {\n          return function (fieldToExtract) {\n            var directives;\n            directives = _this.metadataConfig.getDirectivesByComponentAndField(componentName, fieldToExtract);\n            return directives.forEach(function (directiveName) {\n              var directiveModel, field;\n\n              if (fields[fieldToExtract]) {\n                return;\n              }\n\n              directiveModel = componentModel.directives.get(directiveName);\n\n              if (directiveModel.isEmpty()) {\n                return;\n              }\n\n              field = _this.extractFieldFromDirective(directiveModel, fieldToExtract);\n              return fields[fieldToExtract] = field;\n            });\n          };\n        }(this));\n        return fields;\n      };\n\n      FieldExtractor.prototype.onComponentChange = function (componentModel, directiveName) {\n        var changedFields, componentName, directiveModel, fieldNames, fieldsThatNeedFullExtraction;\n        componentName = componentModel.componentName;\n        fieldNames = this.metadataConfig.getFieldsBySource(componentName, directiveName);\n        changedFields = {};\n        fieldsThatNeedFullExtraction = [];\n        directiveModel = componentModel.directives.get(directiveName);\n\n        _(fieldNames).forEach(function (_this) {\n          return function (fieldName) {\n            var currentComponentIndex, field, fieldIsEmpty, fieldWasEmpty, fieldWasFilledFromThisComponent, previousComponentIndex, _ref;\n\n            field = directiveModel.isEmpty() ? void 0 : _this.extractFieldFromDirective(directiveModel, fieldName);\n            fieldIsEmpty = field == null;\n            fieldWasEmpty = _this.fields[fieldName] == null;\n            fieldWasFilledFromThisComponent = ((_ref = _this.fields[fieldName]) != null ? _ref.component.id : void 0) === componentModel.id;\n\n            if (fieldIsEmpty && fieldWasFilledFromThisComponent) {\n              fieldsThatNeedFullExtraction.push(fieldName);\n              return _this.fields[fieldName] = changedFields[fieldName] = void 0;\n            } else if ((fieldWasEmpty || fieldWasFilledFromThisComponent) && !_.isEqual(_this.fields[fieldName], field)) {\n              return _this.fields[fieldName] = changedFields[fieldName] = field;\n            } else if (!fieldIsEmpty && !fieldWasFilledFromThisComponent) {\n              previousComponentIndex = componentModel.componentTree.indexOf(_this.fields[fieldName].component);\n              currentComponentIndex = componentModel.componentTree.indexOf(componentModel);\n\n              if (previousComponentIndex > currentComponentIndex) {\n                return _this.fields[fieldName] = changedFields[fieldName] = field;\n              }\n            }\n          };\n        }(this));\n\n        if (fieldsThatNeedFullExtraction.length) {\n          _(this.extractFields(fieldsThatNeedFullExtraction)).forEach(function (_this) {\n            return function (field, fieldName) {\n              return _this.fields[fieldName] = changedFields[fieldName] = field;\n            };\n          }(this));\n        }\n\n        if (_(changedFields).size()) {\n          return this.fieldsChanged.fire(changedFields, this.fields);\n        }\n      };\n\n      FieldExtractor.prototype.initEvents = function () {\n        return this.fieldsChanged = $.Callbacks();\n      };\n\n      FieldExtractor.prototype.extractFieldFromDirective = function (directiveModel, fieldToExtract) {\n        var type, value;\n        type = this.metadataConfig.getConfigMap()[fieldToExtract].type;\n\n        if (type === 'text') {\n          return value = this.extractTextField(directiveModel);\n        } else if (type === 'image') {\n          if (!directiveModel.isBase64()) {\n            return value = this.extractImageField(directiveModel);\n          }\n        } else {\n          return assert(false, \"Unknown template type \" + type);\n        }\n      };\n\n      FieldExtractor.prototype.extractTextField = function (directiveModel) {\n        var content;\n        content = directiveModel.getContent();\n        return {\n          content: content,\n          component: directiveModel.component,\n          directiveName: directiveModel.name,\n          text: directiveModel.getText(),\n          type: 'text'\n        };\n      };\n\n      FieldExtractor.prototype.extractImageField = function (imageDirective) {\n        var _ref, _ref1;\n\n        return {\n          component: imageDirective.component,\n          directiveName: imageDirective.name,\n          type: 'image',\n          image: {\n            originalUrl: imageDirective.getOriginalUrl(),\n            url: imageDirective.getImageUrl(),\n            width: (_ref = imageDirective.getOriginalImageDimensions()) != null ? _ref.width : void 0,\n            height: (_ref1 = imageDirective.getOriginalImageDimensions()) != null ? _ref1.height : void 0,\n            mimeType: imageDirective.getMimeType(),\n            imageService: imageDirective.getImageServiceName()\n          }\n        };\n      };\n\n      FieldExtractor.prototype.getFields = function () {\n        return this.fields;\n      };\n\n      return FieldExtractor;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"jquery\": \"jquery\",\n    \"underscore\": 10\n  }],\n  22: [function (require, module, exports) {\n    var ComponentDirective,\n        HtmlDirective,\n        assert,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    assert = require('../modules/logging/assert');\n    ComponentDirective = require('./component_directive');\n\n    module.exports = HtmlDirective = function (_super) {\n      __extends(HtmlDirective, _super);\n\n      function HtmlDirective() {\n        return HtmlDirective.__super__.constructor.apply(this, arguments);\n      }\n\n      HtmlDirective.prototype.isHtml = true;\n\n      HtmlDirective.prototype.setEmbedHandler = function (embedHandlerName) {\n        return this.setData('_embedHandler', embedHandlerName);\n      };\n\n      HtmlDirective.prototype.getEmbedHandler = function () {\n        return this.getData('_embedHandler');\n      };\n\n      return HtmlDirective;\n    }(ComponentDirective);\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"./component_directive\": 15\n  }],\n  23: [function (require, module, exports) {\n    var ComponentDirective,\n        ImageDirective,\n        assert,\n        imageService,\n        _,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    _ = require('underscore');\n    assert = require('../modules/logging/assert');\n    imageService = require('../image_services/image_service');\n    ComponentDirective = require('./component_directive');\n\n    module.exports = ImageDirective = function (_super) {\n      __extends(ImageDirective, _super);\n\n      function ImageDirective() {\n        return ImageDirective.__super__.constructor.apply(this, arguments);\n      }\n\n      ImageDirective.prototype.isImage = true;\n\n      ImageDirective.prototype.setContent = function (value) {\n        return this.setImageUrl(value);\n      };\n\n      ImageDirective.prototype.getContent = function () {\n        return this.getImageUrl();\n      };\n\n      ImageDirective.prototype.copyTo = function (otherDirective) {\n        otherDirective.setImageUrl(this.getOriginalUrl());\n        otherDirective.setOriginalImageDimensions(this.getOriginalImageDimensions());\n        return otherDirective.setMimeType(this.getMimeType());\n      };\n\n      ImageDirective.prototype.isBackgroundImage = function (directive) {\n        return this.templateDirective.getTagName() !== 'img';\n      };\n\n      ImageDirective.prototype.isInlineImage = function (directive) {\n        return this.templateDirective.getTagName() === 'img';\n      };\n\n      ImageDirective.prototype.isBase64 = function () {\n        return !!this.base64Image;\n      };\n\n      ImageDirective.prototype.setBase64Image = function (base64String) {\n        this.base64Image = base64String;\n\n        if (this.component.componentTree) {\n          return this.component.componentTree.contentChanging(this.component, this.name);\n        }\n      };\n\n      ImageDirective.prototype.setImageUrl = function (value) {\n        var _base, _name;\n\n        if ((_base = this.component.content)[_name = this.name] == null) {\n          _base[_name] = {};\n        }\n\n        this.component.content[this.name].url = value;\n        this.resetCrop();\n        this.base64Image = void 0;\n        return this.processImageUrl(value);\n      };\n\n      ImageDirective.prototype.getImageUrl = function () {\n        var image;\n        image = this.component.content[this.name];\n\n        if (image) {\n          return image.url;\n        } else {\n          return void 0;\n        }\n      };\n\n      ImageDirective.prototype.getImageObject = function () {\n        return this.component.content[this.name];\n      };\n\n      ImageDirective.prototype.getOriginalUrl = function () {\n        var _ref;\n\n        return ((_ref = this.component.content[this.name]) != null ? _ref.originalUrl : void 0) || this.getImageUrl();\n      };\n\n      ImageDirective.prototype.setCrop = function (crop) {\n        var currentValue, height, name, width, x, y;\n        currentValue = this.component.content[this.name];\n\n        if ((currentValue != null ? currentValue.url : void 0) == null) {\n          return;\n        }\n\n        if (crop) {\n          x = crop.x, y = crop.y, width = crop.width, height = crop.height, name = crop.name;\n          currentValue.crop = {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            name: name\n          };\n        } else {\n          delete currentValue.crop;\n        }\n\n        this.processImageUrl(currentValue.originalUrl || currentValue.url);\n\n        if (this.component.componentTree) {\n          return this.component.componentTree.contentChanging(this.component, this.name);\n        }\n      };\n\n      ImageDirective.prototype.getCrop = function () {\n        return this.component.content[this.name].crop;\n      };\n\n      ImageDirective.prototype.setOriginalImageDimensions = function (_arg) {\n        var content, height, width;\n        width = _arg.width, height = _arg.height;\n        content = this.component.content[this.name];\n        content.width = width;\n        return content.height = height;\n      };\n\n      ImageDirective.prototype.getOriginalImageDimensions = function () {\n        var content;\n        content = this.component.content[this.name];\n        return {\n          width: content != null ? content.width : void 0,\n          height: content != null ? content.height : void 0\n        };\n      };\n\n      ImageDirective.prototype.setMimeType = function (mimeType) {\n        var content, _base, _name;\n\n        if ((_base = this.component.content)[_name = this.name] == null) {\n          _base[_name] = {};\n        }\n\n        content = this.component.content[this.name];\n        return content.mimeType = mimeType;\n      };\n\n      ImageDirective.prototype.getMimeType = function () {\n        var content;\n        content = this.component.content[this.name];\n        return content != null ? content.mimeType : void 0;\n      };\n\n      ImageDirective.prototype.resetCrop = function () {\n        var currentValue;\n        currentValue = this.component.content[this.name];\n\n        if (currentValue != null) {\n          return currentValue.crop = null;\n        }\n      };\n\n      ImageDirective.prototype.setImageService = function (imageServiceName) {\n        var imageUrl;\n        assert(imageService.has(imageServiceName), \"Error: could not load image service \" + imageServiceName);\n        imageUrl = this.getImageUrl();\n        return this.component.content[this.name] = {\n          url: imageUrl,\n          imageService: imageServiceName || null\n        };\n      };\n\n      ImageDirective.prototype.getImageServiceName = function () {\n        return this.getImageService().name;\n      };\n\n      ImageDirective.prototype.hasDefaultImageService = function () {\n        return this.getImageServiceName() === 'default';\n      };\n\n      ImageDirective.prototype.getImageService = function () {\n        var serviceName, _ref;\n\n        serviceName = (_ref = this.component.content[this.name]) != null ? _ref.imageService : void 0;\n        return imageService.get(serviceName || void 0);\n      };\n\n      ImageDirective.prototype.processImageUrl = function (url) {\n        var imgObj, imgService;\n\n        if (!this.hasDefaultImageService()) {\n          imgService = this.getImageService();\n          imgObj = this.getImageObject();\n          imgObj.url = imgService.getUrl(url, {\n            crop: imgObj.crop\n          });\n          return imgObj.originalUrl = url;\n        }\n      };\n\n      ImageDirective.prototype.setOrigins = function (origins) {\n        var identifier, name, origin, _base, _name;\n\n        if ((_base = this.component.content)[_name = this.name] == null) {\n          _base[_name] = {};\n        }\n\n        if (!_.isArray(origins)) {\n          origins = [origins];\n        }\n\n        origins = function () {\n          var _i, _len, _results;\n\n          _results = [];\n\n          for (_i = 0, _len = origins.length; _i < _len; _i++) {\n            origin = origins[_i];\n            assert((origin != null ? origin.name : void 0) && origin.identifier, \"Error: setOrigins must be called with an array or a hash with name and identifier keys\");\n\n            _results.push((name = origin.name, identifier = origin.identifier, origin));\n          }\n\n          return _results;\n        }();\n\n        return this.component.content[this.name].origins = origins;\n      };\n\n      ImageDirective.prototype.getOrigins = function () {\n        var _ref;\n\n        return (_ref = this.component.content[this.name]) != null ? _ref.origins : void 0;\n      };\n\n      return ImageDirective;\n    }(ComponentDirective);\n  }, {\n    \"../image_services/image_service\": 37,\n    \"../modules/logging/assert\": 50,\n    \"./component_directive\": 15,\n    \"underscore\": 10\n  }],\n  24: [function (require, module, exports) {\n    var ComponentDirective,\n        LinkDirective,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    ComponentDirective = require('./component_directive');\n\n    module.exports = LinkDirective = function (_super) {\n      __extends(LinkDirective, _super);\n\n      function LinkDirective() {\n        return LinkDirective.__super__.constructor.apply(this, arguments);\n      }\n\n      LinkDirective.prototype.isLink = true;\n      return LinkDirective;\n    }(ComponentDirective);\n  }, {\n    \"./component_directive\": 15\n  }],\n  25: [function (require, module, exports) {\n    module.exports = function (config) {\n      var name, prefix, value, _ref;\n\n      config.docDirective = {};\n      config.templateAttrLookup = {};\n      _ref = config.directives;\n\n      for (name in _ref) {\n        value = _ref[name];\n        prefix = config.attributePrefix ? \"\" + config.attributePrefix + \"-\" : '';\n        value.renderedAttr = \"\" + prefix + value.attr;\n        config.docDirective[name] = value.renderedAttr;\n        config.templateAttrLookup[value.attr] = name;\n      }\n\n      return config;\n    };\n  }, {}],\n  26: [function (require, module, exports) {\n    var augmentConfig;\n    augmentConfig = require('./augment_config');\n    module.exports = augmentConfig({\n      loadResources: true,\n      ignoreInteraction: '.ld-control',\n      livingdocsCssFile: '/assets/css/livingdocs.css',\n      wordSeparators: \"./\\\\()\\\"':,.;<>~!#%^&*|+=[]{}`~?\",\n      singleLineBreak: /^<br\\s*\\/?>\\s*$/,\n      attributePrefix: 'data',\n      editable: {\n        allowNewline: true,\n        changeDelay: 0,\n        browserSpellcheck: false,\n        mouseMoveSelectionChanges: false\n      },\n      css: {\n        section: 'doc-section',\n        component: 'doc-component',\n        htmlcontent: 'doc-htmlcontent',\n        editable: 'doc-editable',\n        noPlaceholder: 'doc-no-placeholder',\n        emptyContent: 'doc-content-empty',\n        emptyImage: 'doc-image-empty',\n        \"interface\": 'doc-ui',\n        componentHighlight: 'doc-component-highlight',\n        containerHighlight: 'doc-container-highlight',\n        dragged: 'doc-dragged',\n        draggedPlaceholder: 'doc-dragged-placeholder',\n        draggedPlaceholderCounter: 'doc-drag-counter',\n        dragBlocker: 'doc-drag-blocker',\n        dropMarker: 'doc-drop-marker',\n        beforeDrop: 'doc-before-drop',\n        noDrop: 'doc-drag-no-drop',\n        afterDrop: 'doc-after-drop',\n        longpressIndicator: 'doc-longpress-indicator',\n        preventSelection: 'doc-no-selection',\n        maximizedContainer: 'doc-js-maximized-container',\n        interactionBlocker: 'doc-interaction-blocker'\n      },\n      attr: {\n        template: 'data-doc-template',\n        placeholder: 'data-doc-placeholder'\n      },\n      directives: {\n        container: {\n          attr: 'doc-container',\n          renderedAttr: 'calculated in augment_config',\n          overwritesContent: true\n        },\n        embeditem: {\n          attr: 'doc-embeditem',\n          renderedAttr: 'calculated in augment_config',\n          overwritesContent: true\n        },\n        wysiwyg: {\n          attr: 'doc-wysiwyg',\n          renderedAttr: 'calculated in augment_config',\n          overwritesContent: true\n        },\n        editable: {\n          attr: 'doc-editable',\n          renderedAttr: 'calculated in augment_config',\n          overwritesContent: true\n        },\n        html: {\n          attr: 'doc-html',\n          renderedAttr: 'calculated in augment_config',\n          overwritesContent: true\n        },\n        image: {\n          attr: 'doc-image',\n          renderedAttr: 'calculated in augment_config'\n        },\n        link: {\n          attr: 'doc-link',\n          renderedAttr: 'calculated in augment_config'\n        },\n        optional: {\n          attr: 'doc-optional',\n          renderedAttr: 'calculated in augment_config',\n          modifies: ['editable']\n        }\n      },\n      animations: {\n        optionals: {\n          show: function show($elem) {\n            return $elem.slideDown(250);\n          },\n          hide: function hide($elem) {\n            return $elem.slideUp(250);\n          }\n        }\n      },\n      imagePlaceholder: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"620\" height=\"350\" viewBox=\"0 0 620 350\" preserveAspectRatio=\"none\"><rect width=\"620\" height=\"350\" fill=\"#D4D4CE\"/><line x1=\"0\" y1=\"0\" x2=\"620\" y2=\"350\" style=\"stroke:#ffffff;stroke-width:2\"/><line x1=\"620\" y1=\"0\" x2=\"0\" y2=\"350\" style=\"stroke:#ffffff;stroke-width:2\"/></svg>'),\n      imageServices: {\n        'resrc.it': {\n          quality: 75,\n          host: 'https://app.resrc.it'\n        }\n      }\n    });\n  }, {\n    \"./augment_config\": 25\n  }],\n  27: [function (require, module, exports) {\n    var MetadataConfig;\n\n    module.exports = MetadataConfig = function () {\n      function MetadataConfig(config) {\n        this.fieldsArray = [];\n        this.editableFieldsArray = [];\n        this.fieldMap = {};\n        this.configMap = {};\n        this.componentDirectiveMap = {};\n        this.componentMap = {};\n\n        if (config != null && config.length) {\n          this.parse(config);\n        }\n      }\n\n      MetadataConfig.prototype.parse = function (config) {\n        var componentName, directive, fieldItemConfig, fieldName, isEditable, pattern, type, _base, _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = config.length; _i < _len; _i++) {\n          fieldItemConfig = config[_i];\n          fieldName = fieldItemConfig.identifier;\n          type = fieldItemConfig.type;\n          this.fieldsArray.push(fieldName);\n          this.configMap[fieldName] = fieldItemConfig;\n\n          if ((_base = this.fieldMap)[fieldName] == null) {\n            _base[fieldName] = {};\n          }\n\n          isEditable = fieldItemConfig.isEditable != null ? !!fieldItemConfig.isEditable : true;\n\n          if (isEditable) {\n            this.editableFieldsArray.push(fieldName);\n          }\n\n          _results.push(function () {\n            var _base1, _base2, _base3, _base4, _j, _len1, _ref, _ref1, _results1;\n\n            _ref = fieldItemConfig.matches;\n            _results1 = [];\n\n            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n              pattern = _ref[_j];\n              _ref1 = pattern.split('.'), componentName = _ref1[0], directive = _ref1[1];\n\n              if ((_base1 = this.componentDirectiveMap)[componentName] == null) {\n                _base1[componentName] = {};\n              }\n\n              if ((_base2 = this.componentDirectiveMap[componentName])[directive] == null) {\n                _base2[directive] = [];\n              }\n\n              this.componentDirectiveMap[componentName][directive].push(fieldName);\n\n              if ((_base3 = this.componentMap)[componentName] == null) {\n                _base3[componentName] = [];\n              }\n\n              this.componentMap[componentName].push(fieldName);\n\n              if ((_base4 = this.fieldMap[fieldName])[componentName] == null) {\n                _base4[componentName] = [];\n              }\n\n              _results1.push(this.fieldMap[fieldName][componentName].push(directive));\n            }\n\n            return _results1;\n          }.call(this));\n        }\n\n        return _results;\n      };\n\n      MetadataConfig.prototype.getListOfEditableFields = function () {\n        return this.editableFieldsArray;\n      };\n\n      MetadataConfig.prototype.getListOfFields = function () {\n        return this.fieldsArray;\n      };\n\n      MetadataConfig.prototype.getConfigMap = function () {\n        return this.configMap;\n      };\n\n      MetadataConfig.prototype.getComponentMap = function () {\n        return this.componentMap;\n      };\n\n      MetadataConfig.prototype.getFieldsBySource = function (componentName, directive) {\n        var _ref;\n\n        return ((_ref = this.componentDirectiveMap[componentName]) != null ? _ref[directive] : void 0) || [];\n      };\n\n      MetadataConfig.prototype.getDirectivesByComponentAndField = function (componentName, fieldName) {\n        return this.fieldMap[fieldName][componentName];\n      };\n\n      return MetadataConfig;\n    }();\n  }, {}],\n  28: [function (require, module, exports) {\n    var CssModificatorProperty, assert, log, words;\n    log = require('../modules/logging/log');\n    assert = require('../modules/logging/assert');\n    words = require('../modules/words');\n\n    module.exports = CssModificatorProperty = function () {\n      function CssModificatorProperty(_arg) {\n        var label, options, value;\n        this.name = _arg.name, label = _arg.label, this.type = _arg.type, value = _arg.value, options = _arg.options;\n        this.label = label || words.humanize(this.name);\n\n        switch (this.type) {\n          case 'option':\n            assert(value, \"TemplateStyle error: no 'value' provided\");\n            this.value = value;\n            break;\n\n          case 'select':\n            assert(options, \"TemplateStyle error: no 'options' provided\");\n            this.options = options;\n            break;\n\n          case 'text':\n            assert(value, \"TemplateStyle error: no 'value' provided\");\n            this.value = value;\n            break;\n\n          default:\n            log.error(\"TemplateStyle error: unknown type '\" + this.type + \"'\");\n        }\n      }\n\n      CssModificatorProperty.prototype.cssClassChanges = function (value, currentClasses) {\n        if (this.validateValue(value)) {\n          if (this.type === 'option') {\n            return {\n              remove: !value ? [this.value] : void 0,\n              add: value\n            };\n          } else if (this.type === 'select') {\n            return {\n              remove: this.otherClasses(value),\n              add: value\n            };\n          } else if (this.type === 'text') {\n            // todo(Marcus)\n            var current = currentClasses ? currentClasses.split(' ') : [];\n            var remove = [];\n\n            for (var i in current) {\n              if (current[i].indexOf('doc-') === 0 || current[i].indexOf('js-') === 0) {\n                continue;\n              }\n\n              remove.push(current[i]);\n            }\n\n            return {\n              remove: remove,\n              add: value\n            };\n          }\n        } else {\n          if (this.type === 'option') {\n            return {\n              remove: currentValue,\n              add: void 0\n            };\n          } else if (this.type === 'select') {\n            return {\n              remove: this.otherClasses(void 0),\n              add: void 0\n            };\n          }\n        }\n      };\n\n      CssModificatorProperty.prototype.validateValue = function (value) {\n        if (!value) {\n          return true;\n        } else if (this.type === 'option') {\n          return value === this.value;\n        } else if (this.type === 'select') {\n          if (this.containsOption(value)) {\n            return true;\n          }\n\n          if (value.indexOf(' ') >= 0) {\n            var allStyles = value.split(' ');\n\n            for (var s in allStyles) {\n              if (this.containsOption(allStyles[s])) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        } else if (this.type === 'text') {\n          return true;\n        } else {\n          return log.warn(\"Not implemented: CssModificatorProperty#validateValue() for type \" + this.type);\n        }\n      };\n\n      CssModificatorProperty.prototype.containsOption = function (value) {\n        var option, _i, _len, _ref;\n\n        _ref = this.options;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          option = _ref[_i];\n\n          if (value === option.value) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      CssModificatorProperty.prototype.otherOptions = function (value) {\n        var option, others, _i, _len, _ref;\n\n        others = [];\n        _ref = this.options;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          option = _ref[_i];\n\n          if (option.value !== value) {\n            others.push(option);\n          }\n        }\n\n        return others;\n      };\n\n      CssModificatorProperty.prototype.otherClasses = function (value) {\n        var option, others, _i, _len, _ref;\n\n        others = [];\n        _ref = this.options;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          option = _ref[_i];\n\n          if (option.value !== value) {\n            others.push(option.value);\n          }\n        }\n\n        return others;\n      };\n\n      return CssModificatorProperty;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../modules/words\": 55\n  }],\n  29: [function (require, module, exports) {\n    var Dependencies, Design, OrderedHash, Template, Transforms, assert, config, log, words, _;\n\n    config = require('../configuration/config');\n    assert = require('../modules/logging/assert');\n    log = require('../modules/logging/log');\n    words = require('../modules/words');\n    Template = require('../template/template');\n    OrderedHash = require('../modules/ordered_hash');\n    Dependencies = require('../rendering/dependencies');\n    Transforms = require('./transforms');\n    _ = require('underscore');\n\n    module.exports = Design = function () {\n      function Design(_arg) {\n        var label;\n        this.name = _arg.name, this.version = _arg.version, label = _arg.label, this.author = _arg.author, this.description = _arg.description;\n        assert(this.name != null, 'Design: param \"name\" is required');\n        this.label = label || words.humanize(this.name);\n        this.identifier = Design.getIdentifier(this.name, this.version);\n        this.groups = [];\n        this.components = new OrderedHash();\n        this.imageRatios = {};\n        this.dependencies = new Dependencies();\n        this.defaultParagraph = void 0;\n        this.defaultImage = void 0;\n        this.transforms = new Transforms(this.components);\n      }\n\n      Design.prototype.equals = function (design) {\n        return design.name === this.name && design.version === this.version;\n      };\n\n      Design.prototype.isNewerThan = function (design) {\n        if (design == null) {\n          return true;\n        }\n\n        return this.version > (design.version || '');\n      };\n\n      Design.prototype.get = function (identifier) {\n        var componentName;\n        componentName = this.getComponentNameFromIdentifier(identifier);\n        return this.components.get(componentName);\n      };\n\n      Design.prototype.each = function (callback) {\n        return this.components.each(callback);\n      };\n\n      Design.prototype.add = function (template) {\n        template.setDesign(this);\n        return this.components.push(template.name, template);\n      };\n\n      Design.prototype.getComponentNameFromIdentifier = function (identifier) {\n        var name;\n        name = Template.parseIdentifier(identifier).name;\n        return name;\n      };\n\n      Design.prototype.getDefaultParagraphTemplate = function () {\n        return this.defaultParagraph;\n      };\n\n      Design.prototype.getDefaultImageTemplate = function () {\n        return this.defaultImage;\n      };\n\n      Design.prototype.getDefaultParagraphComponentName = function () {\n        var _ref;\n\n        return (_ref = this.getDefaultParagraphTemplate()) != null ? _ref.name : void 0;\n      };\n\n      Design.prototype.getDefaultImageComponentName = function () {\n        var _ref;\n\n        return (_ref = this.getDefaultImageTemplate()) != null ? _ref.name : void 0;\n      };\n\n      Design.prototype.getDefaultImageDirectiveName = function () {\n        var _ref, _ref1;\n\n        return (_ref = this.defaultImage) != null ? (_ref1 = _ref.directives.firstOfType('image')) != null ? _ref1.name : void 0 : void 0;\n      };\n\n      Design.prototype.getLayout = function (name) {\n        if (!this.layouts) {\n          return {\n            wrapper: this.wrapper\n          };\n        }\n\n        if (!(name != null || this.defaultLayout != null)) {\n          return _.first(this.layouts);\n        }\n\n        if (name == null) {\n          name = this.defaultLayout;\n        }\n\n        return _.findWhere(this.layouts, {\n          name: name\n        });\n      };\n\n      Design.getIdentifier = function (name, version) {\n        if (version) {\n          return \"\" + name + \"@\" + version;\n        } else {\n          return \"\" + name;\n        }\n      };\n\n      return Design;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../modules/ordered_hash\": 52,\n    \"../modules/words\": 55,\n    \"../rendering/dependencies\": 57,\n    \"../template/template\": 74,\n    \"./transforms\": 34,\n    \"underscore\": 10\n  }],\n  30: [function (require, module, exports) {\n    var Design, Version, assert, designParser;\n    assert = require('../modules/logging/assert');\n    Design = require('./design');\n    designParser = require('./design_parser');\n    Version = require('./version');\n\n    module.exports = function () {\n      return {\n        designs: {},\n        load: function load(designSpec, _arg) {\n          var basePath, design;\n          basePath = (_arg != null ? _arg : {}).basePath;\n          assert(designSpec != null, 'design.load() was called with undefined.');\n          assert(!(typeof designSpec === 'string'), 'design.load() loading a design by name is not implemented.');\n\n          if (this.has(designSpec.name, designSpec.version)) {\n            return;\n          }\n\n          if (basePath != null && designSpec.assets != null) {\n            designSpec.assets.basePath = basePath;\n          }\n\n          design = designParser.parse(designSpec);\n\n          if (design) {\n            return this.add(design);\n          } else {\n            throw new Error(Design.parser.errors);\n          }\n        },\n        add: function add(design) {\n          if (design.isNewerThan(this.designs[design.name])) {\n            this.designs[design.name] = design;\n          }\n\n          return this.designs[design.identifier] = design;\n        },\n        has: function has(designName, designVersion) {\n          var identifier;\n\n          if (designVersion == null) {\n            return false;\n          }\n\n          identifier = Design.getIdentifier(designName, designVersion);\n          return this.designs[identifier] != null;\n        },\n        get: function get(designName, designVersion) {\n          var identifier;\n          assert(this.has(designName, designVersion), \"Error: design '\" + designName + \"' version '\" + designVersion + \"' is not loaded.\");\n          identifier = Design.getIdentifier(designName, designVersion);\n          return this.designs[identifier];\n        },\n        resetCache: function resetCache() {\n          return this.designs = {};\n        }\n      };\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"./design\": 29,\n    \"./design_parser\": 32,\n    \"./version\": 35\n  }],\n  31: [function (require, module, exports) {\n    var Version, config, jScheme, validator;\n    config = require('../configuration/config');\n    jScheme = require('jscheme');\n    Version = require('./version');\n    module.exports = validator = jScheme[\"new\"]();\n    validator.add('styleType', function (value) {\n      return value === 'option' || value === 'select' || value === 'text';\n    });\n    validator.add('semVer', function (value) {\n      return Version.semVer.test(value);\n    });\n    validator.add('wrapper', function (value) {\n      var regexp;\n      regexp = /<.*\\u0020(?:[^>]*\\u0020|)class=(\"|')[^'\"]*doc-section[^'\"]*\\1(?:\\u0020[^>]*|)>/;\n\n      if (!regexp.test(value)) {\n        return \"design.wrapper is missing a 'doc-section' class ('\" + value + \"').\";\n      } else {\n        return true;\n      }\n    });\n    validator.add('one empty option', function (value) {\n      var emptyCount, entry, _i, _len;\n\n      emptyCount = 0;\n\n      for (_i = 0, _len = value.length; _i < _len; _i++) {\n        entry = value[_i];\n\n        if (!entry.value) {\n          emptyCount += 1;\n        }\n      }\n\n      return emptyCount === 1;\n    });\n    validator.add('design', {\n      name: 'string',\n      label: 'string, optional',\n      version: 'string, semVer',\n      author: 'string, optional',\n      description: 'string, optional',\n      assets: {\n        __validate: 'optional',\n        css: 'array of string',\n        js: 'array of string, optional',\n        basePath: 'string, optional'\n      },\n      components: 'array of component',\n      componentProperties: {\n        __validate: 'optional',\n        __additionalProperty: function __additionalProperty(key, value) {\n          return validator.validate('componentProperty', value);\n        }\n      },\n      groups: 'array of group, optional',\n      defaultComponents: {\n        __validate: 'optional',\n        paragraph: 'string, optional',\n        image: 'string, optional'\n      },\n      imageRatios: {\n        __validate: 'optional',\n        __additionalProperty: function __additionalProperty(key, value) {\n          return validator.validate('imageRatio', value);\n        }\n      },\n      metadata: 'array of object, optional',\n      wrapper: 'string, wrapper, optional',\n      layouts: 'array of layout, optional',\n      defaultLayout: 'string, optional',\n      defaultContent: 'array of object, optional',\n      prefilledComponents: 'object, optional'\n    });\n    validator.add('component', {\n      name: 'string',\n      // NOTE: Marcus(2019-11-20) Allow icons for UI purposes\n      icon: 'string, optional',\n      label: 'string, optional',\n      html: 'string',\n      directives: 'object, optional',\n      properties: 'array of string, optional',\n      allowedParents: 'array of string, optional',\n      __additionalProperty: function __additionalProperty(key, value) {\n        return false;\n      }\n    });\n    validator.add('group', {\n      label: 'string',\n      components: 'array of string'\n    });\n    validator.add('componentProperty', {\n      label: 'string, optional',\n      type: 'string, styleType',\n      value: 'string, optional',\n      options: 'array of styleOption, one empty option, optional'\n    });\n    validator.add('imageRatio', {\n      label: 'string, optional',\n      ratio: 'string'\n    });\n    validator.add('styleOption', {\n      caption: 'string',\n      value: 'string, optional'\n    });\n    validator.add('layout', {\n      name: 'string',\n      caption: 'string',\n      wrapper: 'wrapper',\n      icon: 'string, optional'\n    });\n  }, {\n    \"../configuration/config\": 26,\n    \"./version\": 35,\n    \"jscheme\": 4\n  }],\n  32: [function (require, module, exports) {\n    var $, CssModificatorProperty, Design, ImageRatio, Template, Version, assert, designConfigSchema, designParser, log;\n    log = require('../modules/logging/log');\n    $ = require('jquery');\n    assert = require('../modules/logging/assert');\n    designConfigSchema = require('./design_config_schema');\n    CssModificatorProperty = require('./css_modificator_property');\n    Template = require('../template/template');\n    Design = require('./design');\n    Version = require('./version');\n    ImageRatio = require('./image_ratio');\n    $ = require('jquery');\n    module.exports = designParser = {\n      parse: function parse(designConfig) {\n        var errors;\n        this.design = void 0;\n\n        if (designConfigSchema.validate('design', designConfig)) {\n          return this.createDesign(designConfig);\n        } else {\n          errors = designConfigSchema.getErrorMessages();\n          throw new Error(errors);\n        }\n      },\n      createDesign: function createDesign(designConfig) {\n        var assets, componentProperties, components, defaultComponents, error, groups, imageRatios;\n        assets = designConfig.assets, components = designConfig.components, componentProperties = designConfig.componentProperties, groups = designConfig.groups, defaultComponents = designConfig.defaultComponents, imageRatios = designConfig.imageRatios;\n\n        try {\n          this.design = this.parseDesignInfo(designConfig);\n          $.each(['metadata', 'wrapper', 'layouts', 'defaultLayout', 'defaultContent', 'prefilledComponents'], function (_this) {\n            return function (index, attributeName) {\n              return _this.design[attributeName] = designConfig[attributeName];\n            };\n          }(this));\n          this.parseAssets(assets);\n          this.parseComponentProperties(componentProperties);\n          this.parseImageRatios(imageRatios);\n          this.parseComponents(components);\n          this.parseGroups(groups);\n          this.parseDefaults(defaultComponents);\n        } catch (_error) {\n          error = _error;\n          error.message = \"Error creating the design: \" + error.message;\n          throw error;\n        }\n\n        return this.design;\n      },\n      parseDesignInfo: function parseDesignInfo(design) {\n        var version;\n        version = new Version(design.version);\n        return new Design({\n          name: design.name,\n          label: design.label,\n          version: version.toString()\n        });\n      },\n      parseAssets: function parseAssets(assets) {\n        var basePath;\n\n        if (assets == null) {\n          return;\n        }\n\n        basePath = assets.basePath;\n        this.eachAsset(assets.js, function (_this) {\n          return function (assetUrl) {\n            return _this.design.dependencies.addJs({\n              src: assetUrl,\n              basePath: basePath\n            });\n          };\n        }(this));\n        return this.eachAsset(assets.css, function (_this) {\n          return function (assetUrl) {\n            return _this.design.dependencies.addCss({\n              src: assetUrl,\n              basePath: basePath\n            });\n          };\n        }(this));\n      },\n      eachAsset: function eachAsset(data, callback) {\n        var entry, _i, _len, _results;\n\n        if (data == null) {\n          return;\n        }\n\n        if ($.type(data) === 'string') {\n          return callback(data);\n        } else {\n          _results = [];\n\n          for (_i = 0, _len = data.length; _i < _len; _i++) {\n            entry = data[_i];\n\n            _results.push(callback(entry));\n          }\n\n          return _results;\n        }\n      },\n      parseComponentProperties: function parseComponentProperties(componentProperties) {\n        var config, name, _results;\n\n        this.componentProperties = {};\n        _results = [];\n\n        for (name in componentProperties) {\n          config = componentProperties[name];\n          config.name = name;\n\n          _results.push(this.componentProperties[name] = this.createComponentProperty(config));\n        }\n\n        return _results;\n      },\n      parseImageRatios: function parseImageRatios(ratios) {\n        var name, ratio, _results;\n\n        _results = [];\n\n        for (name in ratios) {\n          ratio = ratios[name];\n\n          _results.push(this.design.imageRatios[name] = new ImageRatio({\n            name: name,\n            label: ratio.label,\n            ratio: ratio.ratio\n          }));\n        }\n\n        return _results;\n      },\n      parseComponents: function parseComponents(components) {\n        var allowedParents, directives, html, label, name, properties, template, _i, _len, _ref, _results;\n\n        if (components == null) {\n          components = [];\n        }\n\n        _results = [];\n\n        for (_i = 0, _len = components.length; _i < _len; _i++) {\n          _ref = components[_i], name = _ref.name, label = _ref.label, html = _ref.html, properties = _ref.properties, directives = _ref.directives, allowedParents = _ref.allowedParents;\n          properties = this.lookupComponentProperties(properties);\n          template = new Template({\n            name: name,\n            label: label,\n            html: html,\n            properties: properties,\n            allowedParents: allowedParents\n          });\n          this.parseDirectives(template, directives);\n\n          _results.push(this.design.add(template));\n        }\n\n        return _results;\n      },\n      parseDirectives: function parseDirectives(template, directivesConfig) {\n        var conf, directive, directiveConfig, name, _results;\n\n        _results = [];\n\n        for (name in directivesConfig) {\n          conf = directivesConfig[name];\n          directive = template.directives.get(name);\n          assert(directive, \"Could not find directive \" + name + \" in \" + template.name + \" component.\");\n          directiveConfig = $.extend({}, conf);\n\n          if (conf.imageRatios) {\n            directiveConfig.imageRatios = this.lookupImageRatios(conf.imageRatios);\n          }\n\n          _results.push(directive.setConfig(directiveConfig));\n        }\n\n        return _results;\n      },\n      lookupComponentProperties: function lookupComponentProperties(propertyNames) {\n        var name, properties, property, _i, _len, _ref;\n\n        properties = {};\n        _ref = propertyNames || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          name = _ref[_i];\n          property = this.componentProperties[name];\n          assert(property, \"The componentProperty '\" + name + \"' was not found.\");\n          properties[name] = property;\n        }\n\n        return properties;\n      },\n      lookupImageRatios: function lookupImageRatios(ratioNames) {\n        if (ratioNames == null) {\n          return;\n        }\n\n        return this.mapArray(ratioNames, function (_this) {\n          return function (name) {\n            var ratio;\n            ratio = _this.design.imageRatios[name];\n            assert(ratio, \"The imageRatio '\" + name + \"' was not found.\");\n            return ratio;\n          };\n        }(this));\n      },\n      parseGroups: function parseGroups(groups) {\n        var componentName, components, group, _i, _len, _results;\n\n        if (groups == null) {\n          groups = [];\n        }\n\n        _results = [];\n\n        for (_i = 0, _len = groups.length; _i < _len; _i++) {\n          group = groups[_i];\n\n          components = function () {\n            var _j, _len1, _ref, _results1;\n\n            _ref = group.components;\n            _results1 = [];\n\n            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n              componentName = _ref[_j];\n\n              _results1.push(this.design.get(componentName));\n            }\n\n            return _results1;\n          }.call(this);\n\n          _results.push(this.design.groups.push({\n            label: group.label,\n            components: components\n          }));\n        }\n\n        return _results;\n      },\n      parseDefaults: function parseDefaults(defaultComponents) {\n        var image, paragraph;\n\n        if (defaultComponents == null) {\n          return;\n        }\n\n        paragraph = defaultComponents.paragraph, image = defaultComponents.image;\n\n        if (paragraph) {\n          this.design.defaultParagraph = this.getTemplate(paragraph);\n        }\n\n        if (image) {\n          return this.design.defaultImage = this.getTemplate(image);\n        }\n      },\n      getTemplate: function getTemplate(name) {\n        var template;\n        template = this.design.get(name);\n        assert(template, \"Could not find component \" + name);\n        return template;\n      },\n      createComponentProperty: function createComponentProperty(styleDefinition) {\n        return new CssModificatorProperty(styleDefinition);\n      },\n      mapArray: function mapArray(entries, lookup) {\n        var entry, newArray, val, _i, _len;\n\n        newArray = [];\n\n        for (_i = 0, _len = entries.length; _i < _len; _i++) {\n          entry = entries[_i];\n          val = lookup(entry);\n\n          if (val != null) {\n            newArray.push(val);\n          }\n        }\n\n        return newArray;\n      }\n    };\n    Design.parser = designParser;\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../template/template\": 74,\n    \"./css_modificator_property\": 28,\n    \"./design\": 29,\n    \"./design_config_schema\": 31,\n    \"./image_ratio\": 33,\n    \"./version\": 35,\n    \"jquery\": \"jquery\"\n  }],\n  33: [function (require, module, exports) {\n    var $, ImageRatio, assert, words;\n    $ = require('jquery');\n    words = require('../modules/words');\n    assert = require('../modules/logging/assert');\n\n    module.exports = ImageRatio = function () {\n      var ratioString;\n      ratioString = /(\\d+)[\\/:x](\\d+)/;\n\n      function ImageRatio(_arg) {\n        var label, ratio;\n        this.name = _arg.name, label = _arg.label, ratio = _arg.ratio;\n        this.label = label || words.humanize(this.name);\n        this.ratio = this.parseRatio(ratio);\n      }\n\n      ImageRatio.prototype.parseRatio = function (ratio) {\n        var res;\n\n        if ($.type(ratio) === 'string') {\n          res = ratioString.exec(ratio);\n          ratio = Number(res[1]) / Number(res[2]);\n        }\n\n        assert($.type(ratio) === 'number', \"Could not parse image ratio \" + ratio);\n        return ratio;\n      };\n\n      return ImageRatio;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"../modules/words\": 55,\n    \"jquery\": \"jquery\"\n  }],\n  34: [function (require, module, exports) {\n    var Transforms;\n\n    module.exports = Transforms = function () {\n      function Transforms(templates) {\n        this.templates = templates;\n      }\n\n      Transforms.prototype.getTransformations = function (_arg) {\n        var componentName, directives, filter, oneWay, options, template;\n        template = _arg.template, componentName = _arg.componentName, oneWay = _arg.oneWay, directives = _arg.directives, filter = _arg.filter;\n\n        if (componentName) {\n          template = this.templates.get(componentName);\n        }\n\n        if (oneWay == null) {\n          oneWay = false;\n        }\n\n        options = [];\n        this.templates.each(function (_this) {\n          return function (other) {\n            var compatibility;\n\n            if (template.equals(other)) {\n              return;\n            }\n\n            if (filter != null && !filter(other)) {\n              return;\n            }\n\n            compatibility = _this.isCompatible(template, other, {\n              oneWay: oneWay,\n              directives: directives\n            });\n\n            if (compatibility.isCompatible) {\n              compatibility.template = other;\n              return options.push(compatibility);\n            }\n          };\n        }(this));\n\n        if (options.length) {\n          return options;\n        } else {\n          return void 0;\n        }\n      };\n\n      Transforms.prototype.getOptionsList = function (_arg) {\n        var componentName, directives, filter, names, oneWay, option, options, template, _i, _len, _ref;\n\n        template = _arg.template, componentName = _arg.componentName, oneWay = _arg.oneWay, directives = _arg.directives, filter = _arg.filter;\n\n        if (componentName) {\n          template = this.templates.get(componentName);\n        }\n\n        options = this.getTransformations({\n          template: template,\n          oneWay: oneWay,\n          directives: directives,\n          filter: filter\n        });\n        names = [];\n        _ref = options || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          option = _ref[_i];\n          componentName = option.name;\n          template = option.template;\n          names.push({\n            label: template.label,\n            componentName: componentName\n          });\n        }\n\n        return names;\n      };\n\n      Transforms.prototype.isCompatible = function (a, b, options) {\n        var directive, directives, name, obj, type, _i, _len, _ref, _ref1;\n\n        if (options == null) {\n          options = {};\n        }\n\n        obj = {\n          name: b.name,\n          isCompatible: true,\n          mapping: {}\n        };\n\n        directives = function () {\n          var _i, _len, _ref, _results;\n\n          if (options.directives != null) {\n            options.oneWay = true;\n            _ref = options.directives;\n            _results = [];\n\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              name = _ref[_i];\n\n              _results.push(a.directives.get(name));\n            }\n\n            return _results;\n          } else {\n            return a.directives;\n          }\n        }();\n\n        _ref = directives || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          directive = _ref[_i];\n          name = directive.name, type = directive.type;\n\n          if (type !== 'editable' && type !== 'image' && type !== 'link') {\n            obj.isCompatible = false;\n            continue;\n          }\n\n          if (a.directives.count(type) === 1 && b.directives.count(type) === 1) {\n            obj.mapping[name] = b.directives[type][0].name;\n          } else if (((_ref1 = b.directives.get(name)) != null ? _ref1.type : void 0) === type) {\n            obj.mapping[name] = name;\n          } else {\n            obj.mapping[name] = null;\n            obj.isCompatible = false;\n          }\n        }\n\n        if (!options.oneWay) {\n          if (a.directives.length !== b.directives.length) {\n            obj.isCompatible = false;\n          }\n        }\n\n        return obj;\n      };\n\n      return Transforms;\n    }();\n  }, {}],\n  35: [function (require, module, exports) {\n    var Version;\n\n    module.exports = Version = function () {\n      Version.semVer = /(\\d+)\\.(\\d+)\\.(\\d+)(.+)?/;\n\n      function Version(versionString) {\n        this.parseVersion(versionString);\n      }\n\n      Version.prototype.parseVersion = function (versionString) {\n        var res;\n        res = Version.semVer.exec(versionString);\n\n        if (res) {\n          this.major = res[1];\n          this.minor = res[2];\n          this.patch = res[3];\n          return this.addendum = res[4];\n        }\n      };\n\n      Version.prototype.isValid = function () {\n        return this.major != null;\n      };\n\n      Version.prototype.toString = function () {\n        return \"\" + this.major + \".\" + this.minor + \".\" + this.patch + (this.addendum || '');\n      };\n\n      Version.parse = function (versionString) {\n        var v;\n        v = new Version(versionString);\n\n        if (v.isValid()) {\n          return v.toString();\n        } else {\n          return '';\n        }\n      };\n\n      return Version;\n    }();\n  }, {}],\n  36: [function (require, module, exports) {\n    module.exports = {\n      name: 'default',\n      set: function set($elem, value) {\n        if (this.isInlineImage($elem)) {\n          return this.setInlineImage($elem, value);\n        } else {\n          return this.setBackgroundImage($elem, value);\n        }\n      },\n      getUrl: function getUrl(value) {\n        return value;\n      },\n      setInlineImage: function setInlineImage($elem, value) {\n        return $elem.attr('src', value);\n      },\n      setBackgroundImage: function setBackgroundImage($elem, value) {\n        return $elem.css('background-image', \"url(\" + this.escapeCssUri(value) + \")\");\n      },\n      escapeCssUri: function escapeCssUri(uri) {\n        if (/[()]/.test(uri)) {\n          return \"'\" + uri + \"'\";\n        } else {\n          return uri;\n        }\n      },\n      getImageDimensions: function getImageDimensions($elem) {\n        if (this.isInlineImage($elem)) {\n          return {\n            width: $elem.width(),\n            height: $elem.height()\n          };\n        } else {\n          return {\n            width: $elem.outerWidth(),\n            height: $elem.outerHeight()\n          };\n        }\n      },\n      isBase64: function isBase64(value) {\n        if (value != null) {\n          return value.indexOf('data:image') === 0;\n        }\n      },\n      isInlineImage: function isInlineImage($elem) {\n        return $elem[0].nodeName.toLowerCase() === 'img';\n      },\n      isBackgroundImage: function isBackgroundImage($elem) {\n        return $elem[0].nodeName.toLowerCase() !== 'img';\n      }\n    };\n  }, {}],\n  37: [function (require, module, exports) {\n    var assert, defaultImageService, resrcitImageService;\n    assert = require('../modules/logging/assert');\n    defaultImageService = require('./default_image_service');\n    resrcitImageService = require('./resrcit_image_service');\n\n    module.exports = function () {\n      var services;\n      services = {\n        'resrc.it': resrcitImageService,\n        'default': defaultImageService\n      };\n      return {\n        has: function has(serviceName) {\n          if (serviceName == null) {\n            serviceName = 'default';\n          }\n\n          return services[serviceName] != null;\n        },\n        get: function get(serviceName) {\n          if (serviceName == null) {\n            serviceName = 'default';\n          }\n\n          assert(this.has(serviceName), \"Could not load image service \" + serviceName);\n          return services[serviceName];\n        },\n        eachService: function eachService(callback) {\n          var name, service, _results;\n\n          _results = [];\n\n          for (name in services) {\n            service = services[name];\n\n            _results.push(callback(name, service));\n          }\n\n          return _results;\n        }\n      };\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"./default_image_service\": 36,\n    \"./resrcit_image_service\": 38\n  }],\n  38: [function (require, module, exports) {\n    var assert, imgService, resrcitConfig;\n    assert = require('../modules/logging/assert');\n    imgService = require('./default_image_service');\n    resrcitConfig = require('../configuration/config').imageServices['resrc.it'];\n\n    module.exports = function () {\n      return {\n        name: 'resrc.it',\n        set: function set($elem, url) {\n          assert(url != null && url !== '', 'Src value for an image has to be defined');\n\n          if (imgService.isBase64(url)) {\n            return this.setBase64($elem, url);\n          }\n\n          $elem.addClass('resrc');\n\n          if (imgService.isInlineImage($elem)) {\n            return this.setInlineImage($elem, url);\n          } else {\n            return this.setBackgroundImage($elem, url);\n          }\n        },\n        getUrl: function getUrl(value, _arg) {\n          var crop, height, q, quality, style, width, x, y, _ref;\n\n          _ref = _arg != null ? _arg : {}, crop = _ref.crop, quality = _ref.quality;\n          style = \"\";\n\n          if (crop != null) {\n            x = crop.x, y = crop.y, width = crop.width, height = crop.height;\n            assert(typeof x === 'number', 'x should be a number');\n            assert(typeof y === 'number', 'y should be a number');\n            assert(typeof width === 'number', 'width should be a number');\n            assert(typeof height === 'number', 'height should be a number');\n            style += \"/C=W\" + width + \",H\" + height + \",X\" + x + \",Y\" + y;\n          }\n\n          if (q = quality || resrcitConfig.quality) {\n            style += \"/O=\" + q;\n          }\n\n          return \"\" + resrcitConfig.host + style + \"/\" + value;\n        },\n        formatCssUrl: function formatCssUrl(url) {\n          url = imgService.escapeCssUri(url);\n          return \"url(\" + url + \")\";\n        },\n        setInlineImage: function setInlineImage($elem, url) {\n          if (imgService.isBase64($elem.attr('src'))) {\n            $elem.removeAttr('src');\n          }\n\n          return $elem.attr('data-src', url);\n        },\n        setBackgroundImage: function setBackgroundImage($elem, url) {\n          return $elem.css('background-image', this.formatCssUrl(url));\n        },\n        setBase64: function setBase64($elem, base64String) {\n          return imgService.set($elem, base64String);\n        }\n      };\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/logging/assert\": 50,\n    \"./default_image_service\": 36\n  }],\n  39: [function (require, module, exports) {\n    var $, ComponentDrag, config, css, dom, isSupported;\n    $ = require('jquery');\n    dom = require('./dom');\n    isSupported = require('../modules/feature_detection/is_supported');\n    config = require('../configuration/config');\n    css = config.css;\n\n    module.exports = ComponentDrag = function () {\n      var startAndEndOffset, wiggleSpace;\n      wiggleSpace = 0;\n      startAndEndOffset = 0;\n\n      function ComponentDrag(_arg) {\n        var componentView;\n        this.componentModel = _arg.componentModel, componentView = _arg.componentView;\n\n        if (componentView) {\n          this.$view = componentView.$html;\n        }\n\n        this.$highlightedContainer = {};\n      }\n\n      ComponentDrag.prototype.start = function (eventPosition) {\n        this.started = true;\n        this.page.editableController.disableAll();\n        this.page.blurFocusedElement();\n        this.$placeholder = this.createPlaceholder().css({\n          'pointer-events': 'none'\n        });\n        this.$dragBlocker = this.page.$body.find(\".\" + css.dragBlocker);\n        this.$dropMarker = $(\"<div class='\" + css.dropMarker + \"'>\");\n        this.page.$body.append(this.$dropMarker).append(this.$placeholder).css('cursor', 'pointer');\n\n        if (this.$view != null) {\n          this.$view.addClass(css.dragged);\n        }\n\n        return this.move(eventPosition);\n      };\n\n      ComponentDrag.prototype.move = function (eventPosition) {\n        this.$placeholder.css({\n          left: \"\" + eventPosition.pageX + \"px\",\n          top: \"\" + eventPosition.pageY + \"px\"\n        });\n        return this.target = this.findDropTarget(eventPosition);\n      };\n\n      ComponentDrag.prototype.findDropTarget = function (eventPosition) {\n        var coords, elem, target, _ref, _ref1;\n\n        _ref = this.getElemUnderCursor(eventPosition), eventPosition = _ref.eventPosition, elem = _ref.elem;\n\n        if (elem == null) {\n          return void 0;\n        }\n\n        if (elem === this.$dropMarker[0]) {\n          return this.target;\n        }\n\n        coords = {\n          left: eventPosition.pageX,\n          top: eventPosition.pageY\n        };\n\n        if (elem != null) {\n          target = dom.dropTarget(elem, coords);\n        }\n\n        if (!this.canBeDropped(target)) {\n          target = void 0;\n        }\n\n        this.undoMakeSpace();\n\n        if (target != null && ((_ref1 = target.componentView) != null ? _ref1.model : void 0) !== this.componentModel) {\n          this.$placeholder.removeClass(css.noDrop);\n          this.markDropPosition(target);\n          return target;\n        } else {\n          this.$dropMarker.hide();\n          this.removeContainerHighlight();\n\n          if (target == null) {\n            this.$placeholder.addClass(css.noDrop);\n          } else {\n            this.$placeholder.removeClass(css.noDrop);\n          }\n\n          return void 0;\n        }\n      };\n\n      ComponentDrag.prototype.canBeDropped = function (target) {\n        var componentTree, isAllowed;\n\n        if (target == null) {\n          return false;\n        }\n\n        componentTree = target.componentTree;\n\n        if (componentTree == null) {\n          componentTree = target.componentView.model.componentTree;\n        }\n\n        isAllowed = componentTree.isDropAllowed(this.componentModel, target);\n        return isAllowed;\n      };\n\n      ComponentDrag.prototype.markDropPosition = function (target) {\n        switch (target.target) {\n          case 'component':\n            this.componentPosition(target);\n            return this.removeContainerHighlight();\n\n          case 'container':\n            this.showMarkerAtBeginningOfContainer(target.node);\n            return this.highlighContainer($(target.node));\n\n          case 'root':\n            this.showMarkerAtBeginningOfContainer(target.node);\n            return this.highlighContainer($(target.node));\n        }\n      };\n\n      ComponentDrag.prototype.componentPosition = function (target) {\n        var before, next;\n\n        if (target.position === 'before') {\n          before = target.componentView.prev();\n\n          if (before != null) {\n            if (before.model === this.componentModel) {\n              target.position = 'after';\n              return this.componentPosition(target);\n            }\n\n            return this.showMarkerBetweenComponents(before, target.componentView);\n          } else {\n            return this.showMarkerAtBeginningOfContainer(target.componentView.$elem[0].parentNode);\n          }\n        } else {\n          next = target.componentView.next();\n\n          if (next != null) {\n            if (next.model === this.componentModel) {\n              target.position = 'before';\n              return this.componentPosition(target);\n            }\n\n            return this.showMarkerBetweenComponents(target.componentView, next);\n          } else {\n            return this.showMarkerAtEndOfContainer(target.componentView.$elem[0].parentNode);\n          }\n        }\n      };\n\n      ComponentDrag.prototype.showMarkerBetweenComponents = function (viewA, viewB) {\n        var boxA, boxB, halfGap;\n        boxA = dom.getAbsoluteBoundingClientRect(viewA.$elem[0]);\n        boxB = dom.getAbsoluteBoundingClientRect(viewB.$elem[0]);\n        halfGap = boxB.top > boxA.bottom ? (boxB.top - boxA.bottom) / 2 : 0;\n        return this.showMarker({\n          left: boxA.left,\n          top: boxA.bottom + halfGap,\n          width: boxA.width\n        });\n      };\n\n      ComponentDrag.prototype.showMarkerAtBeginningOfContainer = function (elem) {\n        var box, paddingTop;\n\n        if (elem == null) {\n          return;\n        }\n\n        this.makeSpace(elem.firstChild, 'top');\n        box = dom.getAbsoluteBoundingClientRect(elem);\n        paddingTop = parseInt($(elem).css('padding-top')) || 0;\n        return this.showMarker({\n          left: box.left,\n          top: box.top + startAndEndOffset + paddingTop,\n          width: box.width\n        });\n      };\n\n      ComponentDrag.prototype.showMarkerAtEndOfContainer = function (elem) {\n        var box, paddingBottom;\n\n        if (elem == null) {\n          return;\n        }\n\n        this.makeSpace(elem.lastChild, 'bottom');\n        box = dom.getAbsoluteBoundingClientRect(elem);\n        paddingBottom = parseInt($(elem).css('padding-bottom')) || 0;\n        return this.showMarker({\n          left: box.left,\n          top: box.bottom - startAndEndOffset - paddingBottom,\n          width: box.width\n        });\n      };\n\n      ComponentDrag.prototype.showMarker = function (_arg) {\n        var $body, left, top, width;\n        left = _arg.left, top = _arg.top, width = _arg.width;\n\n        if (this.iframeBox != null) {\n          $body = $(this.iframeBox.window.document.body);\n          top -= $body.scrollTop();\n          left -= $body.scrollLeft();\n          left += this.iframeBox.left;\n          top += this.iframeBox.top;\n          this.$dropMarker.css({\n            position: 'fixed'\n          });\n        } else {\n          this.$dropMarker.css({\n            position: 'absolute'\n          });\n        }\n\n        return this.$dropMarker.css({\n          left: \"\" + left + \"px\",\n          top: \"\" + top + \"px\",\n          width: \"\" + width + \"px\"\n        }).show();\n      };\n\n      ComponentDrag.prototype.makeSpace = function (node, position) {\n        var $node;\n\n        if (!(wiggleSpace && node != null)) {\n          return;\n        }\n\n        $node = $(node);\n        this.lastTransform = $node;\n\n        if (position === 'top') {\n          return $node.css({\n            transform: \"translate(0, \" + wiggleSpace + \"px)\"\n          });\n        } else {\n          return $node.css({\n            transform: \"translate(0, -\" + wiggleSpace + \"px)\"\n          });\n        }\n      };\n\n      ComponentDrag.prototype.undoMakeSpace = function (node) {\n        if (this.lastTransform != null) {\n          this.lastTransform.css({\n            transform: ''\n          });\n          return this.lastTransform = void 0;\n        }\n      };\n\n      ComponentDrag.prototype.highlighContainer = function ($container) {\n        var _base, _base1;\n\n        if ($container[0] !== this.$highlightedContainer[0]) {\n          if (typeof (_base = this.$highlightedContainer).removeClass === \"function\") {\n            _base.removeClass(css.containerHighlight);\n          }\n\n          this.$highlightedContainer = $container;\n          return typeof (_base1 = this.$highlightedContainer).addClass === \"function\" ? _base1.addClass(css.containerHighlight) : void 0;\n        }\n      };\n\n      ComponentDrag.prototype.removeContainerHighlight = function () {\n        var _base;\n\n        if (typeof (_base = this.$highlightedContainer).removeClass === \"function\") {\n          _base.removeClass(css.containerHighlight);\n        }\n\n        return this.$highlightedContainer = {};\n      };\n\n      ComponentDrag.prototype.getElemUnderCursor = function (eventPosition) {\n        var elem;\n        elem = void 0;\n        this.unblockElementFromPoint(function (_this) {\n          return function () {\n            var clientX, clientY, _ref;\n\n            clientX = eventPosition.clientX, clientY = eventPosition.clientY;\n\n            if (clientX != null && clientY != null) {\n              elem = _this.page.document.elementFromPoint(clientX, clientY);\n            }\n\n            if ((elem != null ? elem.nodeName : void 0) === 'IFRAME') {\n              return _ref = _this.findElemInIframe(elem, eventPosition), eventPosition = _ref.eventPosition, elem = _ref.elem, _ref;\n            } else {\n              return _this.iframeBox = void 0;\n            }\n          };\n        }(this));\n        return {\n          eventPosition: eventPosition,\n          elem: elem\n        };\n      };\n\n      ComponentDrag.prototype.findElemInIframe = function (iframeElem, eventPosition) {\n        var $body, box, document, elem;\n        this.iframeBox = box = iframeElem.getBoundingClientRect();\n        this.iframeBox.window = iframeElem.contentWindow;\n        document = iframeElem.contentDocument;\n        $body = $(document.body);\n        eventPosition.clientX -= box.left;\n        eventPosition.clientY -= box.top;\n        eventPosition.pageX = eventPosition.clientX + $body.scrollLeft();\n        eventPosition.pageY = eventPosition.clientY + $body.scrollTop();\n        elem = document.elementFromPoint(eventPosition.clientX, eventPosition.clientY);\n        return {\n          eventPosition: eventPosition,\n          elem: elem\n        };\n      };\n\n      ComponentDrag.prototype.unblockElementFromPoint = function (callback) {\n        if (isSupported('htmlPointerEvents')) {\n          this.$dragBlocker.css({\n            'pointer-events': 'none'\n          });\n          callback();\n          return this.$dragBlocker.css({\n            'pointer-events': 'auto'\n          });\n        } else {\n          this.$dragBlocker.hide();\n          this.$placeholder.hide();\n          callback();\n          this.$dragBlocker.show();\n          return this.$placeholder.show();\n        }\n      };\n\n      ComponentDrag.prototype.drop = function () {\n        if (this.target != null) {\n          this.moveToTarget(this.target);\n          return this.page.componentWasDropped.fire(this.componentModel);\n        } else {}\n      };\n\n      ComponentDrag.prototype.moveToTarget = function (target) {\n        var componentModel, componentTree, componentView;\n\n        switch (target.target) {\n          case 'component':\n            componentView = target.componentView;\n\n            if (target.position === 'before') {\n              return componentView.model.before(this.componentModel);\n            } else {\n              return componentView.model.after(this.componentModel);\n            }\n\n            break;\n\n          case 'container':\n            componentModel = target.componentView.model;\n            return componentModel.append(target.containerName, this.componentModel);\n\n          case 'root':\n            componentTree = target.componentTree;\n            return componentTree.prepend(this.componentModel);\n        }\n      };\n\n      ComponentDrag.prototype.reset = function () {\n        if (this.started) {\n          this.undoMakeSpace();\n          this.removeContainerHighlight();\n          this.page.$body.css('cursor', '');\n          this.page.editableController.reenableAll();\n\n          if (this.$view != null) {\n            this.$view.removeClass(css.dragged);\n          }\n\n          dom.restoreContainerHeight();\n          this.$placeholder.remove();\n          return this.$dropMarker.remove();\n        }\n      };\n\n      ComponentDrag.prototype.createPlaceholder = function () {\n        var $placeholder, numberOfDraggedElems, template;\n        numberOfDraggedElems = 1;\n        template = \"<div class=\\\"\" + css.draggedPlaceholder + \"\\\">\\n  <span class=\\\"\" + css.draggedPlaceholderCounter + \"\\\">\\n    \" + numberOfDraggedElems + \"\\n  </span>\\n  Selected Item\\n</div>\";\n        return $placeholder = $(template).css({\n          position: \"absolute\"\n        });\n      };\n\n      return ComponentDrag;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/feature_detection/is_supported\": 48,\n    \"./dom\": 41,\n    \"jquery\": \"jquery\"\n  }],\n  40: [function (require, module, exports) {\n    var ContainerEvent;\n\n    module.exports = ContainerEvent = function () {\n      function ContainerEvent(_arg) {\n        var blur, focus;\n        this.target = _arg.target, focus = _arg.focus, blur = _arg.blur;\n        this.type = focus ? 'containerFocus' : blur ? 'containerBlur' : void 0;\n      }\n\n      return ContainerEvent;\n    }();\n  }, {}],\n  41: [function (require, module, exports) {\n    var $, config, css, directiveFinder;\n    $ = require('jquery');\n    config = require('../configuration/config');\n    directiveFinder = require('../template/directive_finder');\n    css = config.css;\n\n    module.exports = function () {\n      var componentRegex, sectionRegex;\n      componentRegex = new RegExp(\"(?: |^)\" + css.component + \"(?: |$)\");\n      sectionRegex = new RegExp(\"(?: |^)\" + css.section + \"(?: |$)\");\n      return {\n        findComponentView: function findComponentView(node) {\n          var view;\n          node = this.getElementNode(node);\n\n          while (node && node.nodeType === 1) {\n            if (componentRegex.test(node.className)) {\n              view = this.getComponentView(node);\n              return view;\n            }\n\n            node = node.parentNode;\n          }\n\n          return void 0;\n        },\n        getDirectiveContext: function getDirectiveContext(node) {\n          var directives;\n          node = this.getElementNode(node);\n\n          while (node && node.nodeType === 1) {\n            directives = this.getDirectives(node);\n\n            if (directives) {\n              return directives;\n            }\n\n            node = node.parentNode;\n          }\n\n          return void 0;\n        },\n        isInsideDocLink: function isInsideDocLink(node) {\n          var directives;\n\n          while (node && node.nodeType === 1) {\n            directives = this.getDirectives(node);\n\n            if (directives != null ? directives['link'] : void 0) {\n              return true;\n            }\n\n            node = node.parentNode;\n          }\n\n          return false;\n        },\n        getDirectives: function getDirectives(node) {\n          var directives;\n          directives = void 0;\n          directiveFinder.eachDirective(node, function (type, name) {\n            if (type === 'optional') {\n              return;\n            }\n\n            if (directives == null) {\n              directives = {};\n            }\n\n            return directives[type] = {\n              type: type,\n              name: name\n            };\n          });\n          return directives;\n        },\n        findContainer: function findContainer(node) {\n          var containerAttr, containerName, view;\n          node = this.getElementNode(node);\n          containerAttr = config.directives.container.renderedAttr;\n\n          while (node && node.nodeType === 1) {\n            if (node.hasAttribute(containerAttr)) {\n              containerName = node.getAttribute(containerAttr);\n\n              if (!sectionRegex.test(node.className)) {\n                view = this.findComponentView(node);\n              }\n\n              return {\n                node: node,\n                containerName: containerName,\n                componentView: view\n              };\n            }\n\n            node = node.parentNode;\n          }\n\n          return {};\n        },\n        getImageName: function getImageName(node) {\n          var imageAttr, imageName;\n          imageAttr = config.directives.image.renderedAttr;\n\n          if (node.hasAttribute(imageAttr)) {\n            imageName = node.getAttribute(imageAttr);\n            return imageName;\n          }\n        },\n        getHtmlElementName: function getHtmlElementName(node) {\n          var htmlAttr, htmlElementName;\n          htmlAttr = config.directives.html.renderedAttr;\n\n          if (node.hasAttribute(htmlAttr)) {\n            htmlElementName = node.getAttribute(htmlAttr);\n            return htmlElementName;\n          }\n        },\n        getEditableName: function getEditableName(node) {\n          var editableAttr, imageName;\n          editableAttr = config.directives.editable.renderedAttr;\n\n          if (node.hasAttribute(editableAttr)) {\n            imageName = node.getAttribute(editableAttr);\n            return imageName;\n          }\n        },\n        dropTarget: function dropTarget(node, _arg) {\n          var closestComponentData, containerAttr, left, top;\n          top = _arg.top, left = _arg.left;\n          node = this.getElementNode(node);\n          containerAttr = config.directives.container.renderedAttr;\n\n          while (node && node.nodeType === 1) {\n            if (node.hasAttribute(containerAttr)) {\n              closestComponentData = this.getClosestComponent(node, {\n                top: top,\n                left: left\n              });\n\n              if (closestComponentData != null) {\n                return this.getClosestComponentTarget(closestComponentData);\n              } else {\n                return this.getContainerTarget(node);\n              }\n            } else if (componentRegex.test(node.className)) {\n              return this.getComponentTarget(node, {\n                top: top,\n                left: left\n              });\n            } else if (sectionRegex.test(node.className)) {\n              closestComponentData = this.getClosestComponent(node, {\n                top: top,\n                left: left\n              });\n\n              if (closestComponentData != null) {\n                return this.getClosestComponentTarget(closestComponentData);\n              } else {\n                return this.getRootTarget(node);\n              }\n            }\n\n            node = node.parentNode;\n          }\n        },\n        getComponentTarget: function getComponentTarget(elem, _arg) {\n          var left, position, top;\n          top = _arg.top, left = _arg.left, position = _arg.position;\n          return {\n            target: 'component',\n            componentView: this.getComponentView(elem),\n            position: position || this.getPositionOnComponent(elem, {\n              top: top,\n              left: left\n            })\n          };\n        },\n        getClosestComponentTarget: function getClosestComponentTarget(closestComponentData) {\n          var elem, position;\n          elem = closestComponentData.$elem[0];\n          position = closestComponentData.position;\n          return this.getComponentTarget(elem, {\n            position: position\n          });\n        },\n        getContainerTarget: function getContainerTarget(node) {\n          var containerAttr, containerName;\n          containerAttr = config.directives.container.renderedAttr;\n          containerName = node.getAttribute(containerAttr);\n          return {\n            target: 'container',\n            node: node,\n            componentView: this.findComponentView(node),\n            containerName: containerName\n          };\n        },\n        getRootTarget: function getRootTarget(node) {\n          var componentTree;\n          componentTree = $(node).data('componentTree');\n          return {\n            target: 'root',\n            node: node,\n            componentTree: componentTree\n          };\n        },\n        getPositionOnComponent: function getPositionOnComponent(elem, _arg) {\n          var $elem, elemBottom, elemHeight, elemTop, left, top;\n          top = _arg.top, left = _arg.left;\n          $elem = $(elem);\n          elemTop = $elem.offset().top;\n          elemHeight = $elem.outerHeight();\n          elemBottom = elemTop + elemHeight;\n\n          if (this.distance(top, elemTop) < this.distance(top, elemBottom)) {\n            return 'before';\n          } else {\n            return 'after';\n          }\n        },\n        getClosestComponent: function getClosestComponent(container, _arg) {\n          var $components, closest, closestComponent, left, top;\n          top = _arg.top, left = _arg.left;\n          $components = $(container).find(\".\" + css.component);\n          closest = void 0;\n          closestComponent = void 0;\n          $components.each(function (_this) {\n            return function (index, elem) {\n              var $elem, elemBottom, elemHeight, elemTop;\n              $elem = $(elem);\n              elemTop = $elem.offset().top;\n              elemHeight = $elem.outerHeight();\n              elemBottom = elemTop + elemHeight;\n\n              if (closest == null || _this.distance(top, elemTop) < closest) {\n                closest = _this.distance(top, elemTop);\n                closestComponent = {\n                  $elem: $elem,\n                  position: 'before'\n                };\n              }\n\n              if (closest == null || _this.distance(top, elemBottom) < closest) {\n                closest = _this.distance(top, elemBottom);\n                return closestComponent = {\n                  $elem: $elem,\n                  position: 'after'\n                };\n              }\n            };\n          }(this));\n          return closestComponent;\n        },\n        distance: function distance(a, b) {\n          if (a > b) {\n            return a - b;\n          } else {\n            return b - a;\n          }\n        },\n        maximizeContainerHeight: function maximizeContainerHeight(view) {\n          var $elem, $parent, elem, name, outer, parentHeight, _ref, _results;\n\n          if (view.template.containerCount > 1) {\n            _ref = view.containers;\n            _results = [];\n\n            for (name in _ref) {\n              elem = _ref[name];\n              $elem = $(elem);\n\n              if ($elem.hasClass(css.maximizedContainer)) {\n                continue;\n              }\n\n              $parent = $elem.parent();\n              parentHeight = $parent.height();\n              outer = $elem.outerHeight(true) - $elem.height();\n              $elem.height(parentHeight - outer);\n\n              _results.push($elem.addClass(css.maximizedContainer));\n            }\n\n            return _results;\n          }\n        },\n        restoreContainerHeight: function restoreContainerHeight() {\n          return $(\".\" + css.maximizedContainer).css('height', '').removeClass(css.maximizedContainer);\n        },\n        getElementNode: function getElementNode(node) {\n          if (node != null ? node.jquery : void 0) {\n            return node[0];\n          } else if ((node != null ? node.nodeType : void 0) === 3) {\n            return node.parentNode;\n          } else {\n            return node;\n          }\n        },\n        getComponentView: function getComponentView(node) {\n          return $(node).data('componentView');\n        },\n        getAbsoluteBoundingClientRect: function getAbsoluteBoundingClientRect(node) {\n          var coords, scrollX, scrollY, win, _ref;\n\n          win = node.ownerDocument.defaultView;\n          _ref = this.getScrollPosition(win), scrollX = _ref.scrollX, scrollY = _ref.scrollY;\n          coords = node.getBoundingClientRect();\n          coords = {\n            top: coords.top + scrollY,\n            bottom: coords.bottom + scrollY,\n            left: coords.left + scrollX,\n            right: coords.right + scrollX\n          };\n          coords.height = coords.bottom - coords.top;\n          coords.width = coords.right - coords.left;\n          return coords;\n        },\n        getScrollPosition: function getScrollPosition(win) {\n          return {\n            scrollX: win.pageXOffset !== void 0 ? win.pageXOffset : (win.document.documentElement || win.document.body.parentNode || win.document.body).scrollLeft,\n            scrollY: win.pageYOffset !== void 0 ? win.pageYOffset : (win.document.documentElement || win.document.body.parentNode || win.document.body).scrollTop\n          };\n        }\n      };\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../template/directive_finder\": 72,\n    \"jquery\": \"jquery\"\n  }],\n  42: [function (require, module, exports) {\n    var DragBase, config, css;\n    config = require('../configuration/config');\n    css = config.css;\n\n    module.exports = DragBase = function () {\n      function DragBase(page, options) {\n        var defaultConfig;\n        this.page = page;\n        this.modes = ['direct', 'longpress', 'move'];\n        defaultConfig = {\n          preventDefault: false,\n          onDragStart: void 0,\n          scrollArea: 50,\n          longpress: {\n            showIndicator: true,\n            delay: 400,\n            tolerance: 3\n          },\n          move: {\n            distance: 0\n          }\n        };\n        this.defaultConfig = $.extend(true, defaultConfig, options);\n        this.startPoint = void 0;\n        this.dragHandler = void 0;\n        this.initialized = false;\n        this.started = false;\n      }\n\n      DragBase.prototype.setOptions = function (options) {\n        this.options = $.extend(true, {}, this.defaultConfig, options);\n        return this.mode = options.direct != null ? 'direct' : options.longpress != null ? 'longpress' : options.move != null ? 'move' : 'longpress';\n      };\n\n      DragBase.prototype.setDragHandler = function (dragHandler) {\n        this.dragHandler = dragHandler;\n        return this.dragHandler.page = this.page;\n      };\n\n      DragBase.prototype.init = function (dragHandler, event, options) {\n        this.reset();\n        this.initialized = true;\n        this.setOptions(options);\n        this.setDragHandler(dragHandler);\n        this.startPoint = this.getEventPosition(event);\n        this.addStopListeners(event);\n        this.addMoveListeners(event);\n\n        if (this.mode === 'longpress') {\n          this.addLongpressIndicator(this.startPoint);\n          this.timeout = setTimeout(function (_this) {\n            return function () {\n              _this.removeLongpressIndicator();\n\n              return _this.start(event);\n            };\n          }(this), this.options.longpress.delay);\n        } else if (this.mode === 'direct') {\n          this.start(event);\n        }\n\n        if (this.options.preventDefault) {\n          return event.preventDefault();\n        }\n      };\n\n      DragBase.prototype.move = function (event) {\n        var eventPosition;\n        eventPosition = this.getEventPosition(event);\n\n        if (this.mode === 'longpress') {\n          if (this.distance(eventPosition, this.startPoint) > this.options.longpress.tolerance) {\n            return this.reset();\n          }\n        } else if (this.mode === 'move') {\n          if (this.distance(eventPosition, this.startPoint) > this.options.move.distance) {\n            return this.start(event);\n          }\n        }\n      };\n\n      DragBase.prototype.start = function (event) {\n        var eventPosition;\n        eventPosition = this.getEventPosition(event);\n        this.started = true;\n        this.addBlocker();\n        this.page.$body.addClass(css.preventSelection);\n        return this.dragHandler.start(eventPosition);\n      };\n\n      DragBase.prototype.drop = function (event) {\n        if (this.started) {\n          this.dragHandler.drop(event);\n        }\n\n        if ($.isFunction(this.options.onDrop)) {\n          this.options.onDrop(event, this.dragHandler);\n        }\n\n        return this.reset();\n      };\n\n      DragBase.prototype.cancel = function () {\n        return this.reset();\n      };\n\n      DragBase.prototype.reset = function () {\n        if (this.started) {\n          this.started = false;\n          this.page.$body.removeClass(css.preventSelection);\n        }\n\n        if (this.initialized) {\n          this.initialized = false;\n          this.startPoint = void 0;\n          this.dragHandler.reset();\n          this.dragHandler = void 0;\n\n          if (this.timeout != null) {\n            clearTimeout(this.timeout);\n            this.timeout = void 0;\n          }\n\n          this.page.$document.off('.livingdocs-drag');\n          this.removeLongpressIndicator();\n          return this.removeBlocker();\n        }\n      };\n\n      DragBase.prototype.addBlocker = function () {\n        var $blocker;\n        $blocker = $(\"<div class='\" + css.dragBlocker + \"'>\").attr('style', 'position: absolute; top: 0; bottom: 0; left: 0; right: 0;');\n        return this.page.$body.append($blocker);\n      };\n\n      DragBase.prototype.removeBlocker = function () {\n        return this.page.$body.find(\".\" + css.dragBlocker).remove();\n      };\n\n      DragBase.prototype.addLongpressIndicator = function (_arg) {\n        var $indicator, pageX, pageY;\n        pageX = _arg.pageX, pageY = _arg.pageY;\n\n        if (!this.options.longpress.showIndicator) {\n          return;\n        }\n\n        $indicator = $(\"<div class=\\\"\" + css.longpressIndicator + \"\\\"><div></div></div>\");\n        $indicator.css({\n          left: pageX,\n          top: pageY\n        });\n        return this.page.$body.append($indicator);\n      };\n\n      DragBase.prototype.removeLongpressIndicator = function () {\n        return this.page.$body.find(\".\" + css.longpressIndicator).remove();\n      };\n\n      DragBase.prototype.addStopListeners = function (event) {\n        var eventNames;\n        eventNames = event.type === 'touchstart' ? 'touchend.livingdocs-drag touchcancel.livingdocs-drag touchleave.livingdocs-drag' : event.type === 'dragenter' || event.type === 'dragbetterenter' ? 'drop.livingdocs-drag dragend.livingdocs-drag' : 'mouseup.livingdocs-drag';\n        return this.page.$document.on(eventNames, function (_this) {\n          return function (event) {\n            return _this.drop(event);\n          };\n        }(this));\n      };\n\n      DragBase.prototype.addMoveListeners = function (event) {\n        if (event.type === 'touchstart') {\n          return this.page.$document.on('touchmove.livingdocs-drag', function (_this) {\n            return function (event) {\n              event.preventDefault();\n\n              if (_this.started) {\n                return _this.dragHandler.move(_this.getEventPosition(event));\n              } else {\n                return _this.move(event);\n              }\n            };\n          }(this));\n        } else if (event.type === 'dragenter' || event.type === 'dragbetterenter') {\n          return this.page.$document.on('dragover.livingdocs-drag', function (_this) {\n            return function (event) {\n              if (_this.started) {\n                return _this.dragHandler.move(_this.getEventPosition(event));\n              } else {\n                return _this.move(event);\n              }\n            };\n          }(this));\n        } else {\n          return this.page.$document.on('mousemove.livingdocs-drag', function (_this) {\n            return function (event) {\n              if (_this.started) {\n                return _this.dragHandler.move(_this.getEventPosition(event));\n              } else {\n                return _this.move(event);\n              }\n            };\n          }(this));\n        }\n      };\n\n      DragBase.prototype.getEventPosition = function (event) {\n        if (event.type === 'touchstart' || event.type === 'touchmove') {\n          event = event.originalEvent.changedTouches[0];\n        } else if (event.type === 'dragover') {\n          event = event.originalEvent;\n        }\n\n        return {\n          clientX: event.clientX,\n          clientY: event.clientY,\n          pageX: event.pageX,\n          pageY: event.pageY\n        };\n      };\n\n      DragBase.prototype.distance = function (pointA, pointB) {\n        var distX, distY;\n\n        if (!pointA || !pointB) {\n          return void 0;\n        }\n\n        distX = pointA.pageX - pointB.pageX;\n        distY = pointA.pageY - pointB.pageY;\n        return Math.sqrt(distX * distX + distY * distY);\n      };\n\n      return DragBase;\n    }();\n  }, {\n    \"../configuration/config\": 26\n  }],\n  43: [function (require, module, exports) {\n    var EditableController,\n        config,\n        dom,\n        __slice = [].slice;\n    dom = require('./dom');\n    config = require('../configuration/config');\n\n    module.exports = EditableController = function () {\n      function EditableController(page) {\n        this.page = page;\n        this.editable = new Editable({\n          window: this.page.window,\n          browserSpellcheck: config.editable.browserSpellcheck,\n          mouseMoveSelectionChanges: config.editable.mouseMoveSelectionChanges\n        });\n        this.editableAttr = config.directives.editable.renderedAttr;\n        this.selection = $.Callbacks();\n        this.editable.focus(this.withContext(this.focus)).blur(this.withContext(this.blur)).insert(this.withContext(this.insert)).paste(this.withContext(this.paste)).merge(this.withContext(this.merge)).split(this.withContext(this.split)).selection(this.withContext(this.selectionChanged)).newline(this.withContext(this.newline)).change(this.withContext(this.change));\n      }\n\n      EditableController.prototype.add = function (nodes) {\n        return this.editable.add(nodes);\n      };\n\n      EditableController.prototype.disableAll = function () {\n        return this.editable.suspend();\n      };\n\n      EditableController.prototype.reenableAll = function () {\n        return this.editable[\"continue\"]();\n      };\n\n      EditableController.prototype.withContext = function (func) {\n        return function (_this) {\n          return function () {\n            var args, editableName, element, view;\n            element = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n            view = dom.findComponentView(element);\n            editableName = element.getAttribute(_this.editableAttr);\n            args.unshift(view, editableName);\n            return func.apply(_this, args);\n          };\n        }(this);\n      };\n\n      EditableController.prototype.extractContent = function (element) {\n        var value;\n        value = this.editable.getContent(element);\n\n        if (config.singleLineBreak.test(value) || value === '') {\n          return void 0;\n        } else {\n          return value;\n        }\n      };\n\n      EditableController.prototype.updateModel = function (view, editableName, element) {\n        var value;\n        value = this.extractContent(element);\n        return view.model.set(editableName, value);\n      };\n\n      EditableController.prototype.focus = function (view, editableName) {\n        var element;\n        view.focusEditable(editableName);\n        element = view.getDirectiveElement(editableName);\n        this.page.focus.editableFocused(element, view);\n        return true;\n      };\n\n      EditableController.prototype.blur = function (view, editableName) {\n        var element;\n        this.clearChangeTimeout();\n        element = view.getDirectiveElement(editableName);\n        this.updateModel(view, editableName, element);\n        view.blurEditable(editableName);\n        this.page.focus.editableBlurred(element, view);\n        return true;\n      };\n\n      EditableController.prototype.insert = function (view, editableName, direction, cursor) {\n        var copy, defaultParagraph, newView;\n        var newModel = null; // todo(Marcus) - this needs to use this component type's \"insertAfter\" attribute\n        // handle LIs\n\n        if (cursor.host && cursor.host.nodeName == 'LI') {\n          // duplicate the current type\n          newModel = dom.findComponentView(cursor.host);\n        }\n\n        defaultParagraph = newModel ? newModel.template : this.page.design.defaultParagraph;\n\n        if (this.hasSingleEditable(view) && defaultParagraph != null) {\n          copy = defaultParagraph.createModel();\n          newView = direction === 'before' ? (view.model.before(copy), view.prev()) : (view.model.after(copy), view.next());\n\n          if (newView && direction === 'after') {\n            newView.focus();\n          }\n        }\n\n        return false;\n      };\n\n      EditableController.prototype.paste = function (view, editableName, blocks, cursor) {\n        var block, currentBlock, defaultParagraph, firstBlock, firstEditable, index, newBlock, viewDirective, _i, _len, _ref;\n\n        firstBlock = blocks[0];\n        cursor.insertBefore(firstBlock);\n\n        if (blocks.length <= 1) {\n          cursor.setVisibleSelection();\n        } else {\n          defaultParagraph = this.page.design.defaultParagraph;\n          firstEditable = (_ref = defaultParagraph.directives['editable']) != null ? _ref[0] : void 0;\n          currentBlock = view.model;\n\n          for (index = _i = 0, _len = blocks.length; _i < _len; index = ++_i) {\n            block = blocks[index];\n\n            if (index === 0) {\n              continue;\n            }\n\n            newBlock = defaultParagraph.createModel();\n            newBlock.set(firstEditable.name, block);\n            currentBlock.after(newBlock);\n            currentBlock = newBlock;\n          }\n\n          view = currentBlock.getMainView();\n\n          if (view != null) {\n            viewDirective = view.directives.get(firstEditable.name);\n            cursor = this.editable.createCursorAtEnd(viewDirective.elem);\n            cursor.setVisibleSelection();\n          }\n        }\n\n        return false;\n      };\n\n      EditableController.prototype.merge = function (view, editableName, direction, cursor) {\n        var contentToMerge, mergedView, mergedViewElem, viewElem;\n\n        if (this.hasSingleEditable(view)) {\n          mergedView = direction === 'before' ? view.prev() : view.next();\n\n          if (mergedView && mergedView.template === view.template) {\n            viewElem = view.getDirectiveElement(editableName);\n            mergedViewElem = mergedView.getDirectiveElement(editableName);\n            contentToMerge = this.editable.getContent(viewElem);\n            cursor = direction === 'before' ? this.editable.appendTo(mergedViewElem, contentToMerge) : this.editable.prependTo(mergedViewElem, contentToMerge);\n            view.model.remove();\n            cursor.setVisibleSelection();\n            this.updateModel(mergedView, editableName, mergedViewElem);\n          }\n        }\n\n        return false;\n      };\n\n      EditableController.prototype.split = function (view, editableName, before, after, cursor) {\n        var copy, _ref;\n\n        if (this.hasSingleEditable(view)) {\n          copy = view.template.createModel();\n          copy.set(editableName, this.extractContent(after));\n          view.model.after(copy);\n\n          if ((_ref = view.next()) != null) {\n            _ref.focus();\n          }\n\n          view.model.set(editableName, this.extractContent(before));\n        }\n\n        return false;\n      };\n\n      EditableController.prototype.selectionChanged = function (view, editableName, selection) {\n        var element;\n        element = view.getDirectiveElement(editableName);\n        return this.selection.fire(view, element, selection);\n      };\n\n      EditableController.prototype.newline = function (view, editable, cursor) {\n        if (config.editable.allowNewline) {\n          return true;\n        } else {\n          return false;\n        }\n      };\n\n      EditableController.prototype.change = function (view, editableName) {\n        this.clearChangeTimeout();\n\n        if (config.editable.changeDelay === false) {\n          return;\n        }\n\n        return this.changeTimeout = setTimeout(function (_this) {\n          return function () {\n            var elem;\n            elem = view.getDirectiveElement(editableName);\n\n            _this.updateModel(view, editableName, elem);\n\n            return _this.changeTimeout = void 0;\n          };\n        }(this), config.editable.changeDelay);\n      };\n\n      EditableController.prototype.clearChangeTimeout = function () {\n        if (this.changeTimeout != null) {\n          clearTimeout(this.changeTimeout);\n          return this.changeTimeout = void 0;\n        }\n      };\n\n      EditableController.prototype.hasSingleEditable = function (view) {\n        return view.directives.length === 1 && view.directives[0].type === 'editable';\n      };\n\n      return EditableController;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"./dom\": 41\n  }],\n  44: [function (require, module, exports) {\n    var ContainerEvent, Focus, dom;\n    dom = require('./dom');\n    ContainerEvent = require('./container_event');\n\n    module.exports = Focus = function () {\n      function Focus() {\n        this.editableNode = void 0;\n        this.componentView = void 0;\n        this.componentFocus = $.Callbacks();\n        this.componentBlur = $.Callbacks();\n        this.containerFocus = $.Callbacks();\n        this.containerBlur = $.Callbacks();\n      }\n\n      Focus.prototype.setFocus = function (componentView, editableNode) {\n        if (editableNode !== this.editableNode) {\n          this.resetEditable();\n          this.editableNode = editableNode;\n        }\n\n        if (componentView !== this.componentView) {\n          this.resetComponentView();\n\n          if (componentView) {\n            this.componentView = componentView;\n            this.componentFocus.fire(this.componentView);\n            return this.fireContainerEvent({\n              view: this.componentView,\n              focus: true\n            });\n          }\n        }\n      };\n\n      Focus.prototype.editableFocused = function (editableNode, componentView) {\n        if (this.editableNode !== editableNode) {\n          componentView || (componentView = dom.findComponentView(editableNode));\n          return this.setFocus(componentView, editableNode);\n        }\n      };\n\n      Focus.prototype.editableBlurred = function (editableNode) {\n        if (this.editableNode === editableNode) {\n          return this.setFocus(this.componentView, void 0);\n        }\n      };\n\n      Focus.prototype.componentFocused = function (componentView) {\n        if (this.componentView !== componentView) {\n          return this.setFocus(componentView, void 0);\n        }\n      };\n\n      Focus.prototype.blur = function () {\n        return this.setFocus(void 0, void 0);\n      };\n\n      Focus.prototype.resetEditable = function () {\n        if (this.editableNode) {\n          return this.editableNode = void 0;\n        }\n      };\n\n      Focus.prototype.resetComponentView = function () {\n        var previous;\n\n        if (this.componentView) {\n          previous = this.componentView;\n          this.componentView = void 0;\n          this.componentBlur.fire(previous);\n          return this.fireContainerEvent({\n            view: previous,\n            blur: true\n          });\n        }\n      };\n\n      Focus.prototype.fireContainerEvent = function (_arg) {\n        var blur, component, event, focus, view;\n        view = _arg.view, focus = _arg.focus, blur = _arg.blur;\n        event = new ContainerEvent({\n          target: view,\n          focus: focus,\n          blur: blur\n        });\n        component = view.model;\n        return component.parentContainers(function (_this) {\n          return function (container) {\n            return _this[event.type].fire(container, event);\n          };\n        }(this));\n      };\n\n      return Focus;\n    }();\n  }, {\n    \"./container_event\": 40,\n    \"./dom\": 41\n  }],\n  45: [function (require, module, exports) {\n    var ComponentTree,\n        Dependencies,\n        EventEmitter,\n        FieldExtractor,\n        InteractivePage,\n        Livingdoc,\n        MetadataConfig,\n        Page,\n        Renderer,\n        RenderingContainer,\n        View,\n        assert,\n        config,\n        designCache,\n        dom,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    assert = require('./modules/logging/assert');\n    RenderingContainer = require('./rendering_container/rendering_container');\n    Page = require('./rendering_container/page');\n    InteractivePage = require('./rendering_container/interactive_page');\n    Renderer = require('./rendering/renderer');\n    View = require('./rendering/view');\n    EventEmitter = require('wolfy87-eventemitter');\n    config = require('./configuration/config');\n    dom = require('./interaction/dom');\n    designCache = require('./design/design_cache');\n    ComponentTree = require('./component_tree/component_tree');\n    Dependencies = require('./rendering/dependencies');\n    FieldExtractor = require('./component_tree/field_extractor');\n    MetadataConfig = require('./configuration/metadata_config');\n\n    module.exports = Livingdoc = function (_super) {\n      __extends(Livingdoc, _super);\n\n      Livingdoc.create = function (_arg) {\n        var componentTree, data, design, designName, designVersion, layoutName, _ref, _ref1;\n\n        data = _arg.data, designName = _arg.designName, designVersion = _arg.designVersion, layoutName = _arg.layoutName, componentTree = _arg.componentTree;\n        componentTree = data != null ? (designName = (_ref = data.design) != null ? _ref.name : void 0, designVersion = (_ref1 = data.design) != null ? _ref1.version : void 0, assert(designName != null, 'Error creating livingdoc: No design name is specified.'), assert(designVersion != null, 'Error creating livingdoc: No design version is specified.'), design = designCache.get(designName, designVersion), new ComponentTree({\n          content: data,\n          design: design\n        })) : designName != null && designVersion != null ? (design = designCache.get(designName, designVersion), new ComponentTree({\n          design: design\n        })) : componentTree != null ? componentTree : assert(false, 'Insufficient parameters to livingdoc#create. Pass either data, design name and version or component tree');\n\n        if (data != null ? data.layout : void 0) {\n          layoutName = data.layout;\n        }\n\n        return new Livingdoc({\n          componentTree: componentTree,\n          layoutName: layoutName\n        });\n      };\n\n      function Livingdoc(_arg) {\n        this.componentTree = _arg.componentTree, this.layoutName = _arg.layoutName;\n        this.model = this.componentTree;\n        this.interactiveView = void 0;\n        this.readOnlyViews = [];\n        this.design = this.componentTree.design;\n        this.dependencies = new Dependencies({\n          componentTree: this.componentTree\n        });\n        this.metadataConfig = new MetadataConfig(this.design.metadata);\n        this.fieldExtractor = new FieldExtractor(this.componentTree, this.metadataConfig);\n        this.forwardComponentTreeEvents();\n      }\n\n      Livingdoc.prototype.getDropTarget = function (_arg) {\n        var clientX, clientY, coords, document, elem, event, target;\n        event = _arg.event;\n        document = event.target.ownerDocument;\n        clientX = event.clientX, clientY = event.clientY;\n        elem = document.elementFromPoint(clientX, clientY);\n\n        if (elem != null) {\n          coords = {\n            left: event.pageX,\n            top: event.pageY\n          };\n          return target = dom.dropTarget(elem, coords);\n        }\n      };\n\n      Livingdoc.prototype.forwardComponentTreeEvents = function () {\n        return this.componentTree.changed.add(function (_this) {\n          return function () {\n            return _this.emit('change', arguments);\n          };\n        }(this));\n      };\n\n      Livingdoc.prototype.createView = function (_arg) {\n        var $host, host, iframe, interactive, layoutName, loadResources, view, viewWrapper, wrapper;\n        host = _arg.host, interactive = _arg.interactive, loadResources = _arg.loadResources, wrapper = _arg.wrapper, layoutName = _arg.layoutName, iframe = _arg.iframe;\n        $host = $(host);\n\n        if (iframe == null) {\n          iframe = true;\n        }\n\n        $host.html('');\n        viewWrapper = this.getWrapper({\n          wrapper: wrapper,\n          layoutName: layoutName\n        });\n        view = new View({\n          livingdoc: this,\n          parent: $host,\n          isInteractive: interactive,\n          loadResources: loadResources,\n          wrapper: viewWrapper\n        });\n        this.addView(view);\n        return view.create({\n          renderInIframe: iframe\n        });\n      };\n\n      Livingdoc.prototype.appendTo = function (options) {\n        if (options == null) {\n          options = {};\n        }\n\n        options.iframe = false;\n        return this.createView(options);\n      };\n\n      Livingdoc.prototype.createComponent = function () {\n        return this.componentTree.createComponent.apply(this.componentTree, arguments);\n      };\n\n      Livingdoc.prototype.getWrapper = function (_arg) {\n        var layoutName, wrapper, _ref;\n\n        wrapper = _arg.wrapper, layoutName = _arg.layoutName;\n\n        if (wrapper != null) {\n          return wrapper;\n        } else {\n          if (layoutName == null) {\n            layoutName = this.layoutName;\n          }\n\n          return (_ref = this.design.getLayout(layoutName)) != null ? _ref.wrapper : void 0;\n        }\n      };\n\n      Livingdoc.prototype.addView = function (view) {\n        if (view.isInteractive) {\n          assert(this.interactiveView == null, 'Error creating interactive view: A Livingdoc can have only one interactive view');\n          this.interactiveView = view;\n          return view.whenReady.then(function (_this) {\n            return function (_arg) {\n              var iframe, renderer;\n              iframe = _arg.iframe, renderer = _arg.renderer;\n              return _this.componentTree.setMainView(view);\n            };\n          }(this));\n        } else {\n          return this.readOnlyViews.push(view);\n        }\n      };\n\n      Livingdoc.prototype.addJsDependency = function (obj) {\n        return this.dependencies.addJs(obj);\n      };\n\n      Livingdoc.prototype.addCssDependency = function (obj) {\n        return this.dependencies.addCss(obj);\n      };\n\n      Livingdoc.prototype.hasDependencies = function () {\n        var _ref, _ref1;\n\n        return ((_ref = this.dependencies) != null ? _ref.hasJs() : void 0) || ((_ref1 = this.dependencies) != null ? _ref1.hasCss() : void 0);\n      };\n\n      Livingdoc.prototype.toHtml = function (_arg) {\n        var excludeComponents;\n        excludeComponents = (_arg != null ? _arg : {}).excludeComponents;\n        return new Renderer({\n          componentTree: this.componentTree,\n          renderingContainer: new RenderingContainer(),\n          excludeComponents: excludeComponents\n        }).html();\n      };\n\n      Livingdoc.prototype.serialize = function () {\n        var serialized;\n        serialized = this.componentTree.serialize();\n        serialized['layout'] = this.layoutName;\n        return serialized;\n      };\n\n      Livingdoc.prototype.toJson = function (prettify) {\n        var data, indentation, replacer;\n        data = this.serialize();\n\n        if (prettify != null) {\n          replacer = null;\n          indentation = 2;\n          return JSON.stringify(data, replacer, indentation);\n        } else {\n          return JSON.stringify(data);\n        }\n      };\n\n      Livingdoc.prototype.printModel = function () {\n        return this.componentTree.print();\n      };\n\n      Livingdoc.dom = dom;\n      return Livingdoc;\n    }(EventEmitter);\n  }, {\n    \"./component_tree/component_tree\": 19,\n    \"./component_tree/field_extractor\": 21,\n    \"./configuration/config\": 26,\n    \"./configuration/metadata_config\": 27,\n    \"./design/design_cache\": 30,\n    \"./interaction/dom\": 41,\n    \"./modules/logging/assert\": 50,\n    \"./rendering/dependencies\": 57,\n    \"./rendering/renderer\": 60,\n    \"./rendering/view\": 61,\n    \"./rendering_container/interactive_page\": 65,\n    \"./rendering_container/page\": 67,\n    \"./rendering_container/rendering_container\": 68,\n    \"wolfy87-eventemitter\": 11\n  }],\n  46: [function (require, module, exports) {\n    var __slice = [].slice;\n\n    module.exports = function () {\n      return {\n        callOnce: function callOnce(callbacks, listener) {\n          var _selfRemovingFunc;\n\n          _selfRemovingFunc = function selfRemovingFunc() {\n            var args;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            callbacks.remove(_selfRemovingFunc);\n            return listener.apply(this, args);\n          };\n\n          callbacks.add(_selfRemovingFunc);\n          return _selfRemovingFunc;\n        }\n      };\n    }();\n  }, {}],\n  47: [function (require, module, exports) {\n    var $;\n    $ = require('jquery');\n\n    module.exports = function () {\n      return {\n        htmlPointerEvents: function htmlPointerEvents() {\n          var element;\n          element = $('<x>')[0];\n          element.style.cssText = 'pointer-events:auto';\n          return element.style.pointerEvents === 'auto';\n        }\n      };\n    }();\n  }, {\n    \"jquery\": \"jquery\"\n  }],\n  48: [function (require, module, exports) {\n    var detects, executedTests;\n    detects = require('./feature_detects');\n    executedTests = {};\n\n    module.exports = function (name) {\n      var result;\n\n      if ((result = executedTests[name]) === void 0) {\n        return executedTests[name] = Boolean(detects[name]());\n      } else {\n        return result;\n      }\n    };\n  }, {\n    \"./feature_detects\": 47\n  }],\n  49: [function (require, module, exports) {\n    module.exports = function () {\n      var idCounter, lastId;\n      idCounter = lastId = void 0;\n      return {\n        next: function next(user) {\n          var nextId;\n\n          if (user == null) {\n            user = 'doc';\n          }\n\n          nextId = Date.now().toString(32);\n\n          if (lastId === nextId) {\n            idCounter += 1;\n          } else {\n            idCounter = 0;\n            lastId = nextId;\n          }\n\n          return \"\" + user + \"-\" + nextId + idCounter;\n        }\n      };\n    }();\n  }, {}],\n  50: [function (require, module, exports) {\n    var assert, log;\n    log = require('./log');\n\n    module.exports = assert = function assert(condition, message) {\n      if (!condition) {\n        return log.error(message);\n      }\n    };\n  }, {\n    \"./log\": 51\n  }],\n  51: [function (require, module, exports) {\n    var log,\n        __slice = [].slice,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    module.exports = log = function log() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n\n      if (window.console != null) {\n        if (args.length && args[args.length - 1] === 'trace') {\n          args.pop();\n\n          if (window.console.trace != null) {\n            window.console.trace();\n          }\n        }\n\n        window.console.log.apply(window.console, args);\n        return void 0;\n      }\n    };\n\n    (function () {\n      var LivingdocsError, notify;\n\n      LivingdocsError = function (_super) {\n        __extends(LivingdocsError, _super);\n\n        function LivingdocsError(message) {\n          LivingdocsError.__super__.constructor.apply(this, arguments);\n\n          this.message = message;\n          this.thrownByLivingdocs = true;\n        }\n\n        return LivingdocsError;\n      }(Error);\n\n      notify = function notify(message, level) {\n        if (level == null) {\n          level = 'error';\n        }\n\n        if (typeof _rollbar !== \"undefined\" && _rollbar !== null) {\n          _rollbar.push(new Error(message), function () {\n            var _ref;\n\n            if ((level === 'critical' || level === 'error') && ((_ref = window.console) != null ? _ref.error : void 0) != null) {\n              return window.console.error.call(window.console, message);\n            } else {\n              return log.call(void 0, message);\n            }\n          });\n        } else {\n          if (level === 'critical' || level === 'error') {\n            throw new LivingdocsError(message);\n          } else {\n            log.call(void 0, message);\n          }\n        }\n\n        return void 0;\n      };\n\n      log.debug = function (message) {\n        if (!log.debugDisabled) {\n          return notify(message, 'debug');\n        }\n      };\n\n      log.warn = function (message) {\n        if (!log.warningsDisabled) {\n          return notify(message, 'warning');\n        }\n      };\n\n      return log.error = function (message) {\n        return notify(message, 'error');\n      };\n    })();\n  }, {}],\n  52: [function (require, module, exports) {\n    var OrderedHash;\n\n    module.exports = OrderedHash = function () {\n      function OrderedHash() {\n        this.obj = {};\n        this.length = 0;\n      }\n\n      OrderedHash.prototype.push = function (key, value) {\n        this.obj[key] = value;\n        this[this.length] = value;\n        return this.length += 1;\n      };\n\n      OrderedHash.prototype.get = function (key) {\n        return this.obj[key];\n      };\n\n      OrderedHash.prototype.each = function (callback) {\n        var value, _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = this.length; _i < _len; _i++) {\n          value = this[_i];\n\n          _results.push(callback(value));\n        }\n\n        return _results;\n      };\n\n      OrderedHash.prototype.toArray = function () {\n        var value, _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = this.length; _i < _len; _i++) {\n          value = this[_i];\n\n          _results.push(value);\n        }\n\n        return _results;\n      };\n\n      return OrderedHash;\n    }();\n  }, {}],\n  53: [function (require, module, exports) {\n    var Semaphore, assert;\n    assert = require('../modules/logging/assert');\n\n    module.exports = Semaphore = function () {\n      function Semaphore() {\n        this.count = 0;\n        this.started = false;\n        this.wasFired = false;\n        this.callbacks = [];\n      }\n\n      Semaphore.prototype.addCallback = function (callback) {\n        if (this.wasFired) {\n          return callback();\n        } else {\n          return this.callbacks.push(callback);\n        }\n      };\n\n      Semaphore.prototype.isReady = function () {\n        return this.wasFired;\n      };\n\n      Semaphore.prototype.start = function () {\n        assert(!this.started, \"Unable to start Semaphore once started.\");\n        this.started = true;\n        return this.fireIfReady();\n      };\n\n      Semaphore.prototype.increment = function (num) {\n        if (num == null) {\n          num = 1;\n        }\n\n        assert(!this.wasFired, \"Unable to increment count once Semaphore is fired.\");\n        return this.count += num;\n      };\n\n      Semaphore.prototype.decrement = function (num) {\n        if (num == null) {\n          num = 1;\n        }\n\n        assert(this.count > 0, \"Unable to decrement count resulting in negative count.\");\n        this.count -= num;\n        return this.fireIfReady();\n      };\n\n      Semaphore.prototype.wait = function (num) {\n        this.increment(num);\n        return function (_this) {\n          return function () {\n            return _this.decrement(num);\n          };\n        }(this);\n      };\n\n      Semaphore.prototype.fireIfReady = function () {\n        var callback, _i, _len, _ref, _results;\n\n        if (this.count === 0 && this.started === true) {\n          this.wasFired = true;\n          _ref = this.callbacks;\n          _results = [];\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            callback = _ref[_i];\n\n            _results.push(callback());\n          }\n\n          return _results;\n        }\n      };\n\n      return Semaphore;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50\n  }],\n  54: [function (require, module, exports) {\n    module.exports = function () {\n      return {\n        isEmpty: function isEmpty(obj) {\n          var name;\n\n          if (obj == null) {\n            return true;\n          }\n\n          for (name in obj) {\n            if (obj.hasOwnProperty(name)) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        flatCopy: function flatCopy(obj) {\n          var copy, name, value;\n          copy = void 0;\n\n          for (name in obj) {\n            value = obj[name];\n            copy || (copy = {});\n            copy[name] = value;\n          }\n\n          return copy;\n        }\n      };\n    }();\n  }, {}],\n  55: [function (require, module, exports) {\n    var $;\n    $ = require('jquery');\n\n    module.exports = function () {\n      return {\n        humanize: function humanize(str) {\n          var uncamelized;\n          uncamelized = $.trim(str).replace(/([a-z\\d])([A-Z]+)/g, '$1 $2').toLowerCase();\n          return this.titleize(uncamelized);\n        },\n        capitalize: function capitalize(str) {\n          str = str == null ? '' : String(str);\n          return str.charAt(0).toUpperCase() + str.slice(1);\n        },\n        titleize: function titleize(str) {\n          if (str == null) {\n            return '';\n          } else {\n            return String(str).replace(/(?:^|\\s)\\S/g, function (c) {\n              return c.toUpperCase();\n            });\n          }\n        },\n        snakeCase: function snakeCase(str) {\n          return $.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase();\n        },\n        prefix: function prefix(_prefix, string) {\n          if (string.indexOf(_prefix) === 0) {\n            return string;\n          } else {\n            return \"\" + _prefix + string;\n          }\n        },\n        readableJson: function readableJson(obj) {\n          return JSON.stringify(obj, null, 2);\n        },\n        camelize: function camelize(str) {\n          return $.trim(str).replace(/[-_\\s]+(.)?/g, function (match, c) {\n            return c.toUpperCase();\n          });\n        },\n        trim: function trim(str) {\n          return str.replace(/^\\s+|\\s+$/g, '');\n        },\n        extractTextFromHtml: function extractTextFromHtml(str) {\n          var div;\n          div = $('<div>')[0];\n          div.innerHTML = str;\n          return div.textContent;\n        }\n      };\n    }();\n  }, {\n    \"jquery\": \"jquery\"\n  }],\n  56: [function (require, module, exports) {\n    var $, ComponentView, DirectiveIterator, attr, config, css, dom, eventing;\n    $ = require('jquery');\n    config = require('../configuration/config');\n    css = config.css;\n    attr = config.attr;\n    DirectiveIterator = require('../template/directive_iterator');\n    eventing = require('../modules/eventing');\n    dom = require('../interaction/dom');\n\n    module.exports = ComponentView = function () {\n      function ComponentView(_arg) {\n        this.model = _arg.model, this.$html = _arg.$html, this.directives = _arg.directives, this.isReadOnly = _arg.isReadOnly;\n        this.renderer = void 0;\n        this.$elem = this.$html;\n        this.template = this.model.template;\n        this.isAttachedToDom = false;\n        this.wasAttachedToDom = $.Callbacks();\n        this.decorateMarkup();\n        this.render();\n      }\n\n      ComponentView.prototype.decorateMarkup = function () {\n        if (!this.isReadOnly) {\n          return this.$html.data('componentView', this).addClass(css.component).attr(attr.template, this.template.identifier);\n        }\n      };\n\n      ComponentView.prototype.setRenderer = function (renderer) {\n        return this.renderer = renderer;\n      };\n\n      ComponentView.prototype.removeRenderer = function () {\n        return this.renderer = void 0;\n      };\n\n      ComponentView.prototype.viewForModel = function (model) {\n        var _ref;\n\n        if (model != null) {\n          return (_ref = this.renderer) != null ? _ref.getComponentViewById(model.id) : void 0;\n        }\n      };\n\n      ComponentView.prototype.recreateHtml = function () {\n        var _ref;\n\n        this.isAttachedToDom = false;\n        _ref = this.model.template.createViewHtml(this.model), this.$elem = _ref.$elem, this.directives = _ref.directives;\n        this.$html = this.$elem;\n        this.decorateMarkup();\n        return this.render();\n      };\n\n      ComponentView.prototype.refresh = function () {\n        return this.renderer.refreshComponent(this.model);\n      };\n\n      ComponentView.prototype.render = function (mode) {\n        this.updateContent();\n        return this.updateHtml();\n      };\n\n      ComponentView.prototype.updateContent = function (directiveName) {\n        var dataAttrs, name, _ref, $elem, elementStyles;\n\n        if (directiveName) {\n          this.set(directiveName, this.model.content[directiveName]);\n        } else {\n          this.setAll();\n        }\n\n        if (!this.hasFocus()) {\n          this.displayOptionals();\n        }\n\n        _ref = this;\n\n        var updateDirectiveElem = function updateDirectiveElem(name, attributes) {\n          if (attributes && attributes[name]) {\n            $elem = _ref.directives.$getElem(name);\n\n            for (var attr in attributes[name]) {\n              $elem.attr(attr, attributes[name][attr]);\n            }\n          }\n        };\n\n        dataAttrs = this.model.getData('data_attributes');\n\n        if (directiveName) {\n          updateDirectiveElem(directiveName, dataAttrs);\n        } else {// for (var i = 0; i < this.directives.length; i++) {\n          //     updateDirectiveElem(this.directives[i].name, dataAttrs);\n          // }\n        }\n\n        elementStyles = this.model.getData('element_styles');\n\n        if (elementStyles) {\n          if (directiveName) {// updateElem(directiveName, {[directiveName]: {\"style\": styleString}});\n          } else {\n            for (var _name2 in elementStyles) {\n              this.$html.css(_name2, elementStyles[_name2]);\n            }\n          }\n        }\n\n        return this.stripHtmlIfReadOnly();\n      };\n\n      ComponentView.prototype.updateHtml = function () {\n        var name, value, _ref;\n\n        _ref = this.model.styles;\n\n        for (name in _ref) {\n          value = _ref[name];\n          this.setStyle(name, value);\n        }\n\n        return this.stripHtmlIfReadOnly();\n      };\n\n      ComponentView.prototype.displayOptionals = function () {\n        return this.directives.each(function (_this) {\n          return function (directive) {\n            var $elem;\n\n            if (directive.optional) {\n              $elem = $(directive.elem);\n\n              if (_this.model.isEmpty(directive.name)) {\n                return $elem.css('display', 'none');\n              } else {\n                return $elem.css('display', '');\n              }\n            }\n          };\n        }(this));\n      };\n\n      ComponentView.prototype.showOptionals = function () {\n        return this.directives.each(function (_this) {\n          return function (directive) {\n            if (directive.optional) {\n              return config.animations.optionals.show($(directive.elem));\n            }\n          };\n        }(this));\n      };\n\n      ComponentView.prototype.hideEmptyOptionals = function () {\n        return this.directives.each(function (_this) {\n          return function (directive) {\n            if (directive.optional && _this.model.isEmpty(directive.name)) {\n              return config.animations.optionals.hide($(directive.elem));\n            }\n          };\n        }(this));\n      };\n\n      ComponentView.prototype.afterFocused = function () {\n        this.$html.addClass(css.componentHighlight);\n        return this.showOptionals();\n      };\n\n      ComponentView.prototype.afterBlurred = function () {\n        this.$html.removeClass(css.componentHighlight);\n        return this.hideEmptyOptionals();\n      };\n\n      ComponentView.prototype.focus = function (editableName) {\n        var directive, _ref;\n\n        directive = editableName ? this.directives.get(editableName) : (_ref = this.directives.editable) != null ? _ref[0] : void 0;\n\n        if (directive) {\n          return $(directive != null ? directive.elem : void 0).focus();\n        } // note(Marcus) 2019-10-04\n        // check for wysiwyg and focus on that instead\n\n\n        _ref = this.directives.wysiwyg != null ? this.directives.wysiwyg[0] : void 0;\n\n        if (_ref) {\n          $(_ref.elem).focus();\n        }\n      };\n\n      ComponentView.prototype.hasFocus = function () {\n        return this.$html.hasClass(css.componentHighlight);\n      };\n\n      ComponentView.prototype.getBoundingClientRect = function () {\n        return this.$html[0].getBoundingClientRect();\n      };\n\n      ComponentView.prototype.getAbsoluteBoundingClientRect = function () {\n        return dom.getAbsoluteBoundingClientRect(this.$html[0]);\n      };\n\n      ComponentView.prototype.setAll = function () {\n        var name, value, _ref;\n\n        _ref = this.model.content;\n\n        for (name in _ref) {\n          value = _ref[name];\n          this.set(name, value);\n        }\n\n        return void 0;\n      };\n\n      ComponentView.prototype.set = function (name, value) {\n        var directive, attributes, $elem, result;\n        directive = this.model.directives.get(name);\n\n        switch (directive.type) {\n          case 'editable':\n            return this.setEditable(name, value);\n\n          case 'image':\n            if (directive.base64Image != null) {\n              return this.setImage(name, directive.base64Image);\n            } else {\n              return this.setImage(name, directive.getImageUrl());\n            }\n\n            break;\n\n          case 'embeditem':\n            return this.setEmbedItem(name, value);\n\n          case 'wysiwyg':\n            return this.setWysiwyg(name, value);\n\n          case 'html':\n            return this.setHtml(name, value);\n\n          case 'link':\n            return this.setLink(name, value);\n        }\n      };\n\n      ComponentView.prototype.get = function (name) {\n        var directive;\n        directive = this.directives.get(name);\n\n        switch (directive.type) {\n          case 'editable':\n            return this.getEditable(name);\n\n          case 'image':\n            return this.getImage(name);\n\n          case 'html':\n            return this.getHtml(name);\n\n          case 'link':\n            return this.getLink(name);\n        }\n      };\n\n      ComponentView.prototype.getEditable = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.html();\n      };\n\n      ComponentView.prototype.setEditable = function (name, value) {\n        var $elem, element, elementHasFocus, ownerDocument;\n        $elem = this.directives.$getElem(name);\n        element = $elem[0];\n        ownerDocument = element.ownerDocument;\n        elementHasFocus = ownerDocument.activeElement === element;\n\n        if (elementHasFocus) {\n          return;\n        }\n\n        $elem.toggleClass(css.noPlaceholder, Boolean(value));\n        $elem.attr(attr.placeholder, this.template.defaults[name]);\n        return $elem.html(value || '');\n      };\n\n      ComponentView.prototype.focusEditable = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.addClass(css.noPlaceholder);\n      };\n\n      ComponentView.prototype.blurEditable = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n\n        if (this.model.isEmpty(name)) {\n          return $elem.removeClass(css.noPlaceholder);\n        }\n      };\n\n      ComponentView.prototype.getHtml = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.html();\n      };\n\n      ComponentView.prototype.setHtml = function (name, value) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        $elem.html(value || '');\n\n        if (!value) {\n          $elem.html(this.template.defaults[name]);\n        } else if (value && !this.isReadOnly) {\n          this.blockInteraction($elem);\n        }\n\n        this.directivesToReset || (this.directivesToReset = {});\n        return this.directivesToReset[name] = name;\n      };\n\n      ComponentView.prototype.getWysiwyg = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.html();\n      };\n\n      ComponentView.prototype.setWysiwyg = function (name, value) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        $elem.html(value || '');\n        $elem.removeClass(css.emptyContent);\n\n        if (!value) {\n          $elem.html(this.template.defaults[name]);\n          $elem.addClass(css.emptyContent);\n        } else if (value && !this.isReadOnly) {\n          this.blockInteraction($elem);\n        }\n\n        this.directivesToReset || (this.directivesToReset = {});\n        return this.directivesToReset[name] = name;\n      };\n\n      ComponentView.prototype.setEmbedItem = function (name, value) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        value = value || {\n          source: '',\n          attrs: '',\n          content: null\n        };\n\n        if (!value.content) {\n          value.content = this.template.defaults[name];\n        }\n\n        $elem.attr('data-embed-source-' + name, value.source);\n        $elem.attr('data-embed-attrs-' + name, value.attrs);\n        $elem.html(value.content);\n        this.directivesToReset || (this.directivesToReset = {});\n        return this.directivesToReset[name] = name;\n      };\n\n      ComponentView.prototype.getEmbedItem = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.attr('data-embed-source-' + name);\n      };\n\n      ComponentView.prototype.setLink = function (name, value) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n\n        if (value) {\n          return $elem.attr('href', value);\n        } else {\n          return $elem.removeAttr('href');\n        }\n      };\n\n      ComponentView.prototype.getLink = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.attr('href');\n      };\n\n      ComponentView.prototype.getDirectiveElement = function (directiveName) {\n        var _ref;\n\n        return (_ref = this.directives.get(directiveName)) != null ? _ref.elem : void 0;\n      };\n\n      ComponentView.prototype.resetDirectives = function () {\n        var $elem, name, _results;\n\n        _results = [];\n\n        for (name in this.directivesToReset) {\n          $elem = this.directives.$getElem(name);\n\n          if ($elem.find('iframe').length) {\n            _results.push(this.set(name, this.model.content[name]));\n          } else {\n            _results.push(void 0);\n          }\n        }\n\n        return _results;\n      };\n\n      ComponentView.prototype.getImage = function (name) {\n        var $elem;\n        $elem = this.directives.$getElem(name);\n        return $elem.attr('src');\n      };\n\n      ComponentView.prototype.setImage = function (name, value) {\n        var $elem, imageService, setPlaceholder;\n        $elem = this.directives.$getElem(name);\n\n        if (value) {\n          this.cancelDelayed(name);\n          imageService = this.model.directives.get(name).getImageService();\n          imageService.set($elem, value);\n          return $elem.removeClass(config.css.emptyImage);\n        } else {\n          setPlaceholder = $.proxy(this.setPlaceholderImage, this, $elem, name);\n          return this.delayUntilAttached(name, setPlaceholder);\n        }\n      };\n\n      ComponentView.prototype.setPlaceholderImage = function ($elem, name) {\n        var imageService;\n        $elem.addClass(config.css.emptyImage);\n        imageService = this.model.directives.get(name).getImageService(); // NOTE(Marcus) 2019-10-21 - only set placeholders for image components\n        // _not_ backgrounds.\n\n        if (imageService.isBackgroundImage($elem)) {\n          return;\n        }\n\n        return imageService.set($elem, config.imagePlaceholder);\n      };\n\n      ComponentView.prototype.setStyle = function (name, className) {\n        var changes, removeClass, _i, _len, _ref;\n\n        changes = this.template.styles[name].cssClassChanges(className, this.$html.attr('class'));\n\n        if (changes.remove) {\n          _ref = changes.remove;\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            removeClass = _ref[_i];\n            this.$html.removeClass(removeClass);\n          }\n        }\n\n        return this.$html.addClass(changes.add);\n      };\n\n      ComponentView.prototype.disableTabbing = function ($elem) {\n        return setTimeout(function (_this) {\n          return function () {\n            return $elem.find('iframe').attr('tabindex', '-1');\n          };\n        }(this), 400);\n      };\n\n      ComponentView.prototype.blockInteraction = function ($elem) {\n        var $blocker;\n        this.ensureRelativePosition($elem);\n        $blocker = $(\"<div class='\" + css.interactionBlocker + \"'>\").attr('style', 'position: absolute; top: 0; bottom: 0; left: 0; right: 0;');\n        $elem.append($blocker);\n        return this.disableTabbing($elem);\n      };\n\n      ComponentView.prototype.ensureRelativePosition = function ($elem) {\n        var position;\n        position = $elem.css('position');\n\n        if (position !== 'absolute' && position !== 'fixed' && position !== 'relative') {\n          return $elem.css('position', 'relative');\n        }\n      };\n\n      ComponentView.prototype.get$container = function () {\n        return $(dom.findContainer(this.$html[0]).node);\n      };\n\n      ComponentView.prototype.delayUntilAttached = function (name, func) {\n        if (this.isAttachedToDom) {\n          return func();\n        } else {\n          this.cancelDelayed(name);\n          this.delayed || (this.delayed = {});\n          return this.delayed[name] = eventing.callOnce(this.wasAttachedToDom, function (_this) {\n            return function () {\n              _this.delayed[name] = void 0;\n              return func();\n            };\n          }(this));\n        }\n      };\n\n      ComponentView.prototype.cancelDelayed = function (name) {\n        var _ref;\n\n        if ((_ref = this.delayed) != null ? _ref[name] : void 0) {\n          this.wasAttachedToDom.remove(this.delayed[name]);\n          return this.delayed[name] = void 0;\n        }\n      };\n\n      ComponentView.prototype.stripHtmlIfReadOnly = function () {\n        var elem, iterator, _results;\n\n        if (!this.isReadOnly) {\n          return;\n        }\n\n        iterator = new DirectiveIterator(this.$html[0]);\n        _results = [];\n\n        while (elem = iterator.nextElement()) {\n          this.stripDocClasses(elem);\n          this.stripDocAttributes(elem);\n\n          _results.push(this.stripEmptyAttributes(elem));\n        }\n\n        return _results;\n      };\n\n      ComponentView.prototype.stripDocClasses = function (elem) {\n        var $elem, klass, _i, _len, _ref, _results;\n\n        $elem = $(elem);\n        _ref = elem.className.split(/\\s+/);\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          klass = _ref[_i];\n\n          if (/doc\\-.*/i.test(klass)) {\n            _results.push($elem.removeClass(klass));\n          } else {\n            _results.push(void 0);\n          }\n        }\n\n        return _results;\n      };\n\n      ComponentView.prototype.stripDocAttributes = function (elem) {\n        var $elem, attribute, name, _i, _len, _ref, _results;\n\n        $elem = $(elem);\n        _ref = Array.prototype.slice.apply(elem.attributes);\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          attribute = _ref[_i];\n          name = attribute.name;\n\n          if (/data\\-doc\\-.*/i.test(name)) {\n            _results.push($elem.removeAttr(name));\n          } else {\n            _results.push(void 0);\n          }\n        }\n\n        return _results;\n      };\n\n      ComponentView.prototype.stripEmptyAttributes = function (elem) {\n        var $elem, attribute, isEmptyAttribute, isStrippableAttribute, strippableAttributes, _i, _len, _ref, _results;\n\n        $elem = $(elem);\n        strippableAttributes = ['style', 'class'];\n        _ref = Array.prototype.slice.apply(elem.attributes);\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          attribute = _ref[_i];\n          isStrippableAttribute = strippableAttributes.indexOf(attribute.name) >= 0;\n          isEmptyAttribute = attribute.value.trim() === '';\n\n          if (isStrippableAttribute && isEmptyAttribute) {\n            _results.push($elem.removeAttr(attribute.name));\n          } else {\n            _results.push(void 0);\n          }\n        }\n\n        return _results;\n      };\n\n      ComponentView.prototype.setAttachedToDom = function (newVal) {\n        if (newVal === this.isAttachedToDom) {\n          return;\n        }\n\n        this.isAttachedToDom = newVal;\n\n        if (newVal) {\n          this.resetDirectives();\n          return this.wasAttachedToDom.fire();\n        }\n      };\n\n      ComponentView.prototype.getOwnerWindow = function () {\n        return this.$elem[0].ownerDocument.defaultView;\n      };\n\n      ComponentView.prototype.next = function () {\n        return this.viewForModel(this.model.next);\n      };\n\n      ComponentView.prototype.prev = function () {\n        return this.previous();\n      };\n\n      ComponentView.prototype.previous = function () {\n        return this.viewForModel(this.model.previous);\n      };\n\n      ComponentView.prototype.parent = function () {\n        return this.viewForModel(this.model.getParent());\n      };\n\n      return ComponentView;\n    }();\n\n    ['parents', 'children', 'childrenAndSelf', 'descendants', 'descendantsAndSelf'].forEach(function (method) {\n      return ComponentView.prototype[method] = function (callback) {\n        return this.model[method](function (_this) {\n          return function (model) {\n            return callback(_this.viewForModel(model));\n          };\n        }(this));\n      };\n    });\n  }, {\n    \"../configuration/config\": 26,\n    \"../interaction/dom\": 41,\n    \"../modules/eventing\": 46,\n    \"../template/directive_iterator\": 73,\n    \"jquery\": \"jquery\"\n  }],\n  57: [function (require, module, exports) {\n    var $,\n        Dependencies,\n        Dependency,\n        assert,\n        dependenciesToHtml,\n        log,\n        __bind = function __bind(fn, me) {\n      return function () {\n        return fn.apply(me, arguments);\n      };\n    };\n\n    $ = require('jquery');\n    log = require('../modules/logging/log');\n    assert = require('../modules/logging/assert');\n    Dependency = require('./dependency');\n    dependenciesToHtml = require('./dependencies_to_html');\n\n    module.exports = Dependencies = function () {\n      function Dependencies(_arg) {\n        this.componentTree = (_arg != null ? _arg : {}).componentTree;\n        this.onComponentRemoved = __bind(this.onComponentRemoved, this);\n        this.js = [];\n        this.css = [];\n        this.namespaces = {};\n        this.jsWaitlist = [];\n        this.dependenciesAdded = $.Callbacks();\n        this.dependencyToExecute = $.Callbacks();\n        this.codeToExecute = $.Callbacks();\n        this.dependencyRemoved = $.Callbacks();\n\n        if (this.componentTree != null) {\n          this.componentTree.componentRemoved.add(this.onComponentRemoved);\n        }\n      }\n\n      Dependencies.prototype.add = function (obj) {\n        var dep, existing;\n        this.convertToAbsolutePaths(obj);\n        dep = new Dependency(obj);\n\n        if (existing = this.getExisting(dep)) {\n          if (obj.component != null) {\n            return existing.addComponent(obj.component);\n          }\n        } else {\n          return this.addDependency(dep);\n        }\n      };\n\n      Dependencies.prototype.addJs = function (obj) {\n        obj.type = 'js';\n        return this.add(obj);\n      };\n\n      Dependencies.prototype.addCss = function (obj) {\n        obj.type = 'css';\n        return this.add(obj);\n      };\n\n      Dependencies.prototype.executeJs = function (obj) {\n        obj.isExecuteOnly = true;\n        return this.addJs(obj);\n      };\n\n      Dependencies.prototype.executeCode = function (callback) {\n        return this.codeToExecute.fire(callback);\n      };\n\n      Dependencies.prototype.convertToAbsolutePaths = function (obj) {\n        var src;\n\n        if (!obj.src) {\n          return;\n        }\n\n        src = obj.src;\n\n        if (!this.isAbsoluteUrl(src)) {\n          assert(obj.basePath, \"Dependencies: relative urls are not allowed: \" + src);\n          src = src.replace(/^[\\.\\/]*/, '');\n          return obj.src = \"\" + obj.basePath.replace(/\\/$/, '') + \"/\" + src;\n        }\n      };\n\n      Dependencies.prototype.isAbsoluteUrl = function (src) {\n        return /(^\\/\\/|[a-z]*:\\/\\/)/.test(src) || /^\\//.test(src);\n      };\n\n      Dependencies.prototype.addDependency = function (dependency) {\n        if (!dependency.isExecuteOnly) {\n          if (dependency.namespace) {\n            this.addToNamespace(dependency);\n          }\n\n          if (dependency.isJs()) {\n            this.js.push(dependency);\n            this.delayedDependency(dependency);\n          } else {\n            this.css.push(dependency);\n            this.dependenciesAdded.fire(void 0, [dependency]);\n          }\n        } else {\n          this.dependencyToExecute.fire(dependency);\n        }\n\n        return dependency;\n      };\n\n      Dependencies.prototype.delayedDependency = function (dependency) {\n        this.jsWaitlist.push(dependency);\n\n        if (this.jsWaitlist.length === 1) {\n          return setTimeout(function (_this) {\n            return function () {\n              _this.dependenciesAdded.fire(_this.jsWaitlist, void 0);\n\n              return _this.jsWaitlist = [];\n            };\n          }(this), 0);\n        }\n      };\n\n      Dependencies.prototype.addToNamespace = function (dependency) {\n        var namespace, _base, _name;\n\n        if (dependency.namespace) {\n          if ((_base = this.namespaces)[_name = dependency.namespace] == null) {\n            _base[_name] = [];\n          }\n\n          namespace = this.namespaces[dependency.namespace];\n          return namespace.push(dependency);\n        }\n      };\n\n      Dependencies.prototype.removeFromNamespace = function (dependency) {\n        var index, namespace;\n\n        if (namespace = this.getNamespace(dependency.namespace)) {\n          index = namespace.indexOf(dependency);\n\n          if (index > -1) {\n            return namespace.splice(index, 1);\n          }\n        }\n      };\n\n      Dependencies.prototype.getNamespaces = function () {\n        var array, name, _ref, _results;\n\n        _ref = this.namespaces;\n        _results = [];\n\n        for (name in _ref) {\n          array = _ref[name];\n\n          _results.push(name);\n        }\n\n        return _results;\n      };\n\n      Dependencies.prototype.getNamespace = function (name) {\n        var namespace;\n        namespace = this.namespaces[name];\n\n        if (namespace != null ? namespace.length : void 0) {\n          return namespace;\n        } else {\n          return void 0;\n        }\n      };\n\n      Dependencies.prototype.getExisting = function (dep) {\n        var collection, entry, _i, _len;\n\n        collection = dep.isJs() ? this.js : this.css;\n\n        for (_i = 0, _len = collection.length; _i < _len; _i++) {\n          entry = collection[_i];\n\n          if (entry.isSameAs(dep)) {\n            return entry;\n          }\n        }\n\n        return void 0;\n      };\n\n      Dependencies.prototype.hasCss = function () {\n        return this.css.length > 0;\n      };\n\n      Dependencies.prototype.hasJs = function () {\n        return this.js.length > 0;\n      };\n\n      Dependencies.prototype.onComponentRemoved = function (component) {\n        var dependency, needed, toBeRemoved, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;\n\n        toBeRemoved = [];\n        _ref = this.js;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          dependency = _ref[_i];\n          needed = dependency.removeComponent(component);\n\n          if (!needed) {\n            toBeRemoved.push(dependency);\n          }\n        }\n\n        _ref1 = this.css;\n\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          dependency = _ref1[_j];\n          needed = dependency.removeComponent(component);\n\n          if (!needed) {\n            toBeRemoved.push(dependency);\n          }\n        }\n\n        _results = [];\n\n        for (_k = 0, _len2 = toBeRemoved.length; _k < _len2; _k++) {\n          dependency = toBeRemoved[_k];\n\n          _results.push(this.removeDependency(dependency));\n        }\n\n        return _results;\n      };\n\n      Dependencies.prototype.removeDependency = function (dependency) {\n        var collection, index;\n\n        if (dependency.namespace) {\n          this.removeFromNamespace(dependency);\n        }\n\n        collection = dependency.isJs() ? this.js : this.css;\n        index = collection.indexOf(dependency);\n\n        if (index > -1) {\n          collection.splice(index, 1);\n        }\n\n        return this.dependencyRemoved.fire(dependency);\n      };\n\n      Dependencies.prototype.serialize = function () {\n        var data, dependency, _i, _j, _len, _len1, _ref, _ref1;\n\n        data = {};\n        _ref = this.js;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          dependency = _ref[_i];\n\n          if (data['js'] == null) {\n            data['js'] = [];\n          }\n\n          data['js'].push(dependency.serialize());\n        }\n\n        _ref1 = this.css;\n\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          dependency = _ref1[_j];\n\n          if (data['css'] == null) {\n            data['css'] = [];\n          }\n\n          data['css'].push(dependency.serialize());\n        }\n\n        return data;\n      };\n\n      Dependencies.prototype.deserialize = function (data) {\n        var entry, obj, _i, _j, _len, _len1, _ref, _ref1, _results;\n\n        if (data == null) {\n          return;\n        }\n\n        _ref = data.js || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          entry = _ref[_i];\n          obj = {\n            type: 'js',\n            src: entry.src,\n            code: entry.code,\n            namespace: entry.namespace,\n            library: entry.library\n          };\n          this.addDeserialzedObj(obj, entry);\n        }\n\n        _ref1 = data.css || [];\n        _results = [];\n\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          entry = _ref1[_j];\n          obj = {\n            type: 'css',\n            src: entry.src,\n            code: entry.code,\n            namespace: entry.namespace,\n            library: entry.library\n          };\n\n          _results.push(this.addDeserialzedObj(obj, entry));\n        }\n\n        return _results;\n      };\n\n      Dependencies.prototype.addDeserialzedObj = function (obj, entry) {\n        var component, components, dependency, id, _i, _j, _len, _len1, _ref, _ref1, _results;\n\n        if ((_ref = entry.componentIds) != null ? _ref.length : void 0) {\n          components = [];\n          _ref1 = entry.componentIds;\n\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n            id = _ref1[_i];\n            component = this.componentTree.findById(id);\n\n            if (component != null) {\n              components.push(component);\n            }\n          }\n\n          if (components.length) {\n            dependency = this.add(obj);\n            _results = [];\n\n            for (_j = 0, _len1 = components.length; _j < _len1; _j++) {\n              component = components[_j];\n\n              _results.push(dependency.addComponent(component));\n            }\n\n            return _results;\n          } else {\n            return log.warn('Dropped dependency: could not find components that depend on it', entry);\n          }\n        } else {\n          return this.add(obj);\n        }\n      };\n\n      Dependencies.prototype.printJs = function () {\n        return dependenciesToHtml.printJs(this);\n      };\n\n      Dependencies.prototype.printCss = function () {\n        return dependenciesToHtml.printCss(this);\n      };\n\n      return Dependencies;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"./dependencies_to_html\": 58,\n    \"./dependency\": 59,\n    \"jquery\": \"jquery\"\n  }],\n  58: [function (require, module, exports) {\n    var CssLoader, JsLoader;\n    JsLoader = require('../rendering_container/js_loader');\n    CssLoader = require('../rendering_container/css_loader');\n    module.exports = {\n      printJs: function printJs(dependencies) {\n        var dependency, html, _i, _len, _ref;\n\n        html = '';\n        _ref = dependencies.js;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          dependency = _ref[_i];\n\n          if (dependency.inline) {\n            html += this.printInlineScript({\n              codeBlock: dependency.code\n            });\n          } else {\n            html += this.printScriptTag({\n              src: dependency.src\n            });\n          }\n\n          html += '\\n';\n        }\n\n        return html;\n      },\n      printCss: function printCss(dependencies) {\n        var dependency, html, _i, _len, _ref;\n\n        html = '';\n        _ref = dependencies.css;\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          dependency = _ref[_i];\n\n          if (dependency.inline) {\n            html += this.printInlineCss({\n              styles: dependency.code\n            });\n          } else {\n            html += this.printCssLink({\n              src: dependency.src\n            });\n          }\n\n          html += '\\n';\n        }\n\n        return html;\n      },\n      printScriptTag: function printScriptTag(_arg) {\n        var src;\n        src = _arg.src;\n        return \"<script src=\\\"\" + src + \"\\\"></script>\";\n      },\n      printInlineScript: function printInlineScript(_arg) {\n        var codeBlock;\n        codeBlock = _arg.codeBlock;\n        codeBlock = JsLoader.prototype.prepareInlineCode(codeBlock);\n        return \"<script> \" + codeBlock + \" </script>\";\n      },\n      printCssLink: function printCssLink(_arg) {\n        var head, src;\n        src = _arg.src, head = _arg.head;\n\n        if (head == null) {\n          head = true;\n        }\n\n        if (head) {\n          return \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + src + \"\\\">\";\n        } else {\n          return \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\" + src + \"\\\">\";\n        }\n      },\n      printInlineCss: function printInlineCss(_arg) {\n        var styles;\n        styles = _arg.styles;\n        styles = CssLoader.prototype.prepareInlineStyles(styles);\n        return \"<style> \" + styles + \" </style>\";\n      },\n      printComment: function printComment(text) {\n        return \"<!-- \" + text + \" -->\";\n      }\n    };\n  }, {\n    \"../rendering_container/css_loader\": 63,\n    \"../rendering_container/js_loader\": 66\n  }],\n  59: [function (require, module, exports) {\n    var Dependency, assert;\n    assert = require('../modules/logging/assert');\n\n    module.exports = Dependency = function () {\n      function Dependency(_arg) {\n        var component, _ref;\n\n        this.type = _arg.type, this.src = _arg.src, this.code = _arg.code, this.namespace = _arg.namespace, this.library = _arg.library, this.isExecuteOnly = _arg.isExecuteOnly, component = _arg.component;\n        assert(this.src || this.code, 'Dependency: No \"src\" or \"code\" param provided');\n        assert(!(this.src && this.code), 'Dependency: Only provide one of \"src\" or \"code\" params');\n        assert(this.type, \"Dependency: Param type must be specified\");\n        assert((_ref = this.type) === 'js' || _ref === 'css', \"Dependency: Unrecognized type: \" + this.type);\n\n        if (this.code != null) {\n          this.inline = true;\n        }\n\n        this.components = {};\n        this.componentCount = 0;\n\n        if (component != null) {\n          this.addComponent(component);\n        }\n      }\n\n      Dependency.prototype.isJs = function () {\n        return this.type === 'js';\n      };\n\n      Dependency.prototype.isCss = function () {\n        return this.type === 'css';\n      };\n\n      Dependency.prototype.hasComponent = function (component) {\n        return this.components[component.id] != null;\n      };\n\n      Dependency.prototype.addComponent = function (component) {\n        if (!this.hasComponent(component)) {\n          this.componentCount += 1;\n          return this.components[component.id] = true;\n        }\n      };\n\n      Dependency.prototype.removeComponent = function (component) {\n        if (this.hasComponent(component)) {\n          this.componentCount -= 1;\n          this.components[component.id] = void 0;\n          return this.componentCount !== 0;\n        } else {\n          return true;\n        }\n      };\n\n      Dependency.prototype.isSameAs = function (otherDependency) {\n        if (this.type !== otherDependency.type) {\n          return false;\n        }\n\n        if (this.namespace !== otherDependency.namespace) {\n          return false;\n        }\n\n        if (otherDependency.src) {\n          return this.src === otherDependency.src;\n        } else {\n          return this.code === otherDependency.code;\n        }\n      };\n\n      Dependency.prototype.serialize = function () {\n        var componentId, key, obj, _i, _len, _ref;\n\n        assert(!this.isExecuteOnly, 'engine//dependency.coffee: Cannot serialize a temporary dependency');\n        obj = {};\n        _ref = ['src', 'code', 'inline', 'library', 'namespace'];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          key = _ref[_i];\n\n          if (this[key] != null) {\n            obj[key] = this[key];\n          }\n        }\n\n        for (componentId in this.components) {\n          if (obj.componentIds == null) {\n            obj.componentIds = [];\n          }\n\n          obj.componentIds.push(componentId);\n        }\n\n        return obj;\n      };\n\n      return Dependency;\n    }();\n  }, {\n    \"../modules/logging/assert\": 50\n  }],\n  60: [function (require, module, exports) {\n    var $, Renderer, Semaphore, assert, config, log;\n    $ = require('jquery');\n    assert = require('../modules/logging/assert');\n    log = require('../modules/logging/log');\n    Semaphore = require('../modules/semaphore');\n    config = require('../configuration/config');\n\n    module.exports = Renderer = function () {\n      function Renderer(_arg) {\n        var $wrapper, excludeComponents;\n        this.componentTree = _arg.componentTree, this.renderingContainer = _arg.renderingContainer, $wrapper = _arg.$wrapper, excludeComponents = _arg.excludeComponents;\n        assert(this.componentTree, 'no componentTree specified');\n        assert(this.renderingContainer, 'no rendering container specified');\n        this.$root = $(this.renderingContainer.renderNode);\n        this.$wrapperHtml = $wrapper;\n        this.componentViews = {};\n        this.excludedComponentIds = {};\n        this.excludeComponent(excludeComponents);\n        this.readySemaphore = new Semaphore();\n        this.renderOncePageReady();\n        this.readySemaphore.start();\n      }\n\n      Renderer.prototype.excludeComponent = function (componentId) {\n        var compId, view, _i, _len, _results;\n\n        if (componentId == null) {\n          return;\n        }\n\n        if ($.isArray(componentId)) {\n          _results = [];\n\n          for (_i = 0, _len = componentId.length; _i < _len; _i++) {\n            compId = componentId[_i];\n\n            _results.push(this.excludeComponent(compId));\n          }\n\n          return _results;\n        } else {\n          this.excludedComponentIds[componentId] = true;\n          view = this.componentViews[componentId];\n\n          if (view != null && view.isAttachedToDom) {\n            return this.removeComponentFromDom(view.model);\n          }\n        }\n      };\n\n      Renderer.prototype.setRoot = function () {\n        var $insert, selector, _ref;\n\n        if (((_ref = this.$wrapperHtml) != null ? _ref.length : void 0) && this.$wrapperHtml.jquery) {\n          selector = \".\" + config.css.section;\n          $insert = this.$wrapperHtml.find(selector).add(this.$wrapperHtml.filter(selector));\n\n          if ($insert.length) {\n            this.$wrapper = this.$root;\n            this.$wrapper.append(this.$wrapperHtml);\n            this.$root = $insert;\n          }\n        }\n\n        return this.$root.data('componentTree', this.componentTree);\n      };\n\n      Renderer.prototype.renderOncePageReady = function () {\n        this.readySemaphore.increment();\n        return this.renderingContainer.ready(function (_this) {\n          return function () {\n            _this.setRoot();\n\n            _this.render();\n\n            _this.setupComponentTreeListeners();\n\n            return _this.readySemaphore.decrement();\n          };\n        }(this));\n      };\n\n      Renderer.prototype.ready = function (callback) {\n        return this.readySemaphore.addCallback(callback);\n      };\n\n      Renderer.prototype.isReady = function () {\n        return this.readySemaphore.isReady();\n      };\n\n      Renderer.prototype.html = function () {\n        assert(this.isReady(), 'Cannot generate html. Renderer is not ready.');\n        return this.renderingContainer.html();\n      };\n\n      Renderer.prototype.setupComponentTreeListeners = function () {\n        this.componentTree.componentAdded.add($.proxy(this.componentAdded, this));\n        this.componentTree.componentRemoved.add($.proxy(this.componentRemoved, this));\n        this.componentTree.componentMoved.add($.proxy(this.componentMoved, this));\n        this.componentTree.componentContentChanged.add($.proxy(this.componentContentChanged, this));\n        return this.componentTree.componentHtmlChanged.add($.proxy(this.componentHtmlChanged, this));\n      };\n\n      Renderer.prototype.componentAdded = function (model) {\n        return this.insertComponent(model);\n      };\n\n      Renderer.prototype.componentRemoved = function (component) {\n        return component.descendantsAndSelf(function (_this) {\n          return function (model) {\n            _this.removeComponentFromDom(model);\n\n            return _this.deleteCachedComponentView(model);\n          };\n        }(this));\n      };\n\n      Renderer.prototype.componentMoved = function (model) {\n        this.removeComponentFromDom(model);\n        return this.insertComponent(model);\n      };\n\n      Renderer.prototype.componentContentChanged = function (model, directiveName) {\n        return this.getOrCreateComponentView(model).updateContent(directiveName);\n      };\n\n      Renderer.prototype.componentHtmlChanged = function (model) {\n        return this.getOrCreateComponentView(model).updateHtml();\n      };\n\n      Renderer.prototype.getComponentViewById = function (componentId) {\n        return this.componentViews[componentId];\n      };\n\n      Renderer.prototype.getOrCreateComponentView = function (model) {\n        var view;\n\n        if (view = this.componentViews[model.id]) {\n          return view;\n        }\n\n        view = model.createView(this.renderingContainer.isReadOnly);\n        view.setRenderer(this);\n        return this.componentViews[model.id] = view;\n      };\n\n      Renderer.prototype.deleteCachedComponentView = function (model) {\n        var _ref;\n\n        if ((_ref = this.componentViews[model.id]) != null) {\n          _ref.removeRenderer();\n        }\n\n        return delete this.componentViews[model.id];\n      };\n\n      Renderer.prototype.render = function () {\n        return this.componentTree.each(function (_this) {\n          return function (model) {\n            return _this.insertComponent(model);\n          };\n        }(this));\n      };\n\n      Renderer.prototype.clear = function () {\n        this.componentTree.each(function (_this) {\n          return function (model) {\n            return _this.getOrCreateComponentView(model).setAttachedToDom(false);\n          };\n        }(this));\n        return this.$root.empty();\n      };\n\n      Renderer.prototype.redraw = function () {\n        this.clear();\n        return this.render();\n      };\n\n      Renderer.prototype.refreshComponent = function (component) {\n        var view;\n        view = this.getComponentViewById(component.id);\n        view.descendantsAndSelf(function (_this) {\n          return function (view) {\n            _this.removeComponentFromDom(view.model);\n\n            return view.recreateHtml();\n          };\n        }(this));\n        this.insertComponent(component);\n        return this.renderingContainer.componentViewWasRefreshed.fire(view);\n      };\n\n      Renderer.prototype.insertComponent = function (model) {\n        var componentView;\n\n        if (this.isComponentAttached(model) || this.excludedComponentIds[model.id] === true) {\n          return;\n        }\n\n        if (this.isComponentAttached(model.previous)) {\n          this.insertComponentAsSibling(model.previous, model);\n        } else if (this.isComponentAttached(model.next)) {\n          this.insertComponentAsSibling(model.next, model);\n        } else if (model.parentContainer) {\n          this.appendComponentToParentContainer(model);\n        } else {\n          log.error('Component could not be inserted by renderer.');\n        }\n\n        componentView = this.getOrCreateComponentView(model);\n        componentView.setAttachedToDom(true);\n        this.renderingContainer.componentViewWasInserted(componentView);\n        return this.attachChildComponents(model);\n      };\n\n      Renderer.prototype.isComponentAttached = function (model) {\n        var _ref;\n\n        return model && ((_ref = this.getComponentViewById(model.id)) != null ? _ref.isAttachedToDom : void 0);\n      };\n\n      Renderer.prototype.attachChildComponents = function (model) {\n        return model.children(function (_this) {\n          return function (childModel) {\n            if (!_this.isComponentAttached(childModel)) {\n              return _this.insertComponent(childModel);\n            }\n          };\n        }(this));\n      };\n\n      Renderer.prototype.insertComponentAsSibling = function (sibling, model) {\n        var method;\n        method = sibling === model.previous ? 'after' : 'before';\n        return this.$nodeForComponent(sibling)[method](this.$nodeForComponent(model));\n      };\n\n      Renderer.prototype.appendComponentToParentContainer = function (model) {\n        var $container, $node;\n        $node = this.$nodeForComponent(model);\n        $container = this.$nodeForContainer(model.parentContainer);\n        return $container.append($node);\n      };\n\n      Renderer.prototype.$nodeForComponent = function (model) {\n        return this.getOrCreateComponentView(model).$html;\n      };\n\n      Renderer.prototype.$nodeForContainer = function (container) {\n        var parentView;\n\n        if (container.isRoot) {\n          return this.$root;\n        } else {\n          parentView = this.getOrCreateComponentView(container.parentComponent);\n          return $(parentView.getDirectiveElement(container.name));\n        }\n      };\n\n      Renderer.prototype.removeComponentFromDom = function (model) {\n        var view;\n\n        if (this.isComponentAttached(model)) {\n          view = this.getComponentViewById(model.id);\n          view.$html.detach();\n          return view.setAttachedToDom(false);\n        }\n      };\n\n      return Renderer;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../modules/semaphore\": 53,\n    \"jquery\": \"jquery\"\n  }],\n  61: [function (require, module, exports) {\n    var InteractivePage, Page, Renderer, View;\n    Renderer = require('./renderer');\n    Page = require('../rendering_container/page');\n    InteractivePage = require('../rendering_container/interactive_page');\n\n    module.exports = View = function () {\n      function View(_arg) {\n        var parent;\n        this.livingdoc = _arg.livingdoc, parent = _arg.parent, this.isInteractive = _arg.isInteractive, this.wrapper = _arg.wrapper, this.loadResources = _arg.loadResources;\n        this.parent = (parent != null ? parent.jquery : void 0) ? parent[0] : parent;\n\n        if (this.parent == null) {\n          this.parent = window.document.body;\n        }\n\n        if (this.isInteractive == null) {\n          this.isInteractive = false;\n        }\n\n        this.isReady = false;\n        this.whenReadyDeferred = $.Deferred();\n        this.whenReady = this.whenReadyDeferred.promise();\n      }\n\n      View.prototype.create = function (_arg) {\n        var renderInIframe;\n        renderInIframe = (_arg != null ? _arg : {}).renderInIframe;\n\n        if (renderInIframe) {\n          this.createIFrame(this.parent, function (_this) {\n            return function () {\n              _this.addBaseTarget();\n\n              _this.createIFrameRenderer();\n\n              _this.isReady = true;\n              return _this.whenReadyDeferred.resolve({\n                iframe: _this.iframe,\n                renderer: _this.renderer\n              });\n            };\n          }(this));\n        } else {\n          this.createRenderer({\n            renderNode: this.parent\n          });\n          this.isReady = true;\n          this.whenReadyDeferred.resolve({\n            renderer: this.renderer\n          });\n        }\n\n        return this.whenReady;\n      };\n\n      View.prototype.addBaseTarget = function () {\n        var base, doc;\n        doc = this.iframe.contentDocument;\n        base = doc.createElement('base');\n        base.setAttribute('target', '_blank');\n        return doc.getElementsByTagName('head')[0].appendChild(base);\n      };\n\n      View.prototype.createIFrame = function (parent, callback) {\n        var iframe;\n        iframe = parent.ownerDocument.createElement('iframe');\n        iframe.src = 'about:blank';\n        iframe.setAttribute('frameBorder', '0');\n        this.iframe = iframe;\n\n        iframe.onload = function () {\n          return callback(iframe);\n        };\n\n        return parent.appendChild(iframe);\n      };\n\n      View.prototype.createIFrameRenderer = function () {\n        return this.createRenderer({\n          renderNode: this.iframe.contentDocument.body\n        });\n      };\n\n      View.prototype.createRenderer = function (_arg) {\n        var params, renderNode;\n        renderNode = (_arg != null ? _arg : {}).renderNode;\n        params = {\n          renderNode: renderNode || this.parent,\n          documentDependencies: this.livingdoc.dependencies,\n          design: this.livingdoc.design,\n          loadResources: this.loadResources\n        };\n        this.page = this.isInteractive ? new InteractivePage(params) : new Page(params);\n        return this.renderer = new Renderer({\n          renderingContainer: this.page,\n          componentTree: this.livingdoc.componentTree,\n          $wrapper: $(this.wrapper)\n        });\n      };\n\n      return View;\n    }();\n  }, {\n    \"../rendering_container/interactive_page\": 65,\n    \"../rendering_container/page\": 67,\n    \"./renderer\": 60\n  }],\n  62: [function (require, module, exports) {\n    var $, Assets, CssLoader, JsLoader, Semaphore;\n    $ = require('jquery');\n    JsLoader = require('./js_loader');\n    CssLoader = require('./css_loader');\n    Semaphore = require('../modules/semaphore');\n\n    module.exports = Assets = function () {\n      function Assets(_arg) {\n        var disable;\n        this.window = _arg.window, disable = _arg.disable;\n        this.isDisabled = disable || false;\n        this.cssLoader = new CssLoader(this.window);\n        this.jsLoader = new JsLoader(this.window);\n      }\n\n      Assets.prototype.loadDependencies = function (jsDependencies, cssDependencies, callback) {\n        var dep, semaphore, _i, _len, _ref;\n\n        semaphore = new Semaphore();\n        semaphore.addCallback(callback);\n        this.loadSequentially(jsDependencies, semaphore);\n        _ref = cssDependencies || [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          dep = _ref[_i];\n          this.loadCss(dep, semaphore.wait());\n        }\n\n        return semaphore.start();\n      };\n\n      Assets.prototype.loadSequentially = function (jsDependencies, semaphore) {\n        var current, next;\n\n        if (jsDependencies != null ? jsDependencies.length : void 0) {\n          semaphore.increment(jsDependencies.length);\n          current = 0;\n\n          next = function (_this) {\n            return function () {\n              return _this.loadJs(jsDependencies[current], function () {\n                semaphore.decrement();\n                current += 1;\n\n                if (current < jsDependencies.length) {\n                  return next();\n                }\n              });\n            };\n          }(this);\n\n          return next();\n        }\n      };\n\n      Assets.prototype.loadDependency = function (dependency, callback) {\n        if (dependency.isJs()) {\n          return this.loadJs(dependency, callback);\n        } else if (dependency.isCss()) {\n          return this.loadCss(dependency, callback);\n        }\n      };\n\n      Assets.prototype.loadJs = function (dependency, callback) {\n        var preventRepeatedExecution;\n\n        if (this.isDisabled) {\n          return callback();\n        }\n\n        if (dependency.inline) {\n          preventRepeatedExecution = !dependency.isExecuteOnly;\n          return this.jsLoader.loadInlineScript(dependency.code, preventRepeatedExecution, callback);\n        } else {\n          return this.jsLoader.loadSingleUrl(dependency.src, callback);\n        }\n      };\n\n      Assets.prototype.loadCss = function (dependency, callback) {\n        if (this.isDisabled) {\n          return callback();\n        }\n\n        if (dependency.inline) {\n          return this.cssLoader.loadInlineStyles(dependency.code, callback);\n        } else {\n          return this.cssLoader.loadSingleUrl(dependency.src, callback);\n        }\n      };\n\n      return Assets;\n    }();\n  }, {\n    \"../modules/semaphore\": 53,\n    \"./css_loader\": 63,\n    \"./js_loader\": 66,\n    \"jquery\": \"jquery\"\n  }],\n  63: [function (require, module, exports) {\n    var $, CssLoader;\n    $ = require('jquery');\n\n    module.exports = CssLoader = function () {\n      function CssLoader(window) {\n        this.window = window;\n        this.loadedUrls = [];\n        this.loadedInlineStyles = [];\n      }\n\n      CssLoader.prototype.loadSingleUrl = function (url, callback) {\n        var link;\n\n        if (callback == null) {\n          callback = function callback() {};\n        }\n\n        if (this.isUrlLoaded(url)) {\n          return callback();\n        }\n\n        link = $('<link rel=\"stylesheet\" type=\"text/css\" />')[0];\n        link.onload = callback;\n\n        link.onerror = function () {\n          console.warn(\"Stylesheet could not be loaded: \" + url);\n          return callback();\n        };\n\n        link.href = url;\n        this.window.document.head.appendChild(link);\n        return this.loadedUrls.push(url);\n      };\n\n      CssLoader.prototype.isUrlLoaded = function (url) {\n        return this.loadedUrls.indexOf(url) >= 0;\n      };\n\n      CssLoader.prototype.loadInlineStyles = function (inlineStyles, callback) {\n        var doc, styles;\n\n        if (callback == null) {\n          callback = function callback() {};\n        }\n\n        inlineStyles = this.prepareInlineStyles(inlineStyles);\n\n        if (this.areInlineStylesLoaded(inlineStyles)) {\n          return callback();\n        }\n\n        doc = this.window.document;\n        styles = doc.createElement('style');\n        styles.innerHTML = inlineStyles;\n        doc.body.appendChild(styles);\n        this.loadedInlineStyles.push(inlineStyles);\n        return callback();\n      };\n\n      CssLoader.prototype.prepareInlineStyles = function (inlineStyles) {\n        return inlineStyles.replace(/<style[^>]*>|<\\/style>/gi, '');\n      };\n\n      CssLoader.prototype.areInlineStylesLoaded = function (inlineStyles) {\n        return this.loadedInlineStyles.indexOf(inlineStyles) >= 0;\n      };\n\n      return CssLoader;\n    }();\n  }, {\n    \"jquery\": \"jquery\"\n  }],\n  64: [function (require, module, exports) {\n    var ComponentDrag, DragBase, EditorPage, config, css;\n    config = require('../configuration/config');\n    css = config.css;\n    DragBase = require('../interaction/drag_base');\n    ComponentDrag = require('../interaction/component_drag');\n\n    module.exports = EditorPage = function () {\n      function EditorPage() {\n        this.setWindow();\n        this.dragBase = new DragBase(this);\n        this.editableController = {\n          disableAll: function disableAll() {},\n          reenableAll: function reenableAll() {}\n        };\n        this.componentWasDropped = {\n          fire: function fire() {}\n        };\n\n        this.blurFocusedElement = function () {};\n      }\n\n      EditorPage.prototype.startDrag = function (_arg) {\n        var componentDrag, componentModel, componentView, config, event;\n        componentModel = _arg.componentModel, componentView = _arg.componentView, event = _arg.event, config = _arg.config;\n\n        if (!(componentModel || componentView)) {\n          return;\n        }\n\n        if (componentView) {\n          componentModel = componentView.model;\n        }\n\n        componentDrag = new ComponentDrag({\n          componentModel: componentModel,\n          componentView: componentView\n        });\n\n        if (config == null) {\n          config = {\n            longpress: {\n              showIndicator: true,\n              delay: 400,\n              tolerance: 3\n            }\n          };\n        }\n\n        return this.dragBase.init(componentDrag, event, config);\n      };\n\n      EditorPage.prototype.setWindow = function () {\n        this.window = window;\n        this.document = this.window.document;\n        this.$document = $(this.document);\n        return this.$body = $(this.document.body);\n      };\n\n      return EditorPage;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../interaction/component_drag\": 39,\n    \"../interaction/drag_base\": 42\n  }],\n  65: [function (require, module, exports) {\n    var ComponentDrag,\n        DragBase,\n        EditableController,\n        Focus,\n        InteractivePage,\n        Page,\n        config,\n        dom,\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    config = require('../configuration/config');\n    Page = require('./page');\n    dom = require('../interaction/dom');\n    Focus = require('../interaction/focus');\n    EditableController = require('../interaction/editable_controller');\n    DragBase = require('../interaction/drag_base');\n    ComponentDrag = require('../interaction/component_drag');\n\n    module.exports = InteractivePage = function (_super) {\n      var LEFT_MOUSE_BUTTON;\n\n      __extends(InteractivePage, _super);\n\n      LEFT_MOUSE_BUTTON = 1;\n      InteractivePage.prototype.isReadOnly = false;\n\n      function InteractivePage(_arg) {\n        var hostWindow, renderNode, _ref;\n\n        _ref = _arg != null ? _arg : {}, renderNode = _ref.renderNode, hostWindow = _ref.hostWindow;\n\n        InteractivePage.__super__.constructor.apply(this, arguments);\n\n        this.focus = new Focus();\n        this.editableController = new EditableController(this);\n        this.componentClick = $.Callbacks();\n        this.imageClick = $.Callbacks();\n        this.htmlElementClick = $.Callbacks();\n        this.linkClick = $.Callbacks();\n        this.embedItemClick = $.Callbacks();\n        this.wysiwygClick = $.Callbacks();\n        this.componentWillBeDragged = $.Callbacks();\n        this.componentWasDropped = $.Callbacks();\n        this.dragBase = new DragBase(this);\n        this.focus.componentFocus.add($.proxy(this.afterComponentFocused, this));\n        this.focus.componentBlur.add($.proxy(this.afterComponentBlurred, this));\n        this.beforeInteractivePageReady();\n        this.$document.on('mousedown.livingdocs', $.proxy(this.mousedown, this)).on('click.livingdocs', $.proxy(this.click, this)).on('touchstart.livingdocs', $.proxy(this.mousedown, this)).on('dragstart.livingdocs', $.proxy(this.browserDragStart, this));\n      }\n\n      InteractivePage.prototype.beforeInteractivePageReady = function () {\n        if (config.livingdocsCssFile && this.loadResources) {\n          return this.assets.cssLoader.loadSingleUrl(config.livingdocsCssFile, this.readySemaphore.wait());\n        }\n      };\n\n      InteractivePage.prototype.browserDragStart = function (event) {\n        event.preventDefault();\n        return event.stopPropagation();\n      };\n\n      InteractivePage.prototype.removeListeners = function () {\n        this.$document.off('.livingdocs');\n        return this.$document.off('.livingdocs-drag');\n      };\n\n      InteractivePage.prototype.mousedown = function (event) {\n        var componentView, isControl;\n\n        if (event.which !== LEFT_MOUSE_BUTTON && event.type === 'mousedown') {\n          return;\n        }\n\n        isControl = $(event.target).closest(config.ignoreInteraction).length;\n\n        if (isControl) {\n          return;\n        }\n\n        componentView = dom.findComponentView(event.target);\n        this.handleClickedComponent(event, componentView);\n\n        if (componentView) {\n          var opt = {\n            enable: true\n          };\n          this.componentWillBeDragged.fire(opt);\n\n          if (opt.enable) {\n            return this.startDrag({\n              componentView: componentView,\n              event: event\n            });\n          }\n        }\n      };\n\n      InteractivePage.prototype.click = function (event) {\n        var target;\n        target = event.target;\n\n        if (dom.isInsideDocLink(target)) {\n          return event.preventDefault();\n        }\n      };\n\n      InteractivePage.prototype.startDrag = function (_arg) {\n        var componentDrag, componentModel, componentView, config, event;\n        componentModel = _arg.componentModel, componentView = _arg.componentView, event = _arg.event, config = _arg.config;\n\n        if (!(componentModel || componentView)) {\n          return;\n        }\n\n        if (componentView) {\n          componentModel = componentView.model;\n        }\n\n        componentDrag = new ComponentDrag({\n          componentModel: componentModel,\n          componentView: componentView\n        });\n\n        if (config == null) {\n          config = {\n            longpress: {\n              showIndicator: true,\n              delay: 400,\n              tolerance: 3\n            }\n          };\n        }\n\n        return this.dragBase.init(componentDrag, event, config);\n      };\n\n      InteractivePage.prototype.cancelDrag = function () {\n        return this.dragBase.cancel();\n      };\n\n      InteractivePage.prototype.handleClickedComponent = function (event, componentView) {\n        var directives;\n\n        if (componentView) {\n          this.focus.componentFocused(componentView);\n          directives = dom.getDirectiveContext(event.target);\n          this.componentClick.fire(componentView, this, directives, event);\n\n          if (directives != null) {\n            if (directives['image']) {\n              return this.imageClick.fire(componentView, directives['image'].name, event);\n            } else if (directives['link']) {\n              return this.linkClick.fire(componentView, directives['link'].name, event);\n            } else if (directives['html']) {\n              return this.htmlElementClick.fire(componentView, directives['html'].name, event);\n            } else if (directives['embeditem']) {\n              return this.embedItemClick.fire(componentView, directives['embeditem'].name, event);\n            } else if (directives['wysiwyg']) {\n              return this.wysiwygClick.fire(componentView, directives['wysiwyg'].name, event);\n            }\n          }\n        } else {\n          return this.focus.blur();\n        }\n      };\n\n      InteractivePage.prototype.getFocusedElement = function () {\n        return this.window.document.activeElement;\n      };\n\n      InteractivePage.prototype.blurFocusedElement = function () {\n        var focusedElement;\n        this.focus.setFocus(void 0);\n        focusedElement = this.getFocusedElement();\n\n        if (focusedElement) {\n          return $(focusedElement).blur();\n        }\n      };\n\n      InteractivePage.prototype.componentViewWasInserted = function (componentView) {\n        return this.initializeEditables(componentView);\n      };\n\n      InteractivePage.prototype.initializeEditables = function (componentView) {\n        var directive, editableNodes;\n\n        if (componentView.directives.editable) {\n          editableNodes = function () {\n            var _i, _len, _ref, _results;\n\n            _ref = componentView.directives.editable;\n            _results = [];\n\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              directive = _ref[_i];\n\n              _results.push(directive.elem);\n            }\n\n            return _results;\n          }();\n\n          return this.editableController.add(editableNodes);\n        }\n      };\n\n      InteractivePage.prototype.afterComponentFocused = function (componentView) {\n        return componentView.afterFocused();\n      };\n\n      InteractivePage.prototype.afterComponentBlurred = function (componentView) {\n        return componentView.afterBlurred();\n      };\n\n      return InteractivePage;\n    }(Page);\n  }, {\n    \"../configuration/config\": 26,\n    \"../interaction/component_drag\": 39,\n    \"../interaction/dom\": 41,\n    \"../interaction/drag_base\": 42,\n    \"../interaction/editable_controller\": 43,\n    \"../interaction/focus\": 44,\n    \"./page\": 67\n  }],\n  66: [function (require, module, exports) {\n    var JsLoader;\n\n    module.exports = JsLoader = function () {\n      function JsLoader(window) {\n        this.window = window;\n        this.loadedUrls = [];\n        this.loadedScripts = [];\n      }\n\n      JsLoader.prototype.loadSingleUrl = function (path, callback) {\n        var doc, el, head, loaded, onreadystatechange, readyState;\n\n        if (callback == null) {\n          callback = function callback() {};\n        }\n\n        if (this.isUrlLoaded(path)) {\n          return callback();\n        }\n\n        doc = this.window.document;\n        readyState = 'readyState';\n        onreadystatechange = 'onreadystatechange';\n        head = doc.getElementsByTagName('head')[0];\n        el = doc.createElement('script');\n        loaded = void 0;\n\n        el.onload = el.onerror = el[onreadystatechange] = function (_this) {\n          return function () {\n            if (el[readyState] && !/^c|loade/.test(el[readyState]) || loaded) {\n              return;\n            }\n\n            el.onload = el[onreadystatechange] = null;\n            loaded = true;\n\n            _this.loadedUrls.push(path);\n\n            return callback();\n          };\n        }(this);\n\n        el.async = true;\n        el.src = path;\n        return head.insertBefore(el, head.lastChild);\n      };\n\n      JsLoader.prototype.isUrlLoaded = function (url) {\n        return this.loadedUrls.indexOf(url) >= 0;\n      };\n\n      JsLoader.prototype.loadInlineScript = function (codeBlock, preventRepeatedExecution, callback) {\n        var doc, script;\n\n        if (callback == null) {\n          callback = function callback() {};\n        }\n\n        codeBlock = this.prepareInlineCode(codeBlock);\n\n        if (this.isInlineBlockLoaded(codeBlock)) {\n          return callback();\n        }\n\n        doc = this.window.document;\n        script = doc.createElement('script');\n        script.innerHTML = codeBlock;\n        doc.body.appendChild(script);\n\n        if (preventRepeatedExecution) {\n          this.loadedScripts.push(codeBlock);\n        }\n\n        return callback();\n      };\n\n      JsLoader.prototype.prepareInlineCode = function (codeBlock) {\n        return codeBlock.replace(/<script[^>]*>|<\\/script>/gi, '');\n      };\n\n      JsLoader.prototype.isInlineBlockLoaded = function (codeBlock) {\n        return this.loadedScripts.indexOf(codeBlock) >= 0;\n      };\n\n      return JsLoader;\n    }();\n  }, {}],\n  67: [function (require, module, exports) {\n    var $,\n        Assets,\n        Page,\n        RenderingContainer,\n        config,\n        __bind = function __bind(fn, me) {\n      return function () {\n        return fn.apply(me, arguments);\n      };\n    },\n        __hasProp = {}.hasOwnProperty,\n        __extends = function __extends(child, parent) {\n      for (var key in parent) {\n        if (__hasProp.call(parent, key)) child[key] = parent[key];\n      }\n\n      function ctor() {\n        this.constructor = child;\n      }\n\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    };\n\n    $ = require('jquery');\n    RenderingContainer = require('./rendering_container');\n    Assets = require('./assets');\n    config = require('../configuration/config');\n\n    module.exports = Page = function (_super) {\n      __extends(Page, _super);\n\n      function Page(_arg) {\n        var hostWindow, preventAssetLoading, readOnly, renderNode, _ref;\n\n        _ref = _arg != null ? _arg : {}, renderNode = _ref.renderNode, readOnly = _ref.readOnly, hostWindow = _ref.hostWindow, this.documentDependencies = _ref.documentDependencies, this.design = _ref.design, this.componentTree = _ref.componentTree, this.loadResources = _ref.loadResources;\n        this.loadAssets = __bind(this.loadAssets, this);\n\n        if (this.loadResources == null) {\n          this.loadResources = config.loadResources;\n        }\n\n        if (readOnly != null) {\n          this.isReadOnly = readOnly;\n        }\n\n        this.renderNode = (renderNode != null ? renderNode.jquery : void 0) ? renderNode[0] : renderNode;\n        this.setWindow(hostWindow);\n\n        if (this.renderNode == null) {\n          this.renderNode = $(\".\" + config.css.section, this.$body);\n        }\n\n        this.componentViewWasRefreshed = $.Callbacks();\n\n        Page.__super__.constructor.call(this);\n\n        preventAssetLoading = !this.loadResources;\n        this.assets = new Assets({\n          window: this.window,\n          disable: preventAssetLoading\n        });\n        this.loadAssets();\n      }\n\n      Page.prototype.beforeReady = function () {\n        this.readySemaphore.wait();\n        return setTimeout(function (_this) {\n          return function () {\n            return _this.readySemaphore.decrement();\n          };\n        }(this), 0);\n      };\n\n      Page.prototype.loadAssets = function () {\n        var deps;\n\n        if (this.design != null) {\n          deps = this.design.dependencies;\n          this.assets.loadDependencies(deps.js, deps.css, this.readySemaphore.wait());\n        }\n\n        if (this.documentDependencies != null) {\n          deps = this.documentDependencies;\n          this.assets.loadDependencies(deps.js, deps.css, this.readySemaphore.wait());\n          this.documentDependencies.dependenciesAdded.add(function (_this) {\n            return function (jsDependencies, cssDependencies) {\n              return _this.assets.loadDependencies(jsDependencies, cssDependencies, function () {});\n            };\n          }(this));\n          this.documentDependencies.dependencyToExecute.add(function (_this) {\n            return function (dependency) {\n              return _this.assets.loadDependency(dependency);\n            };\n          }(this));\n          return this.documentDependencies.codeToExecute.add(function (_this) {\n            return function (callback) {\n              return callback(_this.window);\n            };\n          }(this));\n        }\n      };\n\n      Page.prototype.setWindow = function (hostWindow) {\n        if (hostWindow == null) {\n          hostWindow = this.getParentWindow(this.renderNode);\n        }\n\n        this.window = hostWindow;\n        this.document = this.window.document;\n        this.$document = $(this.document);\n        return this.$body = $(this.document.body);\n      };\n\n      Page.prototype.getParentWindow = function (elem) {\n        if (elem != null) {\n          return elem.ownerDocument.defaultView;\n        } else {\n          return window;\n        }\n      };\n\n      return Page;\n    }(RenderingContainer);\n  }, {\n    \"../configuration/config\": 26,\n    \"./assets\": 62,\n    \"./rendering_container\": 68,\n    \"jquery\": \"jquery\"\n  }],\n  68: [function (require, module, exports) {\n    var $, RenderingContainer, Semaphore;\n    $ = require('jquery');\n    Semaphore = require('../modules/semaphore');\n\n    module.exports = RenderingContainer = function () {\n      RenderingContainer.prototype.isReadOnly = true;\n\n      function RenderingContainer() {\n        if (this.renderNode == null) {\n          this.renderNode = $('<div>')[0];\n        }\n\n        this.readySemaphore = new Semaphore();\n        this.beforeReady();\n        this.readySemaphore.start();\n      }\n\n      RenderingContainer.prototype.html = function () {\n        return $(this.renderNode).html();\n      };\n\n      RenderingContainer.prototype.componentViewWasInserted = function (componentView) {};\n\n      RenderingContainer.prototype.beforeReady = function () {};\n\n      RenderingContainer.prototype.ready = function (callback) {\n        return this.readySemaphore.addCallback(callback);\n      };\n\n      return RenderingContainer;\n    }();\n  }, {\n    \"../modules/semaphore\": 53,\n    \"jquery\": \"jquery\"\n  }],\n  69: [function (require, module, exports) {\n    var $, Directive, assert, dom, editorConfig;\n    $ = require('jquery');\n    editorConfig = require('../configuration/config');\n    dom = require('../interaction/dom');\n    assert = require('../modules/logging/assert');\n\n    module.exports = Directive = function () {\n      function Directive(_arg) {\n        var config;\n        this.name = _arg.name, this.type = _arg.type, this.elem = _arg.elem, config = _arg.config;\n\n        if (this.type !== 'optional') {\n          assert(this.name, \"TemplateDirective: name is missing from \" + this.type + \" directive\");\n        }\n\n        this.config = Object.create(editorConfig.directives[this.type]);\n        this.setConfig(config);\n        this.optional = false;\n      }\n\n      Directive.prototype.setConfig = function (config) {\n        return $.extend(this.config, config);\n      };\n\n      Directive.prototype.renderedAttr = function () {\n        return this.config.renderedAttr;\n      };\n\n      Directive.prototype.overwritesContent = function () {\n        return !!this.config.overwritesContent;\n      };\n\n      Directive.prototype.isModification = function () {\n        return this.config.modifies != null;\n      };\n\n      Directive.prototype.getTagName = function () {\n        return this.elem.nodeName.toLowerCase();\n      };\n\n      Directive.prototype.clone = function () {\n        var newDirective;\n        newDirective = new Directive({\n          name: this.name,\n          type: this.type,\n          config: this.config\n        });\n        newDirective.optional = this.optional;\n        return newDirective;\n      };\n\n      Directive.prototype.getAbsoluteBoundingClientRect = function () {\n        return dom.getAbsoluteBoundingClientRect(this.elem);\n      };\n\n      Directive.prototype.getBoundingClientRect = function () {\n        return this.elem.getBoundingClientRect();\n      };\n\n      return Directive;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../interaction/dom\": 41,\n    \"../modules/logging/assert\": 50,\n    \"jquery\": \"jquery\"\n  }],\n  70: [function (require, module, exports) {\n    var $, Directive, DirectiveCollection, assert, config;\n    $ = require('jquery');\n    assert = require('../modules/logging/assert');\n    config = require('../configuration/config');\n    Directive = require('./directive');\n\n    module.exports = DirectiveCollection = function () {\n      function DirectiveCollection(all) {\n        this.all = all != null ? all : {};\n        this.length = 0;\n      }\n\n      DirectiveCollection.prototype.add = function (directive) {\n        var _name;\n\n        this.assertNameNotUsed(directive);\n        this[this.length] = directive;\n        directive.index = this.length;\n        this.length += 1;\n        this.all[directive.name] = directive;\n        this[_name = directive.type] || (this[_name] = []);\n        this[directive.type].push(directive);\n        return directive;\n      };\n\n      DirectiveCollection.prototype.next = function (name) {\n        var directive;\n\n        if (name instanceof Directive) {\n          directive = name;\n        }\n\n        if (directive == null) {\n          directive = this.all[name];\n        }\n\n        return this[directive.index += 1];\n      };\n\n      DirectiveCollection.prototype.nextOfType = function (name) {\n        var directive, requiredType;\n\n        if (name instanceof Directive) {\n          directive = name;\n        }\n\n        if (directive == null) {\n          directive = this.all[name];\n        }\n\n        requiredType = directive.type;\n\n        while (directive = this.next(directive)) {\n          if (directive.type === requiredType) {\n            return directive;\n          }\n        }\n      };\n\n      DirectiveCollection.prototype.get = function (name) {\n        return this.all[name];\n      };\n\n      DirectiveCollection.prototype.count = function (type) {\n        var _ref;\n\n        if (type) {\n          return (_ref = this[type]) != null ? _ref.length : void 0;\n        } else {\n          return this.length;\n        }\n      };\n\n      DirectiveCollection.prototype.names = function (type) {\n        var directive, _i, _len, _ref, _ref1, _results;\n\n        if (!((_ref = this[type]) != null ? _ref.length : void 0)) {\n          return [];\n        }\n\n        _ref1 = this[type];\n        _results = [];\n\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          directive = _ref1[_i];\n\n          _results.push(directive.name);\n        }\n\n        return _results;\n      };\n\n      DirectiveCollection.prototype.each = function (callback) {\n        var directive, _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = this.length; _i < _len; _i++) {\n          directive = this[_i];\n\n          _results.push(callback(directive));\n        }\n\n        return _results;\n      };\n\n      DirectiveCollection.prototype.eachOfType = function (type, callback) {\n        var directive, _i, _len, _ref, _results;\n\n        if (this[type]) {\n          _ref = this[type];\n          _results = [];\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            directive = _ref[_i];\n\n            _results.push(callback(directive));\n          }\n\n          return _results;\n        }\n      };\n\n      DirectiveCollection.prototype.firstOfType = function (type) {\n        var _ref;\n\n        return (_ref = this[type]) != null ? _ref[0] : void 0;\n      };\n\n      DirectiveCollection.prototype.eachEditable = function (callback) {\n        return this.eachOfType('editable', callback);\n      };\n\n      DirectiveCollection.prototype.eachImage = function (callback) {\n        return this.eachOfType('image', callback);\n      };\n\n      DirectiveCollection.prototype.eachContainer = function (callback) {\n        return this.eachOfType('container', callback);\n      };\n\n      DirectiveCollection.prototype.eachHtml = function (callback) {\n        return this.eachOfType('html', callback);\n      };\n\n      DirectiveCollection.prototype.clone = function () {\n        var newCollection;\n        newCollection = new DirectiveCollection();\n        this.each(function (directive) {\n          return newCollection.add(directive.clone());\n        });\n        return newCollection;\n      };\n\n      DirectiveCollection.prototype.$getElem = function (name) {\n        return $(this.all[name].elem);\n      };\n\n      DirectiveCollection.prototype.assertAllLinked = function () {\n        this.each(function (directive) {\n          if (!directive.elem) {\n            return false;\n          }\n        });\n        return true;\n      };\n\n      DirectiveCollection.prototype.assertNameNotUsed = function (directive) {\n        return assert(directive && !this.all[directive.name], \"\" + directive.type + \" Template parsing error:\\n\" + config.directives[directive.type].renderedAttr + \"=\\\"\" + directive.name + \"\\\".\\n\\\"\" + directive.name + \"\\\" is a duplicate name.\");\n      };\n\n      return DirectiveCollection;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/logging/assert\": 50,\n    \"./directive\": 69,\n    \"jquery\": \"jquery\"\n  }],\n  71: [function (require, module, exports) {\n    var Directive, assert, config, directiveFinder, _;\n\n    config = require('../configuration/config');\n    Directive = require('./directive');\n    directiveFinder = require('./directive_finder');\n    assert = require('../modules/logging/assert');\n    _ = require('underscore');\n\n    module.exports = function () {\n      return {\n        parse: function parse(elem) {\n          var directives, modifications, overwritesContent;\n          directives = [];\n          modifications = [];\n          overwritesContent = false;\n          this.eachDirective(elem, function (directive) {\n            if (directive.isModification()) {\n              return modifications.push(directive);\n            } else {\n              if (directive.overwritesContent()) {\n                assert(!overwritesContent, \"Incompatible directives declared on element (\" + directive.type + \" directive '\" + directive.name + \"')\");\n                overwritesContent = true;\n              }\n\n              return directives.push(directive);\n            }\n          });\n\n          if (directives.length) {\n            this.applyModifications(directives, modifications);\n          }\n\n          return directives;\n        },\n        eachDirective: function eachDirective(elem, func) {\n          var data, directive, directiveData, _i, _len, _results;\n\n          directiveData = [];\n          directiveFinder.eachDirective(elem, function (_this) {\n            return function (type, name, attributeName) {\n              return directiveData.push({\n                attributeName: attributeName,\n                directive: new Directive({\n                  name: name,\n                  type: type,\n                  elem: elem\n                })\n              });\n            };\n          }(this));\n          _results = [];\n\n          for (_i = 0, _len = directiveData.length; _i < _len; _i++) {\n            data = directiveData[_i];\n            directive = data.directive;\n            this.rewriteAttribute(directive, data.attributeName);\n\n            _results.push(func(directive));\n          }\n\n          return _results;\n        },\n        applyModifications: function applyModifications(directives, modifications) {\n          var directive, modification, _i, _len, _results;\n\n          _results = [];\n\n          for (_i = 0, _len = modifications.length; _i < _len; _i++) {\n            modification = modifications[_i];\n\n            if (modification.type === 'optional') {\n              _results.push(function () {\n                var _j, _len1, _results1;\n\n                _results1 = [];\n\n                for (_j = 0, _len1 = directives.length; _j < _len1; _j++) {\n                  directive = directives[_j];\n\n                  if (_.contains(modification.config.modifies, directive.type)) {\n                    _results1.push(directive.optional = true);\n                  } else {\n                    _results1.push(void 0);\n                  }\n                }\n\n                return _results1;\n              }());\n            } else {\n              _results.push(void 0);\n            }\n          }\n\n          return _results;\n        },\n        rewriteAttribute: function rewriteAttribute(directive, attributeName) {\n          if (directive.isModification()) {\n            return this.removeAttribute(directive, attributeName);\n          } else {\n            if (attributeName !== directive.renderedAttr()) {\n              return this.normalizeAttribute(directive, attributeName);\n            } else if (!directive.name) {\n              return this.normalizeAttribute(directive);\n            }\n          }\n        },\n        normalizeAttribute: function normalizeAttribute(directive, attributeName) {\n          var elem;\n          elem = directive.elem;\n\n          if (attributeName) {\n            this.removeAttribute(directive, attributeName);\n          }\n\n          return elem.setAttribute(directive.renderedAttr(), directive.name);\n        },\n        removeAttribute: function removeAttribute(directive, attributeName) {\n          return directive.elem.removeAttribute(attributeName);\n        }\n      };\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"../modules/logging/assert\": 50,\n    \"./directive\": 69,\n    \"./directive_finder\": 72,\n    \"underscore\": 10\n  }],\n  72: [function (require, module, exports) {\n    var config, directiveFinder;\n    config = require('../configuration/config');\n\n    module.exports = directiveFinder = function () {\n      var prefixes;\n      prefixes = /^(x-|data-)/;\n      return {\n        link: function link(elem, directiveCollection) {\n          return this.eachDirective(elem, function (type, name) {\n            var directive;\n            directive = directiveCollection.get(name);\n            return directive.elem = elem;\n          });\n        },\n        eachDirective: function eachDirective(elem, callback) {\n          var attr, attrName, normalizedName, type, _i, _len, _ref;\n\n          _ref = elem.attributes;\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            attr = _ref[_i];\n            attrName = attr.name;\n            normalizedName = attrName.replace(prefixes, '');\n\n            if (type = config.templateAttrLookup[normalizedName]) {\n              callback(type, attr.value, attrName);\n            }\n          }\n\n          return void 0;\n        }\n      };\n    }();\n  }, {\n    \"../configuration/config\": 26\n  }],\n  73: [function (require, module, exports) {\n    var DirectiveIterator, config, directiveFinder;\n    config = require('../configuration/config');\n    directiveFinder = require('./directive_finder');\n\n    module.exports = DirectiveIterator = function () {\n      function DirectiveIterator(root) {\n        this.root = this._next = root;\n      }\n\n      DirectiveIterator.prototype.current = null;\n\n      DirectiveIterator.prototype.next = function () {\n        var child, n, next;\n        n = this.current = this._next;\n        child = next = void 0;\n\n        if (this.current) {\n          child = n.firstChild;\n\n          if (child && n.nodeType === 1 && !this.skipChildren(n)) {\n            this._next = child;\n          } else {\n            next = null;\n\n            while (n !== this.root && !(next = n.nextSibling)) {\n              n = n.parentNode;\n            }\n\n            this._next = next;\n          }\n        }\n\n        return this.current;\n      };\n\n      DirectiveIterator.prototype.skipChildren = function (elem) {\n        var skipChildren;\n        skipChildren = false;\n        directiveFinder.eachDirective(elem, function (type, name) {\n          if (config.directives[type].overwritesContent) {\n            return skipChildren = true;\n          }\n        });\n        return skipChildren;\n      };\n\n      DirectiveIterator.prototype.nextElement = function () {\n        var skipChildren;\n\n        while (this.next()) {\n          skipChildren = false;\n\n          if (this.current.nodeType === 1) {\n            break;\n          }\n        }\n\n        return this.current;\n      };\n\n      DirectiveIterator.prototype.detach = function () {\n        return this.current = this.root = null;\n      };\n\n      return DirectiveIterator;\n    }();\n  }, {\n    \"../configuration/config\": 26,\n    \"./directive_finder\": 72\n  }],\n  74: [function (require, module, exports) {\n    var $, ComponentModel, ComponentView, DirectiveCollection, DirectiveIterator, Template, assert, config, directiveCompiler, directiveFinder, log, sortByName, words;\n    $ = require('jquery');\n    log = require('../modules/logging/log');\n    assert = require('../modules/logging/assert');\n    words = require('../modules/words');\n    config = require('../configuration/config');\n    DirectiveIterator = require('./directive_iterator');\n    DirectiveCollection = require('./directive_collection');\n    directiveCompiler = require('./directive_compiler');\n    directiveFinder = require('./directive_finder');\n    ComponentModel = require('../component_tree/component_model');\n    ComponentView = require('../rendering/component_view');\n\n    sortByName = function sortByName(a, b) {\n      if (a.name > b.name) {\n        return 1;\n      } else if (a.name < b.name) {\n        return -1;\n      } else {\n        return 0;\n      }\n    };\n\n    module.exports = Template = function () {\n      function Template(_arg) {\n        var html, label, properties, _ref;\n\n        _ref = _arg != null ? _arg : {}, this.name = _ref.name, html = _ref.html, label = _ref.label, properties = _ref.properties, this.allowedParents = _ref.allowedParents;\n        assert(html, 'Template: param html missing');\n        this.$template = $(this.pruneHtml(html)).wrap('<div>');\n        this.$wrap = this.$template.parent();\n        this.label = label || words.humanize(this.name);\n        this.styles = properties || {};\n        this.defaults = {};\n        this.parseTemplate();\n      }\n\n      Template.prototype.equals = function (other) {\n        return this.name === (other != null ? other.name : void 0);\n      };\n\n      Template.prototype.setDesign = function (design) {\n        this.design = design;\n        return this.identifier = \"\" + design.name + \".\" + this.name;\n      };\n\n      Template.prototype.createModel = function () {\n        return new ComponentModel({\n          template: this\n        });\n      };\n\n      Template.prototype.createView = function (componentModel, isReadOnly) {\n        var $elem, componentView, directives, _ref;\n\n        _ref = this.createViewHtml(), $elem = _ref.$elem, directives = _ref.directives;\n        componentModel || (componentModel = this.createModel());\n        return componentView = new ComponentView({\n          model: componentModel,\n          $html: $elem,\n          directives: directives,\n          isReadOnly: isReadOnly\n        });\n      };\n\n      Template.prototype.createViewHtml = function () {\n        var $elem, directives;\n        $elem = this.$template.clone();\n        directives = this.linkDirectives($elem[0]);\n        return {\n          $elem: $elem,\n          directives: directives\n        };\n      };\n\n      Template.prototype.pruneHtml = function (html) {\n        html = $(html).filter(function (index) {\n          return this.nodeType !== 8;\n        });\n        assert(html.length === 1, \"Templates must contain one root element. The Template \\\"\" + this.identifier + \"\\\" contains \" + html.length);\n        return html;\n      };\n\n      Template.prototype.parseTemplate = function () {\n        var elem;\n        elem = this.$template[0];\n        this.directives = this.compileDirectives(elem);\n        return this.directives.each(function (_this) {\n          return function (directive) {\n            switch (directive.type) {\n              case 'editable':\n                return _this.formatEditable(directive.name, directive.elem);\n\n              case 'container':\n                return _this.formatContainer(directive.name, directive.elem);\n\n              case 'html':\n                return _this.formatHtml(directive.name, directive.elem);\n\n              case 'wysiwyg':\n                return _this.formatHtml(directive.name, directive.elem);\n\n              case 'embeditem':\n                // just doing the same for now\n                return _this.formatHtml(directive.name, directive.elem);\n            }\n          };\n        }(this));\n      };\n\n      Template.prototype.compileDirectives = function (elem) {\n        var directive, directives, foundDirectives, iterator, _i, _len;\n\n        iterator = new DirectiveIterator(elem);\n        directives = new DirectiveCollection();\n\n        while (elem = iterator.nextElement()) {\n          foundDirectives = directiveCompiler.parse(elem);\n\n          for (_i = 0, _len = foundDirectives.length; _i < _len; _i++) {\n            directive = foundDirectives[_i];\n            directives.add(directive);\n          }\n        }\n\n        return directives;\n      };\n\n      Template.prototype.linkDirectives = function (elem) {\n        var componentDirectives, iterator;\n        iterator = new DirectiveIterator(elem);\n        componentDirectives = this.directives.clone();\n\n        while (elem = iterator.nextElement()) {\n          directiveFinder.link(elem, componentDirectives);\n        }\n\n        return componentDirectives;\n      };\n\n      Template.prototype.formatEditable = function (name, elem) {\n        var $elem, defaultValue;\n        $elem = $(elem);\n        $elem.addClass(config.css.editable);\n        defaultValue = words.trim(elem.innerHTML);\n        this.defaults[name] = defaultValue ? defaultValue : '';\n        return elem.innerHTML = '';\n      };\n\n      Template.prototype.formatContainer = function (name, elem) {\n        return elem.innerHTML = '';\n      };\n\n      Template.prototype.formatHtml = function (name, elem) {\n        var defaultValue;\n        defaultValue = words.trim(elem.innerHTML);\n        $(elem).addClass(config.css.htmlcontent);\n\n        if (defaultValue) {\n          this.defaults[name] = defaultValue;\n        }\n\n        return elem.innerHTML = '';\n      };\n\n      Template.prototype.info = function () {\n        var doc, name, style, _ref, _ref1;\n\n        doc = {\n          name: this.name,\n          design: (_ref = this.design) != null ? _ref.name : void 0,\n          directives: [],\n          properties: []\n        };\n        this.directives.each(function (_this) {\n          return function (directive) {\n            var name, type;\n            name = directive.name, type = directive.type;\n            return doc.directives.push({\n              name: name,\n              type: type\n            });\n          };\n        }(this));\n        _ref1 = this.styles;\n\n        for (name in _ref1) {\n          style = _ref1[name];\n          doc.properties.push({\n            name: name,\n            type: 'cssModificator'\n          });\n        }\n\n        doc.directives.sort(sortByName);\n        doc.properties.sort(sortByName);\n        return doc;\n      };\n\n      return Template;\n    }();\n\n    Template.parseIdentifier = function (identifier) {\n      var parts;\n\n      if (!identifier) {\n        return;\n      }\n\n      parts = identifier.split('.');\n\n      if (parts.length === 1) {\n        return {\n          designName: void 0,\n          name: parts[0]\n        };\n      } else if (parts.length === 2) {\n        return {\n          designName: parts[0],\n          name: parts[1]\n        };\n      } else {\n        return log.error(\"could not parse component template identifier: \" + identifier);\n      }\n    };\n  }, {\n    \"../component_tree/component_model\": 17,\n    \"../configuration/config\": 26,\n    \"../modules/logging/assert\": 50,\n    \"../modules/logging/log\": 51,\n    \"../modules/words\": 55,\n    \"../rendering/component_view\": 56,\n    \"./directive_collection\": 70,\n    \"./directive_compiler\": 71,\n    \"./directive_finder\": 72,\n    \"./directive_iterator\": 73,\n    \"jquery\": \"jquery\"\n  }],\n  75: [function (require, module, exports) {\n    module.exports = {\n      \"version\": \"0.12.1\",\n      \"revision\": \"f9843a4\"\n    };\n  }, {}],\n  \"jquery\": [function (require, module, exports) {\n    module.exports = $;\n  }, {}]\n}, {}, [12]);\n\n//# sourceURL=webpack:///./src/livingdocs/livingdocs-engine.js?");

/***/ }),

/***/ "./src/modules/lf-attr-editor.js":
/*!***************************************!*\
  !*** ./src/modules/lf-attr-editor.js ***!
  \***************************************/
/*! exports provided: initialise_attribute_editor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialise_attribute_editor\", function() { return initialise_attribute_editor; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n\n\nvar PROPS_HOLDER = 'livingdocs_EditorField_Toolbar_options';\nfunction initialise_attribute_editor(holder, component) {\n  var componentAttrs = component.model.getData('data_attributes');\n\n  if (componentAttrs) {\n    holder.append(\"<h4>Component Attributes</h4>\");\n\n    var changeAttribute = function changeAttribute(componentName, name) {\n      return function () {\n        componentAttrs[componentName][name] = jquery__WEBPACK_IMPORTED_MODULE_0__(this).val();\n\n        if (component.model.componentTree) {\n          component.model.componentTree.contentChanging(component.model, componentName);\n        }\n      };\n    };\n\n    for (var componentName in componentAttrs) {\n      var itemAttrs = componentAttrs[componentName];\n\n      if (!itemAttrs) {\n        continue;\n      }\n\n      holder.append('<h5>' + componentName + '</h5>');\n\n      for (var key in itemAttrs) {\n        var attrInput = null;\n        var attrlbl = jquery__WEBPACK_IMPORTED_MODULE_0__('<label>').text(key);\n        attrInput = jquery__WEBPACK_IMPORTED_MODULE_0__(\"<input>\").attr({\n          type: 'text'\n        }).val(itemAttrs[key]);\n        attrInput.on(\"change\", changeAttribute(componentName, key));\n        attrlbl.append(attrInput);\n        holder.append(attrlbl);\n      }\n    }\n  }\n\n  var newAttr = jquery__WEBPACK_IMPORTED_MODULE_0__('<button class=\"alert\">New Attribute</button>').prependTo(holder.find('.component-actions'));\n  newAttr.click(function (e) {\n    var names = [];\n\n    for (var name in component.model.directives.all) {\n      names.push(name);\n    }\n\n    for (var name in component.model.containers) {\n      names.push(name);\n    }\n\n    if (names.length === 0) {\n      return;\n    }\n\n    var dialog = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].showDialog();\n    var directiveSelect = jquery__WEBPACK_IMPORTED_MODULE_0__('<select>');\n\n    for (var i = 0; i < names.length; i++) {\n      jquery__WEBPACK_IMPORTED_MODULE_0__('<option>').text(names[i]).appendTo(directiveSelect);\n    }\n\n    dialog.append('<label>Add attribute to directive:</label>');\n    dialog.append(directiveSelect);\n    dialog.append('<label>Add attribute named:</label>');\n    dialog.append('<input name=\"attr_name\">');\n    dialog.append('<label>Attribute value</label>');\n    dialog.append('<input name=\"attr_value\">');\n    dialog.append('<br/>');\n    var action = jquery__WEBPACK_IMPORTED_MODULE_0__('<button>OK</button>').appendTo(dialog);\n    action.click(function (e) {\n      var todirective = directiveSelect.val();\n      var attr = dialog.find('input[name=attr_name]').val();\n      var value = dialog.find('input[name=attr_value]').val();\n\n      if (todirective && todirective.length && attr && attr.length > 0) {\n        component.model.setDirectiveAttribute(todirective, attr, value);\n\n        if (component.model.componentTree) {\n          component.model.componentTree.contentChanging(component.model);\n        }\n      }\n\n      _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].closeDialog();\n    });\n  });\n}\n\n//# sourceURL=webpack:///./src/modules/lf-attr-editor.js?");

/***/ }),

/***/ "./src/modules/lf-component-export.js":
/*!********************************************!*\
  !*** ./src/modules/lf-component-export.js ***!
  \********************************************/
/*! exports provided: exportComponent, componentExportForm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exportComponent\", function() { return exportComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"componentExportForm\", function() { return componentExportForm; });\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_fields_TextareaField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextareaField.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n\n\nfunction exportComponent(component) {\n  var output = component.model.componentTree.serialize(component.model); // our component is in content.[0]\n\n  if (output.content && output.content.length >= 1) {\n    output = output.content[0];\n  }\n\n  return output;\n}\nfunction componentExportForm(component) {\n  // // store the 'next' pointer; the serializer\n  // // walks all siblings\n  // var oldNext = component.model.next;\n  //         component.model.next = null;\n  //         var jsonRep = tmpTree.serialize(component.model, true);\n  //         component.model.next = oldNext;\n  var output = exportComponent(component);\n  var fields = {\n    \"exportdata\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextareaField__WEBPACK_IMPORTED_MODULE_0__[\"TextareaField\"]({\n      name: \"exportdata\",\n      label: \"Data\",\n      value: JSON.stringify(output)\n    })\n  };\n  var editContainer = $('.livingdocs-item-properties')[0];\n  Object(_symbiote_silverstripe_prose_editor_editor_src_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_1__[\"openPrompt\"])({\n    title: \"Export\",\n    fields: fields,\n    update: function update(name, value) {},\n    callback: function callback(attrs) {},\n    cancel: function cancel() {}\n  }, editContainer);\n}\n\n//# sourceURL=webpack:///./src/modules/lf-component-export.js?");

/***/ }),

/***/ "./src/modules/lf-editing-history.js":
/*!*******************************************!*\
  !*** ./src/modules/lf-editing-history.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n\n\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('livingfrontend.updateLivingDoc', function (e, livingdoc) {\n  var $pageOptions = jquery__WEBPACK_IMPORTED_MODULE_0__('#livingdocs-page-options');\n  var $history = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"livingdocs-page-history\">');\n  var $toggle = jquery__WEBPACK_IMPORTED_MODULE_0__('<h3>History</h3>');\n  $history.append($toggle);\n  var $historyList = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"livingdocs-history-list\" >');\n  $history.append($historyList);\n  $pageOptions.append($history); // $history.click(function (e) {\n  //     e.preventDefault();\n  //     $historyList.toggle();\n  //     return false;\n  // });\n\n  var drawHistory = function drawHistory() {\n    $historyList.empty();\n\n    for (var i = 0; i < _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].changeStack.length; i++) {\n      var $entry = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"livingdocs-history-entry\">');\n      var str = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].changeStack[i].time.toLocaleTimeString();\n      $entry.append(str + \" - \");\n      var $restore = jquery__WEBPACK_IMPORTED_MODULE_0__('<a href=\"#\" data-index=\"' + i + '\">Restore</a>');\n      $restore.click(function (e) {\n        e.preventDefault();\n        _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].loadState(jquery__WEBPACK_IMPORTED_MODULE_0__(this).attr('data-index'));\n        return false;\n      });\n      $entry.append($restore);\n      $historyList.prepend($entry);\n    }\n  };\n\n  _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].livingdoc.model.changed.add(function () {\n    drawHistory();\n  });\n});\n\n//# sourceURL=webpack:///./src/modules/lf-editing-history.js?");

/***/ }),

/***/ "./src/modules/lf-embed-selection.js":
/*!*******************************************!*\
  !*** ./src/modules/lf-embed-selection.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\n\n\n\nvar PROPS_HOLDER = 'livingdocs_EditorField_Toolbar_options'; // TODO : Move this hardcoded crap to the contentsource.config \n\nvar embeds = JSON.parse(jquery__WEBPACK_IMPORTED_MODULE_0__('input[name=Embeds]').val());\nvar EMBED_LINK = jquery__WEBPACK_IMPORTED_MODULE_0__('input[name=EmbedLink]').val();\nvar SHORTCODE_MATCH_REGEX = /\\[(\\w+)(.*?)\\]/;\nvar SHORTCODE_ATTRS_REGEX = /(\\w+)=['\"]{1}(.*?)['\"]{1}/g;\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('livingfrontend.updateLivingDoc', function (e, livingdoc) {\n  livingdoc.interactiveView.page.embedItemClick.add(function (component, directiveName, event) {\n    var currentValue = component.model.get(directiveName);\n    currentValue = currentValue || {\n      source: '',\n      attrs: '',\n      content: null,\n      url: ''\n    };\n    var currentHtml = component.$html.html();\n    var isEditing = component.$html.attr('data-is-editing');\n\n    if (isEditing) {\n      return;\n    }\n\n    var isShortcode = component.$html.attr('data-use-sc');\n    component.$html.attr('data-is-editing', 1);\n    var holder = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"ld-embed-selection\">');\n    var propHolder = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"ld-embed-properties\">');\n    var attrInput = jquery__WEBPACK_IMPORTED_MODULE_0__(\"<input>\").attr({\n      type: 'text',\n      placeholder: 'Source url'\n    });\n    var attrlbl = jquery__WEBPACK_IMPORTED_MODULE_0__('<label>').text('Source');\n    var fields = {};\n\n    if (embeds && isShortcode) {\n      attrInput = jquery__WEBPACK_IMPORTED_MODULE_0__('<select class=\"with-button\">');\n      attrInput.append('<option>-- select item --</option>');\n\n      for (var label in embeds) {\n        var opt = jquery__WEBPACK_IMPORTED_MODULE_0__('<option>').appendTo(attrInput);\n        opt.attr('value', embeds[label]).text(label);\n      }\n\n      attrInput.change(function (e) {\n        var v = jquery__WEBPACK_IMPORTED_MODULE_0__(this).val();\n        var sc = extractShortcodeData(v);\n\n        if (sc && sc.attrs) {\n          var _fields = {};\n\n          for (var fieldName in sc.attrs) {\n            _fields[fieldName] = new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_1__[\"TextField\"]({\n              label: fieldName,\n              value: sc.attrs[fieldName]\n            });\n          }\n\n          Object(_symbiote_silverstripe_prose_editor_editor_src_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_2__[\"openPrompt\"])({\n            title: \"Options\",\n            fields: _fields,\n            showButtons: false,\n            update: function update() {\n              console.log(arguments);\n            }\n          }, propHolder[0]);\n        }\n      });\n    }\n\n    if (attrInput && currentValue.url) {\n      // let storedAttrs = JSON.parse(currentValue.attrs);\n      attrInput.val(currentValue.url);\n    }\n\n    var cleanUp = function cleanUp() {\n      attrlbl.remove();\n      component.$html.removeAttr('data-is-editing');\n    };\n\n    var attrButton = jquery__WEBPACK_IMPORTED_MODULE_0__('<button>✔</button>');\n    var cancelButton = jquery__WEBPACK_IMPORTED_MODULE_0__('<button>X</button>');\n    attrButton.on(\"click\", function () {\n      var selected = attrInput.val();\n      attrButton.text(\"⏳\").prop('disabled');\n\n      if (selected) {\n        var componentAttrs = component.model.getData('data_attributes');\n        componentAttrs = componentAttrs || {};\n        var attrStr = '';\n        var source = 'embed'; // do we have an actual URL to be embedded, or a shortcode style URL?\n\n        var shortcodeData = extractShortcodeData(selected); // SHORTCODE_MATCH_REGEX.exec(selected);\n\n        if (shortcodeData && shortcodeData.shortcode) {\n          source = shortcodeData.shortcode;\n          attrStr = shortcodeData.attrs ? JSON.stringify(shortcodeData.attrs) : '';\n        } else {\n          attrStr = JSON.stringify({\n            url: selected\n          });\n        }\n\n        jquery__WEBPACK_IMPORTED_MODULE_0__[\"get\"](EMBED_LINK, {\n          shortcode: source,\n          attrs: attrStr\n        }).then(function (data) {\n          cleanUp();\n          var toSave = {\n            attrs: attrStr,\n            source: source,\n            content: data,\n            url: selected\n          };\n          component.model.setContent(directiveName, toSave);\n        });\n      } else {\n        cleanUp();\n        component.$html.html(currentValue.content ? currentValue.content : currentHtml);\n        component.model.setContent(directiveName, {\n          source: '',\n          attrs: '',\n          content: ''\n        });\n      }\n    });\n    cancelButton.on('click', function () {\n      // component.model.setContent(directiveName, currentValue);\n      cleanUp();\n      component.$html.html(currentValue.content ? currentValue.content : currentHtml);\n    });\n    holder.append(attrlbl.append(attrInput)).append(attrButton).append(cancelButton).append(propHolder);\n    component.$html.empty();\n    component.$html.append(holder);\n  });\n});\n\nfunction extractShortcodeData(shortcodeStr) {\n  var shortcodeData = SHORTCODE_MATCH_REGEX.exec(shortcodeStr);\n\n  if (shortcodeData) {\n    var shortcode = shortcodeData[1];\n    var scAttrs = null;\n\n    if (shortcodeData[2] && shortcodeData[2].length > 0) {\n      scAttrs = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = shortcodeData[2].matchAll(SHORTCODE_ATTRS_REGEX)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var match = _step.value;\n          scAttrs[match[1]] = match[2];\n        } // attrStr = JSON.stringify(scAttrs);\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return {\n      shortcode: shortcode,\n      attrs: scAttrs\n    };\n  }\n}\n\n//# sourceURL=webpack:///./src/modules/lf-embed-selection.js?");

/***/ }),

/***/ "./src/modules/lf-html-editing.js":
/*!****************************************!*\
  !*** ./src/modules/lf-html-editing.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ace_builds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ace-builds */ \"./node_modules/ace-builds/src-noconflict/ace.js\");\n/* harmony import */ var ace_builds__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ace_builds__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ace_builds_src_noconflict_mode_markdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ace-builds/src-noconflict/mode-markdown */ \"./node_modules/ace-builds/src-noconflict/mode-markdown.js\");\n/* harmony import */ var ace_builds_src_noconflict_mode_markdown__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_mode_markdown__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var ace_builds_src_noconflict_mode_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ace-builds/src-noconflict/mode-html */ \"./node_modules/ace-builds/src-noconflict/mode-html.js\");\n/* harmony import */ var ace_builds_src_noconflict_mode_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_mode_html__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var showdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! showdown */ \"./node_modules/showdown/dist/showdown.js\");\n/* harmony import */ var showdown__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(showdown__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('livingfrontend.updateLivingDoc', function (e, livingdoc) {\n  // HTML directive handling\n  livingdoc.interactiveView.page.htmlElementClick.add(function (component, directiveName, event) {\n    var isEditing = component.$html.attr('data-is-editing');\n    component.$html.addClass('js-editor-block');\n\n    if (isEditing) {\n      return;\n    }\n\n    component.$html.attr('data-is-editing', 1);\n    var currentContent = component.model.getData(directiveName + '-raw');\n    var $edBlock = jquery__WEBPACK_IMPORTED_MODULE_0__('<div>').css({\n      'width': '100%',\n      'position': 'absolute',\n      'top': 0,\n      'right': 0,\n      'bottom': '20px',\n      'left': 0\n    });\n    var aceeditor = null;\n    var $actions = jquery__WEBPACK_IMPORTED_MODULE_0__('<div>');\n    var $save = jquery__WEBPACK_IMPORTED_MODULE_0__('<button>OK</button>');\n    var $cancel = jquery__WEBPACK_IMPORTED_MODULE_0__('<button>Cancel</button>');\n    $actions.css({\n      position: 'absolute',\n      'bottom': 0\n    }).append($save).append($cancel);\n    $edBlock.text(currentContent);\n    component.$html.html($edBlock);\n    component.$html.append($actions);\n    $edBlock.focus();\n    var aceeditor = ace_builds__WEBPACK_IMPORTED_MODULE_1__[\"edit\"]($edBlock[0]);\n    aceeditor.session.setMode('ace/mode/html');\n\n    if (component.$html.hasClass('js-living-markdown')) {\n      aceeditor.session.setMode('ace/mode/markdown');\n    }\n\n    var cleanUp = function cleanUp() {\n      if (aceeditor) {\n        aceeditor.destroy();\n      }\n\n      $edBlock.remove();\n      component.$html.removeAttr('data-is-editing');\n      component.$html.removeClass('js-editor-block');\n    };\n\n    $cancel.click(function () {\n      component.$html.html(component.model.get(directiveName));\n      cleanUp();\n    });\n\n    var saveEditorBlock = function saveEditorBlock() {\n      var newContent = $edBlock.html();\n\n      if (aceeditor) {\n        newContent = aceeditor.getValue();\n      } // insert some markers for real &gt; and &lt;\n\n\n      newContent = newContent.replace(/&gt;/g, '__RAW_GT_TAG').replace(/&lt;/g, '__RAW_LT_TAG');\n      var catcher = jquery__WEBPACK_IMPORTED_MODULE_0__('<div>');\n      catcher.append(newContent);\n      catcher.find('script').remove().find('textarea').remove();\n      var rawContent = catcher.html();\n      rawContent = rawContent.replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/__RAW_GT_TAG/g, '&gt;').replace(/__RAW_LT_TAG/g, '&lt;');\n      component.model.setData(directiveName + '-raw', rawContent);\n\n      if (component.$html.hasClass('js-living-markdown')) {\n        // parse it first\n        var converter = new showdown__WEBPACK_IMPORTED_MODULE_4__[\"Converter\"]();\n        rawContent = converter.makeHtml(rawContent);\n      } // highlight code blocks\n\n\n      catcher.html(rawContent);\n      catcher.find('pre > code').each(function (i, block) {\n        hljs.highlightBlock(block);\n      });\n      rawContent = catcher.html();\n\n      if (!component.model.setContent(directiveName, rawContent)) {\n        // we need to force this as the content set by rawContent may not\n        // be different and trigger the HTML update\n        if (component.model.componentTree) {\n          component.model.componentTree.contentChanging(component.model, directiveName);\n        }\n      }\n\n      cleanUp();\n    };\n\n    aceeditor.on('blur', saveEditorBlock);\n    $save.click(saveEditorBlock);\n  });\n});\n\n//# sourceURL=webpack:///./src/modules/lf-html-editing.js?");

/***/ }),

/***/ "./src/modules/lf-iframed-dialog.js":
/*!******************************************!*\
  !*** ./src/modules/lf-iframed-dialog.js ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\nvar windowParent = window.parent; //    var windowParent = window;\n// prevent deselection of the source page's highlight\n\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('mousedown', function (e) {//        e.preventDefault();\n});\nvar element = {\n  getEditor: function getEditor() {\n    return editorProxy;\n  }\n  /**\n   * Represents a fake tinymce editor. \n   */\n\n};\nvar editorProxy = {\n  onopen: function onopen() {\n    console.log(\"editorProxy.onopen\");\n  },\n  getContent: function getContent() {\n    var doc = windowParent.ContentBridge.getLivingDoc();\n\n    if (doc) {\n      return doc.toHtml();\n    }\n\n    return '';\n  },\n  getSelectedNode: function getSelectedNode() {\n    console.log(\"editorProxy.getselectednode\");\n    return \"<div>\";\n  },\n  getSelection: function getSelection() {\n    console.log(\"editorProxy.getSelection\");\n    return jquery__WEBPACK_IMPORTED_MODULE_0__(\"<div>\");\n  },\n  createBookmark: function createBookmark() {\n    console.log(\"editorProxy.createBookmark\");\n    return null;\n  },\n  blur: function blur() {\n    console.log(\"editorProxy.blur\");\n  },\n  onclose: function onclose() {\n    console.log(\"editorProxy.onclose\");\n  },\n  moveToBookmark: function moveToBookmark() {\n    console.log(\"editorProxy.moveToBookmark\");\n  },\n  replaceContent: function replaceContent(HTML) {\n    console.log(\"editorProxy.replaceContent\");\n\n    if (windowParent && windowParent.ContentBridge) {\n      windowParent.ContentBridge.setContent(HTML);\n    }\n\n    return false;\n  },\n  repaint: function repaint() {\n    console.log(\"editorProxy.repaint\");\n  },\n  insertContent: function insertContent(content) {\n    if (windowParent && windowParent.ContentBridge) {\n      windowParent.ContentBridge.setContent(content);\n    }\n\n    return false;\n  },\n  addUndo: function addUndo() {\n    console.log(\"editorProxy.addUndo\");\n  },\n  insertLink: function insertLink(link) {\n    if (windowParent && windowParent.ContentBridge) {\n      windowParent.ContentBridge.setLinkObject(link);\n    }\n  } // $.entwine(\"ss\", function ($) {\n  //     $(\"form.htmleditorfield-form\").entwine({\n  //         close: function () {\n  //             windowParent.ContentBridge.closeDialog();\n  //         },\n  //         getEditor: function () {\n  //             console.log('form.htmleditorfield-form getEditor');\n  //             return editorProxy;\n  //         }\n  //     });\n  //     $(\"form.htmleditorfield-form button\").entwine({\n  //         onadd: function () {\n  //             this.button().addClass(\"ss-ui-button\");\n  //         }\n  //     });\n  //     $(\"form.htmleditorfield-linkform button[name=action_remove]\").entwine({\n  //         onclick: function (e) {\n  //             e.preventDefault();\n  //             this.parents(\"form:first\").removeLink();\n  //         }\n  //     });\n  //     $(\".htmleditorfield-dialog\").entwine({\n  //         onadd: function () {\n  //             this.getForm().setElement(element);\n  //             this.trigger(\"ssdialogopen\");\n  //             this._super();\n  //         },\n  //         getEditor: function () {\n  //             return editorProxy;\n  //         },\n  //         close: function () {\n  //             windowParent.ContentBridge.closeDialog();\n  //         }\n  //     });\n  // });\n\n};\n\n//# sourceURL=webpack:///./src/modules/lf-iframed-dialog.js?");

/***/ }),

/***/ "./src/modules/lf-image-selector.js":
/*!******************************************!*\
  !*** ./src/modules/lf-image-selector.js ***!
  \******************************************/
/*! exports provided: selectImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectImage\", function() { return selectImage; });\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_plugins_ss_image_selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-image-selector */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-image-selector.js\");\n\nfunction selectImage(component, img, directiveId) {\n  var params = {};\n  params.src = component.model.get(img.name);\n  params.width = component.model.getDirectiveAttribute(img.name, \"width\");\n  params.height = component.model.getDirectiveAttribute(img.name, \"height\");\n  params.alt = component.model.getDirectiveAttribute(img.name, \"alt\");\n  params.title = component.model.getDirectiveAttribute(img.name, \"title\");\n  params.id = component.model.getDirectiveAttribute(img.name, \"data-id\");\n  Object(_symbiote_silverstripe_prose_editor_editor_src_plugins_ss_image_selector__WEBPACK_IMPORTED_MODULE_0__[\"imageSelectorDialog\"])(params, function (newAttrs) {\n    component.model.setDirectiveAttribute(img.name, 'alt', newAttrs.alt);\n    component.model.setDirectiveAttribute(img.name, 'title', newAttrs.title);\n    component.model.setDirectiveAttribute(img.name, 'width', newAttrs.width);\n    component.model.setDirectiveAttribute(img.name, 'height', newAttrs.height);\n    component.model.setDirectiveAttribute(img.name, 'data-id', newAttrs.imageSel.id);\n    component.model.setContent(img.name, {\n      url: newAttrs.src\n    });\n  });\n}\n\n//# sourceURL=webpack:///./src/modules/lf-image-selector.js?");

/***/ }),

/***/ "./src/modules/lf-keyboard-handler.js":
/*!********************************************!*\
  !*** ./src/modules/lf-keyboard-handler.js ***!
  \********************************************/
/*! exports provided: initialise_keyboard, copyTextToClipboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialise_keyboard\", function() { return initialise_keyboard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyTextToClipboard\", function() { return copyTextToClipboard; });\n/* harmony import */ var _lf_component_export__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lf-component-export */ \"./src/modules/lf-component-export.js\");\n/* harmony import */ var _lib_createComponentList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/createComponentList */ \"./src/lib/createComponentList.js\");\n/* harmony import */ var _lf_messages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lf-messages */ \"./src/modules/lf-messages.js\");\n\n\n\nvar PROPS_HOLDER = 'livingdocs_EditorField_Toolbar_options';\n/**\n *\n * @param {LivingDocState} state\n */\n\nfunction initialise_keyboard(state) {\n  document.addEventListener(\"keydown\", function (e) {\n    // we need ctrl for delete too\n    if (!e.ctrlKey) {\n      return;\n    }\n\n    if (e.keyCode == 46) {\n      if (state.activeComponent) {\n        // check that the component is a container\n        if (confirm(\"Remove this \" + state.activeComponent.model.componentName)) {\n          state.activeComponent.model.remove();\n          $(\".\" + PROPS_HOLDER).remove();\n        }\n      }\n    }\n\n    if (e.keyCode == 67) {\n      // check that what we have selected is copyable\n      var selection = document.getSelection(); // we used to check for classes,\n      // but this ignores having selected a text-based component, ie 'p' \n      // .classList && selection.anchorNode.classList.contains('doc-component')) {\n\n      if (selection.anchorNode && selection.type.toLowerCase() === 'caret') {\n        // if it's an input type, ignore\n        var nodeType = selection.anchorNode.nodeName.toLowerCase();\n\n        if (nodeType == 'input' || nodeType == 'textarea' || nodeType == 'select') {\n          console.log(\"Form input\");\n        } else {\n          var content = Object(_lf_component_export__WEBPACK_IMPORTED_MODULE_0__[\"exportComponent\"])(state.activeComponent);\n          copyTextToClipboard(JSON.stringify(content).replace(/\"id\":\"doc-(.*?)\",/g, \"\"));\n          Object(_lf_messages__WEBPACK_IMPORTED_MODULE_2__[\"showMessage\"])(\"Copied \" + state.activeComponent.model.componentName);\n        }\n      } else {\n        console.log(\"Not copying text node\");\n      }\n    }\n  });\n  document.addEventListener('paste', function (e) {\n    var clipboardData = e.clipboardData || window.clipboardData;\n    var content = clipboardData.getData('Text');\n\n    if (content && content.length > 0 && content.indexOf('identifier') > 0) {\n      try {\n        var newComponent = JSON.parse(content);\n\n        if (newComponent && newComponent.identifier) {\n          // we use the first available container on the target component\n          if (state.activeComponent && state.activeComponent.directives.container && state.activeComponent.directives.container.length > 0) {\n            var targetContainerName = state.activeComponent.directives.container[0].name;\n            var targetContainer = state.activeComponent.model.containers[targetContainerName];\n            Object(_lib_createComponentList__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([newComponent], targetContainer, null, true);\n          } else {\n            if (state.activeComponent) {\n              alert(\"Cannot paste into this component\");\n              e.preventDefault();\n            } else {\n              Object(_lib_createComponentList__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([newComponent], null, null, true);\n            }\n          }\n        }\n      } catch (err) {\n        console.log(\"Paste of non-component text detected - \", err);\n      }\n    }\n  });\n}\nfunction copyTextToClipboard(text) {\n  var textArea = getTempField();\n  textArea.value = text;\n  textArea.focus();\n  textArea.select();\n\n  try {\n    var successful = document.execCommand('copy');\n    var msg = successful ? 'successful' : 'unsuccessful';\n  } catch (err) {\n    console.log('Unable to copy');\n  }\n\n  document.body.removeChild(textArea);\n}\n\nfunction getTempField() {\n  var textArea = document.createElement(\"textarea\"); //\n  // *** This styling is an extra step which is likely not required. ***\n  //\n  // Why is it here? To ensure:\n  // 1. the element is able to have focus and selection.\n  // 2. if element was to flash render it has minimal visual impact.\n  // 3. less flakyness with selection and copying which **might** occur if\n  //    the textarea element is not visible.\n  //\n  // The likelihood is the element won't even render, not even a\n  // flash, so some of these are just precautions. However in\n  // Internet Explorer the element is visible whilst the popup\n  // box asking the user for permission for the web page to\n  // copy to the clipboard.\n  //\n  // Place in top-left corner of screen regardless of scroll position.\n\n  textArea.style.position = 'fixed';\n  textArea.style.top = 0;\n  textArea.style.left = 0; // Ensure it has a small width and height. Setting to 1px / 1em\n  // doesn't work as this gives a negative w/h on some browsers.\n\n  textArea.style.width = '2em';\n  textArea.style.height = '2em'; // We don't need padding, reducing the size if it does flash render.\n\n  textArea.style.padding = 0; // Clean up any borders.\n\n  textArea.style.border = 'none';\n  textArea.style.outline = 'none';\n  textArea.style.boxShadow = 'none'; // Avoid flash of white box if rendered for any reason.\n\n  textArea.style.background = 'transparent';\n  document.body.appendChild(textArea);\n  return textArea;\n}\n\n//# sourceURL=webpack:///./src/modules/lf-keyboard-handler.js?");

/***/ }),

/***/ "./src/modules/lf-links-buttons.js":
/*!*****************************************!*\
  !*** ./src/modules/lf-links-buttons.js ***!
  \*****************************************/
/*! exports provided: selectLink */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectLink\", function() { return selectLink; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_plugins_ss_link_selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/ss-link-selector.js\");\n\n\nfunction selectLink(selection, callback) {\n  var linkAttrs = {\n    href: '',\n    title: '',\n    target: '',\n    text: 'text'\n  };\n\n  if (selection.range && selection.range.startContainer) {\n    var $sc = jquery__WEBPACK_IMPORTED_MODULE_0__(selection.range.startContainer);\n    linkAttrs.href = $sc.attr('href');\n    linkAttrs.title = $sc.attr('title');\n    linkAttrs.target = $sc.attr('target');\n    linkAttrs.text = $sc.text();\n  }\n\n  Object(_symbiote_silverstripe_prose_editor_editor_src_plugins_ss_link_selector__WEBPACK_IMPORTED_MODULE_1__[\"linkSelectorDialog\"])(linkAttrs, {\n    internal: true\n  }, function (attrs) {\n    callback(attrs);\n  });\n}\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('livingfrontend.updateContentButtonBar', function (e, bar, selection) {\n  var addLink = {\n    label: 'Link',\n    click: function click() {\n      selection.save(); // prevents range saving from being cleared on focus lost. @see editable.js pastingAttribute\n\n      selection.host.setAttribute('data-editable-is-pasting', true);\n      selectLink(selection, function (linkObj) {\n        selection.restore();\n        selection.setVisibleSelection();\n        selection.link(linkObj.href, {\n          target: linkObj.target,\n          title: linkObj.title\n        });\n        selection.host.setAttribute('data-editable-is-pasting', false);\n        selection.triggerChange();\n      });\n    }\n  };\n  var addAnchor = {\n    label: 'Anchor',\n    title: 'Insert Named Anchor',\n    click: function click() {\n      var anchorName = prompt(\"Anchor name\");\n      var s = selection.createElement('a');\n      jquery__WEBPACK_IMPORTED_MODULE_0__(s).attr('name', anchorName);\n      selection.toggle(s);\n      selection.triggerChange();\n    }\n  };\n  bar.unshift(addAnchor);\n  bar.unshift(addLink);\n});\n\n//# sourceURL=webpack:///./src/modules/lf-links-buttons.js?");

/***/ }),

/***/ "./src/modules/lf-messages.js":
/*!************************************!*\
  !*** ./src/modules/lf-messages.js ***!
  \************************************/
/*! exports provided: initialise_messages, showMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialise_messages\", function() { return initialise_messages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"showMessage\", function() { return showMessage; });\nvar messages = [];\nvar MESSAGE_DIV = '.livingdocs-toolbar-messages';\nfunction initialise_messages() {}\nfunction showMessage(text) {\n  messages.unshift({\n    time: new Date().getTime(),\n    message: text\n  });\n  updateMessageDisplay();\n}\n\nfunction updateMessageDisplay() {\n  while (messages.length > 10) {\n    messages.pop();\n  }\n\n  $(MESSAGE_DIV).empty();\n\n  for (var i = 0; i < messages.length; i++) {\n    $(MESSAGE_DIV).append('<div>' + messages[i].message + '</div>');\n  }\n}\n\n//# sourceURL=webpack:///./src/modules/lf-messages.js?");

/***/ }),

/***/ "./src/modules/lf-paste-image.js":
/*!***************************************!*\
  !*** ./src/modules/lf-paste-image.js ***!
  \***************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n/* harmony import */ var _lib_FormContentSource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/FormContentSource */ \"./src/lib/FormContentSource.js\");\n\n\n\nvar UPLOAD_ENDPOINT = _lib_FormContentSource__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getConfig().endpoints.paste;\nvar MAX_PASTE_SIZE = 500000;\nvar PASTING = false;\nvar TOOLBAR_FORM = '#Form_LivingForm';\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('paste.editable', function (event) {\n  var imageType = /image.*/; // LivingFrontendHelper.activeComponent.model.parentContainer.insertAfter\n\n  var clipboardData;\n\n  if (PASTING) {\n    return;\n  }\n\n  if (event.clipboardData) {\n    clipboardData = event.clipboardData;\n  }\n\n  if (event.originalEvent && event.originalEvent.clipboardData) {\n    clipboardData = event.originalEvent.clipboardData; // https://codepen.io/netsi1964/pen/IoJbg\n  }\n\n  for (var i = 0; i < clipboardData.types.length; i++) {\n    if (clipboardData.types[i].match(imageType) || clipboardData.items[i].type.match(imageType)) {\n      var file = clipboardData.items[i].getAsFile();\n\n      if (!file) {\n        file = clipboardData.items[i].getAsString(function (s) {\n          console.log(s);\n        });\n        alert(\"Could not convert clipboard data to file, please try a smaller image\");\n        continue;\n      }\n\n      var reader = new FileReader();\n\n      reader.onload = function (evt) {\n        if (evt.target.result && evt.target.result.length > 0 && evt.target.result.length < MAX_PASTE_SIZE) {\n          // declared here, otherwise the paste action can change the focused element before the post responds\n          var selectedComponent = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].activeComponent;\n          var secId = jquery__WEBPACK_IMPORTED_MODULE_0__(TOOLBAR_FORM).find('[name=SecurityID]').val();\n          PASTING = true;\n          var updateModel = null;\n          var updateDirective = null;\n\n          if (!selectedComponent) {\n            return;\n          }\n\n          var srcTemplate = _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].livingdoc.design.defaultImage; // figure out the item we're updating; do we have a selected image, or are we creating\n          // a new one from the default template?\n\n          if (selectedComponent.model.directives.image && selectedComponent.model.directives.image.length > 0) {\n            srcTemplate = selectedComponent.template; //.directives.image[0];\n          } // need to create a new one; this may be inside the container, _or_ as\n          // a sibling to the current item\n\n\n          var newComponent = srcTemplate.createModel();\n\n          if (!srcTemplate.directives.image || srcTemplate.directives.image.length === 0) {\n            // can't paste into an empty block!\n            console.log(\"No place to paste\");\n          }\n\n          var newView = selectedComponent;\n\n          if (selectedComponent.directives.container && selectedComponent.directives.container.length > 0) {\n            var containerName = selectedComponent.directives.container[0].name;\n            selectedComponent.model.containers[containerName].append(newComponent);\n          } else {\n            selectedComponent.model.after(newComponent);\n            newView = selectedComponent.next();\n          }\n\n          newView.focus();\n          updateModel = newComponent;\n          updateDirective = updateModel.directives.image[0].name;\n          updateModel.setContent(updateDirective, {\n            url: 'frontend-livingdoc/javascript/lf-paste-loading.png'\n          });\n          jquery__WEBPACK_IMPORTED_MODULE_0__[\"post\"](UPLOAD_ENDPOINT, {\n            SecurityID: secId,\n            rawData: evt.target.result\n          }).then(function (res) {\n            PASTING = false;\n\n            if (res && res.success) {\n              updateModel.setContent(updateDirective, {\n                url: res.url\n              });\n            }\n          }).done(function (done) {\n            PASTING = false;\n          });\n        }\n      };\n\n      reader.readAsDataURL(file);\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/modules/lf-paste-image.js?");

/***/ }),

/***/ "./src/modules/lf-style-editor.js":
/*!****************************************!*\
  !*** ./src/modules/lf-style-editor.js ***!
  \****************************************/
/*! exports provided: createStyleEditor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createStyleEditor\", function() { return createStyleEditor; });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField */ \"../../../symbiote/silverstripe-prose-editor/editor/src/fields/TextField.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt */ \"../../../symbiote/silverstripe-prose-editor/editor/src/proseutil/prose-prompt.js\");\nfunction _objectSpread2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar STYLES_PROP = 'element_styles';\nfunction createStyleEditor(component, editContainer) {\n  var customStyles = component.model.getData(STYLES_PROP);\n\n  if (!customStyles) {\n    customStyles = {};\n  }\n\n  var fields = {\n    \"width\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Width',\n      value: customStyles['width'] || ''\n    }),\n    \"min-width\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Minimum Width',\n      value: customStyles['min-width'] || ''\n    }),\n    \"height\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Height',\n      value: customStyles['height'] || ''\n    }),\n    \"min-height\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Minumum Height',\n      value: customStyles['min-height'] || ''\n    }),\n    \"padding\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Padding',\n      value: customStyles['padding'] || ''\n    }),\n    \"margin\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Margin',\n      value: customStyles['margin'] || ''\n    }),\n    \"background-color\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Background Colour',\n      value: customStyles['background-color'] || ''\n    }),\n    'background-size': new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Background Size',\n      value: customStyles['background-size'] || ''\n    }),\n    'background-position': new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Background Position',\n      value: customStyles['background-position'] || ''\n    }),\n    'background-attachment': new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Background Attachment',\n      value: customStyles['background-attachment'] || ''\n    }),\n    \"background-repeat\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Background Repeat',\n      value: customStyles['background-repeat'] || ''\n    }),\n    \"object-fit\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Object fit',\n      value: customStyles['object-fit'] || ''\n    }),\n    \"color\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: \"Text colour\",\n      value: customStyles['color'] || ''\n    }),\n    \"text-align\": new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: \"Text alignment\",\n      value: customStyles['text-align'] || ''\n    })\n  }; // fields['background-color'].textType = 'color';\n\n  fields.color.textType = 'color';\n\n  if (component.model.styles['position-absolute']) {\n    fields[\"top\"] = new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Top',\n      value: customStyles['top'] || ''\n    });\n    fields[\"left\"] = new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Left',\n      value: customStyles['left'] || ''\n    });\n    fields[\"bottom\"] = new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Bottom',\n      value: customStyles['bottom'] || ''\n    });\n    fields[\"right\"] = new _symbiote_silverstripe_prose_editor_editor_src_fields_TextField__WEBPACK_IMPORTED_MODULE_2__[\"TextField\"]({\n      label: 'Right',\n      value: customStyles['right'] || ''\n    });\n  }\n\n  if (!editContainer) {\n    editContainer = jquery__WEBPACK_IMPORTED_MODULE_0__('.livingdocs-item-properties')[0];\n  }\n\n  Object(_symbiote_silverstripe_prose_editor_editor_src_proseutil_prose_prompt__WEBPACK_IMPORTED_MODULE_3__[\"openPrompt\"])({\n    title: \"Component Styles\",\n    fields: fields,\n    forceRemainOpen: true,\n    hideButtons: true,\n    update: function update(name, value) {\n      var currentStyles = component.model.getData(STYLES_PROP);\n\n      if (!currentStyles) {\n        currentStyles = {};\n      }\n\n      var newStyles = _objectSpread2({}, currentStyles);\n\n      newStyles[name] = value;\n      component.model.setData(STYLES_PROP, newStyles);\n      updateComponentStyles(component, newStyles);\n    },\n    callback: function callback(attrs) {},\n    cancel: function cancel() {\n      component.model.setData(STYLES_PROP, customStyles);\n      updateComponentStyles(component, customStyles);\n    }\n  }, editContainer);\n}\n\nfunction updateComponentStyles(component, styleset) {\n  for (var name in styleset) {\n    component.$html.css(name, styleset[name]);\n  }\n}\n\n//# sourceURL=webpack:///./src/modules/lf-style-editor.js?");

/***/ }),

/***/ "./src/modules/lf-text-actions.js":
/*!****************************************!*\
  !*** ./src/modules/lf-text-actions.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/LivingDocState */ \"./src/lib/LivingDocState.js\");\n\n\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('livingfrontend.updateLivingDoc', function (e, livingdoc) {\n  // text formatting options\n  // @TODO - provide more in-paragraph options\n  //  - sup/sub\n  //  - strike\n  //  - text-alignment (an option maybe?) \n  livingdoc.interactiveView.page.editableController.selection.add(function (view, editableName, selection) {\n    if (selection && selection.isSelection) {\n      var rect = selection.getCoordinates();\n      var barOptions = [{\n        label: '<strong>B</strong>',\n        title: 'Bold',\n        click: function click() {\n          selection.toggleBold();\n          selection.triggerChange();\n        }\n      }, {\n        label: '<em>I</em>',\n        title: 'Italics',\n        click: function click() {\n          selection.toggleEmphasis();\n          selection.triggerChange();\n        }\n      }, {\n        label: '<sub>s</sub>',\n        title: 'Subscript',\n        click: function click() {\n          var s = selection.createElement('sub');\n          selection.toggle(s);\n          selection.triggerChange();\n        }\n      }, {\n        label: '<sup>s</sup>',\n        title: 'Superscript',\n        click: function click() {\n          var s = selection.createElement('sup');\n          selection.toggle(s);\n          selection.triggerChange();\n        }\n      }, {\n        label: 'Clear',\n        click: function click() {\n          selection.removeFormatting();\n        }\n      }];\n      jquery__WEBPACK_IMPORTED_MODULE_0__(document).trigger('livingfrontend.updateContentButtonBar', [barOptions, selection]);\n      _lib_LivingDocState__WEBPACK_IMPORTED_MODULE_1__[\"default\"].showButtonBar(barOptions, rect);\n    }\n  });\n});\n\n//# sourceURL=webpack:///./src/modules/lf-text-actions.js?");

/***/ }),

/***/ "./src/modules/lf-wysiwyg-editing.js":
/*!*******************************************!*\
  !*** ./src/modules/lf-wysiwyg-editing.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/setup.js */ \"../../../symbiote/silverstripe-prose-editor/editor/src/setup.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_style_index_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/style/index.scss */ \"../../../symbiote/silverstripe-prose-editor/editor/style/index.scss\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_style_index_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_symbiote_silverstripe_prose_editor_editor_style_index_scss__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_FormContentSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/FormContentSource.js */ \"./src/lib/FormContentSource.js\");\n/* harmony import */ var _symbiote_silverstripe_prose_editor_editor_src_plugins_shortcodes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js */ \"../../../symbiote/silverstripe-prose-editor/editor/src/plugins/shortcodes.js\");\n\n\n\n\n\n\nfunction replaceShortcodesIn(elem) {\n  jquery__WEBPACK_IMPORTED_MODULE_0__(elem).find('.prose-shortcode').each(function () {\n    var $shortcodeHolder = jquery__WEBPACK_IMPORTED_MODULE_0__(this);\n\n    if ($shortcodeHolder.attr('data-rendered-shortcode')) {\n      return;\n    }\n\n    $shortcodeHolder.attr('data-rendered-shortcode', 1);\n    var rawShortcode = $shortcodeHolder.attr('data-shortcode');\n\n    if (!rawShortcode) {\n      return;\n    }\n\n    var shortcodeData = JSON.parse(rawShortcode);\n\n    if (shortcodeData && shortcodeData.type) {\n      var originalContent = $shortcodeHolder.html();\n      $shortcodeHolder.html(\"Loading data...\");\n      Object(_symbiote_silverstripe_prose_editor_editor_src_plugins_shortcodes_js__WEBPACK_IMPORTED_MODULE_4__[\"renderProseShortcode\"])(shortcodeData.type, shortcodeData.args).text(function (data) {\n        $shortcodeHolder.html(data);\n      }).catch(function (err) {\n        $shortcodeHolder.html(originalContent);\n      });\n    }\n  });\n}\n\njquery__WEBPACK_IMPORTED_MODULE_0__(document).on('livingfrontend.updateLivingDoc', function (e, livingdoc) {\n  // initial render\n  setTimeout(function () {\n    replaceShortcodesIn(jquery__WEBPACK_IMPORTED_MODULE_0__('#livingdocs-editor'));\n  }, 500); // subsequent content changes\n\n  livingdoc.model.changed.add(function () {\n    replaceShortcodesIn(jquery__WEBPACK_IMPORTED_MODULE_0__('#livingdocs-editor'));\n  });\n  livingdoc.interactiveView.page.componentWasDropped.add(function (component) {\n    var componentView = livingdoc.componentTree.getMainComponentView(component.id); // clean up any things attached to the component\n\n    if (componentView && componentView.$html) {\n      componentView.$html.find('[data-is-editing]').removeAttr('data-is-editing');\n    }\n  });\n  livingdoc.interactiveView.page.wysiwygClick.add(function (component, directiveName, event) {\n    var $elem = component.directives.$getElem(directiveName);\n\n    if (!$elem) {\n      return;\n    }\n\n    var isEditing = $elem.attr('data-is-editing');\n    $elem.addClass('js-wysiwyg-editor-block');\n\n    if (isEditing) {\n      return;\n    }\n\n    $elem.attr('data-is-editing', 1);\n    var currentContent = component.model.get(directiveName); // var rawContent = component.model.getData(directiveName + '-raw');\n\n    var config = _lib_FormContentSource_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getConfig();\n    var proseNode = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"ProseWrapper\">');\n    proseNode.attr('data-prose-url', '__prose');\n    proseNode.attr('data-context-id', config.pageId);\n    proseNode.attr('data-upload-path', config.pageLink);\n    proseNode.attr('data-prose-config', JSON.stringify({\n      \"menu\": {\n        \"insertlink\": true,\n        \"insertimage\": true,\n        \"bulletlist\": true,\n        \"orderedlist\": true,\n        \"quote\": true,\n        \"paragraph\": true,\n        \"pre\": true,\n        \"hr\": true,\n        \"table\": true,\n        \"shortcode\": true,\n        \"viewsource\": true\n      },\n      \"linkSelector\": {\n        \"internal\": true\n      }\n    }));\n    var editorNode = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"ProseEditorFieldEditor\" data-prose-config=\"\">');\n    var valueNode = jquery__WEBPACK_IMPORTED_MODULE_0__('<div class=\"ProseEditorFieldValue\" style=\"display: none\">');\n    var storageNode = jquery__WEBPACK_IMPORTED_MODULE_0__('<input type=\"hidden\" name=\"ThisProseEditor\" class=\"ProseEditorFieldStorage\" value=\"\" />');\n    proseNode.append(editorNode).append(valueNode).append(storageNode);\n    storageNode.val(currentContent);\n    valueNode.html(currentContent);\n    var $actions = jquery__WEBPACK_IMPORTED_MODULE_0__('<div>');\n    var $save = jquery__WEBPACK_IMPORTED_MODULE_0__('<button class=\"Button--Primary\">OK</button>');\n    var $cancel = jquery__WEBPACK_IMPORTED_MODULE_0__('<button>Cancel</button>');\n    $save.css('display', 'inline');\n    $cancel.css('display', 'inline');\n    $actions.append($save).append($cancel);\n    $elem.empty();\n    $elem.append(proseNode).append($actions);\n    var thisEditor = Object(_symbiote_silverstripe_prose_editor_editor_src_setup_js__WEBPACK_IMPORTED_MODULE_1__[\"setupEditor\"])(editorNode[0], valueNode[0], storageNode[0]);\n\n    var cleanUp = function cleanUp() {\n      thisEditor.destroy();\n      $elem.removeAttr('data-is-editing');\n      $elem.removeClass('js-wysiwyg-editor-block');\n    };\n\n    $cancel.click(function () {\n      cleanUp();\n      $elem.empty();\n      proseNode.remove();\n      $elem.html(component.model.get(directiveName));\n      replaceShortcodesIn($elem);\n    });\n\n    var saveEditorBlock = function saveEditorBlock() {\n      var newContent = storageNode.val(); // insert some markers for real &gt; and &lt;\n\n      newContent = newContent.replace(/&gt;/g, '__RAW_GT_TAG').replace(/&lt;/g, '__RAW_LT_TAG');\n      var catcher = jquery__WEBPACK_IMPORTED_MODULE_0__('<div>');\n      catcher.append(newContent);\n      catcher.find('script').remove().find('textarea').remove();\n      var rawContent = catcher.html();\n      rawContent = rawContent.replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/__RAW_GT_TAG/g, '&gt;').replace(/__RAW_LT_TAG/g, '&lt;'); // highlight code blocks\n\n      catcher.html(rawContent);\n      catcher.find('pre > code').each(function (i, block) {\n        hljs.highlightBlock(block);\n      });\n      rawContent = catcher.html(); // component.model.setData(directiveName + '-raw', rawContent);\n      // let displayDom = editorNode.find('div.ProseMirror').first();\n      // displayDom.find('svg').remove\n\n      if (!component.model.setContent(directiveName, rawContent)) {\n        // we need to force this as the content set by rawContent may not\n        // be different and trigger the HTML update\n        if (component.model.componentTree) {\n          component.model.componentTree.contentChanging(component.model, directiveName);\n        }\n\n        replaceShortcodesIn($elem);\n      }\n    };\n\n    $save.click(function () {\n      saveEditorBlock();\n      cleanUp();\n    });\n  });\n});\n\n//# sourceURL=webpack:///./src/modules/lf-wysiwyg-editing.js?");

/***/ }),

/***/ "./src/style/living-frontend.scss":
/*!****************************************!*\
  !*** ./src/style/living-frontend.scss ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style/living-frontend.scss?");

/***/ }),

/***/ "./src/style/livingdocs.scss":
/*!***********************************!*\
  !*** ./src/style/livingdocs.scss ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style/livingdocs.scss?");

/***/ }),

/***/ "./style/index.scss":
/*!**************************!*\
  !*** ./style/index.scss ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./style/index.scss?");

/***/ }),

/***/ 0:
/*!***********************************************!*\
  !*** multi ./src/index.js ./style/index.scss ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/index.js */\"./src/index.js\");\nmodule.exports = __webpack_require__(/*! ./style/index.scss */\"./style/index.scss\");\n\n\n//# sourceURL=webpack:///multi_./src/index.js_./style/index.scss?");

/***/ })

/******/ });